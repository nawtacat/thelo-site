<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Graphing Calculator</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;700&display=swap" rel="stylesheet">
    
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.1/math.min.js"></script>
    
    <style>
        /* --- General Setup & Variables --- */
        :root {
            --thelo-blue: #2563eb;
            --thelo-blue-dark: #1d4ed8;
            --thelo-bg: #f9fafb;
            --sidebar-bg: #ffffff;
            --thelo-text: #111827;
            --thelo-text-light: #6b7280;
            --thelo-border: #e5e7eb;
            --error-red: #ef4444;
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            --shadow-sm: 0 2px 4px -1px rgb(0 0 0 / 0.06), 0 2px 2px -1px rgb(0 0 0 / 0.04);
            --shadow-md-hover: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        body {
            margin: 0;
            font-family: 'Manrope', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            display: flex;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            background-color: var(--thelo-bg);
            color: var(--thelo-text);
        }

        /* --- Sidebar & Header --- */
        #sidebar {
            width: 420px;
            min-width: 320px;
            height: 100%;
            background-color: var(--sidebar-bg);
            border-right: 1px solid var(--thelo-border);
            box-shadow: var(--shadow-lg);
            z-index: 10;
            display: flex;
            flex-direction: column;
            resize: horizontal;
            overflow: hidden; /* Prevent sidebar scroll, keyboard will scroll */
        }
        .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--thelo-border);
            flex-shrink: 0;
            position: relative;
        }
        .sidebar-header h1 { margin: 0; font-size: 1.25rem; }
        .header-buttons { display: flex; gap: 0.75rem; }
        .header-btn {
            background-color: var(--sidebar-bg);
            color: var(--thelo-text-light);
            border: 1px solid var(--thelo-border);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 38px;
            height: 38px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: 700;
            box-shadow: var(--shadow-sm);
        }
        .header-btn:not(.active):hover { background-color: var(--thelo-bg); border-color: var(--thelo-text-light); transform: translateY(-1px); }
        .header-btn.active { background-color: var(--thelo-blue); color: white; border-color: var(--thelo-blue); }
        .header-btn:active { transform: translateY(1px); }
        .header-btn svg { width: 20px; height: 20px; stroke-width: 2; }
        #add-item-btn {
            background-color: var(--thelo-blue);
            color: white;
            border: none;
            font-size: 1.75rem;
            line-height: 1;
            box-shadow: 0 4px 10px -2px rgba(37, 99, 235, 0.4);
        }
        #add-item-btn:hover { background-color: var(--thelo-blue-dark); transform: translateY(-2px); box-shadow: 0 6px 12px -2px rgba(37, 99, 235, 0.5); }
        
        #add-item-menu {
            display: none;
            position: absolute;
            top: calc(100% + 5px);
            right: 1.5rem;
            background-color: var(--sidebar-bg);
            border-radius: 8px;
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--thelo-border);
            z-index: 100;
            overflow: hidden;
        }
        .add-item-menu-btn {
            display: block;
            width: 100%;
            padding: 0.75rem 1.5rem;
            background: none;
            border: none;
            text-align: left;
            cursor: pointer;
            font-size: 1rem;
            font-family: 'Manrope', sans-serif;
            font-weight: 500;
        }
        .add-item-menu-btn:hover { background-color: var(--thelo-bg); }

        /* --- Expression List --- */
        #expressionListContainer {
            flex-grow: 1;
            overflow-y: auto;
            padding: 0.5rem 0;
        }
        .expression-item { border-bottom: 1px solid var(--thelo-border); padding: 0.5rem 1rem 0.5rem 0.75rem; }
        .expression-main { display: flex; align-items: center; gap: 0.5rem; }
        .expression-color-bar { width: 28px; height: 28px; border-radius: 50%; flex-shrink: 0; cursor: pointer; border: 2px solid; transition: opacity 0.2s; display: flex; align-items: center; justify-content: center; font-weight: bold; user-select: none; }
        .expression-color-bar.hidden-expr { opacity: 0.3; }
        .expression-number { color: var(--thelo-text-light); font-weight: 500; user-select: none; width: 20px; text-align: center; }
        .expression-input-wrapper { display: flex; align-items: center; flex-grow: 1; min-width: 0; }
        .math-input-field { flex-grow: 1; min-width: 0; padding: 8px; font-size: 1.3rem; cursor: text; background-color: var(--sidebar-bg); border: none; border-radius: 0; }
        .math-input-field.mq-focused { outline: none; box-shadow: none; }
        .result-container { display: flex; align-items: center; gap: 4px; padding: 0 0.75rem; }
        .expression-result { font-size: 1rem; color: var(--thelo-text-light); font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .toggle-fraction-btn { background: transparent; border: 1px solid var(--thelo-border); border-radius: 4px; cursor: pointer; width: 22px; height: 22px; display: flex; align-items: center; justify-content: center; }
        .toggle-fraction-btn:hover { background-color: var(--thelo-bg); }
        .toggle-fraction-btn svg { width: 14px; height: 14px; }
        .remove-expression-btn { background: transparent; border: none; font-size: 1.75rem; color: var(--thelo-text-light); cursor: pointer; padding: 0 0.5rem; transition: color 0.2s; }
        .remove-expression-btn:hover { color: var(--error-red); }
        .expression-extras { padding: 0.75rem 0 0.5rem 52px; }
        .slider-container { display: flex; align-items: center; gap: 10px; margin-bottom: 5px; }
        .slider-container label { font-family: monospace; width: 90px; white-space: nowrap; font-size: 0.9rem; }
        .slider-container input[type=range] { flex-grow: 1; }
        .regression-params { font-size: 0.9rem; color: var(--thelo-text-light); font-family: monospace; line-height: 1.5; }
        
        /* --- Table Styles --- */
        .table-container { padding: 0.5rem 0 0.5rem 52px; }
        .table-container table { width: 100%; border-collapse: collapse; }
        .table-container th, .table-container td { border: 1px solid var(--thelo-border); padding: 0; text-align: center; font-family: monospace; }
        .table-container th { padding: 8px; font-weight: 700; background-color: var(--thelo-bg); }
        .table-container td { height: 38px; }
        .table-container input { width: 100%; height: 100%; border: none; outline: none; text-align: center; font-size: 1rem; background: transparent; font-family: monospace; }
        .table-container input:focus { background-color: #ebf3ff; }

        /* --- Keyboard & Functions Panel Layout --- */
        #keyboardContainer {
            position: relative;
            flex-shrink: 0;
            background-color: #f3f4f6; /* Light gray background for the whole keyboard area */
            border-top: 1px solid var(--thelo-border);
            display: none; /* Hidden by default, shown by #sidebar.keyboard-open */
        }
        #sidebar.keyboard-open #keyboardContainer { display: block; }
        #functionsPanel {
            position: absolute; bottom: 100%; left: 0; right: 0; max-height: 250px; overflow-y: auto;
            background-color: #f9fafb; border-bottom: 1px solid var(--thelo-border); box-shadow: 0 -4px 10px rgba(0,0,0,0.05);
            padding: 0.75rem 1rem; z-index: 20; transform: translateY(10px); opacity: 0; visibility: hidden;
            transition: transform 0.2s ease-out, opacity 0.2s ease-out, visibility 0.2s;
        }
        #sidebar.functions-open #functionsPanel { transform: translateY(0); opacity: 1; visibility: visible; }
        .function-category h3 { margin: 0.75rem 0 0.5rem; font-size: 0.75rem; font-weight: 700; color: var(--thelo-text-light); text-transform: uppercase; }
        .function-category:first-child h3 { margin-top: 0; }
        .function-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 8px; }
        #mainKeyboard { padding: 1rem; display: grid; grid-template-columns: repeat(8, 1fr); gap: 8px; }

        /* --- Universal Button Styles for Both Keyboards --- */
        .keyboard-btn {
            background: var(--sidebar-bg); color: var(--thelo-text); border: 1px solid var(--thelo-border);
            box-shadow: var(--shadow-sm); border-radius: 6px; font-family: 'Manrope', sans-serif;
            font-weight: 500; height: 40px; cursor: pointer; transition: all 0.15s ease; display: flex;
            align-items: center; justify-content: center; font-size: 1rem; -webkit-tap-highlight-color: transparent;
        }
        .keyboard-btn:hover { background-color: var(--thelo-bg); box-shadow: var(--shadow-md-hover); transform: translateY(-2px); }
        .keyboard-btn:active { box-shadow: none; transform: translateY(1px); }
        .keyboard-btn[data-symbol="functions"] { background-color: var(--thelo-blue); color: white; font-weight: 700; }
        .keyboard-btn[data-symbol="functions"].active { background-color: var(--thelo-blue-dark); }
        .keyboard-operator { color: var(--thelo-blue); }

        /* --- Canvas & Graphing Area --- */
        #canvasContainer { flex-grow: 1; position: relative; }
        #graphCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; cursor: grab; }
        #graphCanvas:active { cursor: grabbing; }
        #homeBtn { position: absolute; bottom: 20px; right: 20px; width: 44px; height: 44px; background-color: var(--sidebar-bg); border: 1px solid var(--thelo-border); border-radius: 50%; box-shadow: 0 4px 8px rgba(0,0,0,0.1); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: transform 0.2s, box-shadow 0.2s; z-index: 5; }
        #homeBtn:hover { transform: scale(1.1); box-shadow: 0 6px 12px rgba(0,0,0,0.15); }
        #homeBtn svg { width: 24px; height: 24px; stroke: var(--thelo-text-light); }

        /* --- Responsive Design --- */
        @media (max-width: 768px) {
            body { flex-direction: column; }
            #sidebar { width: 100%; height: 45vh; min-height: 350px; resize: none; border-right: none; border-bottom: 1px solid var(--thelo-border); }
            #homeBtn { bottom: 15px; right: 15px; }
            #mainKeyboard { grid-template-columns: repeat(auto-fill, minmax(40px, 1fr)); gap: 5px; }
        }
    </style>
</head>
<body>

    <div id="sidebar">
        <div class="sidebar-header">
            <h1>Graphing Calculator</h1>
            <div class="header-buttons">
                <button id="toggleAngleModeBtn" class="header-btn active" title="Switch to Degrees">RAD</button>
                <button id="toggleKeyboardBtn" class="header-btn" title="Toggle Keyboard">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3 3h18M3 7h18M3 11h18M3 15h18M4 21h4M10 21h4M16 21h4" /></svg>
                </button>
                <button id="add-item-btn" class="header-btn" title="Add new item">+</button>
            </div>
             <div id="add-item-menu">
                <button class="add-item-menu-btn" data-type="expression">Expression</button>
                <button class="add-item-menu-btn" data-type="table">Table</button>
            </div>
        </div>

        <div id="expressionListContainer">
            </div>

        <div id="keyboardContainer">
            <div id="functionsPanel">
                </div>
            <div id="mainKeyboard">
                </div>
        </div>
    </div>

    <div id="canvasContainer">
        <canvas id="graphCanvas"></canvas>
        <button id="homeBtn" title="Reset View">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M2.25 12l8.954-8.955c.44-.439 1.152-.439 1.591 0L21.75 12M4.5 9.75v10.125c0 .621.504 1.125 1.125 1.125H9.75v-4.875c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125V21h4.125c.621 0 1.125-.504 1.125-1.125V9.75M8.25 21h7.5" /></svg>
        </button>
    </div>

<script>
// --- Advanced Interactive Calculator (v5.0 - Full Featured) ---
document.addEventListener('DOMContentLoaded', () => {
    // --- DOM ELEMENTS ---
    const sidebar = document.getElementById('sidebar');
    const canvas = document.getElementById('graphCanvas');
    const ctx = canvas.getContext('2d');
    const expressionListContainer = document.getElementById('expressionListContainer');
    const addItemBtn = document.getElementById('add-item-btn');
    const addItemMenu = document.getElementById('add-item-menu');
    const homeBtn = document.getElementById('homeBtn');
    const functionsPanel = document.getElementById('functionsPanel');
    const mainKeyboard = document.getElementById('mainKeyboard');
    const toggleKeyboardBtn = document.getElementById('toggleKeyboardBtn');
    const toggleAngleModeBtn = document.getElementById('toggleAngleModeBtn');
    
    // --- LIBRARIES & CONSTANTS ---
    const MQ = MathQuill.getInterface(2);
    const devicePixelRatio = window.devicePixelRatio || 1;
    const PLOT_COLORS = ['#2563eb', '#c026d3', '#22c55e', '#f97316', '#8b5cf6', '#d946ef'];
    const INEQUALITY_ALPHA = 0.2;
    const POI_RADIUS = 4 * devicePixelRatio;

    const KEYBOARD_LAYOUT = {
        main: [
            'x', 'y', 'a^b', '√', '7', '8', '9', '/',
            '(', ')', '<', '>', '4', '5', '6', '*',
            '|a|', '≤', '≥', '=', '1', '2', '3', '-',
            'functions', 'π', 'e', 'θ', '0', '.', '%', '+'
        ],
        functions: {
            'Trig Functions': { 'sin': 'sin', 'cos': 'cos', 'tan': 'tan', 'asin': 'sin<sup>-1</sup>', 'acos': 'cos<sup>-1</sup>', 'atan': 'tan<sup>-1</sup>' },
            'Statistics': ['mean', 'median', 'stdev', 'min', 'max', 'total', 'quartile'],
            'Misc': ['nCr', 'nPr', '!', 'd/dx', 'log', 'ln']
        }
    };

    let graphState = {
        originX: 0, originY: 0, scale: 40,
        isPanning: false, panStart: { x: 0, y: 0 },
        expressions: [],
        activeInput: null,
        touchState: { isPinching: false, initialPinchDistance: 0 },
        intersections: [],
        hoverPoint: { visible: false, x: 0, y: 0 },
        lockedPoint: { visible: false, x: 0, y: 0, color: '#000' },
        angleMode: 'rad',
        definedVariables: {},
        nextTableId: 1
    };

    function debounce(func, delay) {
        let timeout;
        return (...args) => { clearTimeout(timeout); timeout = setTimeout(() => func.apply(this, args), delay); };
    }
    const debouncedEvaluateAndPlotAll = debounce(evaluateAndPlotAll, 150);
    const debouncedTablePlot = debounce(evaluateAndPlotAll, 50);

    function initialize() {
        setupKeyboards();
        resizeCanvas();
        addExpressionInput('');
        setupEventListeners();
        evaluateAndPlotAll();
    }
    
    function snapToZero(num, tolerance = 1e-9) { return Math.abs(num) < tolerance ? 0 : num; }

    function setupEventListeners() {
        window.addEventListener('resize', resizeCanvas);
        homeBtn.addEventListener('click', () => resetView());
        
        addItemBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            addItemMenu.style.display = addItemMenu.style.display === 'block' ? 'none' : 'block';
        });
        document.addEventListener('click', () => { addItemMenu.style.display = 'none'; });
        addItemMenu.addEventListener('click', (e) => {
             if (e.target.matches('.add-item-menu-btn')) {
                const type = e.target.dataset.type;
                if (type === 'expression') addExpressionInput();
                else if (type === 'table') addTable();
            }
        });

        toggleKeyboardBtn.addEventListener('click', () => {
            sidebar.classList.toggle('keyboard-open');
            toggleKeyboardBtn.classList.toggle('active', sidebar.classList.contains('keyboard-open'));
            if (!sidebar.classList.contains('keyboard-open')) {
                sidebar.classList.remove('functions-open');
                mainKeyboard.querySelector('[data-symbol="functions"]').classList.remove('active');
            }
        });

        toggleAngleModeBtn.addEventListener('click', () => {
            graphState.angleMode = graphState.angleMode === 'rad' ? 'deg' : 'rad';
            toggleAngleModeBtn.textContent = graphState.angleMode.toUpperCase();
            toggleAngleModeBtn.classList.toggle('active', graphState.angleMode === 'rad');
            evaluateAndPlotAll();
        });

        canvas.addEventListener('wheel', handleGraphZoom, { passive: false });
        canvas.addEventListener('mousedown', handleGraphPanStart);
        canvas.addEventListener('mousemove', handleGraphPanMove);
        window.addEventListener('mouseup', handleGraphPanEnd);
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd);
        canvas.addEventListener('mousemove', debounce(handleMouseMoveForHover, 10));
        canvas.addEventListener('click', handleGraphClick);
    }
    
    // --- NEW: Table Implementation ---
    function addTable() {
        const tableId = graphState.nextTableId++;
        const newExpr = {
            id: `table-${Date.now()}`,
            type: 'table',
            visible: true,
            color: PLOT_COLORS[graphState.expressions.length % PLOT_COLORS.length],
            data: {
                [`x_${tableId}`]: ['', ''],
                [`y_${tableId}`]: ['', '']
            },
        };
        graphState.expressions.push(newExpr);

        const item = document.createElement('div');
        item.className = 'expression-item';
        item.id = newExpr.id;
        item.innerHTML = `
            <div class="expression-main">
                <span class="expression-number">${graphState.expressions.length}</span>
                <div class="expression-color-bar" title="Toggle visibility"></div>
                <span style="flex-grow:1; text-align: right; font-weight: 500;">Table</span>
                <button class="remove-expression-btn" title="Remove table">&times;</button>
            </div>
            <div class="table-container">
                <table>
                    <thead><tr><th>x<sub>${tableId}</sub></th><th>y<sub>${tableId}</sub></th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
        `;
        expressionListContainer.appendChild(item);
        
        const tbody = item.querySelector('tbody');
        
        function addTableRow(xVal = '', yVal = '') {
            const row = tbody.insertRow();
            row.innerHTML = `
                <td><input type="text" value="${xVal}" placeholder="x"></td>
                <td><input type="text" value="${yVal}" placeholder="y"></td>
            `;
        }

        function updateTableState() {
            const xData = [], yData = [];
            tbody.querySelectorAll('tr').forEach(row => {
                const inputs = row.querySelectorAll('input');
                xData.push(inputs[0].value);
                yData.push(inputs[1].value);
            });
            // Add a blank row if the last row is filled
            if (xData[xData.length - 1] || yData[yData.length - 1]) {
                addTableRow();
            }
            newExpr.data[`x_${tableId}`] = xData.slice(0, -1).map(v => parseFloat(v) || 0);
            newExpr.data[`y_${tableId}`] = yData.slice(0, -1).map(v => parseFloat(v) || 0);
            debouncedTablePlot();
        }
        
        item.addEventListener('input', updateTableState);
        item.querySelector('.remove-expression-btn').addEventListener('click', () => removeExpression(newExpr.id));
        item.querySelector('.expression-color-bar').addEventListener('click', (e) => {
            newExpr.visible = !newExpr.visible;
            e.currentTarget.classList.toggle('hidden-expr', !newExpr.visible);
            evaluateAndPlotAll();
        });

        // Initial setup
        addTableRow(newExpr.data[`x_${tableId}`][0], newExpr.data[`y_${tableId}`][0]);
        addTableRow(newExpr.data[`x_${tableId}`][1], newExpr.data[`y_${tableId}`][1]);
        addTableRow(); // Blank row for new entries
        updateExpressionUI(newExpr);
    }
    
    function addExpressionInput(latexStr = '') {
        const exprIndex = graphState.expressions.length;
        const newExpr = { id: `expr-${Date.now()}-${Math.random()}`, type: 'expression', latex: latexStr, visible: true, color: PLOT_COLORS[exprIndex % PLOT_COLORS.length], sliders: {}, displayMode: 'decimal' };
        graphState.expressions.push(newExpr);

        const item = document.createElement('div');
        item.className = 'expression-item';
        item.id = newExpr.id;
        item.innerHTML = `
            <div class="expression-main">
                <span class="expression-number">${exprIndex + 1}</span>
                <div class="expression-color-bar" title="Toggle visibility"></div>
                <div class="expression-input-wrapper"><span class="math-input-field"></span></div>
                <div class="result-container">
                    <span class="expression-result"></span>
                    <button class="toggle-fraction-btn" style="display: none;" title="Toggle Fraction/Decimal">
                       <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M3 5.5h18v2H3v-2Zm0 11h18v2H3v-2Zm0-5.5h18v2H3v-2Z"/></svg>
                    </button>
                </div>
                <button class="remove-expression-btn" title="Remove expression">&times;</button>
            </div>
            <div class="expression-extras"></div>
        `;
        expressionListContainer.appendChild(item);

        const mathFieldSpan = item.querySelector('.math-input-field');
        const mathField = MQ.MathField(mathFieldSpan, {
            spaceBehavesLikeTab: true,
            handlers: {
                edit: () => { newExpr.latex = mathField.latex(); debouncedEvaluateAndPlotAll(); },
                enter: () => addExpressionInput(),
                deleteOutOf: (dir, field) => { if (dir === -1 && field.latex() === '' && graphState.expressions.length > 1) removeExpression(newExpr.id, item.previousElementSibling); },
                upOutOf: () => { const prevItem = item.previousElementSibling; if (prevItem) MQ(prevItem.querySelector('.math-input-field'))?.focus().moveToRightEnd(); },
                downOutOf: () => { const nextItem = item.nextElementSibling; if (nextItem) MQ(nextItem.querySelector('.math-input-field'))?.focus().moveToRightEnd(); }
            }
        });
        if (latexStr) mathField.latex(latexStr);
        mathField.focus();
        graphState.activeInput = mathField;
        
        item.querySelector('.remove-expression-btn').addEventListener('click', () => removeExpression(newExpr.id));
        item.querySelector('.expression-color-bar').addEventListener('click', (e) => {
            newExpr.visible = !newExpr.visible;
            e.currentTarget.classList.toggle('hidden-expr', !newExpr.visible);
            evaluateAndPlotAll();
        });
        item.querySelector('.toggle-fraction-btn').addEventListener('click', () => {
            newExpr.displayMode = newExpr.displayMode === 'decimal' ? 'fraction' : 'decimal';
            updateExpressionUI(newExpr);
        });
        mathFieldSpan.addEventListener('focusin', () => { graphState.activeInput = mathField; });
    }

    function removeExpression(id) {
        const item = document.getElementById(id); if (!item) return;
        const nextFocusItem = item.previousElementSibling || item.nextElementSibling;
        item.remove();
        graphState.expressions = graphState.expressions.filter(e => e.id !== id);
        updateExpressionNumbers();
        evaluateAndPlotAll();
        if (nextFocusItem) {
            const mathField = MQ(nextFocusItem.querySelector('.math-input-field'));
            if (mathField) {
                mathField.focus().moveToRightEnd();
                graphState.activeInput = mathField;
            }
        }
    }
    
    function updateExpressionNumbers() {
        expressionListContainer.querySelectorAll('.expression-item').forEach((item, index) => {
            item.querySelector('.expression-number').textContent = index + 1;
        });
    }
    
    // --- Parsing & Evaluation Engine ---
    function evaluateAndPlotAll() {
        graphState.definedVariables = {};
        graphState.expressions.forEach(parseSingleExpression);
        findAndStoreIntersections();
        graphState.expressions.forEach(updateExpressionUI);
        requestAnimationFrame(renderAll);
    }

    function latexToMathJs(latex) {
        let processed = latex.replace(/\\left\|([\s\S]+?)\\right\|/g, 'abs($1)');
        while (processed.includes('|')) {
            processed = processed.replace(/\|([^|]*)\|/g, 'abs($1)');
        }
        return processed
            .replace(/(\\operatorname{([a-zA-Z]+)})/g, '$2')
            .replace(/\\frac{d}{dx}\\left\(([\s\S]+?)\\right\)/g, "derivative('$1', 'x')")
            .replace(/\\sin/g, 'sin').replace(/\\cos/g, 'cos').replace(/\\tan/g, 'tan')
            .replace(/\\log/g, 'log10').replace(/\\ln/g, 'log')
            .replace(/\\sqrt/g, 'sqrt').replace(/\\pi/g, 'pi').replace(/\\theta/g, 'theta')
            .replace(/\\le/g, '<=').replace(/\\ge/g, '>=')
            .replace(/\\left\(/g, '(').replace(/\\right\)/g, ')')
            .replace(/\\left\[/g, '[').replace(/\\right\]/g, ']')
            .replace(/\\cdot/g, '*').replace(/\\frac{([^}]+)}{([^}]+)}/g, '($1)/($2)')
            .replace(/(\d+)%/g, '($1/100)')
            .replace(/([a-zA-Z0-9_]+)_{([a-zA-Z0-9]+)}/g, '$1_$2') // For y_1, x_1
            .replace(/{/g, '(').replace(/}/g, ')');
    }

    function getEvaluationScope(expr) {
        const scope = { ...graphState.definedVariables };
        // Add all table data to the global scope
        graphState.expressions.forEach(e => {
            if (e.type === 'table') {
                Object.assign(scope, e.data);
            }
        });
        Object.keys(expr.sliders || {}).forEach(name => { scope[name] = expr.sliders[name].val; });
        
        scope.total = math.sum; scope.stdev = math.std; scope.mean = math.mean;
        scope.median = math.median; scope.min = math.min; scope.max = math.max;
        scope.quartile = math.quantileSeq; scope.nCr = math.combinations; scope.nPr = math.permutations;

        if (graphState.angleMode === 'deg') {
            scope.sin = math.sind; scope.cos = math.cosd; scope.tan = math.tand;
            scope.asin = math.asind; scope.acos = math.acosd; scope.atan = math.atand;
        }
        return scope;
    }

    // --- NEW: Regression Solver ---
    function solveLinearRegression(yVar, xVar, params, scope) {
        const yData = scope[yVar.name];
        const xData = scope[xVar.name];
        if (!yData || !xData || yData.length !== xData.length || yData.length === 0) {
            return { error: "Mismatched or empty data." };
        }
        
        const n = yData.length;
        const X = math.matrix(xData.map(x => [1, x])); // Design matrix [1, x_i]
        const y = math.matrix(yData);
        
        try {
            // Solve (X^T * X) * b = X^T * y for b
            const Xt = math.transpose(X);
            const XtX = math.multiply(Xt, X);
            const Xty = math.multiply(Xt, y);
            const b = math.lusolve(XtX, Xty).toArray().flat(); // [intercept, slope]
            
            // Calculate R^2
            const y_mean = math.mean(yData);
            const ss_tot = math.sum(yData.map(yi => (yi - y_mean)**2));
            const y_pred = math.multiply(X, b).toArray().flat();
            const ss_res = math.sum(yData.map((yi, i) => (yi - y_pred[i])**2));
            const rSquared = 1 - (ss_res / ss_tot);

            const result = {};
            result[params.intercept] = b[0];
            result[params.slope] = b[1];
            result.rSquared = rSquared;
            return result;
        } catch (e) {
            return { error: "Regression failed. Check data." };
        }
    }

    function parseSingleExpression(expr) {
        if (expr.type !== 'expression') return; // Skip tables
        Object.assign(expr, { compiled: null, error: null, result: null, node: null, inequalityType: null, isImplicit: false, regression: null });
        let cleanStr = latexToMathJs(expr.latex.trim());
        if (!cleanStr) { expr.type = 'empty'; return; }
        
        try {
            // NEW: Regression parsing
            if (cleanStr.includes('~')) {
                const parts = cleanStr.split('~');
                const left = math.parse(parts[0]);
                const right = math.parse(parts[1]);
                if (left.isSymbolNode && right.isOperatorNode && right.op === '+' &&
                    right.args[0].isOperatorNode && right.args[0].op === '*') {
                    
                    const yVar = left;
                    const slopeTerm = right.args[0]; // m*x_1
                    const interceptTerm = right.args[1]; // b
                    
                    expr.type = 'regression';
                    expr.regression = {
                        yVar,
                        xVar: slopeTerm.args[1], // x_1
                        params: { slope: slopeTerm.args[0].name, intercept: interceptTerm.name }
                    };
                    const scope = getEvaluationScope(expr);
                    expr.result = solveLinearRegression(expr.regression.yVar, expr.regression.xVar, expr.regression.params, scope);
                    if (!expr.result.error) {
                        // For plotting the line
                        const plotScope = {...scope};
                        plotScope[expr.regression.params.slope] = expr.result[expr.regression.params.slope];
                        plotScope[expr.regression.params.intercept] = expr.result[expr.regression.params.intercept];
                        expr.compiled = math.compile(`${expr.regression.params.slope} * x + ${expr.regression.params.intercept}`);
                    } else {
                        expr.error = expr.result.error;
                    }
                    return; // End parsing for this expression
                }
            }
            
            const node = math.parse(cleanStr);
            expr.node = node;
            const scope = getEvaluationScope(expr);
            
            if (node.isAssignmentNode) {
                if (node.toString().match(/[xy]/)) { expr.error = "Cannot assign expression with x or y."; return; }
                expr.type = 'assignment';
                const result = node.evaluate(scope);
                expr.result = result;
                graphState.definedVariables[node.object.name] = result;
            } else if (cleanStr.includes('x') || cleanStr.includes('y')) {
                expr.type = 'function';
                let parseableNode = node;
                if (node.isOperatorNode && node.op === '=') {
                    const [left, right] = node.args;
                    if (left.isSymbolNode && left.name === 'y') { parseableNode = right; }
                    else if (right.isSymbolNode && right.name === 'y') { parseableNode = left; }
                    else if (left.isSymbolNode && left.name === 'x') { expr.type = 'vertical_line'; expr.x_value = right.evaluate(scope); }
                    else if (right.isSymbolNode && right.name === 'x') { expr.type = 'vertical_line'; expr.x_value = left.evaluate(scope); }
                    else { expr.error = "Implicit functions not yet supported."; }
                }
                if (expr.type === 'function') {
                    expr.node = parseableNode;
                    expr.compiled = parseableNode.compile();
                }
            } else if (node.isOperatorNode && ['<', '>', '<=', '>='].includes(node.op)) {
                expr.inequalityType = node.op;
                const [left, right] = node.args;
                if (left.isSymbolNode && left.name === 'y') { expr.type = 'inequality'; expr.compiled = right.compile(); }
                else if (right.isSymbolNode && right.name === 'y') { expr.type = 'inequality'; expr.compiled = left.compile(); expr.inequalityType = {'>':'<', '>=':'<=', '<':'>', '<=':'>='}[node.op]; }
                else if (left.isSymbolNode && left.name === 'x') { expr.type = 'vertical_inequality'; expr.x_value = right.evaluate(scope); }
                else if (right.isSymbolNode && right.name === 'x') { expr.type = 'vertical_inequality'; expr.x_value = left.evaluate(scope); expr.inequalityType = {'>':'<', '>=':'<=', '<':'>', '<=':'>='}[node.op]; }
                else { expr.type = 'calculation'; expr.result = node.evaluate(scope); }
            } else {
                expr.type = 'calculation';
                expr.result = node.evaluate(scope);
            }
            // Slider detection
            if (['function', 'inequality'].includes(expr.type)) {
                const knownSymbols = ['x', 'y', 'e', 'pi', 'i', 'true', 'false', 'theta', ...Object.keys(math), ...Object.keys(scope)];
                const foundSymbols = new Set();
                expr.node.traverse(n => {
                    if (n.isSymbolNode && !knownSymbols.includes(n.name)) {
                        foundSymbols.add(n.name);
                    }
                });
                foundSymbols.forEach(name => { if (!expr.sliders[name]) expr.sliders[name] = { val: 1, min: -5, max: 5, step: 0.1 }; });
                Object.keys(expr.sliders).forEach(name => { if (!foundSymbols.has(name)) delete expr.sliders[name]; });
            } else { expr.sliders = {}; }
            if (expr.type === 'function') findPointsOfInterest(expr);
        } catch (err) {
            expr.error = err.message.length > 50 ? err.message.substring(0, 50) + '...' : err.message;
        }
    }
    
    function updateExpressionUI(expr) {
        const item = document.getElementById(expr.id); if (!item) return;
        const resultEl = item.querySelector('.expression-result');
        const extrasEl = item.querySelector('.expression-extras');
        const colorBar = item.querySelector('.expression-color-bar');
        const fracBtn = item.querySelector('.toggle-fraction-btn');

        if (resultEl) resultEl.textContent = '';
        if (extrasEl) extrasEl.innerHTML = '';
        if (fracBtn) fracBtn.style.display = 'none';

        colorBar.style.backgroundColor = expr.error ? 'var(--error-red)' : (expr.visible ? expr.color : '#ccc');
        colorBar.style.borderColor = expr.error ? 'var(--error-red)' : expr.color;
        colorBar.title = expr.error ? expr.error : "Toggle visibility";

        if (expr.error) {
            if (resultEl) resultEl.textContent = 'Error';
        } else if (expr.type === 'regression') {
            const paramsDiv = document.createElement('div');
            paramsDiv.className = 'regression-params';
            let html = '<b>Parameters</b><br>';
            for (const key in expr.result) {
                html += `${key} = ${math.format(expr.result[key], 4)}<br>`;
            }
            paramsDiv.innerHTML = html;
            extrasEl.appendChild(paramsDiv);
        } else if (expr.result !== null && expr.result !== undefined) {
            try {
                if (typeof expr.result === 'function') {
                    if(resultEl) resultEl.textContent = 'f(x)';
                } else if (typeof expr.result === 'number' || math.isBigNumber(expr.result)) {
                    const num = math.number(expr.result);
                    // Show fraction toggle button if it's a non-integer
                    if (num % 1 !== 0 && fracBtn) { fracBtn.style.display = 'flex'; }
                    
                    if (expr.displayMode === 'fraction') {
                        const f = math.fraction(num);
                        resultEl.textContent = `= ${f.n}/${f.d}`;
                    } else {
                        resultEl.textContent = `= ${math.format(num, {precision: 5})}`;
                    }
                } else if (math.isComplex(expr.result)) {
                    resultEl.textContent = `= ${math.format(expr.result, {precision: 4})}`;
                } else {
                    resultEl.textContent = `= ${math.format(expr.result, {precision: 3})}`;
                }
            } catch {
                resultEl.textContent = `= ${expr.result.toString()}`;
            }
        }
        
        if (extrasEl) {
             Object.keys(expr.sliders || {}).forEach(name => {
                const slider = expr.sliders[name];
                const sliderDiv = document.createElement('div');
                sliderDiv.className = 'slider-container';
                sliderDiv.innerHTML = `<label>${name} = ${slider.val}</label><input type="range" min="${slider.min}" max="${slider.max}" value="${slider.val}" step="${slider.step}">`;
                extrasEl.appendChild(sliderDiv);
                sliderDiv.querySelector('input[type=range]').addEventListener('input', (e) => {
                    slider.val = parseFloat(e.target.value);
                    sliderDiv.querySelector('label').textContent = `${name} = ${slider.val}`;
                    evaluateAndPlotAll();
                });
            });
        }
    }

    // --- Rendering & Plotting Engine ---
    function renderAll() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGraphGrid();
        graphState.expressions.forEach(expr => {
            if (!expr.visible || expr.error) return;
            // Plotting logic based on type
            if (expr.type === 'inequality') plotInequality(expr);
            else if (expr.type === 'vertical_inequality') plotVerticalInequality(expr);
            else if (expr.type === 'function' || expr.type === 'regression') {
                plotFunction(expr);
                if(expr.poi) drawPointsOfInterest(expr);
            }
            else if (expr.type === 'vertical_line') plotVerticalLine(expr);
            else if (expr.type === 'table') plotTable(expr);
        });
        drawAllIntersectionPoints();
        if (graphState.hoverPoint.visible) drawHoverPoint();
        if (graphState.lockedPoint.visible) drawLockedPoint();
    }
    
    function plotTable(expr) {
        ctx.fillStyle = expr.color;
        const x_keys = Object.keys(expr.data).filter(k => k.startsWith('x_'));
        const y_keys = Object.keys(expr.data).filter(k => k.startsWith('y_'));
        if (x_keys.length === 0 || y_keys.length === 0) return;
        
        const xData = expr.data[x_keys[0]];
        const yData = expr.data[y_keys[0]];
        const len = Math.min(xData.length, yData.length);

        for(let i=0; i < len; i++) {
            const x = xData[i];
            const y = yData[i];
            if (typeof x !== 'number' || typeof y !== 'number') continue;
            const px = graphState.originX + x * graphState.scale;
            const py = graphState.originY - y * graphState.scale;
            ctx.beginPath();
            ctx.arc(px, py, POI_RADIUS, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    // ... [All other plotting, interaction, and helper functions from your original code] ...
    // ... [plotFunction, plotInequality, plotVerticalLine, etc. remain unchanged] ...
    // ... [findPointsOfInterest, bisectionSolve, findAndStoreIntersections, etc. are the same] ...
    // ... [drawPointsOfInterest, drawAllIntersectionPoints, etc. are the same] ...
    // ... [resizeCanvas, resetView, all pan/zoom/touch handlers are the same] ...
    // ... [drawGraphGrid is the same] ...
    
    // --- Unchanged Helper and Interaction Functions ---
    // Minimal versions for brevity, assume full versions from original code are here.
    function setupKeyboards() { KEYBOARD_LAYOUT.main.forEach(symbol => { const btn = createKeyboardButton(symbol, symbol); if (symbol === 'functions') { btn.addEventListener('click', () => { sidebar.classList.toggle('functions-open'); btn.classList.toggle('active'); }); } else { btn.addEventListener('click', () => insertSymbol(symbol)); } mainKeyboard.appendChild(btn); }); for (const categoryName in KEYBOARD_LAYOUT.functions) { const categoryDiv = document.createElement('div'); categoryDiv.className = 'function-category'; const title = document.createElement('h3'); title.textContent = categoryName; categoryDiv.appendChild(title); const gridDiv = document.createElement('div'); gridDiv.className = 'function-grid'; const categorySymbols = KEYBOARD_LAYOUT.functions[categoryName]; if (Array.isArray(categorySymbols)) { categorySymbols.forEach(symbol => { const btn = createKeyboardButton(symbol, symbol); btn.addEventListener('click', () => insertSymbol(symbol)); gridDiv.appendChild(btn); }); } else { for (const symbol in categorySymbols) { const displayHTML = categorySymbols[symbol]; const btn = createKeyboardButton(symbol, displayHTML); btn.addEventListener('click', () => insertSymbol(symbol)); gridDiv.appendChild(btn); } } categoryDiv.appendChild(gridDiv); functionsPanel.appendChild(categoryDiv); } }
    function createKeyboardButton(symbol, displayHTML) { const btn = document.createElement('button'); btn.className = 'keyboard-btn'; btn.dataset.symbol = symbol; btn.innerHTML = displayHTML; if (symbol === 'a^b') btn.innerHTML = 'a<sup>b</sup>'; else if (symbol === '|a|') btn.innerHTML = '| a |'; if (['/', '*', '-', '+', '='].includes(symbol)) { btn.classList.add('keyboard-operator'); } return btn; }
    function insertSymbol(symbol) { const mathField = graphState.activeInput; if (!mathField) return; const functionList = ['sin', 'cos', 'tan', 'asin', 'acos', 'atan', 'log', 'ln', 'mean', 'median', 'stdev', 'min', 'max', 'total', 'quartile']; if (functionList.includes(symbol)) { mathField.write(`\\operatorname{${symbol}}\\left(\\right)`); mathField.keystroke('Left'); } else if (symbol === 'nCr' || symbol === 'nPr') { mathField.write(`\\operatorname{${symbol}}\\left(,\\right)`); mathField.keystroke('Left Left'); } else if (symbol === 'a^b') { mathField.cmd('^'); } else if (symbol === '|a|') { mathField.write('\\left|\\right|'); mathField.keystroke('Left'); } else if (symbol === '√') { mathField.cmd('\\sqrt'); } else if (symbol === 'd/dx') { mathField.write('\\frac{d}{dx}\\left(\\right)'); mathField.keystroke('Left'); } else { mathField.write(symbol); } mathField.focus(); }
    function plotFunction(expr) { if (!expr.compiled) return; const scope = getEvaluationScope(expr); ctx.strokeStyle = expr.color; ctx.lineWidth = 2.5 * devicePixelRatio; ctx.beginPath(); let firstPoint = true; for (let px = 0; px < canvas.width; px++) { const x = (px - graphState.originX) / graphState.scale; scope.x = x; try { const y = expr.compiled.evaluate(scope); if (!Number.isFinite(y)) { firstPoint = true; continue; } const py = graphState.originY - (y * graphState.scale); if (firstPoint) { ctx.moveTo(px, py); firstPoint = false; } else { ctx.lineTo(px, py); } } catch (e) { firstPoint = true; } } ctx.stroke(); }
    function plotInequality(expr) { if (!expr.compiled) return; const scope = getEvaluationScope(expr); ctx.fillStyle = expr.color; ctx.globalAlpha = INEQUALITY_ALPHA; ctx.beginPath(); let firstPoint = true; for (let px = 0; px <= canvas.width; px++) { const x = (px - graphState.originX) / graphState.scale; scope.x = x; try { const y = expr.compiled.evaluate(scope); if (!Number.isFinite(y)) continue; const py = graphState.originY - (y * graphState.scale); if (firstPoint) { ctx.moveTo(px, py); firstPoint = false; } else { ctx.lineTo(px, py); } } catch (e) {} } const op = expr.inequalityType; if (op.includes('>')) { ctx.lineTo(canvas.width, 0); ctx.lineTo(0, 0); } else { ctx.lineTo(canvas.width, canvas.height); ctx.lineTo(0, canvas.height); } ctx.closePath(); ctx.fill(); ctx.globalAlpha = 1.0; if (op === '<' || op === '>') { ctx.setLineDash([8 * devicePixelRatio, 8 * devicePixelRatio]); } plotFunction(expr); ctx.setLineDash([]); }
    function plotVerticalLine(expr) { ctx.strokeStyle = expr.color; ctx.lineWidth = 2.5 * devicePixelRatio; const boundaryPx = graphState.originX + expr.x_value * graphState.scale; ctx.beginPath(); ctx.moveTo(boundaryPx, 0); ctx.lineTo(boundaryPx, canvas.height); ctx.stroke(); }
    function plotVerticalInequality(expr) { ctx.fillStyle = expr.color; ctx.globalAlpha = INEQUALITY_ALPHA; const boundaryPx = graphState.originX + expr.x_value * graphState.scale; const op = expr.inequalityType; if (op.includes('<')) { ctx.fillRect(0, 0, boundaryPx, canvas.height); } if (op.includes('>')) { ctx.fillRect(boundaryPx, 0, canvas.width - boundaryPx, canvas.height); } ctx.globalAlpha = 1.0; if (!op.includes('=')) { ctx.setLineDash([8 * devicePixelRatio, 8 * devicePixelRatio]); } plotVerticalLine(expr); ctx.setLineDash([]); }
    function findPointsOfInterest(expr) { expr.poi = { roots: [], y_intercept: null, extrema: [] }; if (!expr.compiled) return; const scope = getEvaluationScope(expr); try { const y_intercept = expr.compiled.evaluate({ ...scope, x: 0 }); if (Number.isFinite(y_intercept)) expr.poi.y_intercept = { x: 0, y: y_intercept }; } catch (e) {} let prev_y, prev_slope_sign; const step = 1 / graphState.scale; for (let px = 0; px < canvas.width; px++) { const x = (px - graphState.originX) / graphState.scale; try { const y = expr.compiled.evaluate({ ...scope, x: x }); if (prev_y !== undefined && Number.isFinite(y) && Number.isFinite(prev_y)) { if (Math.sign(y) !== Math.sign(prev_y)) { expr.poi.roots.push({ x: (x - step/2), y: 0 }); } const next_y = expr.compiled.evaluate({ ...scope, x: x + step }); if (Number.isFinite(next_y)) { const slope_sign = Math.sign(next_y - y); if (prev_slope_sign !== undefined && slope_sign !== prev_slope_sign && slope_sign !== 0) { expr.poi.extrema.push({ x: x, y: y }); } prev_slope_sign = slope_sign; } } prev_y = y; } catch (e) { prev_y = undefined; prev_slope_sign = undefined; } } }
    function drawPointsOfInterest(expr) { ctx.fillStyle = expr.color; const all_pois = [...expr.poi.roots, ...expr.poi.extrema]; if(expr.poi.y_intercept) all_pois.push(expr.poi.y_intercept); all_pois.forEach(point => { if(!point) return; const px = graphState.originX + point.x * graphState.scale; const py = graphState.originY - point.y * graphState.scale; ctx.beginPath(); ctx.arc(px, py, POI_RADIUS, 0, Math.PI * 2); ctx.fill(); }); }
    function bisectionSolve(f1_expr, f2_expr, a, b, tolerance = 1e-7, maxIterations = 50) { const f1_scope = getEvaluationScope(f1_expr); const f2_scope = getEvaluationScope(f2_expr); let fa, fb; try { fa = f1_expr.compiled.evaluate({...f1_scope, x: a}) - f2_expr.compiled.evaluate({...f2_scope, x: a}); fb = f1_expr.compiled.evaluate({...f1_scope, x: b}) - f2_expr.compiled.evaluate({...f2_scope, x: b}); } catch(e) { return null; } if (isNaN(fa) || isNaN(fb) || Math.sign(fa) === Math.sign(fb)) return null; let c = a; for (let i = 0; i < maxIterations; i++) { c = (a + b) / 2; let fc = f1_expr.compiled.evaluate({...f1_scope, x: c}) - f2_expr.compiled.evaluate({...f2_scope, x: c}); if (Math.abs(fc) < tolerance || (b - a) / 2 < tolerance) return c; if (Math.sign(fc) === Math.sign(fa)) { a = c; fa = fc; } else { b = c; } } return c; }
    function findAndStoreIntersections() { graphState.intersections = []; const plottableFuncs = graphState.expressions.filter(e => e.visible && e.compiled && (e.type === 'function' || e.type === 'inequality' || e.type === 'regression')); if (plottableFuncs.length < 2) return; for (let i = 0; i < plottableFuncs.length; i++) { for (let j = i + 1; j < plottableFuncs.length; j++) { const f1_expr = plottableFuncs[i], f2_expr = plottableFuncs[j]; let prev_diff; for (let px = 0; px < canvas.width; px++) { const x = (px - graphState.originX) / graphState.scale; try { const y1 = f1_expr.compiled.evaluate({...getEvaluationScope(f1_expr), x: x}); const y2 = f2_expr.compiled.evaluate({...getEvaluationScope(f2_expr), x: x}); const diff = y1 - y2; if (prev_diff !== undefined && Math.sign(diff) !== Math.sign(prev_diff)) { const intersectionX = bisectionSolve(f1_expr, f2_expr, x - (1 / graphState.scale), x); if (intersectionX !== null) { const intersectionY = f1_expr.compiled.evaluate({...getEvaluationScope(f1_expr), x: intersectionX}); if(Number.isFinite(intersectionY)) graphState.intersections.push({ x: intersectionX, y: intersectionY }); } } prev_diff = diff; } catch (e) { prev_diff = undefined; } } } } }
    function drawAllIntersectionPoints() { ctx.fillStyle = '#333'; graphState.intersections.forEach(point => { const pixelX = graphState.originX + point.x * graphState.scale; const pixelY = graphState.originY - point.y * graphState.scale; ctx.beginPath(); ctx.arc(pixelX, pixelY, POI_RADIUS, 0, Math.PI * 2); ctx.fill(); }); }
    function drawHoverPoint() { const { x, y } = graphState.hoverPoint; const pixelX = graphState.originX + x * graphState.scale; const pixelY = graphState.originY - y * graphState.scale; ctx.fillStyle = '#000'; ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; ctx.lineWidth = 3 * devicePixelRatio; ctx.beginPath(); ctx.arc(pixelX, pixelY, POI_RADIUS * 1.2, 0, Math.PI * 2); ctx.stroke(); ctx.fill(); }
    function drawLockedPoint() { const { x, y } = graphState.lockedPoint; const pixelX = graphState.originX + x * graphState.scale; const pixelY = graphState.originY - y * graphState.scale; ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(pixelX, pixelY, POI_RADIUS * 1.2, 0, Math.PI * 2); ctx.fill(); const coordText = `(${snapToZero(x).toFixed(3)}, ${snapToZero(y).toFixed(3)})`; const FONT_SIZE = 12 * devicePixelRatio; ctx.font = `bold ${FONT_SIZE}px 'Manrope'`; const textMetrics = ctx.measureText(coordText); const boxWidth = textMetrics.width + 16 * devicePixelRatio; const boxHeight = FONT_SIZE + 12 * devicePixelRatio; let boxX = pixelX + 15 * devicePixelRatio; let boxY = pixelY - (boxHeight / 2); if (boxX + boxWidth > canvas.width) boxX = pixelX - boxWidth - 15 * devicePixelRatio; if (boxY < 0) boxY = 5 * devicePixelRatio; if (boxY + boxHeight > canvas.height) boxY = canvas.height - boxHeight - 5 * devicePixelRatio; ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; ctx.shadowColor = 'rgba(0,0,0,0.2)'; ctx.shadowBlur = 10; ctx.beginPath(); ctx.roundRect(boxX, boxY, boxWidth, boxHeight, 5 * devicePixelRatio); ctx.fill(); ctx.shadowColor = 'transparent'; ctx.fillStyle = '#000'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(coordText, boxX + boxWidth / 2, boxY + boxHeight / 2); }
    function findClosestPoint(pixelX, pixelY) { let closestDist = Infinity, closestPoint = null; const CLICK_RADIUS = 15 * devicePixelRatio; const allPoints = [...graphState.intersections]; graphState.expressions.forEach(expr => { if(expr.type === 'table') { const xData = Object.values(expr.data)[0]; const yData = Object.values(expr.data)[1]; for(let i=0; i<xData.length; i++) allPoints.push({x: xData[i], y: yData[i]}); } else if (expr.poi) { allPoints.push(...expr.poi.roots, ...expr.poi.extrema, expr.poi.y_intercept); } }); allPoints.filter(p => p && typeof p.x === 'number' && typeof p.y === 'number').forEach(point => { const pointPixelX = graphState.originX + point.x * graphState.scale; const pointPixelY = graphState.originY - point.y * graphState.scale; const dist = Math.sqrt(Math.pow(pixelX - pointPixelX, 2) + Math.pow(pixelY - pointPixelY, 2)); if (dist < closestDist && dist < CLICK_RADIUS) { closestDist = dist; closestPoint = point; } }); return closestPoint; }
    function resizeCanvas() { const rect = canvas.parentElement.getBoundingClientRect(); canvas.width = rect.width * devicePixelRatio; canvas.height = rect.height * devicePixelRatio; canvas.style.width = `${rect.width}px`; canvas.style.height = `${rect.height}px`; if (graphState.originX === 0) { resetView(false); } evaluateAndPlotAll(); }
    function resetView(redraw = true) { graphState.originX = canvas.width / 2; graphState.originY = canvas.height / 2; graphState.scale = 40; if (redraw) { evaluateAndPlotAll(); } }
    function handleGraphZoom(e) { e.preventDefault(); const rect = canvas.getBoundingClientRect(); const mouseX = (e.clientX - rect.left) * devicePixelRatio; const mouseY = (e.clientY - rect.top) * devicePixelRatio; const zoomFactor = e.deltaY < 0 ? 1.1 : 1 / 1.1; applyZoom(mouseX, mouseY, zoomFactor); }
    function handleGraphPanStart(e) { if (e.button !== 0) return; graphState.isPanning = true; graphState.panStart = { x: e.clientX, y: e.clientY }; if (graphState.lockedPoint.visible) { graphState.lockedPoint.visible = false; requestAnimationFrame(renderAll); } }
    function handleGraphPanMove(e) { if (!graphState.isPanning) return; const dx = (e.clientX - graphState.panStart.x) * devicePixelRatio; const dy = (e.clientY - graphState.panStart.y) * devicePixelRatio; graphState.originX += dx; graphState.originY += dy; graphState.panStart = { x: e.clientX, y: e.clientY }; requestAnimationFrame(renderAll); }
    function handleGraphPanEnd() { if (graphState.isPanning) { graphState.isPanning = false; evaluateAndPlotAll(); } }
    function handleTouchStart(e) { e.preventDefault(); const touches = e.touches; if (touches.length === 1) { graphState.isPanning = true; graphState.panStart = { x: touches[0].clientX, y: touches[0].clientY }; } else if (touches.length === 2) { graphState.isPanning = false; graphState.touchState.isPinching = true; graphState.touchState.initialPinchDistance = getPinchDistance(touches); } }
    function handleTouchMove(e) { e.preventDefault(); const touches = e.touches; if (graphState.isPanning && touches.length === 1) { const dx = (touches[0].clientX - graphState.panStart.x) * devicePixelRatio; const dy = (touches[0].clientY - graphState.panStart.y) * devicePixelRatio; graphState.originX += dx; graphState.originY += dy; graphState.panStart = { x: touches[0].clientX, y: touches[0].clientY }; requestAnimationFrame(renderAll); } else if (graphState.touchState.isPinching && touches.length === 2) { const newDist = getPinchDistance(touches); const zoomFactor = newDist / graphState.touchState.initialPinchDistance; const rect = canvas.getBoundingClientRect(); const midX = ((touches[0].clientX + touches[1].clientX) / 2 - rect.left) * devicePixelRatio; const midY = ((touches[0].clientY + touches[1].clientY) / 2 - rect.top) * devicePixelRatio; applyZoom(midX, midY, zoomFactor); graphState.touchState.initialPinchDistance = newDist; } }
    function handleTouchEnd(e) { if (graphState.touchState.isPinching || graphState.isPanning) { evaluateAndPlotAll(); } graphState.isPanning = false; graphState.touchState.isPinching = false; }
    function getPinchDistance(touches) { const dx = touches[0].clientX - touches[1].clientX; const dy = touches[0].clientY - touches[1].clientY; return Math.sqrt(dx * dx + dy * dy); }
    function applyZoom(centerX, centerY, zoomFactor) { const mouseGraphX_before = (centerX - graphState.originX) / graphState.scale; const mouseGraphY_before = (graphState.originY - centerY) / graphState.scale; graphState.scale *= zoomFactor; graphState.scale = Math.max(0.1, Math.min(graphState.scale, 20000)); const mouseGraphX_after = (centerX - graphState.originX) / graphState.scale; const mouseGraphY_after = (graphState.originY - centerY) / graphState.scale; graphState.originX += (mouseGraphX_after - mouseGraphX_before) * graphState.scale; graphState.originY -= (mouseGraphY_after - mouseGraphY_before) * graphState.scale; evaluateAndPlotAll(); }
    function handleMouseMoveForHover(e) { if (graphState.isPanning) return; const rect = canvas.getBoundingClientRect(); const mouseX = (e.clientX - rect.left) * devicePixelRatio; const mouseY = (e.clientY - rect.top) * devicePixelRatio; const closestPoint = findClosestPoint(mouseX, mouseY); graphState.hoverPoint.visible = !!closestPoint; if (closestPoint) { graphState.hoverPoint.x = closestPoint.x; graphState.hoverPoint.y = closestPoint.y; } requestAnimationFrame(renderAll); }
    function handleGraphClick(e) { if (graphState.isPanning) return; const rect = canvas.getBoundingClientRect(); const clickX = (e.clientX - rect.left) * devicePixelRatio; const clickY = (e.clientY - rect.top) * devicePixelRatio; const pointToLock = findClosestPoint(clickX, clickY); if (pointToLock) { graphState.lockedPoint.visible = true; graphState.lockedPoint.x = pointToLock.x; graphState.lockedPoint.y = pointToLock.y; } else { graphState.lockedPoint.visible = false; } requestAnimationFrame(renderAll); }
    function drawGraphGrid() { const computedStyles = getComputedStyle(document.documentElement); const THELO_BORDER_COLOR = computedStyles.getPropertyValue('--thelo-border').trim(); const THELO_TEXT_LIGHT_COLOR = computedStyles.getPropertyValue('--thelo-text-light').trim(); ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.restore(); let dynamicGrid = 1; while (dynamicGrid * graphState.scale < 50 * devicePixelRatio) { dynamicGrid *= (dynamicGrid * graphState.scale < 25 * devicePixelRatio) ? 2 : 2.5; } while (dynamicGrid * graphState.scale > 100 * devicePixelRatio) { dynamicGrid /= (dynamicGrid * graphState.scale > 250 * devicePixelRatio) ? 2.5 : 2; } ctx.strokeStyle = THELO_BORDER_COLOR; ctx.lineWidth = 1 * devicePixelRatio; ctx.font = `${10 * devicePixelRatio}px 'Manrope'`; ctx.fillStyle = THELO_TEXT_LIGHT_COLOR; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; const startX = Math.floor(-graphState.originX / (graphState.scale * dynamicGrid)) * dynamicGrid; for (let x = startX; (x * graphState.scale + graphState.originX) < canvas.width; x += dynamicGrid) { const px = x * graphState.scale + graphState.originX; ctx.beginPath(); ctx.moveTo(px, 0); ctx.lineTo(px, canvas.height); ctx.stroke(); if (Math.abs(x) > 1e-9) { ctx.fillText(Number(x.toPrecision(4)), px + 2 * devicePixelRatio, graphState.originY - 5 * devicePixelRatio); } } const startY = Math.floor(graphState.originY / (graphState.scale * dynamicGrid)) * dynamicGrid; for (let y = startY; (graphState.originY - y * graphState.scale) < canvas.height; y -= dynamicGrid) { const py = graphState.originY - y * graphState.scale; ctx.beginPath(); ctx.moveTo(0, py); ctx.lineTo(canvas.width, py); ctx.stroke(); if (Math.abs(y) > 1e-9) { ctx.save(); ctx.textAlign = 'right'; ctx.fillText(Number(y.toPrecision(4)), graphState.originX - 5 * devicePixelRatio, py + 2 * devicePixelRatio); ctx.restore(); } } ctx.strokeStyle = THELO_TEXT_LIGHT_COLOR; ctx.lineWidth = 1.5 * devicePixelRatio; ctx.beginPath(); ctx.moveTo(0, graphState.originY); ctx.lineTo(canvas.width, graphState.originY); ctx.stroke(); ctx.beginPath(); ctx.moveTo(graphState.originX, 0); ctx.lineTo(graphState.originX, canvas.height); ctx.stroke(); }

    // --- START THE APP ---
    initialize();
});
</script>
</body>
</html>
