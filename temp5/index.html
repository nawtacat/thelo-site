<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Graphing Calculator</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;700&display=swap" rel="stylesheet">

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.1/math.min.js"></script>

    <style>
        /* --- General Setup & Variables --- */
        :root {
            --thelo-blue: #2563eb;
            --thelo-blue-dark: #1d4ed8;
            --thelo-bg: #f9fafb;
            --sidebar-bg: #ffffff;
            --thelo-text: #111827;
            --thelo-text-light: #6b7280;
            --thelo-border: #e5e7eb;
            --error-red: #ef4444;
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            --shadow-sm: 0 2px 4px -1px rgb(0 0 0 / 0.06), 0 2px 2px -1px rgb(0 0 0 / 0.04);
            --shadow-md-hover: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        body {
            margin: 0;
            font-family: 'Manrope', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            display: flex;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            background-color: var(--thelo-bg);
            color: var(--thelo-text);
        }

        /* --- Sidebar & Header --- */
        #sidebar {
            width: 420px;
            min-width: 320px;
            height: 100%;
            background-color: var(--sidebar-bg);
            border-right: 1px solid var(--thelo-border);
            box-shadow: var(--shadow-lg);
            z-index: 10;
            display: flex;
            flex-direction: column;
            resize: horizontal;
            overflow: hidden; /* Prevent sidebar scroll, keyboard will scroll */
        }
        .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--thelo-border);
            flex-shrink: 0;
        }
        .sidebar-header h1 { margin: 0; font-size: 1.25rem; }
        .header-buttons { display: flex; gap: 0.75rem; position: relative; }
        .header-btn {
            background-color: var(--sidebar-bg);
            color: var(--thelo-text-light);
            border: 1px solid var(--thelo-border);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 38px;
            height: 38px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: 700;
            box-shadow: var(--shadow-sm);
        }
        .header-btn:not(.active):hover { background-color: var(--thelo-bg); border-color: var(--thelo-text-light); transform: translateY(-1px); }
        .header-btn.active { background-color: var(--thelo-blue); color: white; border-color: var(--thelo-blue); }
        .header-btn:active { transform: translateY(1px); }
        .header-btn svg { width: 20px; height: 20px; stroke-width: 2; }
        
        #add-item-btn {
            background-color: var(--thelo-blue);
            color: white;
            border: none;
            font-size: 1.75rem;
            line-height: 1;
            box-shadow: 0 4px 10px -2px rgba(37, 99, 235, 0.4);
        }
        #add-item-btn:hover { background-color: var(--thelo-blue-dark); transform: translateY(-2px); box-shadow: 0 6px 12px -2px rgba(37, 99, 235, 0.5); }
        #add-item-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 8px;
            background-color: var(--sidebar-bg);
            border: 1px solid var(--thelo-border);
            border-radius: 8px;
            box-shadow: var(--shadow-lg);
            padding: 0.5rem;
            z-index: 100;
        }
        .dropdown-item {
            background: none;
            border: none;
            display: block;
            width: 100%;
            padding: 0.5rem 1rem;
            text-align: left;
            border-radius: 6px;
            cursor: pointer;
        }
        .dropdown-item:hover { background-color: var(--thelo-bg); }


        /* --- Expression List & Tables --- */
        #expressionListContainer {
            flex-grow: 1;
            overflow-y: auto;
            padding: 0.5rem 0;
        }
        .expression-item { border-bottom: 1px solid var(--thelo-border); padding: 0.5rem 1rem 0.5rem 0.75rem; }
        .expression-main { display: flex; align-items: center; gap: 0.5rem; }
        .expression-color-bar { width: 28px; height: 28px; border-radius: 50%; flex-shrink: 0; cursor: pointer; border: 2px solid; transition: opacity 0.2s; display: flex; align-items: center; justify-content: center; font-weight: bold; user-select: none; }
        .expression-color-bar.hidden-expr { opacity: 0.3; }
        .expression-number { color: var(--thelo-text-light); font-weight: 500; user-select: none; width: 20px; text-align: center; }
        .expression-input-wrapper { display: flex; align-items: center; flex-grow: 1; min-width: 0; }
        .math-input-field { flex-grow: 1; min-width: 0; padding: 8px; font-size: 1.3rem; cursor: text; background-color: var(--sidebar-bg); border: none; border-radius: 0; }
        .math-input-field.mq-focused { outline: none; box-shadow: none; }
        .expression-result { padding: 0 0.75rem; font-size: 1rem; color: var(--thelo-text-light); font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .remove-expression-btn { background: transparent; border: none; font-size: 1.75rem; color: var(--thelo-text-light); cursor: pointer; padding: 0 0.5rem; transition: color 0.2s; }
        .remove-expression-btn:hover { color: var(--error-red); }
        .expression-extras { padding: 0.75rem 0 0.5rem 52px; display: flex; flex-direction: column; gap: 8px;}
        .slider-container, .table-options-container { display: flex; align-items: center; gap: 10px; }
        .slider-container label { font-family: monospace; width: 90px; white-space: nowrap; font-size: 0.9rem; }
        .slider-container input[type=range] { flex-grow: 1; }
        .table-container { padding-left: 28px; margin-top: 8px; }
        .expression-table { border-collapse: collapse; width: 100%; }
        .expression-table th, .expression-table td { border: 1px solid var(--thelo-border); text-align: center; padding: 4px; }
        .expression-table th > div, .expression-table td > div { min-height: 24px; outline: none; padding: 4px; }
        .expression-table th { background-color: var(--thelo-bg); font-weight: 700; }
        .expression-table td > div[contenteditable="true"]:focus { box-shadow: 0 0 0 2px var(--thelo-blue); border-radius: 2px; }

        /* --- Keyboard & Functions Panel Layout --- */
        #keyboardContainer {
            position: relative;
            flex-shrink: 0;
            background-color: #f3f4f6; /* Light gray background for the whole keyboard area */
            border-top: 1px solid var(--thelo-border);
            display: none; /* Hidden by default, shown by #sidebar.keyboard-open */
        }
        #sidebar.keyboard-open #keyboardContainer { display: block; }
        #functionsPanel {
            position: absolute;
            bottom: 100%;
            left: 0; right: 0;
            max-height: 250px;
            overflow-y: auto;
            background-color: #f9fafb;
            border-bottom: 1px solid var(--thelo-border);
            box-shadow: 0 -4px 10px rgba(0,0,0,0.05);
            padding: 0.75rem 1rem;
            z-index: 20;
            transform: translateY(10px);
            opacity: 0; visibility: hidden;
            transition: transform 0.2s ease-out, opacity 0.2s ease-out, visibility 0.2s;
        }
        #sidebar.functions-open #functionsPanel { transform: translateY(0); opacity: 1; visibility: visible; }
        .function-category h3 { margin: 0.75rem 0 0.5rem; font-size: 0.75rem; font-weight: 700; color: var(--thelo-text-light); text-transform: uppercase; }
        .function-category:first-child h3 { margin-top: 0; }
        .function-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 8px; }
        #mainKeyboard { padding: 1rem; display: grid; grid-template-columns: repeat(8, 1fr); gap: 8px; }

        /* Universal Button Styles for Both Keyboards */
        .keyboard-btn {
            background: var(--sidebar-bg);
            color: var(--thelo-text);
            border: 1px solid var(--thelo-border);
            box-shadow: var(--shadow-sm);
            border-radius: 6px;
            font-family: 'Manrope', sans-serif;
            font-weight: 500;
            height: 40px;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex; align-items: center; justify-content: center;
            font-size: 1rem;
            -webkit-tap-highlight-color: transparent;
        }
        .keyboard-btn:hover { background-color: var(--thelo-bg); box-shadow: var(--shadow-md-hover); transform: translateY(-2px); }
        .keyboard-btn:active { box-shadow: none; transform: translateY(1px); }
        .keyboard-btn[data-symbol="functions"] { background-color: var(--thelo-blue); color: white; font-weight: 700; }
        .keyboard-btn[data-symbol="functions"].active { background-color: var(--thelo-blue-dark); }
        .keyboard-operator { color: var(--thelo-blue); }

        /* --- Canvas & Graphing Area --- */
        #canvasContainer { flex-grow: 1; position: relative; }
        #graphCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; cursor: grab; }
        #graphCanvas:active { cursor: grabbing; }
        #homeBtn { position: absolute; bottom: 20px; right: 20px; width: 44px; height: 44px; background-color: var(--sidebar-bg); border: 1px solid var(--thelo-border); border-radius: 50%; box-shadow: 0 4px 8px rgba(0,0,0,0.1); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: transform 0.2s, box-shadow 0.2s; z-index: 5; }
        #homeBtn:hover { transform: scale(1.1); box-shadow: 0 6px 12px rgba(0,0,0,0.15); }
        #homeBtn svg { width: 24px; height: 24px; stroke: var(--thelo-text-light); }

        /* --- Responsive Design --- */
        @media (max-width: 768px) {
            body { flex-direction: column; }
            #sidebar { width: 100%; height: 45vh; min-height: 350px; resize: none; border-right: none; border-bottom: 1px solid var(--thelo-border); }
            #homeBtn { bottom: 15px; right: 15px; }
            #mainKeyboard { grid-template-columns: repeat(auto-fill, minmax(40px, 1fr)); gap: 5px; }
        }
    </style>
</head>
<body>

    <div id="sidebar">
        <div class="sidebar-header">
            <h1>Graphing Calculator</h1>
            <div class="header-buttons">
                <button id="toggleAngleModeBtn" class="header-btn active" title="Switch to Degrees">RAD</button>
                <button id="toggleKeyboardBtn" class="header-btn" title="Toggle Keyboard">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3 3h18M3 7h18M3 11h18M3 15h18M4 21h4M10 21h4M16 21h4" /></svg>
                </button>
                <div id="add-item-container">
                     <button id="add-item-btn" class="header-btn" title="Add new item">+</button>
                     <div id="add-item-dropdown">
                         <button class="dropdown-item" data-type="expression">Expression</button>
                         <button class="dropdown-item" data-type="table">Table</button>
                     </div>
                </div>
            </div>
        </div>

        <div id="expressionListContainer"></div>

        <div id="keyboardContainer">
            <div id="functionsPanel"></div>
            <div id="mainKeyboard"></div>
        </div>
    </div>

    <div id="canvasContainer">
        <canvas id="graphCanvas"></canvas>
        <button id="homeBtn" title="Reset View">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M2.25 12l8.954-8.955c.44-.439 1.152-.439 1.591 0L21.75 12M4.5 9.75v10.125c0 .621.504 1.125 1.125 1.125H9.75v-4.875c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125V21h4.125c.621 0 1.125-.504 1.125-1.125V9.75M8.25 21h7.5" /></svg>
        </button>
    </div>

<script>
// --- Advanced Interactive Calculator (v5.0 - Tables Feature) ---
document.addEventListener('DOMContentLoaded', () => {
    // --- DOM ELEMENTS ---
    const sidebar = document.getElementById('sidebar');
    const canvas = document.getElementById('graphCanvas');
    const ctx = canvas.getContext('2d');
    const expressionListContainer = document.getElementById('expressionListContainer');
    const homeBtn = document.getElementById('homeBtn');
    const functionsPanel = document.getElementById('functionsPanel');
    const mainKeyboard = document.getElementById('mainKeyboard');
    const toggleKeyboardBtn = document.getElementById('toggleKeyboardBtn');
    const toggleAngleModeBtn = document.getElementById('toggleAngleModeBtn');
    const addItemBtn = document.getElementById('add-item-btn');
    const addItemDropdown = document.getElementById('add-item-dropdown');

    // --- LIBRARIES & CONSTANTS ---
    const MQ = MathQuill.getInterface(2);
    const devicePixelRatio = window.devicePixelRatio || 1;
    const PLOT_COLORS = ['#2563eb', '#c026d3', '#22c55e', '#f97316', '#8b5cf6', '#d946ef'];
    const INEQUALITY_ALPHA = 0.2;
    const POI_RADIUS = 4 * devicePixelRatio;

    const KEYBOARD_LAYOUT = {
        main: [
            'x', 'y', 'a^b', '√', '7', '8', '9', '/',
            '(', ')', '<', '>', '4', '5', '6', '*',
            '|a|', '≤', '≥', '=', '1', '2', '3', '-',
            'functions', 'π', 'e', 'θ', '0', '.', '[]', '+'
        ],
        functions: {
            'Trig Functions': { 'sin': 'sin', 'cos': 'cos', 'tan': 'tan', 'asin': 'sin<sup>-1</sup>', 'acos': 'cos<sup>-1</sup>', 'atan': 'tan<sup>-1</sup>' },
            'Statistics': ['mean', 'median', 'stdev', 'min', 'max', 'total', 'quartile'],
            'Misc': ['nCr', 'nPr', '!', 'd/dx', 'log', 'ln']
        }
    };

    let graphState = {
        originX: 0, originY: 0, scale: 40,
        isPanning: false, panStart: { x: 0, y: 0 },
        expressions: [],
        activeInput: null,
        touchState: { isPinching: false, initialPinchDistance: 0 },
        intersections: [],
        hoverPoint: { visible: false, x: 0, y: 0 },
        lockedPoint: { visible: false, x: 0, y: 0, color: '#000' },
        angleMode: 'rad',
        definedVariables: {},
        nextTableId: 1
    };

    function debounce(func, delay) {
        let timeout;
        return (...args) => { clearTimeout(timeout); timeout = setTimeout(() => func.apply(this, args), delay); };
    }
    const debouncedEvaluateAndPlotAll = debounce(evaluateAndPlotAll, 150);
    
    function initialize() {
        setupKeyboards();
        resizeCanvas();
        addExpressionInput(); // Start with one empty expression
        setupEventListeners();
        evaluateAndPlotAll();
    }

    function snapToZero(num, tolerance = 1e-9) {
        return Math.abs(num) < tolerance ? 0 : num;
    }

    function setupEventListeners() {
        window.addEventListener('resize', resizeCanvas);
        homeBtn.addEventListener('click', () => resetView());
        
        // Add item dropdown logic
        addItemBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            addItemDropdown.style.display = addItemDropdown.style.display === 'block' ? 'none' : 'block';
        });
        document.addEventListener('click', () => { addItemDropdown.style.display = 'none'; });
        addItemDropdown.addEventListener('click', (e) => {
            if (e.target.matches('.dropdown-item')) {
                const type = e.target.dataset.type;
                if (type === 'expression') addExpressionInput();
                else if (type === 'table') addTableExpression();
            }
        });

        toggleKeyboardBtn.addEventListener('click', () => {
            sidebar.classList.toggle('keyboard-open');
            toggleKeyboardBtn.classList.toggle('active', sidebar.classList.contains('keyboard-open'));
            if (!sidebar.classList.contains('keyboard-open')) {
                sidebar.classList.remove('functions-open');
                mainKeyboard.querySelector('[data-symbol="functions"]').classList.remove('active');
            }
        });

        toggleAngleModeBtn.addEventListener('click', () => {
            graphState.angleMode = graphState.angleMode === 'rad' ? 'deg' : 'rad';
            toggleAngleModeBtn.textContent = graphState.angleMode.toUpperCase();
            toggleAngleModeBtn.classList.toggle('active', graphState.angleMode === 'rad');
            evaluateAndPlotAll();
        });

        canvas.addEventListener('wheel', handleGraphZoom, { passive: false });
        canvas.addEventListener('mousedown', handleGraphPanStart);
        canvas.addEventListener('mousemove', handleGraphPanMove);
        window.addEventListener('mouseup', handleGraphPanEnd);
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd);
        canvas.addEventListener('mousemove', debounce(handleMouseMoveForHover, 10));
        canvas.addEventListener('click', handleGraphClick);
    }
    
    function setupKeyboards() { /* ... KEPT IDENTICAL ... */ }
    function createKeyboardButton(symbol, displayHTML) { /* ... KEPT IDENTICAL ... */ }
    function insertSymbol(symbol) { /* ... KEPT IDENTICAL ... */ }

    // --- Expression & Table Creation ---
    
    function addExpressionInput(latexStr = '') {
        const exprIndex = graphState.expressions.length;
        const newExpr = {
            id: `expr-${Date.now()}-${Math.random()}`,
            type: 'expression',
            latex: latexStr,
            visible: true,
            color: PLOT_COLORS[exprIndex % PLOT_COLORS.length],
            sliders: {},
        };
        graphState.expressions.push(newExpr);
        
        const item = document.createElement('div');
        item.className = 'expression-item';
        item.id = newExpr.id;
        item.innerHTML = `
            <div class="expression-main">
                <span class="expression-number">${exprIndex + 1}</span>
                <div class="expression-color-bar" title="Toggle visibility"></div>
                <div class="expression-input-wrapper"><span class="math-input-field"></span></div>
                <span class="expression-result"></span>
                <button class="remove-expression-btn" title="Remove expression">&times;</button>
            </div>
            <div class="expression-extras"></div>`;
        expressionListContainer.appendChild(item);

        const mathFieldSpan = item.querySelector('.math-input-field');
        const mathField = MQ.MathField(mathFieldSpan, {
            spaceBehavesLikeTab: true,
            handlers: {
                edit: () => { newExpr.latex = mathField.latex(); debouncedEvaluateAndPlotAll(); },
                enter: () => addExpressionInput(),
                deleteOutOf: (dir, field) => { if (dir === -1 && field.latex() === '' && graphState.expressions.length > 1) removeExpression(newExpr.id, item.previousElementSibling); },
                upOutOf: () => { const prevItem = item.previousElementSibling; if (prevItem) MQ(prevItem.querySelector('.math-input-field'))?.focus().moveToRightEnd(); },
                downOutOf: () => { const nextItem = item.nextElementSibling; if (nextItem) MQ(nextItem.querySelector('.math-input-field'))?.focus().moveToRightEnd(); }
            }
        });
        if (latexStr) mathField.latex(latexStr);
        mathField.focus();
        graphState.activeInput = mathField;
        
        item.querySelector('.remove-expression-btn').addEventListener('click', () => { if (graphState.expressions.length > 1) removeExpression(newExpr.id); });
        item.querySelector('.expression-color-bar').addEventListener('click', (e) => { newExpr.visible = !newExpr.visible; e.currentTarget.classList.toggle('hidden-expr', !newExpr.visible); evaluateAndPlotAll(); });
        mathFieldSpan.addEventListener('focusin', () => { graphState.activeInput = mathField; });
    }

    function addTableExpression() {
        const tableIndex = graphState.nextTableId++;
        const exprIndex = graphState.expressions.length;
        const newExpr = {
            id: `expr-${Date.now()}-${Math.random()}`,
            type: 'table',
            tableId: tableIndex,
            columns: [
                { name: `x_{${tableIndex}}`, values: ['', '', ''], formula: null },
                { name: `y_{${tableIndex}}`, values: ['', '', ''], formula: null },
            ],
            plotOptions: { connect: false },
            visible: true,
            color: PLOT_COLORS[exprIndex % PLOT_COLORS.length],
        };
        graphState.expressions.push(newExpr);

        const item = document.createElement('div');
        item.className = 'expression-item';
        item.id = newExpr.id;
        item.innerHTML = `
            <div class="expression-main">
                <span class="expression-number">${exprIndex + 1}</span>
                <div class="expression-color-bar" title="Toggle visibility"></div>
                <div style="flex-grow: 1;"></div> <button class="remove-expression-btn" title="Remove expression">&times;</button>
            </div>
            <div class="table-container"></div>
            <div class="expression-extras"></div>
        `;
        expressionListContainer.appendChild(item);
        
        buildTableDOM(item, newExpr);

        item.querySelector('.remove-expression-btn').addEventListener('click', () => removeExpression(newExpr.id));
        item.querySelector('.expression-color-bar').addEventListener('click', (e) => { newExpr.visible = !newExpr.visible; e.currentTarget.classList.toggle('hidden-expr', !newExpr.visible); evaluateAndPlotAll(); });

        evaluateAndPlotAll();
    }
    
    function buildTableDOM(item, expr) {
        const container = item.querySelector('.table-container');
        container.innerHTML = ''; // Clear previous
        const table = document.createElement('table');
        table.className = 'expression-table';

        // Header
        const thead = table.createTHead();
        const headerRow = thead.insertRow();
        expr.columns.forEach((col, colIndex) => {
            const th = document.createElement('th');
            const div = document.createElement('div');
            div.contentEditable = true;
            div.textContent = col.formula ? col.formula : col.name;
            th.appendChild(div);
            headerRow.appendChild(th);
            
            div.addEventListener('blur', () => {
                const newContent = div.textContent.trim();
                const isFormula = newContent.includes(expr.columns[0].name); // Simple check
                if (isFormula) {
                    col.formula = newContent;
                } else {
                    col.formula = null;
                    col.name = newContent;
                }
                evaluateAndPlotAll();
            });
        });

        // Body
        const tbody = table.createTBody();
        const numRows = expr.columns[0].values.length;
        for (let rowIndex = 0; rowIndex < numRows; rowIndex++) {
            const row = tbody.insertRow();
            expr.columns.forEach((col, colIndex) => {
                const cell = row.insertCell();
                const div = document.createElement('div');
                div.contentEditable = !col.formula;
                div.textContent = col.values[rowIndex];
                cell.appendChild(div);

                if (!col.formula) {
                    div.addEventListener('input', () => {
                        col.values[rowIndex] = div.textContent;
                        if (rowIndex === expr.columns[0].values.length - 1 && div.textContent.trim() !== '') {
                            expr.columns.forEach(c => c.values.push(''));
                            buildTableDOM(item, expr); // Rebuild to add new row
                        }
                        debouncedEvaluateAndPlotAll();
                    });
                }
            });
        }
        container.appendChild(table);

        // Options
        const extras = item.querySelector('.expression-extras');
        extras.innerHTML = `<div class="table-options-container"><label>Connect points</label><input type="checkbox" ${expr.plotOptions.connect ? 'checked' : ''}></div>`;
        extras.querySelector('input[type=checkbox]').addEventListener('change', (e) => {
            expr.plotOptions.connect = e.target.checked;
            evaluateAndPlotAll();
        });
    }

    function removeExpression(id) {
        // ... KEPT IDENTICAL, but will now also correctly remove tables ...
    }
    function updateExpressionNumbers() { /* ... KEPT IDENTICAL ... */ }
    
    // --- Parsing & Evaluation Engine ---

    function evaluateAndPlotAll() {
        graphState.definedVariables = {}; // Reset state at the beginning of a full run.
        
        // First pass: evaluate all tables to define their variables
        graphState.expressions.forEach(expr => {
            if (expr.type === 'table') parseTableExpression(expr);
        });

        // Second pass: evaluate all other expressions
        graphState.expressions.forEach(expr => {
            if (expr.type === 'expression') parseSingleExpression(expr);
        });

        findAndStoreIntersections();
        graphState.expressions.forEach(updateExpressionUI);
        requestAnimationFrame(renderAll);
    }
    
    function latexToMathJs(latex) { /* ... KEPT IDENTICAL ... */ }
    function preprocessInputString(str) { /* ... KEPT IDENTICAL ... */ }
    function getEvaluationScope(expr) { /* ... KEPT IDENTICAL ... */ }

    function parseTableExpression(expr) {
        Object.assign(expr, { error: null });
        const scope = { ...graphState.definedVariables }; // Use global scope
        
        // Process independent columns first (the ones without formulas)
        expr.columns.forEach(col => {
            if (!col.formula) {
                col.numericValues = col.values.map(val => {
                    try {
                        if (val.trim() === '') return undefined;
                        return math.evaluate(val, scope);
                    } catch { return undefined; }
                });
                graphState.definedVariables[col.name] = col.numericValues;
            }
        });
        
        // Process dependent columns (with formulas)
        expr.columns.forEach(col => {
            if (col.formula) {
                const independentColName = expr.columns[0].name;
                const independentCol = expr.columns[0];
                const node = math.parse(col.formula);
                const compiled = node.compile();

                col.numericValues = independentCol.numericValues.map((val, i) => {
                    if (val === undefined) return undefined;
                    const rowScope = { ...scope, [independentColName]: val };
                    try {
                        const result = compiled.evaluate(rowScope);
                        // Update table cell in the DOM
                        const cellDiv = document.querySelector(`#${expr.id} tbody tr:nth-child(${i + 1}) td:nth-child(2) div`);
                        if (cellDiv) cellDiv.textContent = math.format(result, {precision: 4});
                        return result;
                    } catch { return undefined; }
                });
                graphState.definedVariables[col.name] = col.numericValues;
            }
        });
    }

    function parseSingleExpression(expr) { /* ... KEPT IDENTICAL ... */ }
    
    function updateExpressionUI(expr) {
        const item = document.getElementById(expr.id);
        if (!item) return;
        const colorBar = item.querySelector('.expression-color-bar');
        colorBar.style.backgroundColor = expr.error ? 'var(--error-red)' : (expr.visible ? expr.color : '#ccc');
        colorBar.style.borderColor = expr.error ? 'var(--error-red)' : expr.color;
        colorBar.title = expr.error ? expr.error : "Toggle visibility";
        
        if (expr.type === 'expression') {
            const resultEl = item.querySelector('.expression-result');
            const extrasEl = item.querySelector('.expression-extras');
            resultEl.textContent = '';
            extrasEl.innerHTML = '';

            if (expr.error) { resultEl.textContent = 'Error'; } 
            else if (expr.result !== null && expr.result !== undefined) { /* ... KEPT IDENTICAL ... */ }

            Object.keys(expr.sliders).forEach(name => {
                // ... Slider UI logic KEPT IDENTICAL ...
            });
        }
        // Table UI is mostly managed by buildTableDOM and the evaluation loop
    }
    
    // --- Rendering Engine ---
    
    function renderAll() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGraphGrid();
        graphState.expressions.forEach(expr => {
            if (!expr.visible || expr.error) return;
            switch(expr.type) {
                case 'inequality': plotInequality(expr); break;
                case 'vertical_inequality': plotVerticalInequality(expr); break;
                case 'function':
                    plotFunction(expr);
                    drawPointsOfInterest(expr);
                    break;
                case 'vertical_line': plotVerticalLine(expr); break;
                case 'table': plotTable(expr); break;
            }
        });
        drawAllIntersectionPoints();
        if (graphState.hoverPoint.visible) drawHoverPoint();
        if (graphState.lockedPoint.visible) drawLockedPoint();
    }
    
    function plotTable(expr) {
        const [xCol, yCol] = expr.columns;
        if (!xCol?.numericValues || !yCol?.numericValues) return;
        
        ctx.strokeStyle = expr.color;
        ctx.fillStyle = expr.color;
        ctx.lineWidth = 2 * devicePixelRatio;

        const pointsToConnect = [];

        for(let i = 0; i < xCol.numericValues.length; i++) {
            const x = xCol.numericValues[i];
            const y = yCol.numericValues[i];

            if (typeof x !== 'number' || typeof y !== 'number' || !isFinite(x) || !isFinite(y)) {
                continue;
            }
            
            const px = graphState.originX + x * graphState.scale;
            const py = graphState.originY - y * graphState.scale;
            
            ctx.beginPath();
            ctx.arc(px, py, POI_RADIUS, 0, Math.PI * 2);
            ctx.fill();

            if (expr.plotOptions.connect) {
                pointsToConnect.push({px, py});
            }
        }
        
        if (expr.plotOptions.connect && pointsToConnect.length > 1) {
            ctx.beginPath();
            ctx.moveTo(pointsToConnect[0].px, pointsToConnect[0].py);
            for(let i = 1; i < pointsToConnect.length; i++) {
                ctx.lineTo(pointsToConnect[i].px, pointsToConnect[i].py);
            }
            ctx.stroke();
        }
    }

    function plotFunction(expr) { /* ... KEPT IDENTICAL ... */ }
    function plotInequality(expr) { /* ... KEPT IDENTICAL ... */ }
    function plotVerticalLine(expr) { /* ... KEPT IDENTICAL ... */ }
    function plotVerticalInequality(expr) { /* ... KEPT IDENTICAL ... */ }
    function findPointsOfInterest(expr) { /* ... KEPT IDENTICAL ... */ }
    function drawPointsOfInterest(expr) { /* ... KEPT IDENTICAL ... */ }
    function bisectionSolve(f1_expr, f2_expr, a, b, tolerance = 1e-7, maxIterations = 50) { /* ... KEPT IDENTICAL ... */ }
    function findAndStoreIntersections() { /* ... KEPT IDENTICAL ... */ }
    function drawAllIntersectionPoints() { /* ... KEPT IDENTICAL ... */ }
    function drawHoverPoint() { /* ... KEPT IDENTICAL ... */ }
    function drawLockedPoint() { /* ... KEPT IDENTICAL ... */ }
    function findClosestPoint(pixelX, pixelY) { /* ... KEPT IDENTICAL ... */ }
    function resizeCanvas() { /* ... KEPT IDENTICAL ... */ }
    function resetView(redraw = true) { /* ... KEPT IDENTICAL ... */ }
    function handleGraphZoom(e) { /* ... KEPT IDENTICAL ... */ }
    function handleGraphPanStart(e) { /* ... KEPT IDENTICAL ... */ }
    function handleGraphPanMove(e) { /* ... KEPT IDENTICAL ... */ }
    function handleGraphPanEnd() { /* ... KEPT IDENTICAL ... */ }
    function handleTouchStart(e) { /* ... KEPT IDENTICAL ... */ }
    function handleTouchMove(e) { /* ... KEPT IDENTICAL ... */ }
    function handleTouchEnd(e) { /* ... KEPT IDENTICAL ... */ }
    function getPinchDistance(touches) { /* ... KEPT IDENTICAL ... */ }
    function applyZoom(centerX, centerY, zoomFactor) { /* ... KEPT IDENTICAL ... */ }
    function handleMouseMoveForHover(e) { /* ... KEPT IDENTICAL ... */ }
    function handleGraphClick(e) { /* ... KEPT IDENTICAL ... */ }
    function drawGraphGrid() { /* ... KEPT IDENTICAL ... */ }

    // --- START THE APP ---
    initialize();
});
</script>
</body>
</html>
