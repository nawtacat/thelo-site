<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thelo Geometry SVG Creator</title>
    <link rel="icon" href="https://thelo.space/img/thelofavicon.png" type="image/png" />

    <!-- Fonts and Icons -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;700;800&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" rel="stylesheet">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        :root {
            --thelo-blue: #2563EB;
            --thelo-blue-light: #EFF6FF;
            --thelo-green: #10B981;
            --thelo-amber: #F59E0B;
            --thelo-bg: #F8F9FA;
            --thelo-text: #111827;
            --thelo-text-light: #6B7280;
            --grid-color: #E5E7EB;
        }

        body {
            font-family: 'Manrope', sans-serif;
            background-color: var(--thelo-bg);
            color: var(--thelo-text);
            overflow: hidden;
        }

        .tool-btn {
            transition: all 0.2s ease;
        }

        .tool-btn.active {
            background-color: var(--thelo-blue);
            color: white;
            box-shadow: 0 4px 14px rgba(37, 99, 235, 0.25);
        }
        
        #svg-canvas {
            background-color: #fff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 14px rgba(0,0,0,0.05);
        }

        #svg-canvas.mode-panning { cursor: grab; }
        #svg-canvas.mode-dragging { cursor: move; }
        #svg-canvas.mode-drawing, #svg-canvas.mode-cropping { cursor: crosshair; }
        
        .drawable:hover {
            stroke: var(--thelo-blue);
            stroke-width: 3.5px;
            fill-opacity: 0.7;
        }
        
        .selected {
            stroke: var(--thelo-amber) !important;
            stroke-width: 3.5px !important;
            stroke-dasharray: 5 5;
        }
        
        .crop-rect {
            fill: rgba(37, 99, 235, 0.1);
            stroke: var(--thelo-blue);
            stroke-width: 2px;
            stroke-dasharray: 6 6;
        }

        .crop-overlay {
            fill: rgba(0, 0, 0, 0.5);
            pointer-events: none;
        }
        
        .smart-guide {
            stroke: var(--thelo-blue);
            stroke-width: 1px;
            stroke-dasharray: 4 4;
            pointer-events: none;
        }

        .smart-guide-label {
            fill: var(--thelo-blue);
            font-family: 'Manrope', sans-serif;
            font-size: 12px;
            font-weight: bold;
            pointer-events: none;
        }
        
        .vertex-handle {
            fill: var(--thelo-blue);
            stroke: white;
            stroke-width: 2px;
            cursor: move;
        }
        
        .vertex-handle:hover {
            r: 8;
        }
    </style>
</head>
<body class="w-screen h-screen flex flex-col antialiased">

    <header class="bg-white/70 backdrop-blur-lg border-b border-gray-200 p-4 flex justify-between items-center z-10">
        <div class="flex items-center gap-4">
            <img src="https://thelo.space/img/bluethelo.svg" alt="Thelo logo" class="h-10 w-auto" />
            <h1 class="text-xl font-bold text-gray-800">Geometry Creator</h1>
        </div>
        <div class="text-sm text-gray-500">
             <kbd class="px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg">Shift</kbd> to straighten, <kbd class="px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg">Scroll</kbd> to Zoom
        </div>
    </header>

    <div class="flex-grow flex gap-6 p-6 overflow-hidden">

        <aside class="w-72 bg-white p-5 rounded-xl shadow-sm border border-gray-200 flex flex-col gap-8 z-10">
            <div>
                <h2 class="font-bold text-lg mb-3">Tools</h2>
                <div class="grid grid-cols-2 gap-3">
                    <button id="tool-select" class="tool-btn active flex items-center justify-center gap-2 p-3 rounded-lg border bg-gray-50 hover:bg-gray-100">
                        <i class="fas fa-mouse-pointer fa-lg w-5 text-center"></i>
                        <span class="text-sm font-semibold">Select</span>
                    </button>
                    <button id="tool-line" class="tool-btn flex items-center justify-center gap-2 p-3 rounded-lg border bg-gray-50 hover:bg-gray-100">
                        <i class="fas fa-drafting-compass fa-lg w-5 text-center"></i>
                        <span class="text-sm font-semibold">Line</span>
                    </button>
                    <button id="tool-triangle" class="tool-btn flex items-center justify-center gap-2 p-3 rounded-lg border bg-gray-50 hover:bg-gray-100">
                        <i class="fas fa-play fa-lg w-5 text-center" style="transform: rotate(-90deg);"></i>
                        <span class="text-sm font-semibold">Triangle</span>
                    </button>
                    <button id="tool-circle" class="tool-btn flex items-center justify-center gap-2 p-3 rounded-lg border bg-gray-50 hover:bg-gray-100">
                        <i class="far fa-circle fa-lg w-5 text-center"></i>
                        <span class="text-sm font-semibold">Circle</span>
                    </button>
                    <button id="tool-text" class="tool-btn flex items-center justify-center gap-2 p-3 rounded-lg border bg-gray-50 hover:bg-gray-100">
                        <i class="fas fa-font fa-lg w-5 text-center"></i>
                        <span class="text-sm font-semibold">Text</span>
                    </button>
                    <button id="tool-crop" class="tool-btn flex items-center justify-center gap-2 p-3 rounded-lg border bg-gray-50 hover:bg-gray-100">
                        <i class="fas fa-crop-simple fa-lg w-5 text-center"></i>
                        <span class="text-sm font-semibold">Crop</span>
                    </button>
                </div>
            </div>
            
            <div id="crop-actions" class="hidden space-y-3">
                <h2 class="font-bold text-lg">Crop Area</h2>
                 <button id="confirm-crop-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                    <i class="fas fa-check mr-2"></i>Confirm Crop
                </button>
                 <button id="cancel-crop-btn" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                    <i class="fas fa-times mr-2"></i>Cancel
                </button>
            </div>


            <div id="properties-panel" class="hidden">
                <h2 class="font-bold text-lg mb-3">Properties</h2>
                <div class="space-y-4">
                    <div id="text-properties" class="hidden">
                        <div>
                            <label for="text-input" class="block text-sm font-medium text-gray-700">Text</label>
                            <input type="text" id="text-input" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm sm:text-sm">
                        </div>
                        <div>
                            <label for="font-size-input" class="block text-sm font-medium text-gray-700">Font Size</label>
                            <input type="number" id="font-size-input" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm sm:text-sm" min="1">
                        </div>
                    </div>
                    <div>
                        <label for="stroke-color" class="block text-sm font-medium text-gray-700">Color</label>
                        <input type="color" id="stroke-color" value="#111827" class="mt-1 block w-full h-8 rounded-md border-gray-300 shadow-sm">
                    </div>
                    <button id="delete-btn" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                        <i class="fas fa-trash-alt mr-2"></i>Delete
                    </button>
                </div>
            </div>
            
            <div class="mt-auto">
                 <h2 class="font-bold text-lg mb-3">Export</h2>
                 <div class="space-y-3">
                    <button id="download-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                        <i class="fas fa-download mr-2"></i>Download SVG
                    </button>
                    <button id="copy-btn" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                        <i class="fas fa-copy mr-2"></i>Copy Code
                    </button>
                 </div>
            </div>
        </aside>

        <main class="flex-grow bg-white rounded-xl border border-gray-200" id="canvas-container">
            <svg id="svg-canvas" class="w-full h-full"></svg>
        </main>

    </div>
    
    <textarea id="svg-code-output" class="absolute -left-full"></textarea>

    <script type="module">
        // --- DOM Elements ---
        const svgCanvas = document.getElementById('svg-canvas');
        const canvasContainer = document.getElementById('canvas-container');
        const propertiesPanel = document.getElementById('properties-panel');
        const textProperties = document.getElementById('text-properties');
        const textInput = document.getElementById('text-input');
        const fontSizeInput = document.getElementById('font-size-input');
        const strokeColorInput = document.getElementById('stroke-color');
        const deleteBtn = document.getElementById('delete-btn');
        const downloadBtn = document.getElementById('download-btn');
        const copyBtn = document.getElementById('copy-btn');
        const svgCodeOutput = document.getElementById('svg-code-output');
        const cropActions = document.getElementById('crop-actions');
        const confirmCropBtn = document.getElementById('confirm-crop-btn');
        const cancelCropBtn = document.getElementById('cancel-crop-btn');
        const toolButtons = {
            select: document.getElementById('tool-select'),
            line: document.getElementById('tool-line'),
            triangle: document.getElementById('tool-triangle'),
            circle: document.getElementById('tool-circle'),
            text: document.getElementById('tool-text'),
            crop: document.getElementById('tool-crop'),
        };

        // --- State Management ---
        let currentTool = 'select';
        let svgObjects = [];
        let selectedObjectId = null;
        let history = [];
        let historyIndex = -1;
        let isShiftDown = false;
        
        let state = {
            mode: 'idle', // idle, drawing, panning, dragging, cropping
            startPoint: { x: 0, y: 0 },
            dragOffset: { x: 0, y: 0 },
            draggedVertex: null,
            previewObject: null,
            cropRect: null,
        };

        const SELECTION_THRESHOLD = 10;
        const SNAP_THRESHOLD = 10;
        
        let viewBox = { x: 0, y: 0, w: 1000, h: 750 };
        let CTM;

        // --- History (Undo/Redo) ---
        function saveState() {
            history = history.slice(0, historyIndex + 1);
            history.push({ objects: JSON.parse(JSON.stringify(svgObjects)), viewBox: { ...viewBox } });
            historyIndex++;
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                const previousState = history[historyIndex];
                svgObjects = JSON.parse(JSON.stringify(previousState.objects));
                viewBox = { ...previousState.viewBox };
                deselectObject();
                render();
            }
        }

        // --- Tool and Mode Switching ---
        function setActiveTool(toolName) {
            currentTool = toolName;
            Object.values(toolButtons).forEach(btn => btn.classList.remove('active'));
            if (toolButtons[toolName]) {
                toolButtons[toolName].classList.add('active');
            }
            deselectObject();
            if (toolName !== 'crop') {
                cancelCrop();
            }
            updateCursor();
        }

        function setMode(newMode) {
            state.mode = newMode;
            updateCursor();
        }

        function updateCursor() {
            svgCanvas.classList.remove('mode-panning', 'mode-dragging', 'mode-drawing', 'mode-cropping');
            if (state.mode === 'panning') {
                svgCanvas.classList.add('mode-panning');
            } else if (state.mode === 'dragging') {
                svgCanvas.classList.add('mode-dragging');
            } else if (state.mode === 'drawing') {
                svgCanvas.classList.add('mode-drawing');
            } else if (state.mode === 'cropping') {
                svgCanvas.classList.add('mode-cropping');
            }
        }

        // --- Coordinate and Geometry Utilities ---
        function getMousePos(event) {
            if (!CTM) CTM = svgCanvas.getScreenCTM();
            if (!CTM) return { x: 0, y: 0 };
            const pt = svgCanvas.createSVGPoint();
            pt.x = event.clientX;
            pt.y = event.clientY;
            try {
                return pt.matrixTransform(CTM.inverse());
            } catch (e) {
                return { x: 0, y: 0 };
            }
        }

        function getSnapPoint(pos) {
            const scaledSnapThreshold = SNAP_THRESHOLD / (viewBox.w / 1000);
            
            for (const obj of svgObjects) {
                let points = [];
                if (obj.type === 'line') {
                    points = [{x: obj.x1, y: obj.y1}, {x: obj.x2, y: obj.y2}];
                } else if (obj.type === 'triangle') {
                    points = [obj.p1, obj.p2, obj.p3];
                }
                
                for (const p of points) {
                    if (Math.hypot(pos.x - p.x, pos.y - p.y) < scaledSnapThreshold) {
                        return { ...p, snapped: true };
                    }
                }
            }
            return { ...pos, snapped: false };
        }

        // --- Rendering Engine ---
        function render() {
            svgCanvas.innerHTML = '';
            svgCanvas.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
            
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const gridPattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
            gridPattern.setAttribute('id', 'grid');
            gridPattern.setAttribute('x', viewBox.x);
            gridPattern.setAttribute('y', viewBox.y);
            gridPattern.setAttribute('width', '20');
            gridPattern.setAttribute('height', '20');
            gridPattern.setAttribute('patternUnits', 'userSpaceOnUse');
            const gridPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            gridPath.setAttribute('d', 'M 20 0 L 0 0 0 20');
            gridPath.setAttribute('fill', 'none');
            gridPath.setAttribute('stroke', 'var(--grid-color)');
            gridPath.setAttribute('stroke-width', '0.5');
            gridPattern.appendChild(gridPath);
            defs.appendChild(gridPattern);
            svgCanvas.appendChild(defs);
            const gridRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            gridRect.setAttribute('x', viewBox.x);
            gridRect.setAttribute('y', viewBox.y);
            gridRect.setAttribute('width', '100%');
            gridRect.setAttribute('height', '100%');
            gridRect.setAttribute('fill', 'url(#grid)');
            svgCanvas.appendChild(gridRect);

            const allObjects = [...svgObjects];
            if (state.previewObject) allObjects.push(state.previewObject);

            allObjects.forEach(obj => {
                let element;
                switch (obj.type) {
                    case 'line':
                        element = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        element.setAttribute('x1', obj.x1);
                        element.setAttribute('y1', obj.y1);
                        element.setAttribute('x2', obj.x2);
                        element.setAttribute('y2', obj.y2);
                        break;
                    case 'circle':
                        element = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        element.setAttribute('cx', obj.cx);
                        element.setAttribute('cy', obj.cy);
                        element.setAttribute('r', obj.r);
                        element.setAttribute('fill', 'transparent');
                        break;
                    case 'text':
                        element = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        element.setAttribute('x', obj.x);
                        element.setAttribute('y', obj.y);
                        element.setAttribute('fill', obj.color);
                        element.setAttribute('font-size', obj.fontSize || '20');
                        element.setAttribute('font-weight', 'bold');
                        element.setAttribute('font-family', 'Manrope, sans-serif');
                        element.textContent = obj.content;
                        break;
                    case 'triangle':
                        element = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        const points = `${obj.p1.x},${obj.p1.y} ${obj.p2.x},${obj.p2.y} ${obj.p3.x},${obj.p3.y}`;
                        element.setAttribute('points', points);
                        element.setAttribute('fill', 'transparent');
                        break;
                }

                if (element) {
                    element.setAttribute('stroke', obj.color);
                    element.setAttribute('stroke-width', '2.5');
                    element.setAttribute('stroke-linecap', 'round');

                    element.setAttribute('id', `obj-${obj.id}`);
                    if (!obj.isPreview) {
                        element.classList.add('drawable');
                        if (obj.id === selectedObjectId) element.classList.add('selected');
                    } else {
                        element.setAttribute('opacity', '0.6');
                        element.setAttribute('stroke-dasharray', '5 5');
                    }
                    svgCanvas.appendChild(element);

                    if (obj.type === 'triangle' && obj.id === selectedObjectId) {
                        ['p1', 'p2', 'p3'].forEach(pKey => {
                            const handle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                            handle.setAttribute('cx', obj[pKey].x);
                            handle.setAttribute('cy', obj[pKey].y);
                            handle.setAttribute('r', '6');
                            handle.setAttribute('class', 'vertex-handle');
                            handle.dataset.vertex = pKey;
                            handle.dataset.objId = obj.id;
                            svgCanvas.appendChild(handle);
                        });
                    }
                }
            });

            if (state.cropRect) {
                const {x, y, width, height} = state.cropRect;
                const overlay = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const worldBorder = `M ${viewBox.x} ${viewBox.y} H ${viewBox.x + viewBox.w} V ${viewBox.y + viewBox.h} H ${viewBox.x} Z`;
                const cropHole = `M ${x} ${y} H ${x + width} V ${y + height} H ${x} Z`;
                overlay.setAttribute('d', worldBorder + " " + cropHole);
                overlay.setAttribute('class', 'crop-overlay');
                overlay.setAttribute('fill-rule', 'evenodd');
                svgCanvas.appendChild(overlay);

                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', x);
                rect.setAttribute('y', y);
                rect.setAttribute('width', width);
                rect.setAttribute('height', height);
                rect.setAttribute('class', 'crop-rect');
                svgCanvas.appendChild(rect);
            }

            CTM = svgCanvas.getScreenCTM();
        }

        function drawSmartGuides(start, end) {
            svgCanvas.querySelectorAll('.smart-guide, .smart-guide-label').forEach(el => el.remove());
            const scaledSnapThreshold = SNAP_THRESHOLD / (viewBox.w / 1000);
            const dx = Math.abs(start.x - end.x);
            const dy = Math.abs(start.y - end.y);

            let guide, label;

            if (dy < scaledSnapThreshold) {
                guide = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                guide.setAttribute('x1', viewBox.x);
                guide.setAttribute('y1', start.y);
                guide.setAttribute('x2', viewBox.x + viewBox.w);
                guide.setAttribute('y2', start.y);
                label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', end.x + 10);
                label.setAttribute('y', end.y - 10);
                label.textContent = "Horizontal";
                end.y = start.y;
            } else if (dx < scaledSnapThreshold) {
                guide = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                guide.setAttribute('x1', start.x);
                guide.setAttribute('y1', viewBox.y);
                guide.setAttribute('x2', start.x);
                guide.setAttribute('y2', viewBox.y + viewBox.h);
                label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', end.x + 10);
                label.setAttribute('y', end.y);
                label.textContent = "Vertical";
                end.x = start.x;
            }

            if (guide) {
                guide.setAttribute('class', 'smart-guide');
                svgCanvas.appendChild(guide);
                label.setAttribute('class', 'smart-guide-label');
                svgCanvas.appendChild(label);
            }
        }

        // --- Object and Property Management ---
        function selectObject(id) {
            selectedObjectId = id;
            const selectedObject = svgObjects.find(obj => obj.id === id);
            
            if (selectedObject) {
                propertiesPanel.classList.remove('hidden');
                strokeColorInput.value = selectedObject.color;
                
                if (selectedObject.type === 'text') {
                    textProperties.classList.remove('hidden');
                    textInput.value = selectedObject.content;
                    fontSizeInput.value = selectedObject.fontSize || 20;
                } else {
                    textProperties.classList.add('hidden');
                }
            } else {
                deselectObject();
            }
            render();
        }

        function deselectObject() {
            if (selectedObjectId === null) return;
            selectedObjectId = null;
            propertiesPanel.classList.add('hidden');
            textProperties.classList.add('hidden');
            render();
        }
        
        function updateSelectedObject(prop, value) {
            if (selectedObjectId === null) return;
            const obj = svgObjects.find(o => o.id === selectedObjectId);
            if (obj) {
                if (prop === 'fontSize') {
                    obj[prop] = parseFloat(value);
                } else {
                    obj[prop] = value;
                }
                render();
            }
        }

        function findClosestObject(pos) {
            let closest = null;
            let minDistance = Infinity;
            const scaledThreshold = SELECTION_THRESHOLD / (viewBox.w / 1000);

            svgObjects.forEach(obj => {
                let dist = Infinity;
                if (obj.type === 'line') {
                    const { x1, y1, x2, y2 } = obj;
                    const l2 = (x2 - x1)**2 + (y2 - y1)**2;
                    if (l2 === 0) {
                        dist = Math.hypot(pos.x - x1, pos.y - y1);
                    } else {
                        let t = ((pos.x - x1) * (x2 - x1) + (pos.y - y1) * (y2 - y1)) / l2;
                        t = Math.max(0, Math.min(1, t));
                        dist = Math.hypot(pos.x - (x1 + t * (x2 - x1)), pos.y - (y1 + t * (y2 - y1)));
                    }
                } else if (obj.type === 'circle') {
                    dist = Math.abs(Math.hypot(pos.x - obj.cx, pos.y - obj.cy) - obj.r);
                } else if (obj.type === 'text') {
                    const { x, y, content, fontSize } = obj;
                    const w = content.length * (fontSize || 20) * 0.6;
                    const h = (fontSize || 20);
                    if (pos.x >= x && pos.x <= x + w && pos.y >= y - h && pos.y <= y) {
                        dist = 0;
                    }
                } else if (obj.type === 'triangle') {
                    const sides = [[obj.p1, obj.p2], [obj.p2, obj.p3], [obj.p3, obj.p1]];
                    for (const side of sides) {
                        const [pA, pB] = side;
                        const l2 = (pB.x - pA.x)**2 + (pB.y - pA.y)**2;
                        if (l2 === 0) continue;
                        let t = ((pos.x - pA.x) * (pB.x - pA.x) + (pos.y - pA.y) * (pB.y - pA.y)) / l2;
                        t = Math.max(0, Math.min(1, t));
                        const d = Math.hypot(pos.x - (pA.x + t * (pB.x - pA.x)), pos.y - (pA.y + t * (pB.y - pA.y)));
                        if (d < dist) dist = d;
                    }
                }

                if (dist < minDistance) {
                    minDistance = dist;
                    closest = obj;
                }
            });

            return (minDistance < scaledThreshold) ? closest : null;
        }

        // --- Crop Functionality ---
        function confirmCrop() {
            if (!state.cropRect) return;
            viewBox.x = state.cropRect.x;
            viewBox.y = state.cropRect.y;
            viewBox.w = state.cropRect.width;
            viewBox.h = state.cropRect.height;
            cancelCrop();
            saveState();
        }

        function cancelCrop() {
            state.cropRect = null;
            cropActions.classList.add('hidden');
            render();
        }

        // --- Mouse Event Handlers ---
        svgCanvas.addEventListener('mousedown', (e) => {
            const mousePos = getMousePos(e);
            
            if (currentTool === 'select') {
                if (e.target.classList.contains('vertex-handle')) {
                    setMode('dragging');
                    state.draggedVertex = {
                        objId: parseInt(e.target.dataset.objId),
                        vertexKey: e.target.dataset.vertex
                    };
                    return;
                }
                const target = findClosestObject(mousePos);
                if (target) {
                    selectObject(target.id);
                    setMode('dragging');
                    state.dragOffset.x = target.x1 ? mousePos.x - target.x1 : mousePos.x - target.cx;
                    state.dragOffset.y = target.y1 ? mousePos.y - target.y1 : mousePos.y - target.cy;
                } else {
                    deselectObject();
                    setMode('panning');
                    state.startPoint = { x: e.clientX, y: e.clientY };
                }
            } else if (currentTool === 'crop') {
                setMode('cropping');
                state.startPoint = mousePos;
            } else {
                setMode('drawing');
                const snapPoint = getSnapPoint(mousePos);
                state.startPoint = snapPoint.snapped ? snapPoint : mousePos;
            }
        });

        svgCanvas.addEventListener('mousemove', (e) => {
            if (state.mode === 'idle') return;
            const mousePos = getMousePos(e);

            switch (state.mode) {
                case 'panning':
                    const dx = (e.clientX - state.startPoint.x) * (viewBox.w / svgCanvas.clientWidth);
                    const dy = (e.clientY - state.startPoint.y) * (viewBox.h / svgCanvas.clientHeight);
                    viewBox.x -= dx;
                    viewBox.y -= dy;
                    state.startPoint = { x: e.clientX, y: e.clientY };
                    break;

                case 'dragging':
                    if (state.draggedVertex) {
                        const obj = svgObjects.find(o => o.id === state.draggedVertex.objId);
                        if (obj) {
                            const snapPoint = getSnapPoint(mousePos);
                            obj[state.draggedVertex.vertexKey] = snapPoint.snapped ? snapPoint : mousePos;
                        }
                    } else if (selectedObjectId !== null) {
                        const obj = svgObjects.find(o => o.id === selectedObjectId);
                        if (obj) {
                            const dragDx = mousePos.x - (obj.x1 || obj.cx || obj.p1.x) - state.dragOffset.x;
                            const dragDy = mousePos.y - (obj.y1 || obj.cy || obj.p1.y) - state.dragOffset.y;
                             if (obj.type === 'line') {
                                obj.x1 += dragDx; obj.y1 += dragDy; obj.x2 += dragDx; obj.y2 += dragDy;
                            } else if (obj.type === 'circle') {
                                obj.cx += dragDx; obj.cy += dragDy;
                            } else if (obj.type === 'triangle') {
                                obj.p1.x += dragDx; obj.p1.y += dragDy;
                                obj.p2.x += dragDx; obj.p2.y += dragDy;
                                obj.p3.x += dragDx; obj.p3.y += dragDy;
                            } else { 
                                obj.x += dragDx; obj.y += dragDy;
                            }
                        }
                    }
                    break;
                
                case 'cropping':
                    const cropX = Math.min(state.startPoint.x, mousePos.x);
                    const cropY = Math.min(state.startPoint.y, mousePos.y);
                    const cropW = Math.abs(state.startPoint.x - mousePos.x);
                    const cropH = Math.abs(state.startPoint.y - mousePos.y);
                    state.cropRect = { x: cropX, y: cropY, width: cropW, height: cropH };
                    break;

                case 'drawing':
                    let currentPos = mousePos;
                    const snapPoint = getSnapPoint(currentPos);
                    if (snapPoint.snapped) {
                        currentPos = snapPoint;
                    }

                    if (currentTool === 'line') {
                        drawSmartGuides(state.startPoint, currentPos);
                        if (isShiftDown) {
                            const dxShift = currentPos.x - state.startPoint.x;
                            const dyShift = currentPos.y - state.startPoint.y;
                            if (Math.abs(dxShift) > Math.abs(dyShift)) currentPos.y = state.startPoint.y;
                            else currentPos.x = state.startPoint.x;
                        }
                    }
                    
                    const color = strokeColorInput.value;
                    switch (currentTool) {
                        case 'line':
                            state.previewObject = { id: -1, type: 'line', x1: state.startPoint.x, y1: state.startPoint.y, x2: currentPos.x, y2: currentPos.y, color, isPreview: true };
                            break;
                        case 'circle':
                            const r = Math.hypot(currentPos.x - state.startPoint.x, currentPos.y - state.startPoint.y);
                            state.previewObject = { id: -1, type: 'circle', cx: state.startPoint.x, cy: state.startPoint.y, r, color, isPreview: true };
                            break;
                    }
                    break;
            }
            render();
        });

        svgCanvas.addEventListener('mouseup', (e) => {
            if (state.mode === 'idle') return;

            if (state.mode === 'dragging') {
                saveState();
            } else if (state.mode === 'cropping') {
                if (state.cropRect && (state.cropRect.width > 10 || state.cropRect.height > 10)) {
                    cropActions.classList.remove('hidden');
                } else {
                    cancelCrop();
                }
            } else if (state.mode === 'drawing') {
                svgCanvas.querySelectorAll('.smart-guide, .smart-guide-label').forEach(el => el.remove());
                
                let endPoint = getMousePos(e);
                const snapPoint = getSnapPoint(endPoint);
                if (snapPoint.snapped) endPoint = snapPoint;

                let newObject;
                const color = strokeColorInput.value;

                switch (currentTool) {
                    case 'line':
                         if (isShiftDown) {
                            const dx = endPoint.x - state.startPoint.x;
                            const dy = endPoint.y - state.startPoint.y;
                            if (Math.abs(dx) > Math.abs(dy)) endPoint.y = state.startPoint.y;
                            else endPoint.x = state.startPoint.x;
                        }
                        if (Math.hypot(endPoint.x - state.startPoint.x, endPoint.y - state.startPoint.y) > 5) {
                            newObject = { id: nextId++, type: 'line', x1: state.startPoint.x, y1: state.startPoint.y, x2: endPoint.x, y2: endPoint.y, color };
                        }
                        break;
                    case 'triangle':
                        const side = 100;
                        const h = side * Math.sqrt(3)/2;
                        newObject = {
                            id: nextId++,
                            type: 'triangle',
                            p1: { x: state.startPoint.x, y: state.startPoint.y - h/2 },
                            p2: { x: state.startPoint.x - side/2, y: state.startPoint.y + h/2 },
                            p3: { x: state.startPoint.x + side/2, y: state.startPoint.y + h/2 },
                            color
                        };
                        break;
                    case 'circle':
                         const r = Math.hypot(endPoint.x - state.startPoint.x, endPoint.y - state.startPoint.y);
                         if (r > 5) {
                            newObject = { id: nextId++, type: 'circle', cx: state.startPoint.x, cy: state.startPoint.y, r, color };
                         }
                        break;
                    case 'text':
                        const content = prompt("Enter text:", "A");
                        if (content) {
                           newObject = { id: nextId++, type: 'text', x: state.startPoint.x, y: state.startPoint.y, content, color, fontSize: 20 };
                        }
                        break;
                }

                if (newObject) {
                    svgObjects.push(newObject);
                    saveState();
                }
            }
            
            // Reset state
            setMode('idle');
            state.draggedVertex = null;
            state.previewObject = null;
            render();
        });

        canvasContainer.addEventListener('wheel', (e) => {
            e.preventDefault();
            const mousePos = getMousePos(e);
            if (!mousePos) return;

            const zoomFactor = 1.1;
            const scale = (e.deltaY < 0) ? 1 / zoomFactor : zoomFactor;
            
            viewBox.x = mousePos.x + (viewBox.x - mousePos.x) * scale;
            viewBox.y = mousePos.y + (viewBox.y - mousePos.y) * scale;
            viewBox.w *= scale;
            viewBox.h *= scale;
            
            render();
        });
        
        // --- Keyboard and Button Listeners ---
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Shift') isShiftDown = true;
            if (e.ctrlKey && (e.key.toLowerCase() === 'z')) {
                e.preventDefault();
                undo();
            }
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (selectedObjectId !== null) {
                    svgObjects = svgObjects.filter(obj => obj.id !== selectedObjectId);
                    deselectObject();
                    saveState();
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.key === 'Shift') isShiftDown = false;
        });

        Object.entries(toolButtons).forEach(([name, btn]) => {
            btn.addEventListener('click', () => setActiveTool(name));
        });

        confirmCropBtn.addEventListener('click', confirmCrop);
        cancelCropBtn.addEventListener('click', cancelCrop);

        deleteBtn.addEventListener('click', () => {
            if (selectedObjectId !== null) {
                svgObjects = svgObjects.filter(obj => obj.id !== selectedObjectId);
                deselectObject();
                saveState();
            }
        });
        
        textInput.addEventListener('input', (e) => updateSelectedObject('content', e.target.value));
        fontSizeInput.addEventListener('input', (e) => updateSelectedObject('fontSize', e.target.value));
        strokeColorInput.addEventListener('input', (e) => updateSelectedObject('color', e.target.value));
        
        textInput.addEventListener('change', saveState);
        fontSizeInput.addEventListener('change', saveState);
        strokeColorInput.addEventListener('change', saveState);

        // --- Export ---
        function getSvgForExport() {
            const tempSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            tempSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            tempSvg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
            
            svgObjects.forEach(obj => {
                const element = document.getElementById(`obj-${obj.id}`)?.cloneNode(true);
                if (element) {
                    element.classList.remove('selected', 'drawable');
                    tempSvg.appendChild(element);
                }
            });
            return new XMLSerializer().serializeToString(tempSvg);
        }

        downloadBtn.addEventListener('click', () => {
            const svgData = getSvgForExport();
            const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'thelo-geometry.svg';
            a.click();
            URL.revokeObjectURL(url);
        });

        copyBtn.addEventListener('click', () => {
            const svgData = getSvgForExport();
            svgCodeOutput.value = svgData;
            svgCodeOutput.select();
            document.execCommand('copy');
            alert('SVG code copied to clipboard!');
        });

        // --- Initial Setup ---
        function initialize() {
            const initialBounds = canvasContainer.getBoundingClientRect();
            viewBox.w = initialBounds.width || 1000;
            viewBox.h = initialBounds.height || 750;
            
            setActiveTool('select');
            saveState();
            render();
        }

        initialize();

        window.addEventListener('resize', () => {
            const newBounds = canvasContainer.getBoundingClientRect();
            if (state.mode === 'idle') { 
                viewBox.w = newBounds.width || 1000;
                viewBox.h = newBounds.height || 750;
            }
            render();
        });
    </script>

</body>
</html>
