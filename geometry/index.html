<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thelo Geometry SVG Creator</title>
    <link rel="icon" href="https://thelo.space/img/thelofavicon.png" type="image/png" />

    <!-- Fonts and Icons -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;700;800&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" rel="stylesheet">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        :root {
            --thelo-blue: #2563EB;
            --thelo-blue-light: #EFF6FF;
            --thelo-green: #10B981;
            --thelo-amber: #F59E0B;
            --thelo-bg: #F8F9FA;
            --thelo-text: #111827;
            --thelo-text-light: #6B7280;
            --grid-color: #E5E7EB;
        }

        body {
            font-family: 'Manrope', sans-serif;
            background-color: var(--thelo-bg);
            color: var(--thelo-text);
            overflow: hidden;
        }

        .tool-btn {
            transition: all 0.2s ease;
        }

        .tool-btn.active {
            background-color: var(--thelo-blue);
            color: white;
            box-shadow: 0 4px 14px rgba(37, 99, 235, 0.25);
        }
        
        #svg-canvas {
            cursor: crosshair;
            background-color: #fff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 14px rgba(0,0,0,0.05);
        }

        #svg-canvas.panning {
            cursor: grab;
        }
        
        .drawable:hover {
            stroke: var(--thelo-blue);
            stroke-width: 3px;
            fill-opacity: 0.7;
        }
        
        .selected {
            stroke: var(--thelo-amber) !important;
            stroke-width: 3.5px !important;
            stroke-dasharray: 5 5;
        }
        
        .right-angle-symbol, .angle-arc {
            fill: none;
            stroke: var(--thelo-text);
            stroke-width: 2;
        }

        .snap-point {
            fill: var(--thelo-blue);
            stroke: white;
            stroke-width: 2px;
        }
    </style>
</head>
<body class="w-screen h-screen flex flex-col antialiased">

    <header class="bg-white/70 backdrop-blur-lg border-b border-gray-200 p-4 flex justify-between items-center z-10">
        <div class="flex items-center gap-4">
            <img src="https://thelo.space/img/bluethelo.svg" alt="Thelo logo" class="h-10 w-auto" />
            <h1 class="text-xl font-bold text-gray-800">Geometry Creator</h1>
        </div>
        <div class="text-sm text-gray-500">
            <kbd class="px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg">Shift</kbd> to straighten, <kbd class="px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg">Scroll</kbd> to Zoom
        </div>
    </header>

    <div class="flex-grow flex gap-6 p-6 overflow-hidden">

        <aside class="w-72 bg-white p-5 rounded-xl shadow-sm border border-gray-200 flex flex-col gap-8 z-10">
            <div>
                <h2 class="font-bold text-lg mb-3">Tools</h2>
                <div class="grid grid-cols-2 gap-3">
                    <button id="tool-select" class="tool-btn active flex items-center justify-center gap-2 p-3 rounded-lg border bg-gray-50 hover:bg-gray-100">
                        <i class="fas fa-mouse-pointer fa-lg w-5 text-center"></i>
                        <span class="text-sm font-semibold">Select</span>
                    </button>
                    <button id="tool-line" class="tool-btn flex items-center justify-center gap-2 p-3 rounded-lg border bg-gray-50 hover:bg-gray-100">
                        <i class="fas fa-drafting-compass fa-lg w-5 text-center"></i>
                        <span class="text-sm font-semibold">Line</span>
                    </button>
                    <button id="tool-circle" class="tool-btn flex items-center justify-center gap-2 p-3 rounded-lg border bg-gray-50 hover:bg-gray-100">
                        <i class="far fa-circle fa-lg w-5 text-center"></i>
                        <span class="text-sm font-semibold">Circle</span>
                    </button>
                    <button id="tool-text" class="tool-btn flex items-center justify-center gap-2 p-3 rounded-lg border bg-gray-50 hover:bg-gray-100">
                        <i class="fas fa-font fa-lg w-5 text-center"></i>
                        <span class="text-sm font-semibold">Text</span>
                    </button>
                    <button id="tool-right-angle" class="tool-btn flex items-center justify-center gap-2 p-3 rounded-lg border bg-gray-50 hover:bg-gray-100">
                        <i class="far fa-square fa-lg w-5 text-center"></i>
                        <span class="text-sm font-semibold">Right Angle</span>
                    </button>
                    <button id="tool-measure-angle" class="tool-btn flex items-center justify-center gap-2 p-3 rounded-lg border bg-gray-50 hover:bg-gray-100">
                         <i class="fas fa-angle-left fa-lg w-5 text-center"></i>
                        <span class="text-sm font-semibold">Measure</span>
                    </button>
                </div>
            </div>

            <div id="properties-panel" class="hidden">
                <h2 class="font-bold text-lg mb-3">Properties</h2>
                <div class="space-y-4">
                    <div id="text-properties" class="hidden">
                        <div>
                            <label for="text-input" class="block text-sm font-medium text-gray-700">Text</label>
                            <input type="text" id="text-input" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm sm:text-sm">
                        </div>
                        <div>
                            <label for="font-size-input" class="block text-sm font-medium text-gray-700">Font Size</label>
                            <input type="number" id="font-size-input" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm sm:text-sm" min="1">
                        </div>
                    </div>
                    <div>
                        <label for="stroke-color" class="block text-sm font-medium text-gray-700">Color</label>
                        <input type="color" id="stroke-color" value="#111827" class="mt-1 block w-full h-8 rounded-md border-gray-300 shadow-sm">
                    </div>
                    <button id="delete-btn" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                        <i class="fas fa-trash-alt mr-2"></i>Delete
                    </button>
                </div>
            </div>
            
            <div class="mt-auto">
                 <h2 class="font-bold text-lg mb-3">Export</h2>
                 <div class="space-y-3">
                    <button id="download-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                        <i class="fas fa-download mr-2"></i>Download SVG
                    </button>
                    <button id="copy-btn" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                        <i class="fas fa-copy mr-2"></i>Copy Code
                    </button>
                 </div>
            </div>
        </aside>

        <main class="flex-grow bg-white rounded-xl border border-gray-200" id="canvas-container">
            <svg id="svg-canvas" class="w-full h-full"></svg>
        </main>

    </div>
    
    <textarea id="svg-code-output" class="absolute -left-full"></textarea>

    <script type="module">
        const svgCanvas = document.getElementById('svg-canvas');
        const canvasContainer = document.getElementById('canvas-container');
        const propertiesPanel = document.getElementById('properties-panel');
        const textProperties = document.getElementById('text-properties');
        const textInput = document.getElementById('text-input');
        const fontSizeInput = document.getElementById('font-size-input');
        const strokeColorInput = document.getElementById('stroke-color');
        const deleteBtn = document.getElementById('delete-btn');
        const downloadBtn = document.getElementById('download-btn');
        const copyBtn = document.getElementById('copy-btn');
        const svgCodeOutput = document.getElementById('svg-code-output');
        const toolButtons = {
            select: document.getElementById('tool-select'),
            line: document.getElementById('tool-line'),
            circle: document.getElementById('tool-circle'),
            text: document.getElementById('tool-text'),
            rightAngle: document.getElementById('tool-right-angle'),
            measureAngle: document.getElementById('tool-measure-angle'),
        };

        let currentTool = 'select';
        let svgObjects = [];
        let selectedObjectId = null;
        let isDrawing = false;
        let isShiftDown = false;
        let isDragging = false;
        let isPanning = false;
        let startPoint = { x: 0, y: 0 };
        let dragStartPoint = { x: 0, y: 0 };
        let nextId = 0;
        let previewObject = null;
        let history = [];
        let historyIndex = -1;
        let angleCreationState = { active: false, points: [] };
        
        const SNAP_THRESHOLD = 10;
        const SELECTION_THRESHOLD = 10;
        
        let viewBox = { x: 0, y: 0, w: 1000, h: 750 };
        let CTM; // Current Transformation Matrix

        function saveState() {
            history = history.slice(0, historyIndex + 1);
            history.push(JSON.parse(JSON.stringify(svgObjects)));
            historyIndex++;
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                svgObjects = JSON.parse(JSON.stringify(history[historyIndex]));
                deselectObject();
            }
        }

        function setActiveTool(toolName) {
            currentTool = toolName;
            Object.values(toolButtons).forEach(btn => btn.classList.remove('active'));
            toolButtons[toolName]?.classList.add('active');
            deselectObject();
            angleCreationState.active = (toolName === 'measureAngle');
            angleCreationState.points = [];
        }

        function getMousePos(event) {
            const pt = svgCanvas.createSVGPoint();
            pt.x = event.clientX;
            pt.y = event.clientY;
            return pt.matrixTransform(CTM.inverse());
        }
        
        function render() {
            svgCanvas.innerHTML = '';
            svgCanvas.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
            
            // Render grid
            const gridPattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
            gridPattern.setAttribute('id', 'grid');
            gridPattern.setAttribute('width', '20');
            gridPattern.setAttribute('height', '20');
            gridPattern.setAttribute('patternUnits', 'userSpaceOnUse');
            const gridPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            gridPath.setAttribute('d', 'M 20 0 L 0 0 0 20');
            gridPath.setAttribute('fill', 'none');
            gridPath.setAttribute('stroke', 'var(--grid-color)');
            gridPath.setAttribute('stroke-width', '1');
            gridPattern.appendChild(gridPath);
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            defs.appendChild(gridPattern);
            svgCanvas.appendChild(defs);
            const gridRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            gridRect.setAttribute('width', '100%');
            gridRect.setAttribute('height', '100%');
            gridRect.setAttribute('fill', 'url(#grid)');
            svgCanvas.appendChild(gridRect);


            const allObjects = [...svgObjects];
            if (previewObject) allObjects.push(previewObject);

            allObjects.forEach(obj => {
                let element;
                switch (obj.type) {
                    case 'line':
                        element = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        element.setAttribute('x1', obj.x1);
                        element.setAttribute('y1', obj.y1);
                        element.setAttribute('x2', obj.x2);
                        element.setAttribute('y2', obj.y2);
                        element.setAttribute('stroke', obj.color);
                        element.setAttribute('stroke-width', '2.5');
                        element.setAttribute('stroke-linecap', 'round');
                        break;
                    case 'circle':
                        element = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        element.setAttribute('cx', obj.cx);
                        element.setAttribute('cy', obj.cy);
                        element.setAttribute('r', obj.r);
                        element.setAttribute('stroke', obj.color);
                        element.setAttribute('stroke-width', '2.5');
                        element.setAttribute('fill', 'transparent');
                        break;
                    case 'text':
                        element = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        element.setAttribute('x', obj.x);
                        element.setAttribute('y', obj.y);
                        element.setAttribute('fill', obj.color);
                        element.setAttribute('font-size', obj.fontSize || '20');
                        element.setAttribute('font-weight', 'bold');
                        element.setAttribute('font-family', 'Manrope, sans-serif');
                        element.textContent = obj.content;
                        break;
                    // Other cases...
                }

                if (element) {
                    element.setAttribute('id', `obj-${obj.id}`);
                    if (!obj.isPreview) {
                        element.classList.add('drawable');
                        if (obj.id === selectedObjectId) element.classList.add('selected');
                    } else {
                        element.setAttribute('opacity', '0.6');
                        element.setAttribute('stroke-dasharray', '5 5');
                    }
                    svgCanvas.appendChild(element);
                }
            });
            CTM = svgCanvas.getScreenCTM();
        }

        function selectObject(id) {
            selectedObjectId = id;
            const selectedObject = svgObjects.find(obj => obj.id === id);
            
            if (selectedObject) {
                propertiesPanel.classList.remove('hidden');
                strokeColorInput.value = selectedObject.color;
                
                if (selectedObject.type === 'text') {
                    textProperties.classList.remove('hidden');
                    textInput.value = selectedObject.content;
                    fontSizeInput.value = selectedObject.fontSize || 20;
                } else {
                    textProperties.classList.add('hidden');
                }
            } else {
                deselectObject();
            }
            render();
        }

        function deselectObject() {
            if (selectedObjectId === null) return;
            selectedObjectId = null;
            propertiesPanel.classList.add('hidden');
            textProperties.classList.add('hidden');
            render();
        }
        
        function updateSelectedObject(prop, value) {
            if (selectedObjectId === null) return;
            const obj = svgObjects.find(o => o.id === selectedObjectId);
            if (obj) {
                if (prop === 'fontSize') {
                    obj[prop] = parseFloat(value);
                } else {
                    obj[prop] = value;
                }
                render();
            }
        }

        function findClosestObject(pos) {
            let closest = null;
            let minDistance = Infinity;

            svgObjects.forEach(obj => {
                let dist = Infinity;
                if (obj.type === 'line') {
                    const { x1, y1, x2, y2 } = obj;
                    const l2 = (x2 - x1)**2 + (y2 - y1)**2;
                    if (l2 === 0) {
                        dist = Math.hypot(pos.x - x1, pos.y - y1);
                    } else {
                        let t = ((pos.x - x1) * (x2 - x1) + (pos.y - y1) * (y2 - y1)) / l2;
                        t = Math.max(0, Math.min(1, t));
                        dist = Math.hypot(pos.x - (x1 + t * (x2 - x1)), pos.y - (y1 + t * (y2 - y1)));
                    }
                } else if (obj.type === 'circle') {
                    dist = Math.abs(Math.hypot(pos.x - obj.cx, pos.y - obj.cy) - obj.r);
                } else if (obj.type === 'text') {
                    const { x, y, content, fontSize } = obj;
                    const w = content.length * (fontSize || 20) * 0.6;
                    const h = (fontSize || 20);
                    if (pos.x >= x && pos.x <= x + w && pos.y >= y - h && pos.y <= y) {
                        dist = 0;
                    }
                }

                if (dist < minDistance) {
                    minDistance = dist;
                    closest = obj;
                }
            });

            return (minDistance < SELECTION_THRESHOLD) ? closest : null;
        }

        svgCanvas.addEventListener('mousedown', (e) => {
            const mousePos = getMousePos(e);
            
            if (currentTool === 'select') {
                const target = findClosestObject(mousePos);
                if (target) {
                    selectObject(target.id);
                    isDragging = true;
                    dragStartPoint = mousePos;
                } else {
                    deselectObject();
                    isPanning = true;
                    svgCanvas.classList.add('panning');
                    startPoint = { x: e.clientX, y: e.clientY };
                }
                return;
            }

            isDrawing = true;
            startPoint = mousePos;
        });

        svgCanvas.addEventListener('mousemove', (e) => {
            if (isPanning) {
                const dx = (e.clientX - startPoint.x) * (viewBox.w / svgCanvas.clientWidth);
                const dy = (e.clientY - startPoint.y) * (viewBox.h / svgCanvas.clientHeight);
                viewBox.x -= dx;
                viewBox.y -= dy;
                startPoint = { x: e.clientX, y: e.clientY };
                render();
                return;
            }

            if (isDragging && selectedObjectId !== null) {
                const mousePos = getMousePos(e);
                const dx = mousePos.x - dragStartPoint.x;
                const dy = mousePos.y - dragStartPoint.y;
                const obj = svgObjects.find(o => o.id === selectedObjectId);
                if (obj) {
                    if (obj.type === 'line') {
                        obj.x1 += dx; obj.y1 += dy;
                        obj.x2 += dx; obj.y2 += dy;
                    } else if (obj.type === 'circle') {
                        obj.cx += dx; obj.cy += dy;
                    } else { // text, rightAngle
                        obj.x += dx; obj.y += dy;
                    }
                }
                dragStartPoint = mousePos;
                render();
                return;
            }

            if (!isDrawing) return;
            let currentPos = getMousePos(e);

            if (isShiftDown && currentTool === 'line') {
                const dx = currentPos.x - startPoint.x;
                const dy = currentPos.y - startPoint.y;
                if (Math.abs(dx) > Math.abs(dy)) currentPos.y = startPoint.y;
                else currentPos.x = startPoint.x;
            }
            
            const color = strokeColorInput.value;
            switch (currentTool) {
                case 'line':
                    previewObject = { id: -1, type: 'line', x1: startPoint.x, y1: startPoint.y, x2: currentPos.x, y2: currentPos.y, color, isPreview: true };
                    break;
                case 'circle':
                    const r = Math.hypot(currentPos.x - startPoint.x, currentPos.y - startPoint.y);
                    previewObject = { id: -1, type: 'circle', cx: startPoint.x, cy: startPoint.y, r, color, isPreview: true };
                    break;
            }
            render();
        });

        svgCanvas.addEventListener('mouseup', (e) => {
            if (isPanning) {
                isPanning = false;
                svgCanvas.classList.remove('panning');
                return;
            }
            if (isDragging) {
                isDragging = false;
                saveState();
                return;
            }
            if (!isDrawing) return;
            isDrawing = false;
            previewObject = null;
            
            let endPoint = getMousePos(e);
            let newObject;
            const color = strokeColorInput.value;

            switch (currentTool) {
                case 'line':
                    if (isShiftDown) {
                        const dx = endPoint.x - startPoint.x;
                        const dy = endPoint.y - startPoint.y;
                        if (Math.abs(dx) > Math.abs(dy)) endPoint.y = startPoint.y;
                        else endPoint.x = startPoint.x;
                    }
                    if (Math.hypot(endPoint.x - startPoint.x, endPoint.y - startPoint.y) > 5) {
                        newObject = { id: nextId++, type: 'line', x1: startPoint.x, y1: startPoint.y, x2: endPoint.x, y2: endPoint.y, color };
                    }
                    break;
                case 'circle':
                     const r = Math.hypot(endPoint.x - startPoint.x, endPoint.y - startPoint.y);
                     if (r > 5) {
                        newObject = { id: nextId++, type: 'circle', cx: startPoint.x, cy: startPoint.y, r, color };
                     }
                    break;
                case 'text':
                    const content = prompt("Enter text:", "A");
                    if (content) {
                       newObject = { id: nextId++, type: 'text', x: startPoint.x, y: startPoint.y, content, color, fontSize: 20 };
                    }
                    break;
                // Other cases...
            }

            if (newObject) {
                svgObjects.push(newObject);
                saveState();
            }
            render();
        });

        canvasContainer.addEventListener('wheel', (e) => {
            e.preventDefault();
            const mousePos = getMousePos(e);
            const zoomFactor = 1.1;
            
            const scale = (e.deltaY < 0) ? 1 / zoomFactor : zoomFactor;
            
            viewBox.x = mousePos.x + (viewBox.x - mousePos.x) * scale;
            viewBox.y = mousePos.y + (viewBox.y - mousePos.y) * scale;
            viewBox.w *= scale;
            viewBox.h *= scale;
            
            render();
        });
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Shift') isShiftDown = true;
            if (e.ctrlKey && e.key.toLowerCase() === 'z') {
                e.preventDefault();
                undo();
            }
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (selectedObjectId !== null) {
                    svgObjects = svgObjects.filter(obj => obj.id !== selectedObjectId);
                    deselectObject();
                    saveState();
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.key === 'Shift') isShiftDown = false;
        });

        deleteBtn.addEventListener('click', () => {
            if (selectedObjectId !== null) {
                svgObjects = svgObjects.filter(obj => obj.id !== selectedObjectId);
                deselectObject();
                saveState();
            }
        });
        
        textInput.addEventListener('input', (e) => updateSelectedObject('content', e.target.value));
        fontSizeInput.addEventListener('input', (e) => updateSelectedObject('fontSize', e.target.value));
        strokeColorInput.addEventListener('input', (e) => updateSelectedObject('color', e.target.value));
        
        textInput.addEventListener('change', saveState);
        fontSizeInput.addEventListener('change', saveState);
        strokeColorInput.addEventListener('change', saveState);

        downloadBtn.addEventListener('click', () => {
            deselectObject();
            setTimeout(() => {
                // Create a temporary SVG for export without the grid
                const tempSvg = svgCanvas.cloneNode(true);
                tempSvg.querySelector('#grid').parentElement.remove(); // Remove defs with grid
                tempSvg.querySelector('rect[fill="url(#grid)"]').remove(); // Remove grid rect
                
                const svgData = new XMLSerializer().serializeToString(tempSvg);
                const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'thelo-geometry.svg';
                a.click();
                URL.revokeObjectURL(url);
            }, 100);
        });

        copyBtn.addEventListener('click', () => {
            deselectObject();
            setTimeout(() => {
                const tempSvg = svgCanvas.cloneNode(true);
                tempSvg.querySelector('#grid').parentElement.remove();
                tempSvg.querySelector('rect[fill="url(#grid)"]').remove();
                
                const svgData = new XMLSerializer().serializeToString(tempSvg);
                svgCodeOutput.value = svgData;
                svgCodeOutput.select();
                document.execCommand('copy');
                alert('SVG code copied to clipboard!');
            }, 100);
        });

        // --- Initial Setup ---
        const initialBounds = canvasContainer.getBoundingClientRect();
        viewBox.w = initialBounds.width;
        viewBox.h = initialBounds.height;
        setActiveTool('select');
        saveState();
        render();
        window.addEventListener('resize', () => {
            render();
        });
    </script>

</body>
</html>
