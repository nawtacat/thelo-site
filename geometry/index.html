<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thelo Geometry SVG Creator</title>
    <link rel="icon" href="https://thelo.space/img/thelofavicon.png" type="image/png" />

    <!-- Fonts and Icons -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;700;800&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" rel="stylesheet">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        :root {
            --thelo-blue: #2563EB;
            --thelo-blue-light: #EFF6FF;
            --thelo-green: #10B981;
            --thelo-amber: #F59E0B;
            --thelo-bg: #F8F9FA;
            --thelo-text: #111827;
            --thelo-text-light: #6B7280;
            --grid-color: #E5E7EB;
        }

        body {
            font-family: 'Manrope', sans-serif;
            background-color: var(--thelo-bg);
            color: var(--thelo-text);
            overflow: hidden;
        }

        .tool-btn {
            transition: all 0.2s ease;
        }

        .tool-btn.active {
            background-color: var(--thelo-blue);
            color: white;
            box-shadow: 0 4px 14px rgba(37, 99, 235, 0.25);
        }
        
        #svg-canvas {
            background-color: #fff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 14px rgba(0,0,0,0.05);
        }

        #svg-canvas.panning { cursor: grab; }
        #svg-canvas.can-drag { cursor: move; }
        #svg-canvas.crosshair { cursor: crosshair; }
        #svg-canvas.cropping { cursor: crosshair; }
        
        .drawable:hover {
            stroke: var(--thelo-blue);
            stroke-width: 3.5px;
            fill-opacity: 0.7;
        }
        
        .selected {
            stroke: var(--thelo-amber) !important;
            stroke-width: 3.5px !important;
            stroke-dasharray: 5 5;
        }
        
        .crop-rect {
            fill: rgba(37, 99, 235, 0.1);
            stroke: var(--thelo-blue);
            stroke-width: 2px;
            stroke-dasharray: 6 6;
        }

        .crop-overlay {
            fill: rgba(0, 0, 0, 0.5);
            pointer-events: none;
        }
    </style>
</head>
<body class="w-screen h-screen flex flex-col antialiased">

    <header class="bg-white/70 backdrop-blur-lg border-b border-gray-200 p-4 flex justify-between items-center z-10">
        <div class="flex items-center gap-4">
            <img src="https://thelo.space/img/bluethelo.svg" alt="Thelo logo" class="h-10 w-auto" />
            <h1 class="text-xl font-bold text-gray-800">Geometry Creator</h1>
        </div>
        <div class="text-sm text-gray-500">
            <kbd class="px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg">Scroll</kbd> to Zoom, <kbd class="px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg">Backspace</kbd> to Delete
        </div>
    </header>

    <div class="flex-grow flex gap-6 p-6 overflow-hidden">

        <aside class="w-72 bg-white p-5 rounded-xl shadow-sm border border-gray-200 flex flex-col gap-8 z-10">
            <div>
                <h2 class="font-bold text-lg mb-3">Tools</h2>
                <div class="grid grid-cols-2 gap-3">
                    <button id="tool-select" class="tool-btn active flex items-center justify-center gap-2 p-3 rounded-lg border bg-gray-50 hover:bg-gray-100">
                        <i class="fas fa-mouse-pointer fa-lg w-5 text-center"></i>
                        <span class="text-sm font-semibold">Select</span>
                    </button>
                    <button id="tool-line" class="tool-btn flex items-center justify-center gap-2 p-3 rounded-lg border bg-gray-50 hover:bg-gray-100">
                        <i class="fas fa-drafting-compass fa-lg w-5 text-center"></i>
                        <span class="text-sm font-semibold">Line</span>
                    </button>
                    <button id="tool-circle" class="tool-btn flex items-center justify-center gap-2 p-3 rounded-lg border bg-gray-50 hover:bg-gray-100">
                        <i class="far fa-circle fa-lg w-5 text-center"></i>
                        <span class="text-sm font-semibold">Circle</span>
                    </button>
                    <button id="tool-text" class="tool-btn flex items-center justify-center gap-2 p-3 rounded-lg border bg-gray-50 hover:bg-gray-100">
                        <i class="fas fa-font fa-lg w-5 text-center"></i>
                        <span class="text-sm font-semibold">Text</span>
                    </button>
                    <button id="tool-crop" class="tool-btn flex items-center justify-center gap-2 p-3 rounded-lg border bg-gray-50 hover:bg-gray-100 col-span-2">
                        <i class="fas fa-crop-simple fa-lg w-5 text-center"></i>
                        <span class="text-sm font-semibold">Crop</span>
                    </button>
                </div>
            </div>
            
            <div id="crop-actions" class="hidden space-y-3">
                <h2 class="font-bold text-lg">Crop Area</h2>
                 <button id="confirm-crop-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                    <i class="fas fa-check mr-2"></i>Confirm Crop
                </button>
                 <button id="cancel-crop-btn" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                    <i class="fas fa-times mr-2"></i>Cancel
                </button>
            </div>


            <div id="properties-panel" class="hidden">
                <h2 class="font-bold text-lg mb-3">Properties</h2>
                <div class="space-y-4">
                    <div id="text-properties" class="hidden">
                        <div>
                            <label for="text-input" class="block text-sm font-medium text-gray-700">Text</label>
                            <input type="text" id="text-input" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm sm:text-sm">
                        </div>
                        <div>
                            <label for="font-size-input" class="block text-sm font-medium text-gray-700">Font Size</label>
                            <input type="number" id="font-size-input" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm sm:text-sm" min="1">
                        </div>
                    </div>
                    <div>
                        <label for="stroke-color" class="block text-sm font-medium text-gray-700">Color</label>
                        <input type="color" id="stroke-color" value="#111827" class="mt-1 block w-full h-8 rounded-md border-gray-300 shadow-sm">
                    </div>
                    <button id="delete-btn" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                        <i class="fas fa-trash-alt mr-2"></i>Delete
                    </button>
                </div>
            </div>
            
            <div class="mt-auto">
                 <h2 class="font-bold text-lg mb-3">Export</h2>
                 <div class="space-y-3">
                    <button id="download-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                        <i class="fas fa-download mr-2"></i>Download SVG
                    </button>
                    <button id="copy-btn" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                        <i class="fas fa-copy mr-2"></i>Copy Code
                    </button>
                 </div>
            </div>
        </aside>

        <main class="flex-grow bg-white rounded-xl border border-gray-200" id="canvas-container">
            <svg id="svg-canvas" class="w-full h-full"></svg>
        </main>

    </div>
    
    <textarea id="svg-code-output" class="absolute -left-full"></textarea>

    <script type="module">
        const svgCanvas = document.getElementById('svg-canvas');
        const canvasContainer = document.getElementById('canvas-container');
        const propertiesPanel = document.getElementById('properties-panel');
        const textProperties = document.getElementById('text-properties');
        const textInput = document.getElementById('text-input');
        const fontSizeInput = document.getElementById('font-size-input');
        const strokeColorInput = document.getElementById('stroke-color');
        const deleteBtn = document.getElementById('delete-btn');
        const downloadBtn = document.getElementById('download-btn');
        const copyBtn = document.getElementById('copy-btn');
        const svgCodeOutput = document.getElementById('svg-code-output');
        const cropActions = document.getElementById('crop-actions');
        const confirmCropBtn = document.getElementById('confirm-crop-btn');
        const cancelCropBtn = document.getElementById('cancel-crop-btn');
        const toolButtons = {
            select: document.getElementById('tool-select'),
            line: document.getElementById('tool-line'),
            circle: document.getElementById('tool-circle'),
            text: document.getElementById('tool-text'),
            crop: document.getElementById('tool-crop'),
        };

        let currentTool = 'select';
        let svgObjects = [];
        let selectedObjectId = null;
        let startPoint = { x: 0, y: 0 };
        let nextId = 0;
        let history = [];
        let historyIndex = -1;
        let cropRect = null;
        let state = {
            isDrawing: false,
            isDragging: false,
            isPanning: false,
            isCropping: false,
            dragStartPoint: {x: 0, y: 0},
            panStartPoint: {x: 0, y: 0},
        };

        const SELECTION_THRESHOLD = 10;
        
        let viewBox = { x: 0, y: 0, w: 1000, h: 750 };
        let CTM;

        function saveState() {
            history = history.slice(0, historyIndex + 1);
            history.push({ objects: JSON.parse(JSON.stringify(svgObjects)), viewBox: { ...viewBox } });
            historyIndex++;
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                const previousState = history[historyIndex];
                svgObjects = JSON.parse(JSON.stringify(previousState.objects));
                viewBox = { ...previousState.viewBox };
                deselectObject();
                render();
            }
        }

        function setActiveTool(toolName) {
            currentTool = toolName;
            Object.values(toolButtons).forEach(btn => btn.classList.remove('active'));
            if (toolButtons[toolName]) {
                toolButtons[toolName].classList.add('active');
            }
            deselectObject();
            if (toolName !== 'crop') {
                cancelCrop();
            }
            updateCursor();
        }

        function getMousePos(event) {
            if (!CTM) CTM = svgCanvas.getScreenCTM();
            if (!CTM) return { x: 0, y: 0 };
            const pt = svgCanvas.createSVGPoint();
            pt.x = event.clientX;
            pt.y = event.clientY;
            try {
                return pt.matrixTransform(CTM.inverse());
            } catch (e) {
                return { x: 0, y: 0 };
            }
        }
        
        function render() {
            svgCanvas.innerHTML = '';
            svgCanvas.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
            
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const gridPattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
            gridPattern.setAttribute('id', 'grid');
            gridPattern.setAttribute('x', viewBox.x);
            gridPattern.setAttribute('y', viewBox.y);
            gridPattern.setAttribute('width', '20');
            gridPattern.setAttribute('height', '20');
            gridPattern.setAttribute('patternUnits', 'userSpaceOnUse');
            const gridPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            gridPath.setAttribute('d', 'M 20 0 L 0 0 0 20');
            gridPath.setAttribute('fill', 'none');
            gridPath.setAttribute('stroke', 'var(--grid-color)');
            gridPath.setAttribute('stroke-width', '0.5');
            gridPattern.appendChild(gridPath);
            defs.appendChild(gridPattern);
            svgCanvas.appendChild(defs);
            const gridRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            gridRect.setAttribute('x', viewBox.x);
            gridRect.setAttribute('y', viewBox.y);
            gridRect.setAttribute('width', '100%');
            gridRect.setAttribute('height', '100%');
            gridRect.setAttribute('fill', 'url(#grid)');
            svgCanvas.appendChild(gridRect);


            svgObjects.forEach(obj => {
                let element;
                switch (obj.type) {
                    case 'line':
                        element = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        element.setAttribute('x1', obj.x1);
                        element.setAttribute('y1', obj.y1);
                        element.setAttribute('x2', obj.x2);
                        element.setAttribute('y2', obj.y2);
                        element.setAttribute('stroke', obj.color);
                        element.setAttribute('stroke-width', '2.5');
                        element.setAttribute('stroke-linecap', 'round');
                        break;
                    case 'circle':
                        element = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        element.setAttribute('cx', obj.cx);
                        element.setAttribute('cy', obj.cy);
                        element.setAttribute('r', obj.r);
                        element.setAttribute('stroke', obj.color);
                        element.setAttribute('stroke-width', '2.5');
                        element.setAttribute('fill', 'transparent');
                        break;
                    case 'text':
                        element = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        element.setAttribute('x', obj.x);
                        element.setAttribute('y', obj.y);
                        element.setAttribute('fill', obj.color);
                        element.setAttribute('font-size', obj.fontSize || '20');
                        element.setAttribute('font-weight', 'bold');
                        element.setAttribute('font-family', 'Manrope, sans-serif');
                        element.textContent = obj.content;
                        break;
                }

                if (element) {
                    element.setAttribute('id', `obj-${obj.id}`);
                    element.classList.add('drawable');
                    if (obj.id === selectedObjectId) element.classList.add('selected');
                    svgCanvas.appendChild(element);
                }
            });

            if (cropRect) {
                const overlay = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const {x, y, width, height} = cropRect;
                const worldBorder = `M ${viewBox.x} ${viewBox.y} H ${viewBox.x + viewBox.w} V ${viewBox.y + viewBox.h} H ${viewBox.x} Z`;
                const cropHole = `M ${x} ${y} H ${x + width} V ${y + height} H ${x} Z`;
                overlay.setAttribute('d', worldBorder + " " + cropHole);
                overlay.setAttribute('class', 'crop-overlay');
                overlay.setAttribute('fill-rule', 'evenodd');
                svgCanvas.appendChild(overlay);

                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', cropRect.x);
                rect.setAttribute('y', cropRect.y);
                rect.setAttribute('width', cropRect.width);
                rect.setAttribute('height', cropRect.height);
                rect.setAttribute('class', 'crop-rect');
                svgCanvas.appendChild(rect);
            }

            CTM = svgCanvas.getScreenCTM();
        }

        function selectObject(id) {
            selectedObjectId = id;
            const selectedObject = svgObjects.find(obj => obj.id === id);
            
            if (selectedObject) {
                propertiesPanel.classList.remove('hidden');
                strokeColorInput.value = selectedObject.color;
                
                if (selectedObject.type === 'text') {
                    textProperties.classList.remove('hidden');
                    textInput.value = selectedObject.content;
                    fontSizeInput.value = selectedObject.fontSize || 20;
                } else {
                    textProperties.classList.add('hidden');
                }
            } else {
                deselectObject();
            }
            render();
        }

        function deselectObject() {
            if (selectedObjectId === null) return;
            selectedObjectId = null;
            propertiesPanel.classList.add('hidden');
            textProperties.classList.add('hidden');
            render();
        }
        
        function updateSelectedObject(prop, value) {
            if (selectedObjectId === null) return;
            const obj = svgObjects.find(o => o.id === selectedObjectId);
            if (obj) {
                if (prop === 'fontSize') {
                    obj[prop] = parseFloat(value);
                } else {
                    obj[prop] = value;
                }
                render();
            }
        }

        function findClosestObject(pos) {
            let closest = null;
            let minDistance = Infinity;
            const scaledThreshold = SELECTION_THRESHOLD / (viewBox.w / 1000);

            svgObjects.forEach(obj => {
                let dist = Infinity;
                if (obj.type === 'line') {
                    const { x1, y1, x2, y2 } = obj;
                    const l2 = (x2 - x1)**2 + (y2 - y1)**2;
                    if (l2 === 0) {
                        dist = Math.hypot(pos.x - x1, pos.y - y1);
                    } else {
                        let t = ((pos.x - x1) * (x2 - x1) + (pos.y - y1) * (y2 - y1)) / l2;
                        t = Math.max(0, Math.min(1, t));
                        dist = Math.hypot(pos.x - (x1 + t * (x2 - x1)), pos.y - (y1 + t * (y2 - y1)));
                    }
                } else if (obj.type === 'circle') {
                    dist = Math.abs(Math.hypot(pos.x - obj.cx, pos.y - obj.cy) - obj.r);
                } else if (obj.type === 'text') {
                    const { x, y, content, fontSize } = obj;
                    const w = content.length * (fontSize || 20) * 0.6;
                    const h = (fontSize || 20);
                    if (pos.x >= x && pos.x <= x + w && pos.y >= y - h && pos.y <= y) {
                        dist = 0;
                    }
                }

                if (dist < minDistance) {
                    minDistance = dist;
                    closest = obj;
                }
            });

            return (minDistance < scaledThreshold) ? closest : null;
        }

        function updateCursor(mousePos) {
            svgCanvas.classList.remove('panning', 'can-drag', 'crosshair', 'cropping');
            if (state.isPanning) {
                svgCanvas.classList.add('panning');
                return;
            }
            if (currentTool === 'select') {
                if (mousePos && findClosestObject(mousePos)) {
                    svgCanvas.classList.add('can-drag');
                }
            } else if (currentTool === 'crop') {
                svgCanvas.classList.add('cropping');
            } else {
                svgCanvas.classList.add('crosshair');
            }
        }

        function confirmCrop() {
            if (!cropRect) return;
            viewBox.x = cropRect.x;
            viewBox.y = cropRect.y;
            viewBox.w = cropRect.width;
            viewBox.h = cropRect.height;
            cancelCrop();
            saveState();
        }

        function cancelCrop() {
            cropRect = null;
            cropActions.classList.add('hidden');
            render();
        }

        // --- Event Listeners ---

        svgCanvas.addEventListener('mousedown', (e) => {
            const mousePos = getMousePos(e);
            
            if (currentTool === 'select') {
                const target = findClosestObject(mousePos);
                if (target) {
                    selectObject(target.id);
                    state.isDragging = true;
                    state.dragStartPoint = mousePos;
                } else {
                    deselectObject();
                    state.isPanning = true;
                    state.panStartPoint = { x: e.clientX, y: e.clientY };
                }
            } else if (currentTool === 'crop') {
                state.isCropping = true;
                startPoint = mousePos;
            } else {
                state.isDrawing = true;
                startPoint = mousePos;
            }
            updateCursor(mousePos);
        });

        svgCanvas.addEventListener('mousemove', (e) => {
            const mousePos = getMousePos(e);
            if (state.isPanning) {
                const dx = (e.clientX - state.panStartPoint.x) * (viewBox.w / svgCanvas.clientWidth);
                const dy = (e.clientY - state.panStartPoint.y) * (viewBox.h / svgCanvas.clientHeight);
                viewBox.x -= dx;
                viewBox.y -= dy;
                state.panStartPoint = { x: e.clientX, y: e.clientY };
                render();
                return;
            }

            if (state.isDragging && selectedObjectId !== null) {
                const dx = mousePos.x - state.dragStartPoint.x;
                const dy = mousePos.y - state.dragStartPoint.y;
                const obj = svgObjects.find(o => o.id === selectedObjectId);
                if (obj) {
                    if (obj.type === 'line') {
                        obj.x1 += dx; obj.y1 += dy;
                        obj.x2 += dx; obj.y2 += dy;
                    } else if (obj.type === 'circle') {
                        obj.cx += dx; obj.cy += dy;
                    } else { 
                        obj.x += dx; obj.y += dy;
                    }
                }
                state.dragStartPoint = mousePos;
                render();
                return;
            }

            if (state.isDrawing || state.isCropping) {
                const x = Math.min(startPoint.x, mousePos.x);
                const y = Math.min(startPoint.y, mousePos.y);
                const width = Math.abs(startPoint.x - mousePos.x);
                const height = Math.abs(startPoint.y - mousePos.y);
                
                if (state.isCropping) {
                    cropRect = { x, y, width, height };
                } else {
                    // This logic is now simplified as preview objects are not needed for this version
                }
                render();
            }
            updateCursor(mousePos);
        });

        svgCanvas.addEventListener('mouseup', (e) => {
            if (state.isPanning || state.isDragging) {
                if (state.isDragging) saveState();
                state.isPanning = false;
                state.isDragging = false;
                updateCursor(getMousePos(e));
                return;
            }
            
            if (state.isCropping) {
                state.isCropping = false;
                if (cropRect && (cropRect.width > 10 || cropRect.height > 10)) {
                    cropActions.classList.remove('hidden');
                } else {
                    cancelCrop();
                }
                return;
            }

            if (state.isDrawing) {
                state.isDrawing = false;
                let endPoint = getMousePos(e);
                let newObject;
                const color = strokeColorInput.value;

                switch (currentTool) {
                    case 'line':
                        if (Math.hypot(endPoint.x - startPoint.x, endPoint.y - startPoint.y) > 5) {
                            newObject = { id: nextId++, type: 'line', x1: startPoint.x, y1: startPoint.y, x2: endPoint.x, y2: endPoint.y, color };
                        }
                        break;
                    case 'circle':
                         const r = Math.hypot(endPoint.x - startPoint.x, endPoint.y - startPoint.y);
                         if (r > 5) {
                            newObject = { id: nextId++, type: 'circle', cx: startPoint.x, cy: startPoint.y, r, color };
                         }
                        break;
                    case 'text':
                        const content = prompt("Enter text:", "A");
                        if (content) {
                           newObject = { id: nextId++, type: 'text', x: startPoint.x, y: startPoint.y, content, color, fontSize: 20 };
                        }
                        break;
                }

                if (newObject) {
                    svgObjects.push(newObject);
                    saveState();
                }
                render();
            }
            updateCursor(getMousePos(e));
        });

        canvasContainer.addEventListener('wheel', (e) => {
            e.preventDefault();
            const mousePos = getMousePos(e);
            if (!mousePos) return;

            const zoomFactor = 1.1;
            const scale = (e.deltaY < 0) ? 1 / zoomFactor : zoomFactor;
            
            viewBox.x = mousePos.x + (viewBox.x - mousePos.x) * scale;
            viewBox.y = mousePos.y + (viewBox.y - mousePos.y) * scale;
            viewBox.w *= scale;
            viewBox.h *= scale;
            
            render();
        });
        
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && (e.key.toLowerCase() === 'z')) {
                e.preventDefault();
                undo();
            }
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (selectedObjectId !== null) {
                    svgObjects = svgObjects.filter(obj => obj.id !== selectedObjectId);
                    deselectObject();
                    saveState();
                }
            }
        });

        Object.entries(toolButtons).forEach(([name, btn]) => {
            btn.addEventListener('click', () => setActiveTool(name));
        });

        confirmCropBtn.addEventListener('click', confirmCrop);
        cancelCropBtn.addEventListener('click', cancelCrop);

        deleteBtn.addEventListener('click', () => {
            if (selectedObjectId !== null) {
                svgObjects = svgObjects.filter(obj => obj.id !== selectedObjectId);
                deselectObject();
                saveState();
            }
        });
        
        textInput.addEventListener('input', (e) => updateSelectedObject('content', e.target.value));
        fontSizeInput.addEventListener('input', (e) => updateSelectedObject('fontSize', e.target.value));
        strokeColorInput.addEventListener('input', (e) => updateSelectedObject('color', e.target.value));
        
        textInput.addEventListener('change', saveState);
        fontSizeInput.addEventListener('change', saveState);
        strokeColorInput.addEventListener('change', saveState);

        function getSvgForExport() {
            const tempSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            tempSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            tempSvg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
            
            svgObjects.forEach(obj => {
                const element = document.getElementById(`obj-${obj.id}`)?.cloneNode(true);
                if (element) {
                    element.classList.remove('selected', 'drawable');
                    tempSvg.appendChild(element);
                }
            });
            return new XMLSerializer().serializeToString(tempSvg);
        }

        downloadBtn.addEventListener('click', () => {
            const svgData = getSvgForExport();
            const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'thelo-geometry.svg';
            a.click();
            URL.revokeObjectURL(url);
        });

        copyBtn.addEventListener('click', () => {
            const svgData = getSvgForExport();
            svgCodeOutput.value = svgData;
            svgCodeOutput.select();
            document.execCommand('copy');
            alert('SVG code copied to clipboard!');
        });

        // --- Initial Setup ---
        function initialize() {
            const initialBounds = canvasContainer.getBoundingClientRect();
            viewBox.w = initialBounds.width || 1000;
            viewBox.h = initialBounds.height || 750;
            
            setActiveTool('select');
            saveState();
            render();
        }

        initialize();

        window.addEventListener('resize', () => {
            const newBounds = canvasContainer.getBoundingClientRect();
            if (!state.isPanning && !state.isDrawing && !state.isCropping) {
                viewBox.w = newBounds.width || 1000;
                viewBox.h = newBounds.height || 750;
            }
            render();
        });
    </script>

</body>
</html>
