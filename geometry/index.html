<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thelo Geometry SVG Creator</title>
    <link rel="icon" href="https://thelo.space/img/thelofavicon.png" type="image/png" />

    <!-- Fonts and Icons -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;700;800&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" rel="stylesheet">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        /* Thelo Brand Colors and Base Styles */
        :root {
            --thelo-blue: #2563EB;
            --thelo-blue-light: #EFF6FF;
            --thelo-green: #10B981;
            --thelo-amber: #F59E0B;
            --thelo-bg: #F8F9FA;
            --thelo-text: #111827;
            --thelo-text-light: #6B7280;
            --grid-color: #E5E7EB;
        }

        body {
            font-family: 'Manrope', sans-serif;
            background-color: var(--thelo-bg);
            color: var(--thelo-text);
            overflow: hidden; /* Prevent scrolling */
        }

        /* Custom Styles for the Tool */
        .tool-btn {
            transition: all 0.2s ease;
        }

        .tool-btn.active {
            background-color: var(--thelo-blue);
            color: white;
            box-shadow: 0 4px 14px rgba(37, 99, 235, 0.25);
        }
        
        #svg-canvas {
            cursor: crosshair;
            background-color: #fff;
            background-image:
                linear-gradient(var(--grid-color) 1px, transparent 1px),
                linear-gradient(to right, var(--grid-color) 1px, transparent 1px);
            background-size: 20px 20px;
            border-radius: 0.75rem;
            box-shadow: 0 4px 14px rgba(0,0,0,0.05);
        }
        
        /* Styles for SVG elements */
        .drawable:hover {
            stroke: var(--thelo-blue);
            stroke-width: 3px;
            fill-opacity: 0.7;
        }
        
        .selected {
            stroke: var(--thelo-amber) !important;
            stroke-width: 3.5px !important;
            stroke-dasharray: 5 5;
        }
        
        .right-angle-symbol, .angle-arc {
            fill: none;
            stroke: var(--thelo-text);
            stroke-width: 2;
        }

        .snap-point {
            fill: var(--thelo-blue);
            stroke: white;
            stroke-width: 2px;
        }
    </style>
</head>
<body class="w-screen h-screen flex flex-col antialiased">

    <!-- Header -->
    <header class="bg-white/70 backdrop-blur-lg border-b border-gray-200 p-4 flex justify-between items-center">
        <div class="flex items-center gap-4">
            <img src="https://thelo.space/img/bluethelo.svg" alt="Thelo logo" class="h-10 w-auto" />
            <h1 class="text-xl font-bold text-gray-800">Geometry Creator</h1>
        </div>
        <div class="text-sm text-gray-500">
            <kbd class="px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg">Ctrl</kbd>+<kbd class="px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg">Z</kbd> to Undo, <kbd class="px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg">Shift</kbd> to straighten lines.
        </div>
    </header>

    <!-- Main Content -->
    <div class="flex-grow flex gap-6 p-6 overflow-hidden">

        <!-- Left Panel: Toolbar -->
        <aside class="w-72 bg-white p-5 rounded-xl shadow-sm border border-gray-200 flex flex-col gap-8">
            <!-- Tools Section -->
            <div>
                <h2 class="font-bold text-lg mb-3">Tools</h2>
                <div class="grid grid-cols-2 gap-3">
                    <button id="tool-select" class="tool-btn active flex items-center justify-center gap-2 p-3 rounded-lg border bg-gray-50 hover:bg-gray-100">
                        <i class="fas fa-mouse-pointer fa-lg w-5 text-center"></i>
                        <span class="text-sm font-semibold">Select</span>
                    </button>
                    <button id="tool-line" class="tool-btn flex items-center justify-center gap-2 p-3 rounded-lg border bg-gray-50 hover:bg-gray-100">
                        <i class="fas fa-drafting-compass fa-lg w-5 text-center"></i>
                        <span class="text-sm font-semibold">Line</span>
                    </button>
                    <button id="tool-circle" class="tool-btn flex items-center justify-center gap-2 p-3 rounded-lg border bg-gray-50 hover:bg-gray-100">
                        <i class="far fa-circle fa-lg w-5 text-center"></i>
                        <span class="text-sm font-semibold">Circle</span>
                    </button>
                    <button id="tool-text" class="tool-btn flex items-center justify-center gap-2 p-3 rounded-lg border bg-gray-50 hover:bg-gray-100">
                        <i class="fas fa-font fa-lg w-5 text-center"></i>
                        <span class="text-sm font-semibold">Text</span>
                    </button>
                    <button id="tool-right-angle" class="tool-btn flex items-center justify-center gap-2 p-3 rounded-lg border bg-gray-50 hover:bg-gray-100">
                        <i class="far fa-square fa-lg w-5 text-center"></i>
                        <span class="text-sm font-semibold">Right Angle</span>
                    </button>
                    <button id="tool-measure-angle" class="tool-btn flex items-center justify-center gap-2 p-3 rounded-lg border bg-gray-50 hover:bg-gray-100">
                         <i class="fas fa-angle-left fa-lg w-5 text-center"></i>
                        <span class="text-sm font-semibold">Measure</span>
                    </button>
                </div>
            </div>

            <!-- Properties Section -->
            <div id="properties-panel" class="hidden">
                <h2 class="font-bold text-lg mb-3">Properties</h2>
                <div class="space-y-4">
                    <div id="text-properties" class="hidden">
                        <label for="text-input" class="block text-sm font-medium text-gray-700">Text</label>
                        <input type="text" id="text-input" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                    </div>
                    <div>
                        <label for="stroke-color" class="block text-sm font-medium text-gray-700">Color</label>
                        <input type="color" id="stroke-color" value="#111827" class="mt-1 block w-full h-8 rounded-md border-gray-300 shadow-sm">
                    </div>
                    <button id="delete-btn" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                        <i class="fas fa-trash-alt mr-2"></i>Delete
                    </button>
                </div>
            </div>
            
            <!-- Export Section -->
            <div class="mt-auto">
                 <h2 class="font-bold text-lg mb-3">Export</h2>
                 <div class="space-y-3">
                    <button id="download-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                        <i class="fas fa-download mr-2"></i>Download SVG
                    </button>
                    <button id="copy-btn" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                        <i class="fas fa-copy mr-2"></i>Copy Code
                    </button>
                 </div>
            </div>
        </aside>

        <!-- Right Panel: SVG Canvas -->
        <main class="flex-grow bg-white rounded-xl border border-gray-200">
            <svg id="svg-canvas" class="w-full h-full"></svg>
        </main>

    </div>
    
    <textarea id="svg-code-output" class="absolute -left-full"></textarea>

    <script type="module">
        const svgCanvas = document.getElementById('svg-canvas');
        const propertiesPanel = document.getElementById('properties-panel');
        const textProperties = document.getElementById('text-properties');
        const textInput = document.getElementById('text-input');
        const strokeColorInput = document.getElementById('stroke-color');
        const deleteBtn = document.getElementById('delete-btn');
        const downloadBtn = document.getElementById('download-btn');
        const copyBtn = document.getElementById('copy-btn');
        const svgCodeOutput = document.getElementById('svg-code-output');
        const toolButtons = {
            select: document.getElementById('tool-select'),
            line: document.getElementById('tool-line'),
            circle: document.getElementById('tool-circle'),
            text: document.getElementById('tool-text'),
            rightAngle: document.getElementById('tool-right-angle'),
            measureAngle: document.getElementById('tool-measure-angle'),
        };

        let currentTool = 'select';
        let svgObjects = [];
        let selectedObjectId = null;
        let isDrawing = false;
        let isShiftDown = false;
        let startPoint = { x: 0, y: 0 };
        let nextId = 0;
        let previewObject = null;
        
        let history = [];
        let historyIndex = -1;

        let angleCreationState = {
            active: false,
            points: [],
        };
        
        const SNAP_THRESHOLD = 10;

        function saveState() {
            history = history.slice(0, historyIndex + 1);
            history.push(JSON.parse(JSON.stringify(svgObjects)));
            historyIndex++;
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                svgObjects = JSON.parse(JSON.stringify(history[historyIndex]));
                deselectObject();
                render();
            }
        }

        function setActiveTool(toolName) {
            currentTool = toolName;
            Object.values(toolButtons).forEach(btn => btn.classList.remove('active'));
            toolButtons[toolName]?.classList.add('active');
            deselectObject();
            angleCreationState.active = (toolName === 'measureAngle');
            angleCreationState.points = [];
        }

        function getMousePos(event) {
            const rect = svgCanvas.getBoundingClientRect();
            return {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
        }

        function getSnapPoint(pos) {
            // Grid snap
            let snappedPos = { 
                x: Math.round(pos.x / 20) * 20,
                y: Math.round(pos.y / 20) * 20
            };
            let isSnapped = (Math.abs(pos.x - snappedPos.x) < SNAP_THRESHOLD) || (Math.abs(pos.y - snappedPos.y) < SNAP_THRESHOLD);

            // Endpoint snap
            for (const obj of svgObjects) {
                if (obj.type === 'line') {
                    const points = [{x: obj.x1, y: obj.y1}, {x: obj.x2, y: obj.y2}];
                    for (const p of points) {
                        const dist = Math.hypot(pos.x - p.x, pos.y - p.y);
                        if (dist < SNAP_THRESHOLD) {
                            return { ...p };
                        }
                    }
                } else if (obj.type === 'circle') {
                     const dist = Math.hypot(pos.x - obj.cx, pos.y - obj.cy);
                     if (dist < SNAP_THRESHOLD) {
                         return { x: obj.cx, y: obj.cy };
                     }
                }
            }
            
            return isSnapped ? snappedPos : pos;
        }

        function render() {
            svgCanvas.innerHTML = ''; 

            const allObjects = [...svgObjects];
            if (previewObject) allObjects.push(previewObject);

            allObjects.forEach(obj => {
                let element;
                switch (obj.type) {
                    case 'line':
                        element = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        element.setAttribute('x1', obj.x1);
                        element.setAttribute('y1', obj.y1);
                        element.setAttribute('x2', obj.x2);
                        element.setAttribute('y2', obj.y2);
                        element.setAttribute('stroke', obj.color);
                        element.setAttribute('stroke-width', '2.5');
                        element.setAttribute('stroke-linecap', 'round');
                        break;
                    case 'circle':
                        element = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        element.setAttribute('cx', obj.cx);
                        element.setAttribute('cy', obj.cy);
                        element.setAttribute('r', obj.r);
                        element.setAttribute('stroke', obj.color);
                        element.setAttribute('stroke-width', '2.5');
                        element.setAttribute('fill', 'none');
                        break;
                    case 'text':
                        element = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        element.setAttribute('x', obj.x);
                        element.setAttribute('y', obj.y);
                        element.setAttribute('fill', obj.color);
                        element.setAttribute('font-size', '20');
                        element.setAttribute('font-weight', 'bold');
                        element.setAttribute('font-family', 'Manrope, sans-serif');
                        element.textContent = obj.content;
                        break;
                    case 'rightAngle':
                        element = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        element.setAttribute('d', `M ${obj.x} ${obj.y+15} L ${obj.x+15} ${obj.y+15} L ${obj.x+15} ${obj.y}`);
                        element.setAttribute('class', 'right-angle-symbol');
                        element.setAttribute('stroke', obj.color);
                        break;
                    case 'measureAngle':
                        const [p1, vertex, p3] = obj.points;
                        const angleRad1 = Math.atan2(p1.y - vertex.y, p1.x - vertex.x);
                        const angleRad2 = Math.atan2(p3.y - vertex.y, p3.x - vertex.x);
                        let angleDeg = (angleRad2 - angleRad1) * 180 / Math.PI;
                        if (angleDeg < 0) angleDeg += 360;

                        const arcRadius = 30;
                        const startArc = { x: vertex.x + arcRadius * Math.cos(angleRad1), y: vertex.y + arcRadius * Math.sin(angleRad1) };
                        const endArc = { x: vertex.x + arcRadius * Math.cos(angleRad2), y: vertex.y + arcRadius * Math.sin(angleRad2) };
                        const largeArcFlag = (angleDeg <= 180) ? "0" : "1";

                        const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        path.setAttribute('d', `M ${startArc.x} ${startArc.y} A ${arcRadius} ${arcRadius} 0 ${largeArcFlag} 1 ${endArc.x} ${endArc.y}`);
                        path.setAttribute('class', 'angle-arc');
                        path.setAttribute('stroke', obj.color);

                        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        const textAngle = angleRad1 + (angleRad2 - angleRad1) / 2;
                        text.setAttribute('x', vertex.x + (arcRadius + 15) * Math.cos(textAngle));
                        text.setAttribute('y', vertex.y + (arcRadius + 15) * Math.sin(textAngle));
                        text.setAttribute('fill', obj.color);
                        text.setAttribute('font-size', '14');
                        text.textContent = `${angleDeg.toFixed(1)}°`;
                        
                        group.appendChild(path);
                        group.appendChild(text);
                        element = group;
                        break;
                }

                if (element) {
                    element.setAttribute('id', `obj-${obj.id}`);
                    if (!obj.isPreview) {
                        element.classList.add('drawable');
                        if (obj.id === selectedObjectId) {
                            element.classList.add('selected');
                        }
                        element.addEventListener('mousedown', (e) => {
                            e.stopPropagation();
                            if (currentTool === 'select') selectObject(obj.id);
                        });
                    } else {
                        element.setAttribute('opacity', '0.6');
                        element.setAttribute('stroke-dasharray', '5 5');
                    }
                    svgCanvas.appendChild(element);
                }
            });

            if (angleCreationState.active) {
                angleCreationState.points.forEach(p => {
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', p.x);
                    circle.setAttribute('cy', p.y);
                    circle.setAttribute('r', '5');
                    circle.setAttribute('class', 'snap-point');
                    svgCanvas.appendChild(circle);
                });
            }
        }

        function selectObject(id) {
            selectedObjectId = id;
            const selectedObject = svgObjects.find(obj => obj.id === id);
            
            if (selectedObject) {
                propertiesPanel.classList.remove('hidden');
                strokeColorInput.value = selectedObject.color;
                
                if (selectedObject.type === 'text') {
                    textProperties.classList.remove('hidden');
                    textInput.value = selectedObject.content;
                } else {
                    textProperties.classList.add('hidden');
                }
            } else {
                deselectObject();
            }
            render();
        }

        function deselectObject() {
            selectedObjectId = null;
            propertiesPanel.classList.add('hidden');
            textProperties.classList.add('hidden');
            render();
        }
        
        function updateSelectedObject(prop, value) {
            if (selectedObjectId === null) return;
            const obj = svgObjects.find(o => o.id === selectedObjectId);
            if (obj) {
                obj[prop] = value;
                saveState();
                render();
            }
        }

        // --- Event Listeners ---

        Object.entries(toolButtons).forEach(([name, btn]) => {
            btn.addEventListener('click', () => setActiveTool(name));
        });

        svgCanvas.addEventListener('mousedown', (e) => {
            if (currentTool === 'select') {
                 deselectObject();
                 return;
            }
            if (angleCreationState.active) return;
            isDrawing = true;
            startPoint = getSnapPoint(getMousePos(e));
        });

        svgCanvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            let currentPos = getSnapPoint(getMousePos(e));

            if (isShiftDown && (currentTool === 'line')) {
                const dx = currentPos.x - startPoint.x;
                const dy = currentPos.y - startPoint.y;
                if (Math.abs(dx) > Math.abs(dy)) {
                    currentPos.y = startPoint.y;
                } else {
                    currentPos.x = startPoint.x;
                }
            }
            
            const color = strokeColorInput.value;
            switch (currentTool) {
                case 'line':
                    previewObject = { id: -1, type: 'line', x1: startPoint.x, y1: startPoint.y, x2: currentPos.x, y2: currentPos.y, color, isPreview: true };
                    break;
                case 'circle':
                    const r = Math.hypot(currentPos.x - startPoint.x, currentPos.y - startPoint.y);
                    previewObject = { id: -1, type: 'circle', cx: startPoint.x, cy: startPoint.y, r, color, isPreview: true };
                    break;
            }
            render();
        });

        svgCanvas.addEventListener('mouseup', (e) => {
            const endPoint = getSnapPoint(getMousePos(e));

            if (angleCreationState.active) {
                angleCreationState.points.push(endPoint);
                if (angleCreationState.points.length === 3) {
                    const newObject = { id: nextId++, type: 'measureAngle', points: angleCreationState.points, color: strokeColorInput.value };
                    svgObjects.push(newObject);
                    angleCreationState.points = [];
                    saveState();
                }
                render();
                return;
            }

            if (!isDrawing) return;
            isDrawing = false;
            previewObject = null;
            
            let newObject;
            const color = strokeColorInput.value;

            switch (currentTool) {
                case 'line':
                    if (isShiftDown) {
                        const dx = endPoint.x - startPoint.x;
                        const dy = endPoint.y - startPoint.y;
                        if (Math.abs(dx) > Math.abs(dy)) endPoint.y = startPoint.y;
                        else endPoint.x = startPoint.x;
                    }
                    if (Math.hypot(endPoint.x - startPoint.x, endPoint.y - startPoint.y) > 5) {
                        newObject = { id: nextId++, type: 'line', x1: startPoint.x, y1: startPoint.y, x2: endPoint.x, y2: endPoint.y, color };
                    }
                    break;
                case 'circle':
                     const r = Math.hypot(endPoint.x - startPoint.x, endPoint.y - startPoint.y);
                     if (r > 5) {
                        newObject = { id: nextId++, type: 'circle', cx: startPoint.x, cy: startPoint.y, r, color };
                     }
                    break;
                case 'text':
                    const content = prompt("Enter text:", "A");
                    if (content) {
                       newObject = { id: nextId++, type: 'text', x: startPoint.x, y: startPoint.y, content, color };
                    }
                    break;
                case 'rightAngle':
                    newObject = { id: nextId++, type: 'rightAngle', x: startPoint.x, y: startPoint.y, color };
                    break;
            }

            if (newObject) {
                svgObjects.push(newObject);
                saveState();
            }
            render();
        });
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Shift') isShiftDown = true;
            if (e.ctrlKey && e.key.toLowerCase() === 'z') {
                e.preventDefault();
                undo();
            }
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (selectedObjectId !== null) {
                    svgObjects = svgObjects.filter(obj => obj.id !== selectedObjectId);
                    deselectObject();
                    saveState();
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.key === 'Shift') isShiftDown = false;
        });

        deleteBtn.addEventListener('click', () => {
            if (selectedObjectId !== null) {
                svgObjects = svgObjects.filter(obj => obj.id !== selectedObjectId);
                deselectObject();
                saveState();
            }
        });
        
        textInput.addEventListener('input', (e) => updateSelectedObject('content', e.target.value));
        strokeColorInput.addEventListener('input', (e) => updateSelectedObject('color', e.target.value));

        downloadBtn.addEventListener('click', () => {
            deselectObject(); // Ensure no selection artifacts are in the export
            setTimeout(() => {
                const svgData = new XMLSerializer().serializeToString(svgCanvas);
                const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'thelo-geometry.svg';
                a.click();
                URL.revokeObjectURL(url);
            }, 100);
        });

        copyBtn.addEventListener('click', () => {
            deselectObject();
            setTimeout(() => {
                const svgData = new XMLSerializer().serializeToString(svgCanvas);
                svgCodeOutput.value = svgData;
                svgCodeOutput.select();
                document.execCommand('copy');
                alert('SVG code copied to clipboard!');
            }, 100);
        });

        // --- Initial Setup ---
        setActiveTool('select');
        saveState();
    </script>

</body>
</html>
