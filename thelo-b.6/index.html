<!DOCTYPE html>
<html lang="hy">
<head>
Â  Â  <meta charset="UTF-8" />
Â  Â  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
Â  Â  <link rel="icon" href="https://thelo.space/img/thelofavicon.png" type="image/png">
Â  Â  <link rel="apple-touch-icon" href="https://thelo.space/img/yarnicon.png">
Â  Â  <title>thelo</title>
Â  Â  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
Â  Â  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
	<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
Â  Â  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-functions-compat.js"></script>
	<link rel="preconnect" href="https://fonts.googleapis.com">
Â  Â  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
Â  Â  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@300;400;500;700&display=swap" rel="stylesheet">
	<link rel="manifest" href="/manifest.json" />
Â Â 
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd" crossorigin="anonymous"></script>
<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">


<style>
Â /* ===== NEW: Updated Design System ===== */
Â :root {
Â  Â  /* Core Palette */
Â  Â  --thelo-blue: #2563eb;
Â  Â  --thelo-blue-dark: #1d4ed8;
Â  Â  --thelo-bg: #ffffff;
Â  Â  --thelo-text: #111827;
Â  Â  --thelo-text-light: #6b7280;
Â  Â  --thelo-border: #e5e7eb;

Â  Â  /* Status Colors */
Â  Â  --success-green: #22c55e;
Â  Â  --error-red: #ef4444;
Â  Â  --accent-yellow: #f59e0b;

Â  Â  /* UI Element Colors */
Â  Â  --bg-white: #ffffff;
Â  Â  --chat-ai-bg: #ffffff;

Â  Â  /* Ink Colors */
Â  Â  --ink-black: #000000;
Â  Â  --ink-blue: var(--thelo-blue);

Â  Â  /* Effects */
Â  Â  --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
Â  Â  --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
Â  Â  --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);

Â  Â  /* Transitions */
Â  Â  --fade-duration: 0.3s;
Â  Â  --animation-duration: 0.3s;
Â  Â  --thelobook-page-transition-duration: 0.05s;
Â }
Â #loading-overlay {
Â  Â  position: fixed;
Â  Â  top: 0;
Â  Â  left: 0;
Â  Â  width: 100%;
Â  Â  height: 100%;
Â  Â  background-color: var(--thelo-bg); /* Use your existing background color */
Â  Â  display: flex;
Â  Â  justify-content: center;
Â  Â  align-items: center;
Â  Â  z-index: 9999; /* Ensure it's on top of all other content */
Â  Â  opacity: 1;
Â  Â  /* Add a transition for the fade-out effect */
Â  Â  transition: opacity 0.5s ease-out;
}

#loading-overlay.hidden {
Â  Â  opacity: 0;
Â  Â  pointer-events: none; /* Prevents interaction while fading out */
}

#loading-svg {
Â  Â  width: 150px; /* A larger logo as requested */
Â  Â  height: auto;
Â  Â  animation: pulse-loader 1.5s infinite ease-in-out;
}
/* Add this to your CSS */
Â #fullscreenBtn {
Â  Â  background-color: #6b7280; /* A neutral gray */
Â }
/* This is the animation for the logo */
@keyframes pulse-loader {
Â  Â  0% {
Â  Â  Â  Â  transform: scale(1);
Â  Â  Â  Â  opacity: 0.8;
Â  Â  }
Â  Â  50% {
Â  Â  Â  Â  transform: scale(1.1);
Â  Â  Â  Â  opacity: 1;
Â  Â  }
Â  Â  100% {
Â  Â  Â  Â  transform: scale(1);
Â  Â  Â  Â  opacity: 0.8;
Â  Â  }
}

Â /* ===== Font Definition (Unchanged as requested) ===== */
@font-face {
Â  font-family: 'Mardoto-Light';
Â  src: url('../../fonts/Mardoto-Light.ttf') format('truetype');
Â  font-weight: 300;
Â  font-style: normal;
Â  font-display: swap;
}
	@font-face {
Â  Â  Â  font-family: 'Montserrat Arm';
Â  Â  Â  src: url('https://thelo.space/fonts/Montserratarm-Regular.otf') format('opentype');
Â  Â  Â  font-weight: 400; /* Regular */
Â  Â  Â  font-style: normal;
Â  Â  Â  font-display: swap;
Â  Â  }
Â  Â  @font-face {
Â  Â  Â  font-family: 'Montserrat Arm';
Â  Â  Â  src: url('https://thelo.space/fonts/Montserratarm-SemiBold.otf') format('opentype');
Â  Â  Â  font-weight: 600; /* SemiBold */
Â  Â  Â  font-style: normal;
Â  Â  Â  font-display: swap;
Â  Â  }
Â  Â  @font-face {
Â  Â  Â  font-family: 'Montserrat Arm';
Â  Â  Â  src: url('https://thelo.space/fonts/Montserratarm-ExtraBold.otf') format('opentype');
Â  Â  Â  font-weight: 800; /* ExtraBold */
Â  Â  Â  font-style: normal;
Â  Â  Â  font-display: swap;
Â  Â  }

/* ===== Base Styles ===== */
html {
Â  font-size: 16px;
Â  background: var(--thelo-bg);
}
body {
Â  margin: 0;
Â  min-height: 100vh;
Â  height: 100vh;
Â  font-family: 'Montserrat Arm', system-ui, -apple-system, sans-serif;
Â  font-weight: 400;
Â  display: flex;
Â  flex-direction: column;
Â  overflow: hidden;
Â  background-color: var(--thelo-bg);
Â  color: var(--thelo-text);
Â  Â -webkit-user-select: none; /* Safari */
Â  -moz-user-select: none;Â  Â  /* Firefox */
Â  -ms-user-select: none;Â  Â  Â /* IE10+/Edge */
Â  user-select: none;Â  Â  Â  Â  Â /* Standard */
Â  -webkit-touch-callout: none; /* iOS Safari */
}	/* ADD THIS RULE: Use Manrope font when the body has the 'lang-en' class */
body.lang-en {
Â  font-family: 'Manrope', system-ui, -apple-system, sans-serif;
}
	/* MCQ buttons blur when thelobook is active */
.blurred-mcq {
Â  Â  filter: blur(4px);
Â  Â  opacity: 0.55;
Â  Â  pointer-events: none;Â  Â  Â  /* clicks still ignored */
Â  Â  z-index: 5 !important;Â  Â  Â /* sits below thelobookCanvas (z-15) */
Â  Â  transition: filter .2s, opacity .2s;
}


Â /* ===== Layout & App Structure ===== */

Â #lessonArea {
Â  Â  position: absolute; /* <--- NEW */
Â  Â  top: 0;Â  Â  Â  Â  Â  Â  Â /* <--- NEW */
Â  Â  left: 0;Â  Â  Â  Â  Â  Â  /* <--- NEW */
Â  Â  right: 0;Â  Â  Â  Â  Â  Â /* <--- NEW */
Â  Â  bottom: 0;Â  Â  Â  Â  Â  /* <--- NEW */
Â  Â  display: flex;
Â  Â  flex-direction: column;
Â  Â  overflow: hidden;
Â  Â  /* position: relative; can be removed or left, it doesn't matter now */
}
Â #boardWrap {
Â  Â  position: relative;
Â  Â  flex-grow: 1;
Â  Â  overflow: visible; /* Changed from hidden to visible */
Â  Â  background-color: var(--thelo-bg);
Â  Â  /* Grid background */
Â  Â  background-image: linear-gradient(to right, var(--thelo-border) 1px, transparent 1px),
Â  Â  Â  linear-gradient(to bottom, var(--thelo-border) 1px, transparent 1px);
Â  Â  background-size: 40px 40px;
Â }

Â /* ===== Canvases & Overlays ===== */
Â #stageProgressBarContainer {
Â  Â  position: absolute;
Â  Â  top: 30.1px;
Â  Â  left: 2%;
Â  Â  width: 96%;
Â  Â  height: 2px;
Â  Â  background-color: #cccccc;
Â  Â  border-radius: 2px;
Â  Â  z-index: 10;
Â  Â  opacity: 0;
Â  Â  visibility: hidden;
Â  Â  transition: opacity var(--fade-duration) ease-in-out, visibility 0s linear var(--fade-duration);
Â }
Â #stageProgressBarContainer.visible {
Â  Â  opacity: 1;
Â  Â  visibility: visible;
Â  Â  transition: opacity var(--fade-duration) ease-in-out, visibility 0s linear 0s;
Â }
Â #stageProgressFill {
Â  Â  height: 100%;
Â  Â  background-color: #000000;
Â  Â  width: 0%;
Â  Â  border-radius: 2px;
Â  Â  transition: width 0.05s linear;
Â }

Â #backgroundCanvas,
Â #replayCanvas,
Â #board,
Â #finalAnswerCanvas,
Â #thelobookCanvas {
Â  Â  position: absolute;
Â  Â  top: 0;
Â  Â  left: 0;
Â  Â  width: 100%;
Â  Â  height: 100%;
Â  Â  display: block;
Â  Â  background-color: transparent;
Â }
Â #backgroundCanvas {
Â  Â  z-index: 1;
Â  Â  pointer-events: none;
Â  Â  opacity: 1;
Â  Â  transition: opacity var(--fade-duration) ease-in-out;
Â }
Â #backgroundCanvas.fade-out {
Â  Â  opacity: 0;
Â }
Â #replayCanvas {
Â  Â  z-index: 2;
Â  Â  pointer-events: none;
Â  Â  opacity: 1;
Â  Â  transition: opacity var(--fade-duration) ease-in-out;
Â }
Â #replayCanvas.fade-out {
Â  Â  opacity: 0;
Â }
Â #board {
	 opacity: 0 !important;Â  Â  Â  Â  Â  /* invisible */
Â  Â  pointer-events: auto;Â  Â  Â  Â  Â  Â /* keep drawing events working */
Â  Â  z-index: 3;
Â  Â  cursor: crosshair;
Â  Â  touch-action: none;
Â }
Â #finalAnswerCanvas {
Â  Â  z-index: 4;
Â  Â  opacity: 0;
Â  Â  pointer-events: none;
Â }

Â #thelobookCanvas {
Â  Â  backdrop-filter: blur(12px);
Â  Â  -webkit-backdrop-filter: blur(12px);
Â  Â  z-index: 15;
Â  Â  cursor: crosshair;
Â  Â  touch-action: none;
Â  Â  opacity: 0;
Â  Â  visibility: hidden;
Â  Â  transform: scale(0.95);
Â  Â  transition: opacity var(--animation-duration) ease, visibility 0s linear var(--animation-duration),
Â  Â  Â  transform var(--animation-duration) ease;
Â }
Â #thelobookCanvas.active {
Â  Â  opacity: 1;
Â  Â  visibility: visible;
Â  Â  transform: scale(1);
Â  Â  transition-delay: 0s, 0s, 0s;
Â }
Â #thelobookCanvas.grid-underlay {
Â  Â  opacity: 0.9 !important;
Â  Â  transform: scale(1) !important;
Â }
Â #thelobookCanvas.eraser-active {
Â  Â  cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="rgba(0,0,0,0.5)" d="M19.78,2.22a1,1,0,0,0-1.42,0L9.12,11.46a1,1,0,0,0,0,1.41L11.24,15A1,1,0,0,0,12.66,15L22.22,5.39A1,1,0,0,0,22.22,4L19.78,2.22ZM8.41,12.88,2,19.29V21a1,1,0,0,0,1,1H4.71l6.47-6.46-1.42-1.42A1,1,0,0,0,8.41,12.88Z"/></svg>')
Â  Â  Â  12 12, auto;
Â }

Â /* ===== UI Controls ===== */
Â /* ===== MODIFIED for Fullscreen Grid ===== */
#bottomBar {
Â  position: absolute;Â  Â  Â  Â  Â  /* Take the bar out of the normal layout flow */
Â  bottom: 0;Â  Â  Â  Â  Â  Â  Â  Â  Â  Â /* Pin it to the bottom of the viewport */
Â  left: 0;Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â /* Pin it to the left */
Â  width: 100%;Â  Â  Â  Â  Â  Â  Â  Â  Â /* Make it stretch full-width */
Â  background-color: transparent; /* Let the grid background show through */
Â  box-sizing: border-box;Â  Â  Â  /* Ensures padding is included in the width */

Â  /* These existing rules remain to style the buttons inside */
Â  padding: 0.5rem 1rem 1rem 1rem;
Â  display: flex;
Â  justify-content: space-between;
Â  align-items: center;
Â  z-index: 20;
Â  gap: 0.75rem;
Â  transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1);
}
Â .control-btn {
Â  Â  font-family: inherit;
Â  Â  padding: 0.5rem 1rem;
Â  Â  font-size: 0.9rem;
Â  Â  font-weight: 500;
Â  Â  border: none;
Â  Â  border-radius: 0.5rem;
Â  Â  color: var(--bg-white);
Â  Â  cursor: pointer;
Â  Â  transition: background-color 0.2s, transform 0.15s, box-shadow 0.2s;
Â  Â  box-shadow: var(--shadow-md);
Â }
Â .control-btn:hover:not(:disabled) {
Â  Â  transform: translateY(-2px);
Â  Â  box-shadow: var(--shadow-lg);
Â }
Â .control-btn:disabled {
Â  Â  background-color: #9ca3af !important;
Â  Â  cursor: not-allowed;
Â  Â  opacity: 0.7;
Â }

Â /* Button Colors */
Â #prevBtn {
Â  Â  background-color: var(--accent-yellow);
Â }
Â #thelobookBtn {
Â  Â  background-color: var(--success-green);
Â }
Â #clearBtn {
Â  Â  background-color: var(--error-red);
Â }
Â #nextCheckBtn {
Â  Â  background-color: var(--thelo-blue);
Â }
Â #nextCheckBtn:hover:not(:disabled) {
Â  Â  background-color: var(--thelo-blue-dark);
Â }
Â #nextCheckBtn.correct {
Â  Â  background-color: var(--success-green);
Â }
Â #nextCheckBtn.incorrect {
Â  Â  background-color: var(--error-red);
Â  Â  animation: shake 0.5s ease-in-out;
Â }
Â @keyframes shake {
Â  Â  0%,
Â  Â  100% {
Â  Â  Â  transform: translateX(0);
Â  Â  }
Â  Â  25%,
Â  Â  75% {
Â  Â  Â  transform: translateX(-5px);
Â  Â  }
Â  Â  50% {
Â  Â  Â  transform: translateX(5px);
Â  Â  }
Â }

Â /* ===== MODIFIED for Floating Text ===== */
#colorIndicator,
#pointsDisplay {
Â  background-color: transparent; /* Remove the white box */
Â  border: none;Â  Â  Â  Â  Â  Â  Â  Â  Â  /* Remove the border */
Â  box-shadow: none;Â  Â  Â  Â  Â  Â  Â  /* Remove the shadow */
Â  color: var(--thelo-text);Â  Â  Â  /* Use the main text color */
Â  font-size: 1rem;Â  Â  Â  Â  Â  Â  Â  Â /* Make text slightly larger for readability */
Â  font-weight: 500;
Â  padding: 0.5rem 1rem;Â  Â  Â  Â  Â  /* Keep padding to maintain spacing */
Â  white-space: nowrap;
}

Â /* MCQ Buttons */
#mcqOptionsContainer {
Â  Â  position: absolute;
Â  Â  top: 50%;
Â  Â  left: 50%;
Â  Â  transform: translate(-50%, -50%);
Â  Â  z-index: 30;
Â  Â  display: none;
Â  Â  flex-direction: row;
Â  Â  flex-wrap: wrap;
Â  Â  justify-content: center;
Â  Â  gap: 1rem;
Â  Â  width: 90%;
Â  Â  max-width: 1200px;
	transition: opacity var(--fade-duration) ease-in-out;
}

@media (max-width: 1024px) {
Â  Â  .mcq-option-btn {
Â  Â  Â  Â  font-size: 0.7rem;
Â  Â  }
}
.mcq-option-btn {
Â  Â  font-family: inherit;
Â  Â  padding: 0.8rem 1.5rem;
Â  Â  font-size: 1.1rem;
Â  Â  font-weight: 600;
Â  Â  border: 1px solid var(--thelo-border);
Â  Â  background-color: #f9fafb;
Â  Â  color: var(--thelo-text);
Â  Â  border-radius: 0.75rem;
Â  Â  cursor: pointer;
Â  Â  transition: background-color 0.4s ease-out, border-color 0.4s ease-out, color 0.4s ease-out, transform 0.2s ease-out, box-shadow 0.2s ease-out;
Â  Â  box-shadow: var(--shadow-sm);
Â  Â  /* CHANGE: Let the button's width be determined by its content. */
Â  Â  width: fit-content;
Â  Â  /* CHANGE: Don't force the button to grow or have a specific basis. */
Â  Â  flex: 0 1 auto;
Â  Â  white-space: nowrap;
Â  Â  transform: translateY(0);
}

.mcq-option-btn:hover:not(:disabled) {
Â  Â  transform: translateY(-3px);
Â  Â  box-shadow: var(--shadow-lg);
Â  Â  color: var(--thelo-blue);
Â  Â  border-color: #dbeafe;
}
.mcq-option-btn.correct {
Â  Â  background-color: var(--success-green);
Â  Â  color: white;
Â  Â  border-color: var(--success-green);
Â }
Â .mcq-option-btn.incorrect {
Â  Â  background-color: var(--error-red);
Â  Â  color: white;
Â  Â  border-color: var(--error-red);
Â }
Â .mcq-option-btn.correct-answer-shown {
Â  Â  border-color: var(--success-green);
Â  Â  border-width: 2px;
Â }

Â /* ===== Chat Column ===== */
Â #chatCol {
Â  Â  width: 320px;
Â  Â  display: flex;
Â  Â  flex-direction: column;
Â  Â  background: var(--bg-white);
Â  Â  border-left: 1px solid var(--thelo-border);
Â  Â  padding: 1rem;
Â  Â  height: 100%;
Â  Â  box-sizing: border-box;
Â }
Â #terminalLogo {
Â  Â  height: 60px;
Â  Â  width: auto;
Â  Â  display: block;
Â  Â  align-self: center;
Â  Â  margin: 0.5rem 0 1.5rem 0;
Â }
Â #chat {
Â  Â  flex: 1;
Â  Â  overflow-y: auto;
Â  Â  scrollbar-width: thin;
Â  Â  scrollbar-color: var(--thelo-border) transparent;
Â }
Â #chat::-webkit-scrollbar {
Â  Â  width: 5px;
Â }
Â #chat::-webkit-scrollbar-thumb {
Â  Â  background-color: var(--thelo-border);
Â  Â  border-radius: 10px;
Â }
.ai-message {
Â  background-color: var(--bg-white);
Â  border: 1px solid #f0f0f0;
Â  color: var(--thelo-text);
Â  padding: 0.75rem 1rem;
Â  border-radius: 0.75rem;
Â  margin-bottom: 0.75rem;
Â  max-width: 95%;
Â  align-self: flex-start;
Â  word-wrap: break-word;
Â  box-shadow: var(--shadow-sm);
Â  font-size: 0.9rem;
Â  line-height: 1.6;
Â  opacity: 0;
Â  transform: translateY(10px);
Â  transition: opacity 0.3s ease-out, transform 0.3s ease-out;
}

.ai-message.show {
Â  opacity: 1;
Â  transform: translateY(0);
}
.ai-message strong {
Â  Â  color: var(--thelo-blue);
Â  Â  font-weight: inherit;
Â }
Â .ai-message .emoji {
Â  Â  margin-right: 0.5rem;
Â }

#dashboardBtn {
Â  Â  background-color: var(--thelo-blue);
}

#dashboardBtn:hover:not(:disabled) {
Â  Â  background-color: var(--thelo-blue-dark);
}

#dashboardBtn.visible {
Â  Â  display: inline-flex !important;
Â  Â  animation: pulse-glow 2s infinite ease-in-out;
}

#bottomBar.bar-hidden-by-stylus {
Â  Â  transform: translateY(150%);
Â  Â  pointer-events: none;
}
	/* ADD THIS CSS: For the Streak Modal */
#streakModal {
Â  Â  position: fixed;
Â  Â  z-index: 100;
Â  Â  left: 0;
Â  Â  top: 0;
Â  Â  width: 100%;
Â  Â  height: 100%;
Â  Â  background-color: rgba(0, 0, 0, 0.6);
Â  Â  display: flex;
Â  Â  align-items: center;
Â  Â  justify-content: center;
Â  Â  opacity: 0;
Â  Â  visibility: hidden;
Â  Â  transition: opacity 0.3s ease, visibility 0.3s;
}
#streakModal:not(.modal-hidden) {
Â  Â  opacity: 1;
Â  Â  visibility: visible;
}
.streak-modal-content {
Â  Â  background-color: var(--thelo-bg);
Â  Â  color: var(--thelo-text);
Â  Â  padding: 2rem 3rem;
Â  Â  border-radius: 1rem;
Â  Â  text-align: center;
Â  Â  box-shadow: var(--shadow-lg);
Â  Â  position: relative;
Â  Â  transform: scale(0.9);
Â  Â  transition: transform 0.3s ease;
}
#streakModal:not(.modal-hidden) .streak-modal-content {
Â  Â  transform: scale(1);
}
.streak-modal-icon {
Â  Â  font-size: 4rem;
Â  Â  line-height: 1;
Â  Â  margin-bottom: 1rem;
}
.streak-modal-close {
Â  Â  position: absolute;
Â  Â  top: 0.5rem;
Â  Â  right: 1rem;
Â  Â  font-size: 1.75rem;
Â  Â  font-weight: bold;
Â  Â  color: var(--thelo-text-light);
Â  Â  cursor: pointer;
}
#streakModalConfirmBtn {
Â  Â  margin-top: 1.5rem;
Â  Â  background-color: var(--accent-yellow);
}

@keyframes pulse-glow {
Â  Â  0% {
Â  Â  Â  Â  box-shadow: 0 0 5px rgba(37, 99, 235, 0.2), 0 0 7px rgba(37, 99, 235, 0.1);
Â  Â  }
Â  Â  50% {
Â  Â  Â  Â  box-shadow: 0 0 15px rgba(37, 99, 235, 0.4), 0 0 25px rgba(37, 99, 235, 0.3);
Â  Â  }
Â  Â  100% {
Â  Â  Â  Â  box-shadow: 0 0 5px rgba(37, 99, 235, 0.2), 0 0 7px rgba(37, 99, 235, 0.1);
Â  Â  }
}

Â /* ===== ADD THESE STYLES: For Image Terminal & Terminals ===== */
Â #chat,
Â #image-terminal {
Â  Â  flex: 1;
Â  Â  transition: opacity 0.3s ease-in-out;
Â  Â  overflow: hidden;
Â  Â  overflow-y: auto; /* Allow scrolling for chat */
Â }
Â #image-terminal {
Â  Â  display: none; /* Start hidden */
Â  Â  flex-direction: column;
Â  Â  justify-content: flex-start;
Â  Â  padding-top: 1rem;
Â  Â  overflow: hidden; /* No scrollbar needed for image view */
Â }
Â #image-terminal-img-container img {
Â  Â  max-width: 100%;
Â  Â  border-radius: 0.75rem;
Â  Â  box-shadow: var(--shadow-md);
Â }
Â #image-terminal-feedback {
Â  Â  text-align: center;
Â  Â  padding: 1.5rem 1rem;
Â  Â  font-size: 1rem;
Â  Â  font-weight: 500;
Â  Â  opacity: 0;
Â  Â  transition: opacity 0.3s ease-in-out;
Â }
Â .terminal-hidden {
Â  Â  opacity: 0 !important;
Â  Â  display: none !important;
Â }

Â /* ===== ADD THESE STYLES: For Smarter MCQ Layouts ===== */
#mcqOptionsContainer.long-options {
Â  Â  flex-direction: column;
Â  Â  /* CHANGE: Center the shrink-to-fit buttons instead of stretching them. */
Â  Â  align-items: center;
Â  Â  width: fit-content;
Â  Â  max-width: 92%;
Â  Â  left: 50%;
Â  Â  transform: translate(-50%, -50%);
}
Â #mcqOptionsContainer.short-options {
Â  Â  flex-direction: row;
Â  Â  flex-wrap: wrap;
Â  Â  align-items: center;
Â  Â  width: fit-content;
Â  Â  max-width: 92%;
Â  Â  left: 50%;
Â  Â  transform: translate(-50%, -50%);
}


Â #mcqOptionsContainer.short-options .mcq-option-btn {
Â  Â  padding: 1.2rem;
Â  Â  font-size: 1rem;
Â  Â  /* REMOVE (optional): This line prevents buttons from being very small. */
Â  Â  /* min-width: 80px; */
Â  Â  text-align: center;
}
Â /* ===== Thelobook & Grid View ===== */
Â #thelobookControls,
Â #thelobookPageGridHeader,
Â #closePageGridBtn {
Â  Â  backdrop-filter: blur(10px);
Â  Â  -webkit-backdrop-filter: blur(10px);
Â  Â  background-color: rgba(255, 255, 255, 0.7);
Â  Â  border-radius: 9999px; /* pill shape */
Â  Â  box-shadow: var(--shadow-md);
Â  Â  border: 1px solid var(--thelo-border);
Â }
Â #thelobookControls {
Â  Â  position: absolute;
Â  Â  bottom: 2rem;
Â  Â  left: 50%;
Â  Â  transform: translateX(-50%);
Â  Â  z-index: 25;
Â  Â  padding: 0.5rem;
Â  Â  display: flex;
Â  Â  align-items: center;
Â  Â  gap: 0.5rem;
Â  Â  opacity: 0;
Â  Â  visibility: hidden;
Â  Â  transition: opacity 0.2s, visibility 0.2s;
Â }
Â #thelobookControls.visible {
Â  Â  opacity: 1;
Â  Â  visibility: visible;
Â }
Â #thelobookControls button {
Â  Â  background: transparent;
Â  Â  border: none;
Â  Â  font-size: 1.25rem;
Â  Â  width: 40px;
Â  Â  height: 40px;
Â  Â  border-radius: 50%;
Â  Â  display: flex;
Â  Â  align-items: center;
Â  Â  justify-content: center;
Â  Â  cursor: pointer;
Â  Â  transition: background-color 0.2s;
Â }
Â #thelobookControls button:hover:not(:disabled) {
Â  Â  background-color: rgba(0, 0, 0, 0.05);
Â }
Â #thelobookControls button.active {
Â  Â  background-color: var(--thelo-blue);
Â  Â  color: white;
Â }

Â #thelobookPageGridView {
Â  Â  position: absolute;
Â  Â  top: 0;
Â  Â  left: 0;
Â  Â  width: 100%;
Â  Â  height: 100%;
Â  Â  z-index: 40;
Â  Â  display: flex;
Â  Â  flex-direction: column;
Â  Â  padding: 2rem 1rem 1rem;
Â  Â  box-sizing: border-box;
Â  Â  opacity: 0;
Â  Â  visibility: hidden;
Â  Â  transform: scale(0.95);
Â  Â  transition: opacity var(--animation-duration) ease, visibility 0s linear var(--animation-duration),
Â  Â  Â  transform var(--animation-duration) ease;
Â }
Â #thelobookPageGridView.visible {
Â  Â  opacity: 1;
Â  Â  visibility: visible;
Â  Â  transform: scale(1);
Â  Â  transition-delay: 0s;
Â }

Â #thelobookPageGridHeader {
Â  Â  display: flex;
Â  Â  justify-content: space-between;
Â  Â  align-items: center;
Â  Â  margin-bottom: 1rem;
Â  Â  padding: 0.5rem 1.5rem;
Â  Â  max-width: fit-content;
Â  Â  align-self: center;
Â  Â  gap: 1rem;
Â }

Â #pageGridBatchIndicator {
Â  Â  white-space: nowrap;
Â }

Â #thelobookPageGridContentContainer {
Â  Â  flex-grow: 1;
Â  Â  display: flex;
Â  Â  flex-wrap: wrap;
Â  Â  justify-content: center;
Â  Â  align-content: flex-start;
Â  Â  gap: 1rem;
Â  Â  padding: 0.5rem;
Â  Â  overflow-y: auto;
Â  Â  max-height: calc(100vh - 150px);
Â }

Â .chat-image-container {
Â  Â  padding: 0.5rem;
Â  Â  background-color: transparent;
Â  Â  border: none;
Â  Â  box-shadow: none;
Â }

Â .chat-image {
Â  Â  max-width: 100%;
Â  Â  border-radius: 0.75rem;
Â  Â  display: block;
Â  Â  box-shadow: var(--shadow-md);
Â }
Â .page-thumbnail {
Â  Â  border: 1px solid var(--thelo-border);
Â  Â  box-shadow: var(--shadow-sm);
Â  Â  border-radius: 0.5rem;
Â }
Â .page-thumbnail:hover {
Â  Â  transform: translateY(-2px);
Â  Â  box-shadow: var(--shadow-md);
Â }
Â #closePageGridBtn {
Â  Â  border-radius: 50%;
Â  Â  width: 36px;
Â  Â  height: 36px;
Â  Â  font-size: 1.1rem;
Â  Â  display: flex;
Â  Â  align-items: center;
Â  Â  justify-content: center;
Â  Â  flex-shrink: 0;
Â }

Â .page-grid-batch {
Â  Â  display: flex;
Â  Â  flex-wrap: wrap;
Â  Â  justify-content: center;
Â  Â  gap: 1rem;
Â  Â  width: 100%;
Â  Â  transition: none;
Â }

Â @keyframes pageGridFadeIn {
Â  Â  from {
Â  Â  Â  opacity: 0;
Â  Â  Â  transform: scale(0.95);
Â  Â  }
Â  Â  to {
Â  Â  Â  opacity: 1;
Â  Â  Â  transform: scale(1);
Â  Â  }
Â }

Â #thelobookPageGridView.visible {
Â  Â  animation: pageGridFadeIn var(--animation-duration) ease forwards;
Â }

Â #thelobookPageGridContentContainer:empty::before {
Â  Â  content: 'No pages to display. Click "+" to add a new page.';
Â  Â  color: var(--thelo-text-light);
Â  Â  font-size: 1rem;
Â  Â  text-align: center;
Â  Â  margin-top: 2rem;
Â }

Â /* Responsive adjustments */
Â @media (max-width: 768px) {
Â  Â  #app {
Â  Â  Â  flex-direction: column-reverse;
Â  Â  }
	 /* Inside your @media (max-width: 768px) rule... */

Â  Â  #chatCol {
Â  Â  Â  width: 100%;
Â  Â  Â  height: 30vh;
Â  Â  Â  border-left: none;
Â  Â  Â  border-top: 1px solid var(--thelo-border);
Â  Â  }
Â  Â  #bottomBar {
Â  Â  Â  flex-wrap: wrap;
Â  Â  Â  justify-content: center;
Â  Â  }
Â  Â  #actionButtons {
Â  Â  Â  width: 100%;
Â  Â  Â  justify-content: center;
Â  Â  Â  order: 3;
Â  Â  }
Â  Â  #pointsDisplay,
Â  Â  #colorIndicator {
Â  Â  Â  order: 1;
Â  Â  Â  margin-bottom: 0.5rem;
Â  Â  }
Â  Â  .control-btn {
Â  Â  Â  padding: 0.6rem 0.8rem;
Â  Â  Â  font-size: 0.8rem;
Â  Â  }
Â  Â  #stageProgressBarContainer {
Â  Â  Â  top: 0;
Â  Â  Â  height: 2px;
Â  Â  }
Â }

Â /* By default, hide the calculator button in the bottom bar */
Â #openCalculatorBtn {
Â  Â  Â display: none;
Â  Â  Â background-color: var(--thelo-blue); /* Give it the standard blue color */
Â }
Â 
Â #openCalculatorBtn:hover:not(:disabled) {
Â  Â  Â background-color: var(--thelo-blue-dark); /* Add the standard hover effect */
Â }

Â /* ===== NEW: Tablet Immersive Mode ===== */
Â @media (min-width: 769px) and (max-width: 1200px) and (pointer: coarse) {
Â  Â  #openCalculatorBtn {
Â  Â  Â  Â  display: inline-flex;
Â  Â  }
Â  Â  /* (pointer: coarse) is key for detecting touch-first devices like tablets */
	/* ===== ENHANCEMENT: Prevent Palm Selection on Canvas ===== */
Â  Â  #boardWrap {
Â  Â  Â  Â  /* Prevents the user from being able to select the canvas */
Â  Â  Â  Â  -webkit-user-select: none; /* Safari */
Â  Â  Â  Â  -moz-user-select: none;Â  Â  /* Firefox */
Â  Â  Â  Â  -ms-user-select: none;Â  Â  Â /* IE */
Â  Â  Â  Â  user-select: none;

Â  Â  Â  Â  /* Disables the menu (copy/paste) that appears on long-press in Safari */
Â  Â  Â  Â  -webkit-touch-callout: none;
Â  Â  }

Â  Â  #app {
Â  Â  Â  Â  /* Keep the flex layout but hide the chat column */
Â  Â  Â  Â  flex-direction: row;
Â  Â  }

Â  Â  #chatCol {
Â  Â  Â  Â  /* Completely hide the terminal */
Â  Â  Â  Â  display: none !important;
Â  Â  }

Â  Â  #lessonArea {
Â  Â  Â  Â  /* Make the whiteboard take up the full screen width */
Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  flex-basis: 100%;
Â  Â  Â  Â  border-left: none; /* Remove border that separated it from the chat */
Â  Â  }
}
Â /* ===== NEW: Toast Notification System for Tablets ===== */
#toast-container {
Â  Â  position: fixed;
Â  Â  bottom: 20px;
Â  Â  left: 50%;
Â  Â  transform: translateX(-50%);
Â  Â  z-index: 1000;
Â  Â  display: flex;
Â  Â  flex-direction: column-reverse;
Â  Â  align-items: center;
Â  Â  gap: 10px;
Â  Â  width: clamp(300px, 80%, 600px);
Â  Â  pointer-events: none;
}

.toast-message {
Â  Â  font-family: 'Manrope', system-ui, -apple-system, sans-serif;
Â  Â  font-size: 1rem;
Â  Â  font-weight: 500;
Â  Â  color: var(--thelo-text);
Â  Â  background-color: rgba(255, 255, 255, 0.85);
Â  Â  backdrop-filter: blur(10px);
Â  Â  -webkit-backdrop-filter: blur(10px);
Â  Â  padding: 12px 20px;
Â  Â  border-radius: 12px;
Â  Â  box-shadow: var(--shadow-lg);
Â  Â  border: 1px solid rgba(0,0,0,0.05);
Â  Â  display: flex;
Â  Â  align-items: center;
Â  Â  gap: 12px;
Â  Â  pointer-events: all;
Â  Â  cursor: pointer;
Â  Â  overflow: hidden;
Â  Â  max-height: 100px;
Â  Â  margin-top: 10px;
Â  Â  opacity: 0;
Â  Â  transition: max-height 0.3s ease-in-out, opacity 0.3s ease-in-out, margin-top 0.3s ease-in-out, padding 0.3s ease-in-out;
}

.toast-message.show {
Â  Â  animation: toast-in 0.5s cubic-bezier(0.21, 1.02, 0.73, 1) forwards;
}

.toast-message.exiting {
Â  Â  max-height: 0;
Â  Â  opacity: 0;
Â  Â  padding-top: 0;
Â  Â  padding-bottom: 0;
Â  Â  margin-top: 0;
}

@keyframes toast-in {
Â  Â  from {
Â  Â  Â  Â  opacity: 0;
Â  Â  Â  Â  transform: translateY(25px) scale(0.9);
Â  Â  }
Â  Â  to {
Â  Â  Â  Â  opacity: 1;
Â  Â  Â  Â  transform: translateY(0) scale(1);
Â  Â  }
}

.toast-message .emoji {
Â  Â  font-size: 1.5rem;
}

.toast-message.toast-success,
.toast-message.toast-error,
.toast-message.toast-warning {
Â  Â  background-color: rgba(255, 255, 255, 0.6);
Â  Â  color: var(--thelo-text);
}

/* You might also want a rule for landscape tablets without the pointer check */
@media (min-width: 769px) and (max-width: 1200px) and (min-height: 500px) {
Â  Â  #openCalculatorBtn {
Â  Â  Â  Â  display: inline-flex;
Â  Â  }
Â  Â #chatCol {
Â  Â  Â  Â  display: none !important;
Â  Â  }

Â  Â  #lessonArea {
Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  flex-basis: 100%;
Â  Â  Â  Â  border-left: none;
Â  Â  }
}
/* >>> add once, after the existing #mcqOptionsContainer rules <<< */
#mcqOptionsContainer.side-by-side {
Â  Â  position: absolute;
Â  Â  top: 50%;
Â  Â  right: 4%;
Â  Â  left: auto !important;
Â  Â  transform: translateY(-50%);
Â  Â  display: flex;
Â  Â  flex-direction: column;
Â  Â  gap: 1rem;
Â  Â  width: 38vw;
Â  Â  max-width: 420px;
}

/* make the buttons grow full width of the column */
#mcqOptionsContainer.side-by-side .mcq-option-btn{ /* CORRECTED HYPHEN */
Â  Â  flex:0 0 auto;
Â  Â  width:100%;
}
/* REPLACE the old #calculatorOverlay and #calculatorFrame rules with these */

#calculatorOverlay {
Â  Â  position: absolute;
Â  Â  top: 0;
Â  Â  left: 0;
Â  Â  width: 100%;
Â  Â  height: 100%;
Â  Â  z-index: 50;
Â  Â  display: flex;
Â  Â  align-items: center;
Â  Â  justify-content: center;
Â  Â  backdrop-filter: blur(12px);
Â  Â  -webkit-backdrop-filter: blur(12px);
Â  Â  background-color: rgba(255, 255, 255, 0.5); /* Soft white background */
Â  Â  opacity: 0;
Â  Â  visibility: hidden;
Â  Â  transition: opacity 0.3s ease, visibility 0s linear 0.3s;
}

#calculatorFrame {
Â  Â  width: 98%;
Â  Â  height: 98%;
Â  Â  border: none;
Â  Â  border-radius: 1rem;
Â  Â  box-shadow: var(--shadow-lg);
}
/* ADD THIS NEW RULE */
.terminal-hidden-by-calculator {
Â  Â  display: none !important;
}

#calculatorOverlay:not(.calculator-hidden) {
Â  Â  opacity: 1;
Â  Â  visibility: visible;
Â  Â  transition-delay: 0s;
}


#calculatorCloseBtn {
Â  Â  position: absolute;
Â  Â  top: 2rem;
Â  Â  right: 2rem;
Â  Â  width: 40px;
Â  Â  height: 40px;
Â  Â  border-radius: 50%;
Â  Â  border: none;
Â  Â  background-color: rgba(255, 255, 255, 0.7);
Â  Â  backdrop-filter: blur(10px);
Â  Â  -webkit-backdrop-filter: blur(10px);
Â  Â  font-size: 1.2rem;
Â  Â  cursor: pointer;
Â  Â  box-shadow: var(--shadow-md);
Â  Â  display: flex;
Â  Â  align-items: center;
Â  Â  justify-content: center;
}
	/* ===== NEW: Embedded Replay Player Styles ===== */

#replayPlayerContainer {
Â  Â  position: absolute;
Â  Â  top: 0;
Â  Â  left: 0;
Â  Â  width: 100%;
Â  Â  height: 100%;
Â  Â  z-index: 5; /* Below UI controls, but above canvases */
Â  Â  display: flex;
Â  Â  align-items: center;
Â  Â  justify-content: center;
Â  Â  padding-top: 70px;
Â  Â  box-sizing: border-box;
Â  Â  opacity: 0;
Â  Â  visibility: hidden;
Â  Â  transform: scale(0.95);
Â  Â  transition: opacity 0.3s ease, visibility 0s linear 0.3s, transform 0.3s ease;
}

#replayPlayerContainer:not(.replay-hidden) {
Â  Â  opacity: 1;
Â  Â  visibility: visible;
Â  Â  transform: scale(1);
Â  Â  transition-delay: 0s;
}

#replayFrame {
Â  Â  width: 90%;
Â  Â  height: 80%;
Â  Â  max-width: 1200px;
Â  Â  max-height: 700px;
Â  Â  border: 1px solid rgba(0, 0, 0, 0.05);
Â  Â  border-radius: 1rem;
Â  Â  box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.07);
Â  Â  background-color: var(--thelo-bg);
}
	/* Add near your other .mcq-option-btn rules */
.mcq-option-btn.selected {
Â  Â  border-color: var(--thelo-blue);
Â  Â  background-color: #eff6ff; /* A light blue background */
Â  Â  color: var(--thelo-blue);
Â  Â  border-width: 2px;
Â  Â  transform: translateY(-3px);
Â  Â  box-shadow: var(--shadow-lg);
}
Â  .mcq-option-btn .katex { vertical-align: middle; }
/* ===== NEW: Drawing Minimap ===== */
#minimapContainer {
Â  Â  position: absolute;
Â  Â  bottom: 1.5rem;
Â  Â  right: 1.5rem;
Â  Â  width: 220px;
Â  Â  height: 165px;
Â  Â  background-color: rgba(255, 255, 255, 0.95);
Â  Â  border: 1px solid var(--thelo-border);
Â  Â  border-radius: 0.75rem;
Â  Â  box-shadow: var(--shadow-lg);
Â  Â  z-index: 10;
Â  Â  overflow: hidden;
Â  Â  /* Animation styles */
Â  Â  transition: opacity 0.3s ease, transform 0.3s ease;
Â  Â  transform: scale(0.95) translateY(10px);
Â  Â  opacity: 0;
Â  Â  pointer-events: none; /* Don't let it block clicks */
}

/* This class will be toggled by JS to show the minimap */
#minimapContainer:not(.minimap-hidden) {
Â  Â  transform: scale(1) translateY(0);
Â  Â  opacity: 1;
}

#minimapCanvas {
Â  Â  width: 100%;
Â  Â  height: 100%;
Â  Â  display: block;
}
	/* ===== NEW: Animated Feedback System ===== */
#feedbackOverlay {
Â  Â  position: fixed;
Â  Â  top: 0;
Â  Â  left: 0;
Â  Â  width: 100%;
Â  Â  height: 100%;
Â  Â  z-index: 10000;
Â  Â  display: flex;
Â  Â  align-items: center;
Â  Â  justify-content: center;
Â  Â  pointer-events: none; /* Allows clicks to go through to the canvas below */
Â  Â  transition: opacity 0.4s ease;
}

#feedbackOverlay.feedback-hidden {
Â  Â  opacity: 0;
}

#feedbackBox {
Â  Â  background-color: rgba(255, 255, 255, 0.9);
Â  Â  backdrop-filter: blur(15px);
Â  Â  -webkit-backdrop-filter: blur(15px);
Â  Â  color: var(--thelo-text);
Â  Â  padding: 2rem 3rem;
Â  Â  border-radius: 1.5rem;
Â  Â  text-align: center;
Â  Â  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
Â  Â  border: 1px solid rgba(0, 0, 0, 0.05);
Â  Â  max-width: 80%;
Â  Â  transform: scale(0.8);
Â  Â  opacity: 0;
Â  Â  transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.3s ease;
}

/* This is the state when the feedback is visible, triggering the animation */
#feedbackOverlay:not(.feedback-hidden) #feedbackBox {
Â  Â  transform: scale(1);
Â  Â  opacity: 1;
}

#feedbackEmoji {
Â  Â  font-size: 4rem;
Â  Â  line-height: 1;
Â  Â  display: block;
Â  Â  margin-bottom: 1rem;
}

#feedbackText {
Â  Â  font-size: 1.5rem;
Â  Â  font-weight: 500;
Â  Â  line-height: 1.5;
Â  Â  margin: 0;
}

#feedbackText strong {
Â  Â  color: var(--thelo-blue);
Â  Â  font-weight: 700;
}
	#feedbackOverlay:not(.feedback-hidden){
Â  Â  opacity:1; visibility:visible;
}
/* hide cursor when a stylus is down */
.no-cursor {
Â  Â  cursor: none !important;
}
.control-btn { touch-action: manipulation; }
/* ===== NEW: Fixed Bottom Logo ===== */
#bottom-logo-container {
Â  position: fixed;
Â  bottom: 1rem; /* Adjust vertical spacing from the bottom */
Â  left: 50%;
Â  transform: translateX(-50%);
Â  z-index: 10000; /* Ensures it's above the canvas but below modals */
Â  pointer-events: none; /* Allows clicks to pass through to elements underneath */
}

#bottom-logo-container img {
Â  display: block;
Â  height: 35px; /* Adjust the logo size as needed */
Â  width: auto; /* Makes the logo subtle and less distracting */
}
	html, body {
Â  cursor: none !important;
}
	/* ===== NEW: On-Canvas Feedback ===== */
#feedbackCanvas {
Â  Â  position: absolute;
Â  Â  top: 0;
Â  Â  left: 0;
Â  Â  width: 100%;
Â  Â  height: 100%;
Â  Â  z-index: 5; /* Above the drawing board, below UI controls */
Â  Â  pointer-events: none; /* Allows drawing to pass through */
}
	/* Force Armenian font on buttons when the language is not English */
/* Force Armenian font on all key UI text elements when the language is not English */
body:not(.lang-en) .control-btn,
body:not(.lang-en) .mcq-option-btn,
body:not(.lang-en) #pointsDisplay,
body:not(.lang-en) #colorIndicator {
Â  Â  font-family: 'Montserrat Arm', sans-serif !important;
Â  Â  font-weight: 600 !important; /* SemiBold weight for UI elements */
}
Â  /* ===== NEW: MCQ Keyboard-Only Mode ===== */
body.mcq-active {
Â  Â  cursor: none; /* Hide the system cursor */
}

body.mcq-active .mcq-option-btn {
Â  Â  pointer-events: none; /* Disable all mouse/touch interactions on the buttons */
}

/* This makes the selected option more prominent without a cursor */
body.mcq-active .mcq-option-btn.selected {
Â  Â  border-color: var(--thelo-blue);
Â  Â  background-color: #dbeafe; /* A darker blue to show focus */
Â  Â  color: #1e40af;
Â  Â  transform: scale(1.05); /* Make it pop a bit */
Â  Â  box-shadow: var(--shadow-lg);
}
</style>
</head>
<body>
Â  Â  <div id="loading-overlay">
Â  Â  </div>
Â  Â  <div id="app">
Â  Â  Â  Â  <div id="lessonArea">
Â  Â  Â  Â  Â  Â  <div id="boardWrap">
Â  Â  Â  Â  Â  Â  Â  Â  <div id="stageProgressBarContainer"><div id="stageProgressFill"></div></div>
Â  Â  Â  Â  Â  Â  Â  Â  <canvas id="backgroundCanvas"></canvas>
Â  Â  Â  Â  Â  Â  Â  Â  <canvas id="replayCanvas"></canvas>
Â  Â  Â  Â  Â  Â  Â  Â  <canvas id="board"></canvas>
Â  Â  Â  Â  Â  Â  Â  Â  <canvas id="feedbackCanvas"></canvas>
		Â  Â  <canvas id="boardCapture" style="display:none"></canvas>
Â  Â  Â  Â  Â  Â  Â  Â  <canvas id="thelobookCanvas"></canvas>
		<div id="calculatorOverlay" class="calculator-hidden">
Â  Â  Â  Â  Â  Â  Â  Â  <iframe id="calculatorFrame" src="about:blank" allow="clipboard-write"></iframe>
Â  Â  Â  Â  Â  Â  Â  Â  <button id="calculatorCloseBtn" title="Close Calculator">âœ•</button>
Â  Â  Â  Â  Â  Â  </div>
		Â  Â  <div id="replayPlayerContainer" class="replay-hidden">
			<iframe id="replayFrame" src="about:blank"></iframe>
		</div>
Â  Â  Â  Â  Â  Â  Â  Â  <div id="thelobookControls">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button id="thelobookPrevPageBtn" title="Previous Page">â€¹</button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <span id="thelobookPageIndicator">Page 1 / 1</span>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button id="thelobookNextPageBtn" title="Next Page">â€º</button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button id="thelobookEraserBtn" title="Eraser">âœï¸</button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button id="thelobookAddPageBtn" title="Add New Page">+</button>
Â  Â  Â  Â  Â  Â  Â  Â  </div>

Â  Â  Â  Â  Â  Â  Â  Â  <div id="thelobookPageGridView">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div id="thelobookPageGridHeader">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <span id="pageGridBatchIndicator">Pages 1-32</span>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button id="closePageGridBtn" title="Close Grid">âœ•</button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div id="thelobookPageGridContentContainer">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  </div>
		Â  Â  <div id="minimapContainer" class="minimap-hidden">
Â  Â  <canvas id="minimapCanvas"></canvas>
</div>

Â  Â  Â  Â  Â  Â  Â  Â  <div id="mcqOptionsContainer" style="display: none;"></div>
Â  Â  Â  Â  Â  Â  </div>

Â  Â  Â  Â  Â  Â  <div id="bottomBar">
Â  Â  Â  Â  Â  Â  Â  Â  <div id="colorIndicator"></div>
Â  Â  Â  Â  Â  Â  Â  Â  <div id="pointsDisplay"></div>
Â  Â  Â  Â  Â  Â  Â  Â  <div id="actionButtons">
Â  Â  <button id="prevBtn" class="control-btn"></button>
Â  Â  <button id="openCalculatorBtn" class="control-btn" title="Open Calculator">Graph</button>
Â  Â  <button id="thelobookBtn" class="control-btn"></button>
Â  Â Â 
Â  Â  <button id="clearBtn" class="control-btn"></button>
Â  Â  <button id="nextCheckBtn" class="control-btn"></button>
Â  Â  <button id="dashboardBtn" class="control-btn" style="display: none;"></button>
</div>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>
Â  Â  Â  Â Â 
Â  Â  </div>
Â  Â  <div id="toast-container"></div>
Â  Â  <div id="audioContainer" style="display: none;">
Â  Â  Â  Â  <audio id="audio_approve1_hy" src="https://pha.am/audios/approve1.ogg" preload="auto"></audio>
Â  Â  Â  Â  <audio id="audio_approve2_hy" src="https://pha.am/audios/approve2.ogg" preload="auto"></audio>
Â  Â  Â  Â  <audio id="audio_dis1_hy" src="https://pha.am/audios/dis1.ogg" preload="auto"></audio>
Â  Â  Â  Â  <audio id="audio_dis2_hy" src="https://pha.am/audios/dis2.ogg" preload="auto"></audio>
Â  Â  Â  Â  <audio id="audio_approve1_en" src="https://thelo.space/audio/engcorr1.mp3" preload="auto"></audio>
Â  Â  Â  Â  <audio id="audio_approve2_en" src="https://thelo.space/audio/engcorr2.mp3" preload="auto"></audio>
Â  Â  Â  Â  <audio id="audio_dis1_en" src="https://thelo.space/audio/engwrong1.mp3" preload="auto"></audio>
Â  Â  Â  Â  <audio id="audio_dis2_en" src="https://thelo.space/audio/engwrong2.mp3" preload="auto"></audio>
Â  Â  Â  Â  <audio id="stageAudioPlayer"></audio>
Â  Â  Â  Â  <audio id="gotItSound" src="https://thelo.space/audio/corr.mp3" preload="auto"></audio>
Â  Â  </div>
	<div id="streakModal" class="modal-hidden">
Â  Â  <div class="streak-modal-content">
Â  Â  Â  Â  <span id="streakModalCloseBtn" class="streak-modal-close">&times;</span>
Â  Â  Â  Â  <div class="streak-modal-icon">ğŸ”¥</div>
Â  Â  Â  Â  <h2 id="streakModalTitle"></h2>
Â  Â  Â  Â  <p id="streakModalBody"></p>
Â  Â  Â  Â  <button id="streakModalConfirmBtn" class="control-btn">Awesome!</button>
Â  Â  </div>
		
</div>
	<div id="feedbackOverlay" class="feedback-hidden">
Â  Â  <div id="feedbackBox">
Â  Â  Â  Â  <span id="feedbackEmoji"></span>
Â  Â  Â  Â  <p id="feedbackText"></p>
Â  Â  </div>
</div>
	<div id="bottom-logo-container">
Â  Â  <img src="https://thelo.space/img/bluethelo.svg" alt="Thelo Logo">
</div>
</body>
Â  <script>
Â  Â  const firebaseConfig = { apiKey: "AIzaSyAbnPpcIt88B0jIAoLUdC71zmQDvR_fdu8", authDomain: "physmathacademy-722b3.firebaseapp.com", databaseURL: "https://physmathacademy-722b3-default-rtdb.firebaseio.com", projectId: "physmathacademy-722b3", storageBucket: "physmathacademy-722b3.appspot.com", messagingSenderId: "1093640992262", appId: "1:1093640992262:web:35b1bf4d2364bcf745f587" };
Â  Â  firebase.initializeApp(firebaseConfig);


Â  Â  const auth = firebase.auth();
Â  Â  const db = firebase.firestore();

Â  Â  // =================================================================
Â  Â  //Â  NEW FIX: Set auth persistence to 'session' to work around
Â  Â  //Â  potential browser storage restrictions.
Â  Â  // =================================================================
Â  Â  auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL)
Â  Â  Â  Â  .catch((error) => {
Â  Â  Â  Â  Â  Â  console.error("Auth persistence error:", error.code, error.message);
Â  Â  Â  Â  });
Â  Â  getKatexCSSWithEmbeddedFonts().catch(()=>{});
ensureHeadlineFontsLoaded().catch(()=>{});
Â  Â  const INK_COLORS = { black: '#000000', blue: getComputedStyle(document.documentElement).getPropertyValue('--ink-blue').trim() || '#2563eb' };

Â  Â  const UI_TEXT = {
Â  Â  Â  Â  hy: {
Â  Â  Â  Â  Â  Â  next: "Õ€Õ¡Õ»Õ¸Ö€Õ¤Õ¨", gotIt: "Õ€Õ¡Õ½Õ¯Õ¡ÖÕ¡!", check: "ÕÕ¿Õ¸Ö‚Õ£Õ¥Õ¬", checking: "ÕÕ¿Õ¸Ö‚Õ£Õ¾Õ¸Ö‚Õ´ Õ§...",
Â  Â  Â  Â  Â  Â  correct: "ÕƒÕ«Õ·Õ¿ Õ§Ö‰", incorrect: "ÕÕ­Õ¡Õ¬ Õ§", apiKeyInvalid: "API Õ¢Õ¡Õ¶Õ¡Õ¬Õ«Õ¶ Õ¡Õ¶Õ¾Õ¡Õ¾Õ¥Ö€ Õ§",
Â  Â  Â  Â  Â  Â  inkBlack: "Ô³Õ¸Ö‚ÕµÕ¶Õ ÕÖ‡", inkBlue: "Ô³Õ¸Ö‚ÕµÕ¶Õ Ô¿Õ¡ÕºÕ¸Ö‚ÕµÕ¿", loading: "Ô²Õ¥Õ¼Õ¶Õ¾Õ¸Ö‚Õ´ Õ§...",
Â  Â  Â  Â  Â  Â  clear: "Õ„Õ¡Ö„Ö€Õ¥Õ¬", start: "ÕÕ¯Õ½Õ¥Õ¬", prev: "Õ†Õ¡Õ­Õ¸Ö€Õ¤",
Â  Â  Â  Â  Â  Â  welcome: "ÕˆÕ²Õ»Õ¸Ö‚Õ›ÕµÕ¶Ö‰ ÕÕ¥Õ²Õ´Õ«Ö€ ÕÕ¯Õ½Õ¥Õ¬ Õ¤Õ¡Õ½Õ¨ Õ½Õ¯Õ½Õ¥Õ¬Õ¸Ö‚ Õ°Õ¡Õ´Õ¡Ö€Ö‰",
Â  Â  Â  Â  Â  Â  checkingAI: `ÕÕ¿Õ¸Ö‚Õ£Õ¸Ö‚Õ´ Õ¥Õ´ Ö„Õ¸ <strong style="color:${INK_COLORS.blue};">Õ¯Õ¡ÕºÕ¸Ö‚ÕµÕ¿Õ¸Õ¾</strong> Õ£Ö€Õ¾Õ¡Õ® ÕºÕ¡Õ¿Õ¡Õ½Õ­Õ¡Õ¶Õ¨...`,
Â  Â  Â  Â  Â  Â  blankBlueWarning: `âš ï¸ Ô¿Õ¡Ö€Õ®Õ¥Õ½ Õ©Õ¥ ÕºÕ¡Õ¿Õ¡Õ½Õ­Õ¡Õ¶Õ¨ <strong style="color:${INK_COLORS.blue};">Õ¯Õ¡ÕºÕ¸Ö‚ÕµÕ¿Õ¸Õ¾</strong> Õ¹Õ¥Õ½ Õ¶Õ·Õ¥Õ¬Ö‰ ÕÕ¥Õ²Õ´Õ«Ö€ 'A' Õ½Õ¿Õ¥Õ²Õ¶Õ¨ Õ£Õ¸Ö‚ÕµÕ¶Õ¨ ÖƒÕ¸Õ­Õ¥Õ¬Õ¸Ö‚ Õ°Õ¡Õ´Õ¡Ö€Ö‰`,
Â  Â  Â  Â  Â  Â  noTextFound: `âš ï¸ <strong style="color:${INK_COLORS.blue};">Ô¿Õ¡ÕºÕ¸Ö‚ÕµÕ¿Õ¸Õ¾</strong> Õ£Ö€Õ¾Õ¡Õ®Õ«Ö Õ¿Õ¥Ö„Õ½Õ¿ Õ¹Õ£Õ¿Õ¶Õ¾Õ¥ÖÖ‰ Õ“Õ¸Ö€Õ±Õ«Ö€ Õ£Ö€Õ¥Õ¬ Õ¡Õ¾Õ¥Õ¬Õ« ÕºÕ¡Ö€Õ¦Ö‰`,
Â  Â  Â  Â  Â  Â  noDigitsFound: `âš ï¸ Ô¿Õ¡Ö€Õ®Õ¥Õ½ Õ©Õ¥ <strong style="color:${INK_COLORS.blue};">Õ¯Õ¡ÕºÕ¸Ö‚ÕµÕ¿Õ¸Õ¾</strong> Õ©Õ«v Õ¹Õ¥Ö„ Õ£Ö€Õ¥Õ¬Ö‰ (ÕƒÕ¡Õ¶Õ¡Õ¹Õ¾Õ¡Õ® Õ¿Õ¥Ö„Õ½Õ¿Õ {detectedText})`,
Â  Â  Â  Â  Â  Â  correctAI: `ğŸ‰ ÕƒÕ«Õ·Õ¿ Õ§ Google Vision-Õ« Õ¯Õ¡Ö€Õ®Õ«Ö„Õ¸Õ¾Ö‰ (Ô´Õ¸Ö‚Ö„ Õ£Ö€Õ¥Õ¬ Õ§Õ«Ö„ <strong>{detectedAnswer}</strong>)`,
Â  Â  Â  Â  Â  Â  incorrectAI: `ğŸ¤” ÕÕ­Õ¡Õ¬ Õ§Ö‰ Google Vision-Õ¨ <strong style="color:${INK_COLORS.blue};">Õ¯Õ¡ÕºÕ¸Ö‚ÕµÕ¿</strong> Õ£Ö€Õ¾Õ¡Õ®Ö„Õ«Ö Õ¯Õ¡Ö€Õ¤Õ¡Ö <strong>{detectedAnswer}</strong>, Õ¢Õ¡ÕµÖ Õ³Õ«Õ·Õ¿ ÕºÕ¡Õ¿Õ¡Õ½Õ­Õ¡Õ¶Õ¶ Õ§ <strong>{correctAnswer}</strong>Ö‰ Õ“Õ¸Ö€Õ±Õ«Ö€ Õ¯Ö€Õ¯Õ«Õ¶Ö‰`,
Â  Â  Â  Â  Â  Â  parsingError: `âš ï¸ Õ‰Õ¯Õ¡Ö€Õ¸Õ²Õ¡ÖÕ¡ <strong style="color:${INK_COLORS.blue};">Õ¯Õ¡ÕºÕ¸Ö‚ÕµÕ¿</strong> Õ£Ö€Õ¾Õ¡Õ®Ö„Õ«Ö Õ©Õ«Õ¾Õ¨ Õ³Õ¡Õ¶Õ¡Õ¹Õ¥Õ¬Ö‰ (ÕƒÕ¡Õ¶Õ¡Õ¹Õ¾Õ¡Õ® Õ¿Õ¥Ö„Õ½Õ¿Õ {detectedText})`,
Â  Â  Â  Â  Â  Â  imageDataError: `âŒ ÕÕ­Õ¡Õ¬Õ Õ¹Õ°Õ¡Õ»Õ¸Õ²Õ¾Õ¥Ö Õ½Õ¿Õ¡Õ¶Õ¡Õ¬ Õ¶Õ¯Õ¡Ö€Õ¨ Õ£Ö€Õ¡Õ¿Õ¡Õ­Õ¿Õ¡Õ¯Õ«ÖÖ‰ ({errorMessage})`,
Â  Â  Â  Â  Â  Â  apiErrorGeneral: `âŒ ÕÕ­Õ¡Õ¬ Õ¿Õ¥Õ²Õ« Õ¸Ö‚Õ¶Õ¥ÖÕ¡Õ¾ Õ½Õ¿Õ¸Ö‚Õ£Õ´Õ¡Õ¶ ÕªÕ¡Õ´Õ¡Õ¶Õ¡Õ¯Ö‰ ({errorMessage})`,
Â  Â  Â  Â  Â  Â  apiKeyPermissionError: 'âŒ ÕÕ­Õ¡Õ¬Õ API Õ¢Õ¡Õ¶Õ¡Õ¬Õ«Õ¶ Õ¡Õ¶Õ¾Õ¡Õ¾Õ¥Ö€ Õ§ Õ¯Õ¡Õ´ Õ©Õ¸Ö‚ÕµÕ¬Õ¿Õ¾Õ¸Ö‚Õ©ÕµÕ¸Ö‚Õ¶ Õ¹Õ¸Ö‚Õ¶Õ«Ö‰ ÕÕ¿Õ¸Ö‚Õ£Õ¥Ö„ Õ¢Õ¡Õ¶Õ¡Õ¬Õ«Õ¶ Ö‡ Õ°Õ¡Õ´Õ¸Õ¦Õ¾Õ¥Ö„, Õ¸Ö€ Vision API-Õ¶ Õ´Õ«Õ¡ÖÕ¾Õ¡Õ® Õ§Ö‰',
Â  Â  Â  Â  Â  Â  apiBillingError: 'âŒ ÕÕ­Õ¡Õ¬Õ Õ€Õ¡Õ·Õ¾Õ¡Ö€Õ¯Õ´Õ¡Õ¶ (billing) Õ­Õ¶Õ¤Õ«Ö€Ö‰ ÕÕ¿Õ¸Ö‚Õ£Õ¥Ö„, Õ¸Ö€ Õ¡ÕµÕ¶ Õ´Õ«Õ¡ÖÕ¾Õ¡Õ® Õ§ Õ±Õ¥Ö€ Google Cloud Õ¶Õ¡Õ­Õ¡Õ£Õ®Õ« Õ°Õ¡Õ´Õ¡Ö€Ö‰',
Â  Â  Â  Â  Â  Â  apiKeyMissingWarning: 'ğŸ›‘ **Ô¿Ô±ÕÔµÕÕˆÕ:** Google Vision API Õ¢Õ¡Õ¶Õ¡Õ¬Õ«Õ¶ Õ½Õ­Õ¡Õ¬ Õ§ Õ¯Õ¡Õ´ Õ¢Õ¡ÖÕ¡Õ¯Õ¡ÕµÕ¸Ö‚Õ´ Õ§Ö‰ Ô½Õ¶Õ¤Ö€Õ¸Ö‚Õ´ Õ¥Õ¶Ö„ ÖƒÕ¸Õ­Õ¡Ö€Õ«Õ¶Õ¥Õ¬ Õ¡ÕµÕ¶Ö‰ Ô±Õ¼Õ¡Õ¶Ö Õ¤Ö€Õ¡, Õ±Õ¥Õ¼Õ¡Õ£Ö€Õ« Õ½Õ¿Õ¸Ö‚Õ£Õ¸Ö‚Õ´Õ¨ Õ¹Õ« Õ¡Õ·Õ­Õ¡Õ¿Õ«Ö‰',
Â  Â  Â  Â  Â  Â  lessonComplete: "Ô´Õ¡Õ½Õ¶ Õ¡Õ¾Õ¡Ö€Õ¿Õ¾Õ¡Õ® Õ§Ö‰ Õ‡Õ¡Õ¿ Õ¬Õ¡Õ¾ Õ¡Õ·Õ­Õ¡Õ¿Õ¡Õ¶Ö„Ö‰",
Â  Â  Â  Â  Â  Â  drawActivityWarning: "âš ï¸ Ô½Õ¶Õ¤Ö€Õ¸Ö‚Õ´ Õ¥Õ´, Õ¶Õ¡Õ­ ÖƒÕ¸Ö€Õ±Õ«Ö€ Õ¶Õ¯Õ¡Ö€Õ¥Õ¬Ö‰",
Â  Â  Â  Â  Â  Â  achievementsPrefix: "ğŸ“š ",
Â  Â  Â  Â  Â  Â  blueInkErased: "Ô¿Õ¡ÕºÕ¸Ö‚ÕµÕ¿ Õ£Ö€Õ¾Õ¡Õ®Ö„Õ¨ (ÕºÕ¡Õ¿Õ¡Õ½Õ­Õ¡Õ¶Õ¨) Õ´Õ¡Ö„Ö€Õ¾Õ¡Õ® Õ§Ö‰",
Â  Â  Â  Â  Â  Â  authErrorVision: "Ô±Õ¾Õ¿Õ¸Ö€Õ«Õ¦Õ¡ÖÕ«Õ¡ÕµÕ« Õ½Õ­Õ¡Õ¬Ö‰ Ô½Õ¶Õ¤Ö€Õ¸Ö‚Õ´ Õ¥Õ¶Ö„ Õ´Õ¸Ö‚Õ¿Ö„ Õ£Õ¸Ö€Õ®Õ¥Õ¬Õ Õ¡ÕµÕ½ Õ£Õ¸Ö€Õ®Õ¡Õ¼Õ¸Ö‚ÕµÕ©Õ¶ Ö…Õ£Õ¿Õ¡Õ£Õ¸Ö€Õ®Õ¥Õ¬Õ¸Ö‚ Õ°Õ¡Õ´Õ¡Ö€Ö‰",
Â  Â  Â  Â  Â  Â  lessonFileMissing: 'ÕÕ­Õ¡Õ¬Ö‰ Ô´Õ¡Õ½Õ« Ö†Õ¡ÕµÕ¬Õ¨ Õ¶Õ·Õ¾Õ¡Õ® Õ¹Õ§ URL-Õ¸Ö‚Õ´Ö‰',
Â  Â  Â  Â  Â  Â  lessonLoadErrorGeneric: "Ô´Õ¡Õ½Õ¨ Õ¢Õ¥Õ¼Õ¶Õ¥Õ¬Õ¸Ö‚ Õ½Õ­Õ¡Õ¬Ö‰\nÔ½Õ¶Õ¤Ö€Õ¸Ö‚Õ´ Õ¥Õ¶Ö„ Õ¾Õ¥Ö€Õ¡Õ¤Õ¡Õ¼Õ¶Õ¡Õ¬ Ö‡ Õ¶Õ¸Ö€Õ«Ö ÖƒÕ¸Ö€Õ±Õ¥Õ¬Ö‰",
Â  Â  Â  Â  Â  Â  userNotAuthHandwriting: 'âš ï¸ Õ•Õ£Õ¿Õ¡Õ¿Õ¥Ö€Õ¨ Õ¶Õ¸Ö‚ÕµÕ¶Õ¡Õ¯Õ¡Õ¶Õ¡ÖÕ¾Õ¡Õ® Õ¹Õ§: Ô½Õ¶Õ¤Ö€Õ¸Ö‚Õ´ Õ¥Õ¶Ö„ Õ´Õ¸Ö‚Õ¿Ö„ Õ£Õ¸Ö€Õ®Õ¥Õ¬ Õ±Õ¥Õ¼Õ¡Õ£Ö€Õ« Õ¾Õ¥Ö€Õ¬Õ¸Ö‚Õ®Õ¸Ö‚Õ©ÕµÕ¡Õ¶ Õ£Õ¸Ö€Õ®Õ¡Õ¼Õ¸Ö‚ÕµÕ©Õ¶ Ö…Õ£Õ¿Õ¡Õ£Õ¸Ö€Õ®Õ¥Õ¬Õ¸Ö‚ Õ°Õ¡Õ´Õ¡Ö€:',
Â  Â  Â  Â  Â  Â  pointsGained: "+{points} Õ´Õ«Õ¡Õ¾Õ¸Ö€ Õ±Õ¥Õ¼Ö„ Õ¢Õ¥Ö€Õ¾Õ¥ÖÖ‰", error: "ÕÕ­Õ¡Õ¬", titleDefaultHy: "Thelo AI Ô³Ö€Õ¡Õ¿Õ¡Õ­Õ¿Õ¡Õ¯",
Â  Â  Â  Â  Â  Â  thelobookOpen: "Ô¹Õ¥Õ¬Õ¸Õ£Õ«Ö€Ö„", thelobookClose: "Õ“Õ¡Õ¯Õ¥Õ¬", thelobookInk: "Ô³Õ¸Ö‚ÕµÕ¶Õ ÕÖ‡ (Õ†Õ·Õ¸Ö‚Õ´Õ¶Õ¥Ö€)",
Â  Â  Â  Â  Â  Â  thelobookEraser: "Õ‹Õ¶Õ»Õ«Õ¹", thelobookPen: "Ô³Ö€Õ«Õ¹",
Â  Â  Â  Â  Â  Â  thelobookDisabledMCQ: "Ô¹Õ¥Õ¬Õ¸Õ£Õ«Ö€Ö„Õ¨ Õ°Õ¡Õ½Õ¡Õ¶Õ¥Õ¬Õ« Õ¹Õ§ Õ°Õ¡Ö€ÖÕ¡Õ·Õ¡Ö€Õ« ÕªÕ¡Õ´Õ¡Õ¶Õ¡Õ¯Ö‰",
Â  Â  Â  Â  Â  Â  thelobookPagesBtn: "Ô·Õ»Õ¥Ö€",
Â  Â  Â  Â  Â  Â  thelobookPageIndicator: "Ô·Õ» {currentPage} / {totalPages}",
Â  Â  Â  Â  Â  Â  pageGridBatchIndicator: "Ô·Õ»Õ¥Ö€ {startPage}-{endPage}",
Â  Â  Â  Â  Â  Â  pageGridInstructions: "ÕÕ¥Õ²Õ´Õ¥Ö„ 'C' Õ°Õ¡Õ»Õ¸Ö€Õ¤ Õ­Õ´Õ¢Õ« Õ°Õ¡Õ´Õ¡Ö€, 'X' Õ¶Õ¡Õ­Õ¸Ö€Õ¤Õ«Ö‰",
Â  Â  Â  Â  Â  Â  addPage: "Ô±Õ¾Õ¥Õ¬Õ¡ÖÕ¶Õ¥Õ¬ Õ§Õ»",
	Â  Â  viewDashboard: "ÕÕ¥Õ½Õ¶Õ¥Õ¬ Õ¡Õ¼Õ¡Õ»Õ¨Õ¶Õ©Õ¡ÖÕ¨", // ADD THIS LINE
	Â  Â  limitReached: "Ô´Õ¸Ö‚Ö„ Õ£Õ¥Ö€Õ¡Õ¦Õ¡Õ¶ÖÕ¥Õ¬ Õ¥Ö„ Õ±Õ¥Ö€ Õ¡Õ´Õ½Õ¡Õ¯Õ¡Õ¶ Õ¾Õ¥Ö€Õ¬Õ¸Ö‚Õ®Õ¸Ö‚Õ©ÕµÕ¸Ö‚Õ¶Õ¶Õ¥Ö€Õ« Õ½Õ¡Õ°Õ´Õ¡Õ¶Õ¡Õ¹Õ¡ÖƒÕ¨Ö‰ Ô½Õ¶Õ¤Ö€Õ¸Ö‚Õ´ Õ¥Õ¶Ö„ ÖƒÕ¸Ö€Õ±Õ¥Õ¬ Õ¯Ö€Õ¯Õ«Õ¶ Õ°Õ¡Õ»Õ¸Ö€Õ¤ Õ¡Õ´Õ«Õ½Ö‰"
},
		
Â  Â  Â  Â en: {
Â  next: "Next",
Â  gotIt: "Got it",
Â  check: "Check",
Â  checking: "Check",
Â  correct: "That's right!",
Â  incorrect: "Not quite.",

Â  apiKeyInvalid: "Your key doesnâ€™t seem to be working. Please check and try again.",

Â  inkBlack: "Ink: Black",
Â  inkBlue: "Ink: Blue",
Â  loading: "Loading...",
Â  clear: "Clear",
Â  start: "Start",
Â  prev: "Previous",

Â  welcome: "Welcome! Press Start to begin.",
Â  checkingAI: `Looking at your answer in <strong style="color:${INK_COLORS.blue};">blue</strong>...`,
Â  blankBlueWarning: `It looks like there's no answer in <strong style="color:${INK_COLORS.blue};">blue</strong>. Press 'A' to change your ink color.`,
Â  noTextFound: `I couldnâ€™t find any writing in <strong style="color:${INK_COLORS.blue};">blue</strong>. Try writing a bit more clearly.`,
Â  noDigitsFound: `I didnâ€™t see a number written in <strong style="color:${INK_COLORS.blue};">blue</strong>. (Detected text: {detectedText})`,

Â  correctAI: `Looks good to me! You wrote: <strong>{detectedAnswer}</strong>`,
Â  incorrectAI: `I saw <strong>{detectedAnswer}</strong>, but the correct answer is <strong>{correctAnswer}</strong>. Try again.`,
Â  parsingError: `I had trouble reading a number from your answer. (Detected: {detectedText})`,

Â  imageDataError: `Couldn't get the image from the board. ({errorMessage})`,
Â  apiErrorGeneral: `Something went wrong while checking your answer. ({errorMessage})`,
Â  apiKeyPermissionError: "Your key may be missing permissions. Make sure everythingâ€™s set up properly.",
Â  apiBillingError: "There seems to be a billing issue. Check your payment settings.",
Â  apiKeyMissingWarning: "Important: A valid key is missing. Handwriting checking won't work until itâ€™s added.",

Â  lessonComplete: "Lesson complete! Nice work.",
Â  drawActivityWarning: "Please try drawing something first.",
Â  achievementsPrefix: "ğŸ† ",

Â  blueInkErased: "Your blue ink answer has been erased.",
Â  authErrorVision: "Please log in to use this feature.",
Â  lessonFileMissing: "Lesson file not found. Check the link and try again.",
Â  lessonLoadErrorGeneric: "There was a problem loading the lesson. Please try again.",
Â  userNotAuthHandwriting: "You're not logged in. Please log in to use handwriting analysis.",

Â  pointsGained: "+{points} points earned!",
Â  error: "Error",
Â  titleDefaultEn: "Thelo AI Whiteboard",

Â  thelobookOpen: "thelobook",
Â  thelobookClose: "Close",
Â  thelobookInk: "Ink: Black (Notes)",
Â  thelobookEraser: "Eraser",
Â  thelobookPen: "Pen",
Â  thelobookDisabledMCQ: "thelobook is disabled during multiple choice questions.",
Â  thelobookPagesBtn: "Pages",
Â  thelobookPageIndicator: "Page {currentPage} of {totalPages}",
Â  pageGridBatchIndicator: "Pages {startPage}â€“{endPage}",
Â  pageGridInstructions: "Press 'C' for next batch, 'X' for previous batch.",
Â  addPage: "Add Page",

Â  viewDashboard: "View Your Progress",
Â  limitReached: "You've reached your monthly handwriting check limit. Try again next month.",
}

Â  Â  };

Â  Â  let currentLang = 'en';
Â  Â  /* ========================================================================= */
/* ===== ADD THIS BLOCK: For Weekly Streak Calculation ===================== */
/* ========================================================================= */

/**
Â * Calculates the ISO 8601 week number for a given date.
Â * A week starts on Monday. This is robust against timezone issues.
Â * @param {Date} date The date to calculate the week for.
Â * @returns {string} The week identifier in "YYYY-Www" format (e.g., "2025-W26").
Â */
function getISOWeekIdentifier(date) {
Â  Â  // Create a new date object to avoid modifying the original
Â  Â  const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
Â  Â  // Set to the nearest Thursday: current date + 4 - current day number
Â  Â  // Make Sunday's day number 7
Â  Â  d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
Â  Â  // Get first day of year
Â  Â  const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
Â  Â  // Calculate full weeks to nearest Thursday
Â  Â  const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
Â  Â  // Pad week number with a leading zero if needed
Â  Â  const weekString = String(weekNo).padStart(2, '0');
Â  Â Â 
Â  Â  return `${d.getUTCFullYear()}-W${weekString}`;
}

/**
Â * Gets the week identifier for the week immediately preceding the given one.
Â * @param {string} weekId A week identifier like "2025-W26".
Â * @returns {string} The previous week's identifier, e.g., "2025-W25".
Â */
function getPreviousWeekIdentifier(weekId) {
Â  Â  const [year, week] = weekId.split('-W').map(Number);
Â  Â  if (week > 1) {
Â  Â  Â  Â  const prevWeekString = String(week - 1).padStart(2, '0');
Â  Â  Â  Â  return `${year}-W${prevWeekString}`;
Â  Â  } else {
Â  Â  Â  Â  // This is tricky: the last week of the previous year can be 52 or 53.
Â  Â  Â  Â  // We'll calculate it based on the last day of the previous year.
Â  Â  Â  Â  const lastDayOfPrevYear = new Date(year - 1, 11, 31);
Â  Â  Â  Â  return getISOWeekIdentifier(lastDayOfPrevYear);
Â  Â  }
}

Â  Â  /* ========== DOM Elements ========== */
Â  Â  const backgroundCanvas = document.getElementById('backgroundCanvas');
Â  Â  const replayCanvas = document.getElementById('replayCanvas');
Â  Â  const canvas = document.getElementById('board');
Â  Â  const loadingOverlay = document.getElementById('loading-overlay'); // <-- ADD THIS
Â  Â  const thelobookCanvas = document.getElementById('thelobookCanvas');
Â  Â  const boardWrapper = document.getElementById('boardWrap');
Â  Â  const stageAudioPlayer = document.getElementById('stageAudioPlayer');
Â  Â  const gotItSoundPlayer = document.getElementById('gotItSound');
Â  Â  const mcqOptionsContainer = document.getElementById('mcqOptionsContainer');
Â  Â  const bottomBar = document.getElementById('bottomBar');
Â  Â  const stageProgressBarContainer = document.getElementById('stageProgressBarContainer');
Â  Â  const stageProgressFill = document.getElementById('stageProgressFill');
	Â  const minimapContainer = document.getElementById('minimapContainer');
const minimapCanvas = document.getElementById('minimapCanvas');
let minimapCtx = null;
	Â  const feedbackCanvas = document.getElementById('feedbackCanvas');
let feedbackCtx = null; // Will be initialized in setupContexts
let feedbackAnimationId = null; // To manage animations
	Â  let lastFeedbackDetails = null;
	Â  const feedbackOverlay = document.getElementById('feedbackOverlay');
const feedbackEmoji = document.getElementById('feedbackEmoji');
const feedbackText = document.getElementById('feedbackText');
let feedbackTimer = null; // To manage auto-hiding the message
	const imageTerminal = document.getElementById('image-terminal');
	const imageTerminalImgContainer = document.getElementById('image-terminal-img-container');
	const imageTerminalFeedback = document.getElementById('image-terminal-feedback');

Â  Â  const bgCtx = backgroundCanvas.getContext('2d');
Â  Â  let replayCtx = null;
Â  Â  const ctx = canvas.getContext('2d');
	Â  const captureCanvas = document.getElementById('boardCapture');Â  Â // NEW
const captureCtxÂ  Â  = captureCanvas.getContext('2d');Â  Â  Â  Â  Â  Â  // NEW
Â  Â  let thelobookCtx = null;

Â  Â  const prevBtn = document.getElementById('prevBtn');
Â  Â  const nextCheckBtn = document.getElementById('nextCheckBtn');
	Â  /* mobile tap shim */
nextCheckBtn.addEventListener(
Â  'touchend',
Â  e => {
Â  Â  e.preventDefault();Â  Â  Â  // stop the synthetic click
Â  Â  nextCheckBtn.click();Â  Â  // re-use the normal handler
Â  },
Â  { passive: false }
);

Â  Â  const clearBtn = document.getElementById('clearBtn');
Â  Â  const thelobookBtn = document.getElementById('thelobookBtn');
Â  Â  const chatArea = document.getElementById('chat');
Â  Â  const chatCol = document.getElementById('chatCol'); // <-- ADD THIS LINE
Â  Â  const colorIndicator = document.getElementById('colorIndicator');
Â  Â  if (colorIndicator){ colorIndicator.addEventListener('click', () => { toggleColor(); }); }
Â  Â  const pointsDisplayElement = document.getElementById('pointsDisplay');
const dashboardBtn = document.getElementById('dashboardBtn'); // ADD THIS LINE

Â  Â  const thelobookControlsEl = document.getElementById('thelobookControls');
Â  Â  const thelobookPagesBtn = document.getElementById('thelobookPagesBtn');
Â  Â  const thelobookPrevPageBtn = document.getElementById('thelobookPrevPageBtn');
Â  Â  const thelobookNextPageBtn = document.getElementById('thelobookNextPageBtn');
Â  Â  const thelobookPageIndicatorEl = document.getElementById('thelobookPageIndicator');
Â  Â  const thelobookEraserBtn = document.getElementById('thelobookEraserBtn');
Â  Â  const thelobookAddPageBtn = document.getElementById('thelobookAddPageBtn');
Â  Â  const calculatorOverlay = document.getElementById('calculatorOverlay');
Â  Â  const calculatorFrame = document.getElementById('calculatorFrame');
Â  Â  const calculatorCloseBtn = document.getElementById('calculatorCloseBtn');
	const replayPlayerContainer = document.getElementById('replayPlayerContainer');
	const replayFrame = document.getElementById('replayFrame');
Â  Â  const audioElements = {};
Â  Â  const approveSounds_hy = []; const disapproveSounds_hy = [];
Â  Â  const approveSounds_en = []; const disapproveSounds_en = [];

Â  Â  /* ========== State Variables ========== */
Â  Â  let isAuthReady = false;
	Â  let isInitialStageRendered = false;
	Â  let isMcqAnsweredCorrectly = false;
	Â  let selectedMcqIndex = null; // To store the selected MCQ option index
Â  Â  Â  Â  Â  let isTabletMode = false;
	let isCalculatorActive = false;
	let isReplayActive = false;
		let mousePoints = []; // <<< ADD THIS LINE
const IFRAME_UPDATE_INTERVAL = 40; // ms, throttles updates to 25 FPS (1000 / 40 = 25)
let lastIframeUpdateTime = 0;
	let isPageGridVisible = false;Â 
Â  Â  Â  Â  let lessonStartTime = null;
Â  Â  let lessonStagesRoot = null; let lessonStages = []; let isLessonLoading = false;
Â  Â  let isImageModeActive = false;
Â  Â  let currentStageIndex = -1; let currentStageData = null; let isStudentInputAllowed = false;
Â  Â  let drawing = false; let lastPos = { x: 0, y: 0 };
Â  Â  let userDrawingOccurred = false; let isTransitioning = false;
Â  Â  let devicePixelRatio = window.devicePixelRatio || 1; window.userInteracted = false;
Â  Â  let currentReplayAnimationId = null; let currentStageAudio = null;Â 
Â  Â  let userPoints = 0;
Â  Â  let sessionPoints = 0; // ADDED LINE: To track points for the current lesson session.
Â  Â  let currentStageDrawingData = null; let currentStageTotalDuration = 0;
Â  Â  let isMediaScrubbingActive = false; let internalPlaybackTime = 0; let lastFrameTimestampForManualAdvance = 0;
Â  Â  let isThelobookActive = false; let wasMediaPlayingBeforeThelobook = false;
Â  Â  let mediaPlaybackTimeBeforeThelobook = 0; let audioTimeBeforeThelobook = 0;
Â  Â  let thelobookPages = []; let currentThelobookPageIndex = 0;
Â  Â  let thelobookDrawListenersAttached = false;
Â  Â  let isThelobookEraserActive = false;
Â  Â  const THELOBOOK_ERASER_LINEWIDTH = 20;
Â  Â  const THELOBOOK_PEN_LINEWIDTH = 3;
Â  Â  let isPageSwitchingAnimation = false;
Â  Â  const PAGES_PER_GRID_BATCH = 32;
Â  Â  let tempFullPageCanvasForThumbnails = null;
Â  Â  let buttonVanishTimer = null;
Â  Â  let stagesWithPointsAwarded = new Set();
Â  Â  /* ========== Language Functions ========== */
Â  Â  function getCurrentUIText() { return UI_TEXT[currentLang] || UI_TEXT['hy']; }
Â  Â  function updateAllUITexts() {
Â  Â  Â  Â  const TXT = getCurrentUIText();
Â  Â  Â  Â  document.documentElement.lang = currentLang;

Â  Â  Â  Â  if (prevBtn) prevBtn.textContent = TXT.prev;
Â  Â  Â  Â  if (clearBtn) clearBtn.textContent = TXT.clear;
Â  Â  Â  Â  if (thelobookBtn) thelobookBtn.textContent = isThelobookActive ? TXT.thelobookClose : TXT.thelobookOpen;

Â  Â  Â  Â  if (thelobookAddPageBtn) thelobookAddPageBtn.title = TXT.addPage;
Â  Â  Â  Â  if (thelobookEraserBtn) thelobookEraserBtn.title = isThelobookEraserActive ? TXT.thelobookPen : TXT.thelobookEraser;
Â  Â  Â  Â  if (thelobookPagesBtn) thelobookPagesBtn.title = TXT.thelobookPagesBtn;
Â  Â  Â  Â  if (thelobookPrevPageBtn) thelobookPrevPageBtn.title = TXT.prevPage;
Â  Â  Â  Â  if (thelobookNextPageBtn) thelobookNextPageBtn.title = TXT.nextPage;

Â  Â  Â  Â  updateColorIndicator();
Â  Â  Â  Â  updatePointsDisplay();
Â  Â  Â  Â  if(isThelobookActive && !isPageGridVisible) updateThelobookPageControls();


Â  Â  Â  Â  if (lessonStagesRoot && lessonStagesRoot.lessonTitle) {
Â  Â  Â  Â  Â  Â  document.title = lessonStagesRoot.lessonTitle || TXT[`titleDefault${currentLang.charAt(0).toUpperCase() + currentLang.slice(1)}`];
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  document.title = TXT[`titleDefault${currentLang.charAt(0).toUpperCase() + currentLang.slice(1)}`];
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (currentStageIndex === -1 && lessonStages.length > 0 && nextCheckBtn) { nextCheckBtn.textContent = TXT.start; }
Â  Â  Â  Â  else if (isLessonLoading && nextCheckBtn) { nextCheckBtn.textContent = TXT.loading; }
Â  Â  Â  Â  else if (currentStageData && nextCheckBtn) {
Â  Â  Â  Â  Â  Â  Â  Â  if (currentStageData.type === 'question_handwriting') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (nextCheckBtn.classList.contains('correct')) { nextCheckBtn.textContent = TXT.correct; }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  else if (nextCheckBtn.classList.contains('incorrect')) { nextCheckBtn.textContent = TXT.check; }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  else if (nextCheckBtn.textContent === UI_TEXT.hy.checking || nextCheckBtn.textContent === UI_TEXT.en.checking ) { /* Keep "Checking..." */ }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  else { nextCheckBtn.textContent = TXT.check; }
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const mcqDetails = currentStageData.optionsQuiz;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const isMCQDisplayStage = currentStageData.type === "explanation_with_mcq" && mcqDetails && Array.isArray(mcqDetails.choices) && mcqDetails.choices.length > 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!isMCQDisplayStage) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (nextCheckBtn.classList.contains('correct')) { nextCheckBtn.textContent = TXT.correct; }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  else { nextCheckBtn.textContent = TXT.gotIt; }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  if (currentStageData) {
Â  Â  Â  Â  Â  Â  if (!isTransitioning && !isLessonLoading) renderStageUI(currentStageIndex, true);
Â  Â  Â  Â  }
Â  Â  }
Â  Â  function setLanguage(lang) {
Â  Â  Â  Â  if (UI_TEXT[lang]) {
Â  Â  Â  Â  Â  Â  if (currentLang !== lang) { currentLang = lang; console.log(`Language set to: ${currentLang} by lesson file.`); }
Â  Â  Â  Â  Â  Â  else { console.log(`Language already set to: ${currentLang}. Forcing UI text update.`); }
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  console.warn(`Language ${lang} from lesson file not supported. Defaulting to 'hy'.`);
Â  Â  Â  Â  Â  Â  currentLang = 'hy';
Â  Â  Â  Â  }
		// Add or remove the language-specific class on the body
		if (currentLang === 'en') {
			document.body.classList.add('lang-en');
		} else {
			document.body.classList.remove('lang-en');
		}
		updateAllUITexts();
Â  Â  }

Â  Â  /* ========== Core App Functions ========== */
Â  Â  function updatePointsDisplay() {
Â  Â  Â  Â  const TXT = getCurrentUIText();
Â  Â  Â  Â  // MODIFIED: This now uses sessionPoints for the on-screen display.
Â  Â  Â  Â  if (pointsDisplayElement) pointsDisplayElement.textContent = `${TXT.achievementsPrefix}${sessionPoints}`;
Â  Â  }
Â  async function loadLesson(lessonJsonPath) {
Â  Â  if (isLessonLoading) return;
Â  Â  isLessonLoading = true;
Â  Â  if (prevBtn) prevBtn.disabled = true;
Â  Â  if (dashboardBtn) dashboardBtn.style.display = 'none';
Â  Â  if (isThelobookActive) closeThelobook(false);
Â  Â  if (isPageGridVisible) closePageGridView();

Â  Â  try {
Â  Â  Â  Â  const response = await fetch(lessonJsonPath);
Â  Â  Â  Â  if (!response.ok) throw new Error(`HTTP error! status: ${response.status} fetching ${lessonJsonPath}`);
Â  Â  Â  Â  lessonStagesRoot = await response.json();
Â  Â  Â  Â  if (!lessonStagesRoot || !Array.isArray(lessonStagesRoot.stages)) throw new Error("Invalid lesson format.");
Â  Â  Â  Â  const lessonLang = lessonStagesRoot.lessonLanguage || 'hy';
Â  Â  Â  Â  setLanguage(lessonLang);
Â  Â  Â  Â  let TXT = getCurrentUIText();
Â  Â  Â  Â  lessonStages = lessonStagesRoot.stages;

Â  Â  Â  Â  // FIX: Show the welcome message after a brief delay to prevent a font race condition.
Â  Â  Â  Â  // The 'await ensureHeadlineFontsLoaded()' call has been removed.
Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  showOnCanvasFeedback(TXT.welcome);
Â  Â  Â  Â  }, 100); // 100ms delay is enough for the browser to settle.

Â  Â  Â  Â  sessionPoints = 0;
Â  Â  Â  Â  updatePointsDisplay();
Â  Â  Â  Â Â 
Â  Â  Â  Â  stagesWithPointsAwarded = new Set();

Â  Â  Â  Â  document.title = lessonStagesRoot.lessonTitle || TXT[`titleDefault${currentLang.charAt(0).toUpperCase() + currentLang.slice(1)}`];
Â  Â  Â  Â  console.log(`Lesson loaded: ${lessonStages.length} stages. Language: ${currentLang}`);

Â  Â  Â  Â  currentStageIndex = -1;
Â  Â  Â  Â  currentStageData = null;
Â  Â  Â  Â  isStudentInputAllowed = false;
Â  Â  Â  Â  if (currentReplayAnimationId) cancelAnimationFrame(currentReplayAnimationId);
Â  Â  Â  Â  currentReplayAnimationId = null;
Â  Â  Â  Â  if (currentStageAudio && !currentStageAudio.paused) {
Â  Â  Â  Â  Â  Â  currentStageAudio.pause();
Â  Â  Â  Â  Â  Â  currentStageAudio.onloadedmetadata = null;
Â  Â  Â  Â  Â  Â  currentStageAudio.onended = null;
Â  Â  Â  Â  }
Â  Â  Â  Â  currentStageAudio = null;
Â  Â  Â  Â  isMediaScrubbingActive = false;
Â  Â  Â  Â  if (stageProgressBarContainer) stageProgressBarContainer.classList.remove('visible');
Â  Â  Â  Â  if (bgCtx) bgCtx.clearRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
Â  Â  Â  Â  if (replayCtx) replayCtx.clearRect(0, 0, replayCanvas.width, replayCanvas.height);
Â  Â  Â  Â  if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
Â  Â  Â  Â Â 
Â  Â  Â  Â  thelobookPages = [];
Â  Â  Â  Â  currentThelobookPageIndex = 0;
Â  Â  Â  Â  updateThelobookPageControls();

Â  Â  } catch (error) {
Â  Â  Â  Â  console.error("Error loading lesson:", error);
Â  Â  Â  Â  let TXT = getCurrentUIText();
Â  Â  Â  Â  addChatMessage('AI', `${formatAIMessage('error')}: ${error.message}`);
Â  Â  } finally {
Â  Â  Â  Â  isLessonLoading = false;

Â  Â  Â  Â  if (lessonStages && lessonStages.length > 0) {
Â  Â  Â  Â  Â  Â  if (nextCheckBtn) {
Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.disabled = false;
Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.textContent = getCurrentUIText().start;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  if (nextCheckBtn) {
Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.textContent = getCurrentUIText().error;
Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.disabled = true;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  if (!UI_TEXT[currentLang]) currentLang = 'hy';
Â  Â  Â  Â  updateAllUITexts();

Â  Â  Â  Â  if (loadingOverlay) {
Â  Â  Â  Â  Â  Â  loadingOverlay.classList.add('hidden');
Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  if(loadingOverlay) loadingOverlay.style.display = 'none';
Â  Â  Â  Â  Â  Â  }, 500);
Â  Â  Â  Â  }
Â  Â  }
}
function resizeCanvases() {
Â  Â  clearTimeout(window.resizeTimeout);
Â  Â  window.resizeTimeout = setTimeout(() => {
Â  Â  Â  Â  checkTabletMode();
Â  Â  Â  Â  if (!boardWrapper) return;

Â  Â  Â  Â  // Save the current drawing before it gets erased by the resize.
Â  Â  Â  Â  let userDrawingData = null;
Â  Â  Â  Â  if (userDrawingOccurred && canvas.width > 0 && canvas.height > 0) {
Â  Â  Â  Â  Â  Â  userDrawingData = ctx.getImageData(0, 0, canvas.width, canvas.height);
Â  Â  Â  Â  }

Â  Â  Â  Â  const rect = boardWrapper.getBoundingClientRect();
Â  Â  Â  Â  const cssWidth = Math.max(1, Math.floor(rect.width));
Â  Â  Â  Â  const cssHeight = Math.max(1, Math.floor(rect.height));
Â  Â  Â  Â  devicePixelRatio = window.devicePixelRatio || 1;
Â  Â  Â  Â  const internalWidth = Math.floor(cssWidth * devicePixelRatio);
Â  Â  Â  Â  const internalHeight = Math.floor(cssHeight * devicePixelRatio);

Â  Â  Â  Â  // This loop erases the canvases when it sets the new width/height.
Â  Â  Â  Â  [backgroundCanvas, replayCanvas, canvas, thelobookCanvas, feedbackCanvas].forEach(c => {
Â  Â  Â  Â  Â  Â  if (c) {
Â  Â  Â  Â  Â  Â  Â  Â  c.width = internalWidth;
Â  Â  Â  Â  Â  Â  Â  Â  c.height = internalHeight;
Â  Â  Â  Â  Â  Â  Â  Â  c.style.width = `${cssWidth}px`;
Â  Â  Â  Â  Â  Â  Â  Â  c.style.height = `${cssHeight}px`;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });
Â  Â  Â  Â Â 
Â  Â  Â  Â  setupContexts();

Â  Â  Â  Â  // Restore the saved drawing onto the newly resized canvas.
Â  Â  Â  Â  if (userDrawingData) {
Â  Â  Â  Â  Â  Â  ctx.putImageData(userDrawingData, 0, 0);
Â  Â  Â  Â  }

Â  Â  Â  Â  // Redraw the rest of the UI.
Â  Â  Â  Â  if (currentStageIndex >= 0 && lessonStages.length > 0) renderStageUI(currentStageIndex, true);
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (isThelobookActive) {
Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  if (isThelobookActive) loadThelobookPageDrawing(currentThelobookPageIndex);
Â  Â  Â  Â  Â  Â  }, 50);
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  if(isPageGridVisible) renderPageGridBatch(currentPageGridBatch, false);

Â  Â  // At the end of the resizeCanvases function
Â  Â  if (minimapCanvas) {
Â  Â  Â  Â  const minimapRect = minimapCanvas.getBoundingClientRect();
Â  Â  Â  Â  minimapCanvas.width = minimapRect.width * devicePixelRatio;
Â  Â  Â  Â  minimapCanvas.height = minimapRect.height * devicePixelRatio;
Â  Â  }

Â  Â  // The call to setupContexts() should be after this new block
Â  Â  setupContexts();
Â  Â  }, 150);
}
	function setupContexts() {
Â  Â  if (!backgroundCanvas || !replayCanvas || !canvas || !thelobookCanvas) return;
Â  Â Â 
Â  Â  replayCtx = replayCanvas.getContext('2d');Â 
Â  Â  thelobookCtx = thelobookCanvas.getContext('2d');
Â  Â Â 
Â  Â  [bgCtx, replayCtx, ctx, thelobookCtx].forEach(context => {
Â  Â  Â  Â  if (context) {Â 
Â  Â  Â  Â  Â  Â  context.resetTransform();Â 
Â  Â  Â  Â  Â  Â  context.scale(devicePixelRatio, devicePixelRatio);Â 
Â  Â  Â  Â  }
Â  Â  });
Â  Â Â 
Â  Â  bgCtx.lineWidth = 2;Â 
Â  Â  bgCtx.strokeStyle = '#333';Â 
Â  Â  bgCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--thelo-text').trim();
Â  Â Â 
Â  Â  const fontFamily = currentLang === 'en' ? "'Manrope', system-ui, sans-serif" : "'Montserrat Arm', system-ui, sans-serif";
Â  Â  bgCtx.font = `20px ${fontFamily}`;Â 
Â  Â  bgCtx.textAlign = 'center';Â 
Â  Â  bgCtx.textBaseline = 'top';
Â  Â Â 
Â  Â  if (replayCtx) {Â 
Â  Â  Â  Â  replayCtx.lineCap = 'round';Â 
Â  Â  Â  Â  replayCtx.lineJoin = 'round';Â 
Â  Â  }
Â  Â Â 
Â  Â  ctx.lineWidth = THELOBOOK_PEN_LINEWIDTH;Â 
Â  Â  ctx.lineCap = 'round';Â 
Â  Â  ctx.lineJoin = 'round';Â 
Â  Â  ctx.strokeStyle = INK_COLORS.blue; // Hardcoded to blue
Â  Â Â 
Â  Â  if (thelobookCtx) {
Â  Â  Â  Â  thelobookCtx.lineCap = 'round';Â 
Â  Â  Â  Â  thelobookCtx.lineJoin = 'round';
Â  Â  }
Â  Â  if (minimapCanvas) {
Â  Â  Â  Â  minimapCtx = minimapCanvas.getContext('2d');
Â  Â  Â  Â  if (minimapCtx) {
Â  Â  Â  Â  Â  Â  minimapCtx.scale(devicePixelRatio, devicePixelRatio);
Â  Â  Â  Â  Â  Â  minimapCtx.lineWidth = 2;
Â  Â  Â  Â  Â  Â  minimapCtx.lineCap = 'round';
Â  Â  Â  Â  Â  Â  minimapCtx.lineJoin = 'round';
Â  Â  Â  Â  Â  Â  minimapCtx.strokeStyle = INK_COLORS.blue;
Â  Â  Â  Â  }
Â  Â  }
Â  Â  if (feedbackCanvas) {
Â  Â  Â  Â  feedbackCtx = feedbackCanvas.getContext('2d');
Â  Â  Â  Â  if (feedbackCtx) {
Â  Â  Â  Â  Â  Â  feedbackCtx.resetTransform();
Â  Â  Â  Â  Â  Â  feedbackCtx.scale(devicePixelRatio, devicePixelRatio);
Â  Â  Â  Â  }
Â  Â  }
Â  Â Â 
Â  Â  updateColorIndicator();
}
Â  Â  function calculateDrawingDuration(drawingData){
Â  Â  Â  Â  if (!drawingData || !drawingData.strokes || drawingData.strokes.length === 0) return 0;
Â  Â  Â  Â  let maxTime = 0;
Â  Â  Â  Â  drawingData.strokes.forEach(stroke => {
Â  Â  Â  Â  Â  Â  let strokeEndTimeVal = 0;
Â  Â  Â  Â  Â  Â  if (stroke.endTime !== undefined) { strokeEndTimeVal = stroke.endTime; }
Â  Â  Â  Â  Â  Â  else if (stroke.points && stroke.points.length > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  const lastPoint = stroke.points[stroke.points.length - 1];
Â  Â  Â  Â  Â  Â  Â  Â  strokeEndTimeVal = (stroke.startTime || 0) + (lastPoint.timeOffset || 0);
Â  Â  Â  Â  Â  Â  } else { strokeEndTimeVal = (stroke.startTime || 0); }
Â  Â  Â  Â  Â  Â  if (strokeEndTimeVal > maxTime) maxTime = strokeEndTimeVal;
Â  Â  Â  Â  });
Â  Â  Â  Â  return maxTime / 1000;
Â  Â  }
Â  Â  function renderDrawingAtTime(targetTimeInSeconds, drawingData, targetCtx){
Â  Â  Â  Â  if (!targetCtx) return;
Â  Â  Â  Â  const canvasWidth = targetCtx.canvas.width / devicePixelRatio;
Â  Â  Â  Â  const canvasHeight = targetCtx.canvas.height / devicePixelRatio;
Â  Â  Â  Â  targetCtx.clearRect(0, 0, canvasWidth, canvasHeight);

Â  Â  Â  Â  if (!drawingData || !drawingData.strokes) return;

Â  Â  Â  Â  drawingData.strokes.forEach(stroke => {
Â  Â  Â  Â  Â  Â  const strokeStartTime = (stroke.startTime || 0) / 1000;
Â  Â  Â  Â  Â  Â  if (targetTimeInSeconds < strokeStartTime) return;

Â  Â  Â  Â  Â  Â  targetCtx.lineWidth = stroke.lineWidth || 2;
Â  Â  Â  Â  Â  Â  targetCtx.strokeStyle = stroke.color || 'black';
Â  Â  Â  Â  Â  Â  targetCtx.fillStyle = stroke.color || 'black';
Â  Â  Â  Â  Â  Â  targetCtx.lineCap = 'round'; targetCtx.lineJoin = 'round';

Â  Â  Â  Â  Â  Â  const points = stroke.points || [];
Â  Â  Â  Â  Â  Â  if (points.length === 0) return;
Â  Â  Â  Â  Â  Â  targetCtx.beginPath();
Â  Â  Â  Â  Â  Â  let movedToFirstPoint = false;

Â  Â  Â  Â  Â  Â  for (let i = 0; i < points.length; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  const point = points[i];
Â  Â  Â  Â  Â  Â  Â  Â  const pointTimeAbsolute = strokeStartTime + ((point.timeOffset || 0) / 1000);
Â  Â  Â  Â  Â  Â  Â  Â  if (pointTimeAbsolute > targetTimeInSeconds) break;

Â  Â  Â  Â  Â  Â  Â  Â  if (!movedToFirstPoint) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  targetCtx.moveTo(point.normX * canvasWidth, point.normY * canvasHeight);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  movedToFirstPoint = true;
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  targetCtx.lineTo(point.normX * canvasWidth, point.normY * canvasHeight);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if (points.length === 1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  targetCtx.closePath(); targetCtx.beginPath();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  targetCtx.arc(point.normX * canvasWidth, point.normY * canvasHeight, (stroke.lineWidth || 2) / 2, 0, Math.PI * 2);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  targetCtx.fill();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  if (movedToFirstPoint && points.length > 1) targetCtx.stroke();
Â  Â  Â  Â  });
Â  Â  }
Â  Â  function updateMediaProgressBar(effectiveTime, totalDuration){
Â  Â  Â  Â  if (!stageProgressBarContainer) return;
Â  Â  Â  Â  if (isMediaScrubbingActive && totalDuration > 0) {
Â  Â  Â  Â  Â  Â  if (!stageProgressBarContainer.classList.contains('visible')) {
Â  Â  Â  Â  Â  Â  Â  Â  stageProgressBarContainer.classList.add('visible');
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  const progress = (effectiveTime / totalDuration) * 100;
Â  Â  Â  Â  Â  Â  stageProgressFill.style.width = `${Math.min(100, Math.max(0, progress))}%`;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  // Keep progress bar visible if not scrubbing but playback is at the end (handled by new snippet in renderStageUI)
Â  Â  Â  Â  if (!(internalPlaybackTime >= currentStageTotalDuration - 0.05 && currentStageTotalDuration > 0)) {
Â  Â  Â  Â  Â  Â  stageProgressBarContainer.classList.remove('visible');
Â  Â  Â  Â  Â  Â  stageProgressFill.style.width = '0%';
Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  }
Â  Â // In your MAIN app's <script> tag
// In your MAIN app's <script> tag - REPLACE this function

// In your MAIN app's <script> tag - REPLACE this function

// In your MAIN app's <script> tag - REPLACE this function
function mediaPlaybackLoop(timestamp) {
Â  Â  // Exit if playback is no longer supposed to be active
Â  Â  if (!isMediaScrubbingActive) {
Â  Â  Â  Â  if (currentReplayAnimationId) cancelAnimationFrame(currentReplayAnimationId);
Â  Â  Â  Â  currentReplayAnimationId = null;
Â  Â  Â  Â  return;
Â  Â  }

Â  Â  // --- HYBRID TIME CALCULATION (Unchanged) ---
Â  Â  const audioIsPlaying = currentStageAudio && !currentStageAudio.paused && !currentStageAudio.ended;
Â  Â  if (audioIsPlaying) {
Â  Â  Â  Â  internalPlaybackTime = currentStageAudio.currentTime;
Â  Â  Â  Â  lastFrameTimestampForManualAdvance = timestamp;Â 
Â  Â  } else {
Â  Â  Â  Â  if (lastFrameTimestampForManualAdvance === 0) {
Â  Â  Â  Â  Â  Â  lastFrameTimestampForManualAdvance = timestamp;
Â  Â  Â  Â  }
Â  Â  Â  Â  const deltaTime = (timestamp - lastFrameTimestampForManualAdvance) / 1000.0;
Â  Â  Â  Â  internalPlaybackTime += deltaTime;
Â  Â  Â  Â  lastFrameTimestampForManualAdvance = timestamp;
Â  Â  }
Â  Â Â 
Â  Â  // Ensure playback stops precisely at the end (Unchanged)
Â  Â  if (internalPlaybackTime >= currentStageTotalDuration) {
Â  Â  Â  Â  internalPlaybackTime = currentStageTotalDuration;
Â  Â  Â  Â  isMediaScrubbingActive = false;Â 
Â  Â  }

Â  Â  // --- UNIVERSAL UPDATES (Now with throttling) ---

Â  Â  // Update the drawing replay on the main canvas (cheap, runs every frame)
Â  Â  if (currentStageDrawingData && replayCtx) {
Â  Â  Â  Â  renderDrawingAtTime(internalPlaybackTime, currentStageDrawingData, replayCtx);
Â  Â  }

Â  Â  // ======================== THE FIX ========================
Â  Â  // Only update the expensive iframe if enough time has passed.
Â  Â  if (isReplayActive && replayFrame.contentWindow && (timestamp - lastIframeUpdateTime > IFRAME_UPDATE_INTERVAL)) {
Â  Â  Â  Â  replayFrame.contentWindow.postMessage({
Â  Â  Â  Â  Â  Â  command: 'renderAtTime',
Â  Â  Â  Â  Â  Â  timeMs: internalPlaybackTime * 1000
Â  Â  Â  Â  }, '*');
Â  Â  Â  Â  // Update the timestamp of the last update
Â  Â  Â  Â  lastIframeUpdateTime = timestamp;
Â  Â  }
Â  Â  // =========================================================
Â  Â Â 
Â  Â  // Update the progress bar (cheap, runs every frame for smoothness)
Â  Â  updateMediaProgressBar(internalPlaybackTime, currentStageTotalDuration);

Â  Â  // Continue the loop
Â  Â  currentReplayAnimationId = requestAnimationFrame(mediaPlaybackLoop);
}
function playStrokesAbsoluteTiming(strokeData, targetCtx, onFinished){
Â  Â  Â  Â  if (isMediaScrubbingActive) { if (typeof onFinished === 'function') onFinished(); return; }
Â  Â  Â  Â  if (currentReplayAnimationId) { cancelAnimationFrame(currentReplayAnimationId); currentReplayAnimationId = null; }
Â  Â  Â  Â  if (!targetCtx || !strokeData || !strokeData.strokes || strokeData.strokes.length === 0) { if (typeof onFinished === 'function') onFinished(); return; }
Â  Â  Â  Â  const targetWidth = targetCtx.canvas.width / devicePixelRatio;
Â  Â  Â  Â  const targetHeight = targetCtx.canvas.height / devicePixelRatio;
Â  Â  Â  Â  targetCtx.clearRect(0, 0, targetWidth, targetHeight);
Â  Â  Â  Â  let currentStrokeIndex = 0, currentPointIndex = 0, animationStartTime = null, strokeSetupDone = false;
Â  Â  Â  Â  function animateStrokes(timestamp) {
Â  Â  Â  Â  Â  Â  if (!animationStartTime) animationStartTime = timestamp;
Â  Â  Â  Â  Â  Â  const elapsedOverallTime = timestamp - animationStartTime;
Â  Â  Â  Â  Â  Â  if (currentStrokeIndex >= strokeData.strokes.length) { if (typeof onFinished === 'function') onFinished(); currentReplayAnimationId = null; return; }
Â  Â  Â  Â  Â  Â  const stroke = strokeData.strokes[currentStrokeIndex]; const points = stroke.points || [];
Â  Â  Â  Â  Â  Â  const scheduledStrokeStartTime = stroke.startTime || 0; const scheduledStrokeEndTime = stroke.endTime === undefined ? Infinity : stroke.endTime;
Â  Â  Â  Â  Â  Â  if (elapsedOverallTime < scheduledStrokeStartTime) { currentReplayAnimationId = requestAnimationFrame(animateStrokes); return; }
Â  Â  Â  Â  Â  Â  if (elapsedOverallTime >= scheduledStrokeEndTime && currentPointIndex >= points.length) { currentStrokeIndex++; currentPointIndex = 0; strokeSetupDone = false; currentReplayAnimationId = requestAnimationFrame(animateStrokes); return; }
Â  Â  Â  Â  Â  Â  if (!strokeSetupDone) { targetCtx.lineWidth = stroke.lineWidth || 2; targetCtx.strokeStyle = stroke.color || 'black'; targetCtx.fillStyle = stroke.color || 'black'; targetCtx.lineCap = 'round'; targetCtx.lineJoin = 'round'; targetCtx.beginPath(); if (points.length > 0) { targetCtx.moveTo(points[0].normX * targetWidth, points[0].normY * targetHeight); } strokeSetupDone = true; }
Â  Â  Â  Â  Â  Â  const timeElapsedInStroke = elapsedOverallTime - scheduledStrokeStartTime; let processedPointInFrame = false;
Â  Â  Â  Â  Â  Â  while (currentPointIndex < points.length && timeElapsedInStroke >= points[currentPointIndex].timeOffset) {
Â  Â  Â  Â  Â  Â  Â  Â  const pt = points[currentPointIndex];
Â  Â  Â  Â  Â  Â  Â  Â  if (points.length === 1 && currentPointIndex === 0) { targetCtx.arc(pt.normX * targetWidth, pt.normY * targetHeight, (stroke.lineWidth || 2) / 2, 0, Math.PI * 2); targetCtx.fill(); }
Â  Â  Â  Â  Â  Â  Â  Â  else if (currentPointIndex > 0) { targetCtx.lineTo(pt.normX * targetWidth, pt.normY * targetHeight); processedPointInFrame = true; }
Â  Â  Â  Â  Â  Â  Â  Â  else if (currentPointIndex === 0 && points.length > 1) { targetCtx.moveTo(pt.normX * targetWidth, pt.normY * targetHeight); }
Â  Â  Â  Â  Â  Â  Â  Â  currentPointIndex++;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  if (processedPointInFrame) { targetCtx.stroke(); }
Â  Â  Â  Â  Â  Â  currentReplayAnimationId = requestAnimationFrame(animateStrokes);
Â  Â  Â  Â  }
Â  Â  Â  Â  currentReplayAnimationId = requestAnimationFrame(animateStrokes);
Â  Â  }

Â  Â 
Â  Â function updateColorIndicator() {
Â  Â  const TXT = getCurrentUIText();
Â  Â  if (colorIndicator) {
Â  Â  Â  Â  let showIndicator = false;
Â  Â  Â  Â  if (isThelobookActive && !isPageGridVisible) {
Â  Â  Â  Â  Â  Â  colorIndicator.textContent = isThelobookEraserActive ? TXT.thelobookEraser : TXT.thelobookInk;
Â  Â  Â  Â  Â  Â  showIndicator = true;
Â  Â  Â  Â  }
Â  Â  Â  Â  colorIndicator.style.display = showIndicator ? 'inline-flex' : 'none';
Â  Â  }
}
Â  Â  function getPos(e, targetCanvas) {
Â  Â  Â  Â  if (!targetCanvas) return null;
Â  Â  Â  Â  const rect = targetCanvas.getBoundingClientRect(); let clientX, clientY;
Â  Â  Â  Â  if (e.touches && e.touches.length > 0) { clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; }
Â  Â  Â  Â  else if (e.changedTouches && e.changedTouches.length > 0) { clientX = e.changedTouches[0].clientX; clientY = e.changedTouches[0].clientY; }
Â  Â  Â  Â  else { clientX = e.clientX; clientY = e.clientY; }
Â  Â  Â  Â  if (typeof clientX !== 'number' || typeof clientY !== 'number') return null;
Â  Â  Â  Â  return { x: clientX - rect.left, y: clientY - rect.top };
Â  Â  }
// THIS IS THE NEW, UPDATED FUNCTION
function handleDrawingStart(e) {
	
Â  Â  if (isTabletMode && e.type.startsWith('touch')) {
Â  Â  Â  Â  const isStylusPresent = Array.from(e.touches).some(t => t.touchType === 'stylus');
Â  Â  Â  Â  if (!isStylusPresent) {
Â  Â  Â  Â  Â  Â  e.preventDefault();
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }
Â  Â  Â  Â  // The UI-hiding logic has been REMOVED from here.
Â  Â  }

Â  Â  const currentTargetCanvas = e.currentTarget;
Â  Â  const activeCtx = isThelobookActive ? thelobookCtx : ctx;
Â  Â  if (!activeCtx) return;
Â  Â  if (isThelobookActive && currentTargetCanvas !== thelobookCanvas) return;
Â  Â  if (!isThelobookActive && currentTargetCanvas !== canvas) return;
Â  Â  if (!isStudentInputAllowed && !isThelobookActive) return;

Â  Â  const pos = getPos(e, currentTargetCanvas);
Â  Â  if (!pos) return;
Â  Â  if (e.touches) e.preventDefault();

Â  Â  drawing = true;
	if (e.pointerType === 'pen') canvas.classList.add('no-cursor');
Â  Â  if (!isThelobookActive) userDrawingOccurred = true;

Â  Â  if (isThelobookActive) {
Â  Â  Â  Â  activeCtx.lineWidth = isThelobookEraserActive ? THELOBOOK_ERASER_LINEWIDTH : THELOBOOK_PEN_LINEWIDTH;
Â  Â  Â  Â  activeCtx.globalCompositeOperation = isThelobookEraserActive ? 'destination-out' : 'source-over';
Â  Â  } else {
Â  Â  Â  Â  activeCtx.lineWidth = THELOBOOK_PEN_LINEWIDTH;
Â  Â  Â  Â  activeCtx.globalCompositeOperation = 'source-over';
Â  Â  }

Â  Â  lastPos = pos;
Â  Â  activeCtx.beginPath();
Â  Â  activeCtx.moveTo(pos.x, pos.y);
}
// THIS IS THE NEW, UPDATED FUNCTION
// REPLACE the old handleDrawingMove function with this one
function handleDrawingMove(e) {
Â  Â  if (!drawing) return;

Â  Â  if (isTabletMode) {
Â  Â  Â  Â  if (buttonVanishTimer) clearTimeout(buttonVanishTimer);
Â  Â  Â  Â  if (bottomBar && !bottomBar.classList.contains('bar-hidden-by-stylus')) {
Â  Â  Â  Â  Â  Â  bottomBar.classList.add('bar-hidden-by-stylus');
Â  Â  Â  Â  }
Â  Â  }

Â  Â  const currentTargetCanvas = e.currentTarget;
Â  Â  const activeCtx = isThelobookActive ? thelobookCtx : ctx;
Â  Â  if (!activeCtx) return;

Â  Â  const pos = getPos(e, currentTargetCanvas);
Â  Â  if (!pos) return;
Â  Â  if (e.touches) e.preventDefault();

Â  Â  const midPoint = { x: (lastPos.x + pos.x) / 2, y: (lastPos.y + pos.y) / 2 };

Â  Â  activeCtx.quadraticCurveTo(lastPos.x, lastPos.y, midPoint.x, midPoint.y);
Â  Â  activeCtx.stroke();
Â  Â  activeCtx.moveTo(midPoint.x, midPoint.y);
	captureCtx.quadraticCurveTo(lastPos.x, lastPos.y, midPoint.x, midPoint.y);
captureCtx.stroke();

Â  Â  lastPos = pos;

Â  Â  // --- NEW MINIMAP DRAWING LOGIC ---
Â  Â  // If the minimap context exists and we are NOT in thelobook mode...
Â  Â  if (minimapCtx && !isThelobookActive) {
Â  Â  Â  Â  // Clear the previous frame on the minimap
Â  Â  Â  Â  minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
Â  Â  Â  Â  // Draw the entire main canvas (where the ink is) onto the minimap, scaled to fit.
Â  Â  Â  Â  minimapCtx.drawImage(canvas, 0, 0, minimapCanvas.width / devicePixelRatio, minimapCanvas.height / devicePixelRatio);
Â  Â  }
}
function handleDrawingEnd(e) {
	canvas.classList.remove('no-cursor');
Â  Â  if (isTabletMode) {
Â  Â  Â  Â  if (buttonVanishTimer) clearTimeout(buttonVanishTimer);
Â  Â  Â  Â  buttonVanishTimer = setTimeout(() => {
Â  Â  Â  Â  Â  Â  if (bottomBar) bottomBar.classList.remove('bar-hidden-by-stylus');
Â  Â  Â  Â  }, 500);
Â  Â  }

Â  Â  if (!drawing) return;
Â  Â  drawing = false;

Â  Â  const activeCtx = isThelobookActive ? thelobookCtx : ctx;
Â  Â  if (!activeCtx) return;

Â  Â  activeCtx.lineTo(lastPos.x, lastPos.y);
Â  Â  activeCtx.stroke();
Â  Â  activeCtx.closePath();
}
Â  Â  // REPLACE your old drawing functions with these three new versions
function addBoardDrawListeners() {
Â  Â  Â  Â  canvas.addEventListener('mousedown', handleDrawingStart);
Â  Â  Â  Â  canvas.addEventListener('mousemove', handleDrawingMove);
Â  Â  Â  Â  canvas.addEventListener('touchstart', handleDrawingStart, { passive: false });
Â  Â  Â  Â  canvas.addEventListener('touchmove', handleDrawingMove, { passive: false });
Â  Â  Â  Â  canvas.addEventListener('touchend', handleDrawingEnd);
Â  Â  Â  Â  canvas.addEventListener('touchcancel', handleDrawingEnd);
Â  Â  }
Â  Â  function removeBoardDrawListeners() {
Â  Â  Â  Â  canvas.removeEventListener('mousedown', handleDrawingStart);
Â  Â  Â  Â  canvas.removeEventListener('mousemove', handleDrawingMove);
Â  Â  Â  Â  canvas.removeEventListener('touchstart', handleDrawingStart);
Â  Â  Â  Â  canvas.removeEventListener('touchmove', handleDrawingMove);
Â  Â  Â  Â  canvas.removeEventListener('touchend', handleDrawingEnd);
Â  Â  Â  Â  canvas.removeEventListener('touchcancel', handleDrawingEnd);
Â  Â  }
Â  Â  function addThelobookDrawListeners() {
Â  Â  Â  Â  if (thelobookDrawListenersAttached) return;
Â  Â  Â  Â  thelobookCanvas.addEventListener('mousedown', handleDrawingStart);
Â  Â  Â  Â  thelobookCanvas.addEventListener('mousemove', handleDrawingMove);
Â  Â  Â  Â  thelobookCanvas.addEventListener('touchstart', handleDrawingStart, { passive: false });
Â  Â  Â  Â  thelobookCanvas.addEventListener('touchmove', handleDrawingMove, { passive: false });
Â  Â  Â  Â  thelobookCanvas.addEventListener('touchend', handleDrawingEnd);
Â  Â  Â  Â  thelobookCanvas.addEventListener('touchcancel', handleDrawingEnd);
Â  Â  Â  Â  thelobookDrawListenersAttached = true;
Â  Â  }
Â  Â  function removeThelobookDrawListeners() {
Â  Â  Â  Â  if (!thelobookDrawListenersAttached) return;
Â  Â  Â  Â  thelobookCanvas.removeEventListener('mousedown', handleDrawingStart);
Â  Â  Â  Â  thelobookCanvas.removeEventListener('mousemove', handleDrawingMove);
Â  Â  Â  Â  thelobookCanvas.removeEventListener('touchstart', handleDrawingStart);
Â  Â  Â  Â  thelobookCanvas.removeEventListener('touchmove', handleDrawingMove);
Â  Â  Â  Â  thelobookCanvas.removeEventListener('touchend', handleDrawingEnd);
Â  Â  Â  Â  thelobookCanvas.removeEventListener('touchcancel', handleDrawingEnd);
Â  Â  Â  Â  thelobookDrawListenersAttached = false;
Â  Â  }

Â  Â  function wrapText(context, text, x, y, maxWidth, lineHeight){
Â  Â  Â  Â  const words = text.split(' '); let line = ''; let currentY = y; let lines = [];
Â  Â  Â  Â  for(let n = 0; n < words.length; n++) {
Â  Â  Â  Â  Â  Â  const testLine = line + words[n] + ' '; const metrics = context.measureText(testLine);
Â  Â  Â  Â  Â  Â  const testWidth = metrics.width; const wordWidth = context.measureText(words[n]).width;
Â  Â  Â  Â  Â  Â  if (wordWidth > maxWidth && line.trim() !== '') { context.fillText(line.trim(), x, currentY); lines.push(line.trim()); line = ''; currentY += lineHeight; }
Â  Â  Â  Â  Â  Â  if (wordWidth > maxWidth) { context.fillText(words[n], x, currentY); lines.push(words[n]); line = ' '; currentY += lineHeight; }
Â  Â  Â  Â  Â  Â  else if (testWidth > maxWidth && line.trim() !== '') { context.fillText(line.trim(), x, currentY); lines.push(line.trim()); line = words[n] + ' '; currentY += lineHeight; }
Â  Â  Â  Â  Â  Â  else { line = testLine; }
Â  Â  Â  Â  }
Â  Â  Â  Â  if (line.trim() !== '') { context.fillText(line.trim(), x, currentY); lines.push(line.trim());} return lines.length * lineHeight;
Â  Â  }
Â  Â  /**
Â * A cache for the fetched KaTeX stylesheet to avoid re-fetching.
Â */
/**
Â * A cache for the fetched KaTeX stylesheet to avoid re-fetching.
Â */
/**
Â * A cache for the fetched KaTeX stylesheet to avoid re-fetching.
Â */
/**
Â * A cache for the fetched KaTeX stylesheet to avoid re-fetching.
Â */
let katexCSSInlined = null;

function abToBase64(ab) {
Â  const CHUNK = 0x8000;
Â  const bytes = new Uint8Array(ab);
Â  let binary = '';
Â  for (let i = 0; i < bytes.length; i += CHUNK) {
Â  Â  binary += String.fromCharCode(...bytes.subarray(i, i + CHUNK));
Â  }
Â  return btoa(binary);
}

async function getKatexCSSWithEmbeddedFonts() {
Â  if (katexCSSInlined) return katexCSSInlined;

Â  const base = 'https://cdn.jsdelivr.net/npm/katex@0.16.10/dist';
Â  let css = await (await fetch(`${base}/katex.min.css`)).text();

Â  // Minimal set that covers typical inline math + delimiters
Â  const fonts = [
Â  Â  'KaTeX_Main-Regular.woff2',
Â  Â  'KaTeX_Main-Italic.woff2',
Â  Â  'KaTeX_Main-Bold.woff2',
Â  Â  'KaTeX_Math-Italic.woff2',
Â  Â  'KaTeX_AMS-Regular.woff2',
Â  Â  'KaTeX_Size1-Regular.woff2',
Â  Â  'KaTeX_Size2-Regular.woff2'
Â  ];

Â  for (const name of fonts) {
Â  Â  const url = `${base}/fonts/${name}`;
Â  Â  const res = await fetch(url);
Â  Â  const b64 = abToBase64(await res.arrayBuffer());
Â  Â  const dataURL = `url(data:font/woff2;base64,${b64}) format("woff2")`;
Â  Â  css = css.replace(
Â  Â  Â  new RegExp(`url\\([^)]*${name}[^)]*\\)\\s*format\\("woff2"\\)`, 'g'),
Â  Â  Â  dataURL
Â  Â  );
Â  }

Â  katexCSSInlined = css;
Â  return katexCSSInlined;
}
// Wait until the UI font used for headline text is available
async function ensureHeadlineFontsLoaded() {
Â  try {
Â  Â  const family = (currentLang === 'en') ? 'Manrope' : 'Montserrat Arm';
Â  Â  // Load a specific face/size so measureText uses the right metrics
Â  Â  if (document.fonts && document.fonts.load) {
Â  Â  Â  // Try to load; don't hang forever if the browser doesn't support it
Â  Â  Â  await Promise.race([
Â  Â  Â  Â  (async () => {
Â  Â  Â  Â  Â  await document.fonts.load(`20px "${family}"`);
Â  Â  Â  Â  Â  await document.fonts.ready; // resolves when all pending fonts are ready
Â  Â  Â  Â  })(),
Â  Â  Â  Â  new Promise(res => setTimeout(res, 800)) // safety timeout
Â  Â  Â  ]);
Â  Â  }
Â  } catch (_) { /* ignore */ }
}

// Mixed text + KaTeX headline renderer (SVG with embedded KaTeX fonts)
// - Segments delimited by /K ... K/ are rendered with KaTeX
// - Lines are wrapped to widthFraction of the canvas and centered per line
// - Adds 2px pad in SVG to prevent right-edge clipping of last glyphs
async function renderComplexHeadline(bgCtx, headline, y, opts = {}) {
Â  if (!headline || !bgCtx) return;

Â  // ---- config ----
Â  const widthFraction = Math.min(Math.max(opts.widthFraction ?? 0.88, 0.5), 0.98);
Â  const yNudge = opts.yNudge ?? -14;
Â  const fontSize = 20;
Â  const mathFontSize = 22;

Â  const fontColor =
Â  Â  getComputedStyle(document.documentElement)
Â  Â  Â  .getPropertyValue('--thelo-text')
Â  Â  Â  .trim() || '#111827';

Â  // KaTeX CSS with embedded fonts (so data-URL SVG can render the same as DOM)
Â  const katexCSS = await getKatexCSSWithEmbeddedFonts();

Â  // Extra font-family overrides to keep headline matching MCQs
Â  const extraRules = `
.katex, .katex .mathnormal { font-family: "KaTeX_Main", serif !important; }
.katex .mathit, .katex .textit { font-family: "KaTeX_MathItalic", serif !important; }
.katex .mathsf, .katex .textsf { font-family: "KaTeX_SansSerif", sans-serif !important; }
.katex .mathtt, .katex .texttt { font-family: "KaTeX_Typewriter", monospace !important; }
`;

Â  // ---- parse headline into segments: /K ... K/ => math
Â  const segments = (headline.split(/(\/K[\s\S]*?K\/)/g) || [])
Â  Â  .filter(Boolean)
Â  Â  .map(p =>
Â  Â  Â  p.startsWith('/K') && p.endsWith('K/')
Â  Â  Â  Â  ? { type: 'math', content: p.replace(/^\/K\s*/, '').replace(/\s*K\/$/, '') }
Â  Â  Â  Â  : { type: 'text', content: p }
Â  Â  );

Â  // A hidden host for measuring KaTeX DOM sizes (one per call)
Â  const measureHost = document.createElement('div');
Â  measureHost.style.position = 'absolute';
Â  measureHost.style.visibility = 'hidden';
Â  measureHost.style.left = '-9999px';
Â  measureHost.style.top = '-9999px';
Â  document.body.appendChild(measureHost);

Â  // ---- tokenize with measurements ----
Â  const tokens = [];
Â  for (const seg of segments) {
Â  Â  if (seg.type === 'text') {
Â  Â  Â  const parts = seg.content.match(/(\s+|[^\s]+)/g) || [];
Â  Â  Â  for (const p of parts) {
Â  Â  Â  Â  tokens.push({
Â  Â  Â  Â  Â  type: 'text',
Â  Â  Â  Â  Â  content: p,
Â  Â  Â  Â  Â  width: bgCtx.measureText(p).width,
Â  Â  Â  Â  Â  height: fontSize,
Â  Â  Â  Â  Â  isSpace: /^\s+$/.test(p)
Â  Â  Â  Â  });
Â  Â  Â  }
Â  Â  Â  continue;
Â  Â  }

Â  Â  // math segment
Â  Â  try {
Â  Â  Â  const html = katex.renderToString(seg.content, { throwOnError: false, output: 'html' });

Â  Â  Â  Â const style = document.createElement('style');
Â style.textContent = katexCSS;Â  Â  Â  Â  Â  // the CSS you built with embedded fonts
Â measureHost.appendChild(style);

Â const tmp = document.createElement('div');
Â tmp.style.color = fontColor;
Â tmp.style.fontSize = `${mathFontSize}px`;
Â tmp.innerHTML = html;
Â measureHost.appendChild(tmp);

Â  Â  Â  const katexEl = tmp.querySelector('.katex') || tmp;
Â  Â  Â  const rect = katexEl.getBoundingClientRect();

Â  Â  Â  // remove measured node (keep host)
Â  Â  Â  tmp.remove();

Â  Â  Â  // Pad & round to avoid clipping last glyphs
Â  Â  Â  const PAD = 10; // More aggressive padding to guarantee space
Â  Â  Â  const w = Math.ceil(rect.width) + PAD;
Â  Â  Â  const h = Math.ceil(rect.height) + PAD;

Â  Â  Â  const svg = `
Â  Â  Â  Â  <svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}">
Â  Â  Â  Â  Â  <style>${katexCSS}\n${extraRules}</style>
Â  Â  Â  Â  Â  <foreignObject width="100%" height="100%">
Â  Â  Â  Â  Â  Â  <div xmlns="http://www.w3.org/1999/xhtml"
Â  Â  Â  Â  Â  Â  Â  Â  Â style="color:${fontColor};font-size:${mathFontSize}px;line-height:initial;display:inline-block;">
Â  Â  Â  Â  Â  Â  Â  ${html}
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  </foreignObject>
Â  Â  Â  Â  </svg>`;

Â  Â  Â  const dataUrl = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svg)));
Â  Â  Â  const image = new Image();
Â  Â  Â  image.src = dataUrl;
Â  Â  Â  await image.decode();

Â  Â  Â  tokens.push({ type: 'math', image, width: w, height: h, drawW: w, drawH: h });
Â  Â  } catch (e) {
Â  Â  Â  // graceful fallback to text measurement
Â  Â  Â  const w = bgCtx.measureText(seg.content).width;
Â  Â  Â  tokens.push({ type: 'text', content: seg.content, width: w, height: fontSize, isSpace: false });
Â  Â  }
Â  }

Â  // cleanup measure host
Â  measureHost.remove();

Â  // ---- build lines to fit available width ----
Â  const canvasW = bgCtx.canvas.width / (window.devicePixelRatio || 1);
Â  const maxWidth = canvasW * widthFraction;
Â  const lineGap = 8;

Â  const lines = [];
Â  let line = { tokens: [], width: 0, height: fontSize };

Â  for (const t of tokens) {
Â  Â  // allow scaling down oversized math to fit
Â  Â  let width = t.width, height = t.height, drawW = t.drawW ?? t.width, drawH = t.drawH ?? t.height;

Â  Â  if (t.type === 'math' && width > maxWidth) {
Â  Â  Â  const s = maxWidth / width;
Â  Â  Â  width = Math.floor(width * s);
Â  Â  Â  height = Math.floor(height * s);
Â  Â  Â  drawW = t.drawW * s;
Â  Â  Â  drawH = t.drawH * s;
Â  Â  }
Â  Â  const tok = { ...t, width, height, drawW, drawH };

Â  Â  if (line.tokens.length && line.width + width > maxWidth) {
Â  Â  Â  lines.push(line);
Â  Â  Â  line = { tokens: [], width: 0, height: fontSize };
Â  Â  }
Â  Â  if (!(line.tokens.length === 0 && tok.isSpace)) {
Â  Â  Â  line.tokens.push(tok);
Â  Â  Â  line.width += width;
Â  Â  Â  if (height > line.height) line.height = height;
Â  Â  }
Â  }
Â  if (line.tokens.length) lines.push(line);

Â  // ---- render lines, centered horizontally ----
Â  const prevAlign = bgCtx.textAlign;
Â  const prevBase = bgCtx.textBaseline;
Â  const prevFill = bgCtx.fillStyle;

Â  bgCtx.fillStyle = fontColor;
Â  bgCtx.textAlign = 'left';
Â  bgCtx.textBaseline = 'top';

Â  let curY = y + yNudge;
Â  for (const L of lines) {
Â  Â  let x = (canvasW - L.width) / 2;
Â  Â  for (const t of L.tokens) {
Â  Â  Â  const topY = curY + (L.height - t.height) / 2;
Â  Â  Â  if (t.type === 'text') {
Â  Â  Â  Â  bgCtx.fillText(t.content, x, topY);
Â  Â  Â  } else {
Â  Â  Â  Â  bgCtx.drawImage(t.image, x, topY, t.drawW, t.drawH);
Â  Â  Â  }
Â  Â  Â  x += t.width;
Â  Â  }
Â  Â  curY += L.height + lineGap;
Â  }

Â  // restore ctx
Â  bgCtx.textAlign = prevAlign || 'center';
Â  bgCtx.textBaseline = prevBase || 'top';
Â  bgCtx.fillStyle = prevFill || fontColor;
}



	Â  function stopCurrentStageAudio(){ if (currentStageAudio && !currentStageAudio.paused) { currentStageAudio.pause(); console.log("Current stage audio paused.");} }

Â  Â  function playStageAudio(
Â  Â  audioSrc,
Â  Â  onLoadedMetadataCallback,
Â  Â  onEndedCallback,
Â  Â  isResuming = false
Â  Â  ) {
Â  Â  /* â”€â”€â”€â”€â”€ early-out if a modal overlay is open â”€â”€â”€â”€â”€ */
Â  Â  if (isThelobookActive || isPageGridVisible || isCalculatorActive) {
Â  Â  if (onLoadedMetadataCallback) onLoadedMetadataCallback(0);
Â  Â  if (onEndedCallback) onEndedCallback();
Â  Â  return;
Â  Â  }

Â  Â  currentStageAudio = stageAudioPlayer; // make sure weâ€™re pointing at the right element

Â  Â  /* â”€â”€â”€â”€â”€ RESUME PATH â”€â”€â”€â”€â”€
Â  Â  Â  Â  Only run this branch if weâ€™re *resuming* and the element
Â  Â  Â  Â  already has the same source.Â  We now compare the canonical
Â  Â  Â  Â  absolute URLs instead of using `.includes()`. */
Â  Â  if (
Â  Â  isResuming &&
Â  Â  currentStageAudio &&
Â  Â  currentStageAudio.src &&
Â  Â  new URL(currentStageAudio.src, document.baseURI).href ===
Â  Â  Â  Â  new URL(audioSrc, document.baseURI).href
Â  Â  ) {
Â  Â  const audioEffectivelyAtEnd =
Â  Â  Â  Â  currentStageAudio.duration > 0 &&
Â  Â  Â  Â  audioTimeBeforeThelobook >= currentStageAudio.duration - 0.05;

Â  Â  if (wasMediaPlayingBeforeThelobook && !audioEffectivelyAtEnd) {
Â  Â  Â  Â  if (window.userInteracted && currentStageAudio.paused) {
Â  Â  Â  Â  currentStageAudio
Â  Â  Â  Â  Â  Â  .play()
Â  Â  Â  Â  Â  Â  .catch((e) => console.warn("Resume audio play failed:", e));
Â  Â  Â  Â  }
Â  Â  }

Â  Â  // wire callbacks (or call immediately if metadata already available)
Â  Â  if (onLoadedMetadataCallback) {
Â  Â  Â  Â  if (
Â  Â  Â  Â  currentStageAudio.readyState >= HTMLMediaElement.HAVE_METADATA
Â  Â  Â  Â  ) {
Â  Â  Â  Â  onLoadedMetadataCallback(currentStageAudio.duration);
Â  Â  Â  Â  } else {
Â  Â  Â  Â  const tempMetaListener = () => {
Â  Â  Â  Â  Â  Â  onLoadedMetadataCallback(currentStageAudio.duration);
Â  Â  Â  Â  Â  Â  currentStageAudio.removeEventListener(
Â  Â  Â  Â  Â  Â  "loadedmetadata",
Â  Â  Â  Â  Â  Â  tempMetaListener
Â  Â  Â  Â  Â  Â  );
Â  Â  Â  Â  };
Â  Â  Â  Â  currentStageAudio.addEventListener(
Â  Â  Â  Â  Â  Â  "loadedmetadata",
Â  Â  Â  Â  Â  Â  tempMetaListener
Â  Â  Â  Â  );
Â  Â  Â  Â  }
Â  Â  }
Â  Â  if (onEndedCallback) currentStageAudio.onended = onEndedCallback;
Â  Â  return; // â† nothing else to do
Â  Â  }

Â  Â  /* â”€â”€â”€â”€â”€ FULL (re-)INITIALISATION PATH â”€â”€â”€â”€â”€ */
Â  Â  if (currentStageAudio && !currentStageAudio.paused) {
Â  Â  currentStageAudio.pause();
Â  Â  }
Â  Â  if (currentStageAudio) {
Â  Â  currentStageAudio.onloadedmetadata = null;
Â  Â  currentStageAudio.onended = null;
Â  Â  }

Â  Â  if (!audioSrc) {
Â  Â  if (onLoadedMetadataCallback) onLoadedMetadataCallback(0);
Â  Â  if (onEndedCallback) onEndedCallback();
Â  Â  return;
Â  Â  }

Â  Â  currentStageAudio.src = audioSrc;
Â  Â  currentStageAudio.preload = "auto";

Â  Â  let loadedMetaCalled = false;
Â  Â  currentStageAudio.onloadedmetadata = () => {
Â  Â  if (!loadedMetaCalled && onLoadedMetadataCallback) {
Â  Â  Â  Â  loadedMetaCalled = true;
Â  Â  Â  Â  onLoadedMetadataCallback(currentStageAudio.duration);
Â  Â  }
Â  Â  };
Â  Â  if (onEndedCallback) currentStageAudio.onended = onEndedCallback;

Â  Â  currentStageAudio.load();
Â  Â  if (window.userInteracted) {
Â  Â  const playPromise = currentStageAudio.play();
Â  Â  if (playPromise) {
Â  Â  Â  Â  playPromise.catch((error) => {
Â  Â  Â  Â  console.warn("Audio play failed (full init):", error);
Â  Â  Â  Â  if (onEndedCallback) onEndedCallback();
Â  Â  Â  Â  });
Â  Â  }
Â  Â  } else {
Â  Â  console.warn("Audio interaction needed for autoplay.");
Â  Â  }
Â  Â  }
// Render mixed text + /K ... K/ math into a target element (e.g., a button)
function renderMixedKaTeXInto(targetEl, src) {
Â  // Clear current content
Â  while (targetEl.firstChild) targetEl.removeChild(targetEl.firstChild);

Â  if (!src) return;

Â  const parts = src.split(/(\/K[\s\S]*?K\/)/g).filter(Boolean);

Â  for (const part of parts) {
Â  Â  const isMath = part.startsWith('/K') && part.endsWith('K/');
Â  Â  if (!isMath) {
Â  Â  Â  targetEl.appendChild(document.createTextNode(part));
Â  Â  Â  continue;
Â  Â  }

Â  Â  const expr = part.replace(/^\/K\s*/, '').replace(/\s*K\/$/, '');
Â  Â  const span = document.createElement('span');

Â  Â  try {
Â  Â  Â  // Render KaTeX directly into the span (no innerHTML injection)
Â  Â  Â  katex.render(expr, span, { throwOnError: false });

Â  Â  } catch (e) {
Â  Â  Â  // Graceful fallback
Â  Â  Â  span.textContent = expr;
Â  Â  }
Â  Â  targetEl.appendChild(span);
Â  }
}

function displayMcq(mcqDetails){
Â  Â  const choices = mcqDetails.choices;
Â  Â  if (!mcqOptionsContainer || !mcqDetails || !Array.isArray(choices) || choices.length === 0) return;
Â  Â  if (isPageGridVisible) closePageGridView();

Â  Â  mcqOptionsContainer.innerHTML = '';
Â  Â  document.body.classList.add('mcq-active'); // Activate keyboard-only CSS

Â  Â  /* ===== Smartâ€‘layout Logic (Unchanged) ===== */
Â  Â  const isShort = choices.every(choice => choice.length < 10);
Â  Â  mcqOptionsContainer.className = isShort ? 'short-options' : 'long-options';
Â  Â  const isSideBySide = !!(currentStageData && currentStageData.image);
Â  Â  mcqOptionsContainer.classList.toggle('side-by-side', isSideBySide);
Â  Â Â 
Â  Â  choices.forEach((optionText, index) => {
Â  Â  Â  Â  const optionButton = document.createElement('button');
Â  Â  Â  Â  optionButton.classList.add('mcq-option-btn');
Â  Â  Â  Â  renderMixedKaTeXInto(optionButton, optionText);
Â  Â  Â  Â  optionButton.dataset.index = index;
Â  Â  Â  Â  // NO click listener
Â  Â  Â  Â  mcqOptionsContainer.appendChild(optionButton);
Â  Â  });

Â  Â  mcqOptionsContainer.style.display = 'flex';
Â  Â  mcqOptionsContainer.style.opacity = '1';

Â  Â  // Set the initial selection to the first option
Â  Â  updateMcqSelectionVisuals(0);Â 
}
/**
Â * Updates the visual state of MCQ buttons based on the selected index.
Â * @param {number} newIndex - The index of the MCQ option to select.
Â */
function updateMcqSelectionVisuals(newIndex) {
Â  Â  if (!mcqOptionsContainer) return;
Â  Â  selectedMcqIndex = newIndex; // Update the global state

Â  Â  const optionButtons = mcqOptionsContainer.querySelectorAll('.mcq-option-btn');
Â  Â  optionButtons.forEach((btn, index) => {
Â  Â  Â  Â  btn.classList.toggle('selected', index === newIndex);
Â  Â  });
}Â  // Replace your old function with this simplified version
function handleMcqOptionClick(selectedIndex, mcqDetails){
Â  Â  return; // Clicks are disabled
}/**
Â * Toggles a distraction-free fullscreen mode that hides the browser's
Â * default 'X' button on interaction.
Â */
function toggleFocusFullscreen() {
Â  Â  // Check if we are currently in any fullscreen mode
Â  Â  if (!document.fullscreenElement) {
Â  Â  Â  Â  // If not, request fullscreen for the whole page
Â  Â  Â  Â  document.documentElement.requestFullscreen({
Â  Â  Â  Â  Â  Â  navigationUI: 'hide' // This is the magic property!
Â  Â  Â  Â  }).catch(err => {
Â  Â  Â  Â  Â  Â  // Log any errors if the request fails
Â  Â  Â  Â  Â  Â  console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
Â  Â  Â  Â  });
Â  Â  } else {
Â  Â  Â  Â  // If we are in fullscreen, exit it
Â  Â  Â  Â  if (document.exitFullscreen) {
Â  Â  Â  Â  Â  Â  document.exitFullscreen();
Â  Â  Â  Â  }
Â  Â  }
}
	// REPLACE your entire renderStageUI function with this one
/**
Â * Draws the stage image onto the background canvas with the correct layout,
Â * positioning it to the side if MCQs are present, otherwise centering it.
Â * @param {CanvasRenderingContext2D} bgCtx - The context of the background canvas.
Â * @param {HTMLImageElement} img - The image to draw.
Â * @param {object} currentStageData - The data for the current stage.
Â */
function drawImageWithCorrectLayout(bgCtx, img, currentStageData) {
Â  Â  const canvasWidth = bgCtx.canvas.width / devicePixelRatio;
Â  Â  const canvasHeight = bgCtx.canvas.height / devicePixelRatio;
Â  Â Â 
Â  Â  // Determine if the stage also has an MCQ to display.
Â  Â  const hasMcq = currentStageData.optionsQuiz && Array.isArray(currentStageData.optionsQuiz.choices);

Â  Â  if (hasMcq) {
Â  Â  Â  Â  // --- Side-by-Side Layout Logic ---
Â  Â  Â  Â  const sidePad = canvasWidth * 0.04;Â  Â  Â  // 4% gutter
Â  Â  Â  Â  const maxImgWidth = canvasWidth * 0.48;Â  Â // ~50% of board
Â  Â  Â  Â  const maxImgHeight = canvasHeight * 0.85; // Leave vertical room
Â  Â  Â  Â  const scale = Math.min(maxImgWidth / img.width, maxImgHeight / img.height);
Â  Â  Â  Â Â 
Â  Â  Â  Â  const scaledWidth = img.width * scale;
Â  Â  Â  Â  const scaledHeight = img.height * scale;
Â  Â  Â  Â  const x = sidePad; // Position on the left
Â  Â  Â  Â  const y = (canvasHeight - scaledHeight) / 2; // Vertically centered
Â  Â  Â  Â  bgCtx.drawImage(img, x, y, scaledWidth, scaledHeight);

Â  Â  } else {
Â  Â  Â  Â  // --- Default Centered Layout Logic ---
Â  Â  Â  Â  const maxSizePercentage = 0.50;
Â  Â  Â  Â  const maxContainerWidth = canvasWidth * maxSizePercentage;
Â  Â  Â  Â  const maxContainerHeight = canvasHeight * maxSizePercentage;
Â  Â  Â  Â  const scale = Math.min(maxContainerWidth / img.width, maxContainerHeight / img.height);
Â  Â  Â  Â Â 
Â  Â  Â  Â  const scaledWidth = img.width * scale;
Â  Â  Â  Â  const scaledHeight = img.height * scale;
Â  Â  Â  Â  const x = (canvasWidth - scaledWidth) / 2; // Horizontally centered
Â  Â  Â  Â  const y = (canvasHeight - scaledHeight) / 2; // Vertically centered
Â  Â  Â  Â  bgCtx.drawImage(img, x, y, scaledWidth, scaledHeight);
Â  Â  }
}
/**
Â * Opens the replay player, fetches the replay data, and sends it to the iframe.
Â */
// In your MAIN app's <script> tag

// In your MAIN app's <script> tag
async function openReplayPlayer() {
Â  Â  if (isReplayActive || !currentStageData || !currentStageData.replayDataUrl) {
Â  Â  Â  Â  return;
Â  Â  }
Â  Â  isReplayActive = true;

Â  Â  try {
Â  Â  Â  Â  const response = await fetch(currentStageData.replayDataUrl);
Â  Â  Â  Â  const replayJson = await response.json();
Â  Â  Â  Â  const replayActions = replayJson.actions;

Â  Â  Â  Â  const onIframeReady = (event) => {
Â  Â  Â  Â  Â  Â  if (event.source === replayFrame.contentWindow && event.data.command === 'ready') {
Â  Â  Â  Â  Â  Â  Â  Â  replayFrame.contentWindow.postMessage({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  command: 'loadTimeline',
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  actions: replayActions
Â  Â  Â  Â  Â  Â  Â  Â  }, '*');

Â  Â  Â  Â  Â  Â  Â  Â  window.removeEventListener('message', onIframeReady);

Â  Â  Â  Â  Â  Â  Â  Â  // Start the main app's playback loop
Â  Â  Â  Â  Â  Â  Â  Â  isMediaScrubbingActive = true;
Â  Â  Â  Â  Â  Â  Â  Â  lastFrameTimestampForManualAdvance = 0;
Â  Â  Â  Â  Â  Â  Â  Â  internalPlaybackTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  currentReplayAnimationId = requestAnimationFrame(mediaPlaybackLoop);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  };

Â  Â  Â  Â  window.addEventListener('message', onIframeReady);
Â  Â  Â  Â  replayFrame.src = 'https://thelo.space/replay'; // Or your replay URL
Â  Â  Â  Â  replayPlayerContainer.classList.remove('replay-hidden');

Â  Â  } catch (error) {
Â  Â  Â  Â  console.error("Failed to load or send replay data:", error);
Â  Â  Â  Â  isReplayActive = false;
Â  Â  }
}
		// In your MAIN app's <script> tag
function closeReplayPlayer() {
Â  Â  if (!isReplayActive) return;
Â  Â  isReplayActive = false;

Â  Â  // CRITICAL: Stop the main app's animation loop
Â  Â  if (currentReplayAnimationId) {
Â  Â  Â  Â  cancelAnimationFrame(currentReplayAnimationId);
Â  Â  Â  Â  currentReplayAnimationId = null;
Â  Â  }
Â  Â  isMediaScrubbingActive = false;

Â  Â  replayPlayerContainer.classList.add('replay-hidden');
Â  Â  replayFrame.src = 'about:blank';
}
// In your main HTML file, REPLACE your entire renderStageUI function with this one.

function renderStageUI(index, isResize = false) {
Â  Â  return new Promise(async (resolve, reject) => {
Â  Â  Â  Â  if (isLessonLoading || index < 0 || index >= lessonStages.length) {
Â  Â  Â  Â  Â  Â  if (index < 0) {
Â  Â  Â  Â  Â  Â  Â  Â  if (nextCheckBtn) { nextCheckBtn.disabled = true; nextCheckBtn.textContent = getCurrentUIText().start; }
Â  Â  Â  Â  Â  Â  Â  Â  if (prevBtn) prevBtn.disabled = true;
Â  Â  Â  Â  Â  Â  Â  Â  if (clearBtn && clearBtn.style) clearBtn.style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  if (colorIndicator && colorIndicator.style) colorIndicator.style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  if (mcqOptionsContainer && mcqOptionsContainer.style) mcqOptionsContainer.style.display = 'none';
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  return resolve();
Â  Â  Â  Â  }

Â  Â  Â  Â  const TXT = getCurrentUIText();
Â  Â  Â  Â  if (!isResize && isThelobookActive) closeThelobook(true);
Â  Â  Â  Â  if (!isResize && isPageGridVisible) closePageGridView();
Â  Â  Â  Â  if (!isResize) closeReplayPlayer();

Â  Â  Â  Â  if (!isResize) {
Â  Â  Â  Â  Â  Â  if (currentReplayAnimationId) { cancelAnimationFrame(currentReplayAnimationId); currentReplayAnimationId = null; }
Â  Â  Â  Â  Â  Â  if (currentStageAudio && !currentStageAudio.paused) { currentStageAudio.pause(); currentStageAudio.currentTime = 0; currentStageAudio.onloadedmetadata = null; currentStageAudio.onended = null; }
Â  Â  Â  Â  Â  Â  isMediaScrubbingActive = false; currentStageDrawingData = null; currentStageTotalDuration = 0; internalPlaybackTime = 0; lastFrameTimestampForManualAdvance = 0;
Â  Â  Â  Â  Â  Â  if (stageProgressBarContainer) stageProgressBarContainer.classList.remove('visible');
Â  Â  Â  Â  Â  Â  if (stageProgressFill) stageProgressFill.style.width = '0%';
Â  Â  Â  Â  }

Â  Â  Â  Â  currentStageData = lessonStages[index];
Â  Â  Â  Â  currentStageIndex = index;
Â  Â  Â  Â  isStudentInputAllowed = currentStageData.studentInput === true;

Â  Â  Â  Â  if (mcqOptionsContainer) { mcqOptionsContainer.innerHTML = ''; mcqOptionsContainer.style.display = 'none'; }

Â  Â  Â  Â  if (bgCtx) bgCtx.clearRect(0, 0, backgroundCanvas.width / devicePixelRatio, backgroundCanvas.height / devicePixelRatio);
Â  Â  Â  Â  if (!isResize) {
Â  Â  Â  Â  Â  Â  clearUserCanvas();
Â  Â  Â  Â  Â  Â  if (replayCtx) replayCtx.clearRect(0, 0, replayCanvas.width / devicePixelRatio, replayCanvas.height / devicePixelRatio);
Â  Â  Â  Â  }

Â  Â  Â  Â  function drawImageWithCorrectLayout(bgCtx, img, currentStageData) {
Â  Â  Â  Â  Â  Â  const canvasWidth = bgCtx.canvas.width / devicePixelRatio;
Â  Â  Â  Â  Â  Â  const canvasHeight = bgCtx.canvas.height / devicePixelRatio;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  const hasMcq = currentStageData.optionsQuiz && Array.isArray(currentStageData.optionsQuiz.choices);

Â  Â  Â  Â  Â  Â  if (hasMcq) {
Â  Â  Â  Â  Â  Â  Â  Â  const sidePad = canvasWidth * 0.04;
Â  Â  Â  Â  Â  Â  Â  Â  const maxImgWidth = canvasWidth * 0.48;
Â  Â  Â  Â  Â  Â  Â  Â  const maxImgHeight = canvasHeight * 0.85;
Â  Â  Â  Â  Â  Â  Â  Â  const scale = Math.min(maxImgWidth / img.width, maxImgHeight / img.height);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  const scaledWidth = img.width * scale;
Â  Â  Â  Â  Â  Â  Â  Â  const scaledHeight = img.height * scale;
Â  Â  Â  Â  Â  Â  Â  Â  const x = sidePad;
Â  Â  Â  Â  Â  Â  Â  Â  const y = (canvasHeight - scaledHeight) / 2;
Â  Â  Â  Â  Â  Â  Â  Â  bgCtx.drawImage(img, x, y, scaledWidth, scaledHeight);
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  const maxSizePercentage = 0.50;
Â  Â  Â  Â  Â  Â  Â  Â  const maxContainerWidth = canvasWidth * maxSizePercentage;
Â  Â  Â  Â  Â  Â  Â  Â  const maxContainerHeight = canvasHeight * maxSizePercentage;
Â  Â  Â  Â  Â  Â  Â  Â  const scale = Math.min(maxContainerWidth / img.width, maxContainerHeight / img.height);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  const scaledWidth = img.width * scale;
Â  Â  Â  Â  Â  Â  Â  Â  const scaledHeight = img.height * scale;
Â  Â  Â  Â  Â  Â  Â  Â  const x = (canvasWidth - scaledWidth) / 2;
Â  Â  Â  Â  Â  Â  Â  Â  const y = (canvasHeight - scaledHeight) / 2;
Â  Â  Â  Â  Â  Â  Â  Â  bgCtx.drawImage(img, x, y, scaledWidth, scaledHeight);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  async function drawHeadlineText() {
Â  Â  Â  Â  Â  Â  const padding = 27;
Â  Â  Â  Â  Â  Â  let headlineCurrentY = padding * 2;
Â  Â  Â  Â  Â  Â  const headlineText = currentStageData.headline || '';

Â  Â  Â  Â  Â  Â  if (headlineText && bgCtx && bgCtx.canvas.width > 0) {
Â  Â  Â  Â  Â  Â  Â  // FIX: This line is updated to use 'Montserrat Arm'
Â  Â  Â  Â  Â  Â  Â  Â  const fontFamily = currentLang === 'en' ? "'Manrope', system-ui, sans-serif" : "'Montserrat Arm', system-ui, sans-serif";
Â  Â  Â  Â  Â  Â  Â  Â  bgCtx.font = `20px ${fontFamily}`;
Â  Â  Â  Â  Â  Â  Â  Â  await ensureHeadlineFontsLoaded();
Â  Â  Â  Â  Â  Â  Â  Â  await renderComplexHeadline(bgCtx, headlineText, headlineCurrentY + 10);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  function setupStageContent() {
Â  Â  Â  Â  Â  Â  const mcqDetails = currentStageData.optionsQuiz;
Â  Â  Â  Â  Â  Â  const isMCQDisplayStage = currentStageData.type === "explanation_with_mcq" && mcqDetails && Array.isArray(mcqDetails.choices) && mcqDetails.choices.length > 0;
Â  Â  Â  Â  Â  Â  const isQuestionStage = currentStageData.type === 'question_handwriting' || currentStageData.type === 'question_math_solution' || isMCQDisplayStage;

Â  Â  Â  Â  Â  Â  if (!isMCQDisplayStage && nextCheckBtn) {
Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.style.display = 'inline-flex';
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  if (currentStageData.type === 'calculator_replay') {
Â  Â  Â  Â  Â  Â  Â  Â  openReplayPlayer();
Â  Â  Â  Â  Â  Â  Â  Â  if (!isResize) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  internalPlaybackTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lastFrameTimestampForManualAdvance = 0;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  const audioMetaPromise = new Promise((resolveAudio) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (currentStageData.audioFile) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  playStageAudio(currentStageData.audioFile, (duration) => resolveAudio(duration || 0), () => { }, isResize);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  resolveAudio(0);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  const replayDataDurationPromise = fetch(currentStageData.replayDataUrl)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  .then(r => r.ok ? r.json() : Promise.reject(`HTTP ${r.status}`))
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  .then(json => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let totalReplayTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  json.actions.forEach(action => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (action.action === 'delay') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  totalReplayTime += action.ms;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (action.action === 'animateView') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  totalReplayTime += action.payload.duration;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return totalReplayTime / 1000;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  })
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  .catch(e => { console.error("Failed to load replay data for duration calculation:", e); return 0; });
Â  Â  Â  Â  Â  Â  Â  Â  Promise.all([audioMetaPromise, replayDataDurationPromise]).then(([audioDuration, replayDuration]) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentStageTotalDuration = Math.max(audioDuration, replayDuration);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isMediaScrubbingActive = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  updateMediaProgressBar(internalPlaybackTime, currentStageTotalDuration);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (stageProgressBarContainer) stageProgressBarContainer.classList.add('visible');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!currentReplayAnimationId) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentReplayAnimationId = requestAnimationFrame(mediaPlaybackLoop);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }).catch(e => console.error("Error setting up replay stage durations:", e));
Â  Â  Â  Â  Â  Â  Â  Â  if (nextCheckBtn) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.textContent = TXT.gotIt;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.disabled = false;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if (clearBtn) clearBtn.style.display = 'none';
Â  Â  Â  Â  Â  Â  } else if (isQuestionStage) {
Â  Â  Â  Â  Â  Â  Â  Â  if (!isResize) isMediaScrubbingActive = false;
Â  Â  Â  Â  Â  Â  Â  Â  if (stageProgressBarContainer) stageProgressBarContainer.classList.remove('visible');
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (isMCQDisplayStage && mcqDetails) {
Â  Â  Â  Â  Â  Â  if (bottomBar) bottomBar.style.display = 'flex';
Â  Â  Â  Â  Â  Â  displayMcq(mcqDetails);
Â  Â  Â  Â  Â  Â  if (clearBtn) clearBtn.style.display = 'none';

Â  Â  Â  Â  Â  Â  if (nextCheckBtn) {
Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.style.display = 'inline-flex';
Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.disabled = false; // Button starts ENABLED for keyboard
Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.textContent = TXT.check;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  } else if (currentStageData.type === 'question_handwriting' || currentStageData.type === 'question_math_solution') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (bottomBar) bottomBar.style.display = 'flex';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (nextCheckBtn) { nextCheckBtn.textContent = TXT.check; nextCheckBtn.disabled = false; }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (clearBtn) clearBtn.style.display = 'inline-flex';
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if (currentStageData.audioFile) { playStageAudio(currentStageData.audioFile, (d) => { }, () => { }, isResize); }
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  if (bottomBar) bottomBar.style.display = 'flex';
Â  Â  Â  Â  Â  Â  Â  Â  if (mcqOptionsContainer) mcqOptionsContainer.style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  const isDrawingInputStage = currentStageData.studentInput === true;
Â  Â  Â  Â  Â  Â  Â  Â  if (clearBtn) clearBtn.style.display = isDrawingInputStage ? 'inline-flex' : 'none';
Â  Â  Â  Â  Â  Â  Â  Â  if (currentStageData.audioFile || currentStageData.drawingRecord) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!isResize) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isMediaScrubbingActive = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lastFrameTimestampForManualAdvance = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  internalPlaybackTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  updateMediaProgressBar(internalPlaybackTime, currentStageTotalDuration > 0 ? currentStageTotalDuration : 1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const audioMetaPromise = new Promise((resolveAudio) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (currentStageData.audioFile) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  playStageAudio(currentStageData.audioFile, (duration) => resolveAudio(duration || 0), () => { }, isResize);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  resolveAudio(0);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let drawingDataPromise;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (currentStageData.drawingRecord) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!isResize || !currentStageDrawingData) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  drawingDataPromise = fetch(currentStageData.drawingRecord).then(r => r.ok ? r.json() : Promise.reject(`HTTP ${r.status}`)).then(json => { if (!json || !json.strokes) throw "Bad drawing JSON"; currentStageDrawingData = json; return json; }).catch(e => { console.error("Failed to load drawing data:", e); currentStageDrawingData = null; return null; });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  drawingDataPromise = Promise.resolve(currentStageDrawingData);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentStageDrawingData = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  drawingDataPromise = Promise.resolve(null);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Promise.all([audioMetaPromise, drawingDataPromise]).then(([audioDuration, loadedDrawingData]) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (loadedDrawingData) currentStageDrawingData = loadedDrawingData;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const drawingAnimDuration = currentStageDrawingData ? calculateDrawingDuration(currentStageDrawingData) : 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentStageTotalDuration = Math.max(audioDuration, drawingAnimDuration);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (isMediaScrubbingActive && currentStageTotalDuration > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  updateMediaProgressBar(internalPlaybackTime, currentStageTotalDuration);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (stageProgressBarContainer) stageProgressBarContainer.classList.add('visible');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (currentReplayAnimationId) cancelAnimationFrame(currentReplayAnimationId);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentReplayAnimationId = requestAnimationFrame(mediaPlaybackLoop);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isMediaScrubbingActive = false; if (stageProgressBarContainer) stageProgressBarContainer.classList.remove('visible');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentStageAudio = null; currentStageDrawingData = null; currentStageTotalDuration = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (replayCtx) replayCtx.clearRect(0, 0, replayCanvas.width / devicePixelRatio, replayCanvas.height / devicePixelRatio);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if (nextCheckBtn) { nextCheckBtn.textContent = TXT.gotIt; nextCheckBtn.disabled = false; }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  updateColorIndicator();
Â  Â  Â  Â  Â  Â  canvas.style.pointerEvents = (isStudentInputAllowed && !isThelobookActive && !isPageGridVisible && !isReplayActive) ? 'auto' : 'none';
Â  Â  Â  Â  Â  Â  if (nextCheckBtn) { nextCheckBtn.classList.remove('correct', 'incorrect'); nextCheckBtn.style.backgroundColor = ''; }
Â  Â  Â  Â  Â  Â  if (!isResize) userDrawingOccurred = false;
Â  Â  Â  Â  Â  Â  if (prevBtn) prevBtn.disabled = (index === 0 || isThelobookActive || isPageGridVisible || isReplayActive);
Â  Â  Â  Â  Â  Â  if (nextCheckBtn) {
Â  Â  Â  Â  Â  Â  Â  Â  const isCorrectlyAnsweredHW = currentStageData.type === 'question_handwriting' && nextCheckBtn.classList.contains('correct');
Â  Â  Â  Â  Â  Â  Â  Â  if (!isMCQDisplayStage) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.disabled = (isThelobookActive || isPageGridVisible || isCorrectlyAnsweredHW || isReplayActive && !currentStageData.audioFile);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  if (clearBtn) clearBtn.disabled = (isThelobookActive || isPageGridVisible || isReplayActive);
Â  Â  Â  Â  }

Â  Â  Â  Â  if (currentStageData.image && bgCtx) {
Â  Â  Â  Â  Â  Â  const img = new Image();
Â  Â  Â  Â  Â  Â  img.crossOrigin = "Anonymous";
Â  Â  Â  Â  Â  Â  img.src = currentStageData.image;
Â  Â  Â  Â  Â  Â  img.onload = async () => {
Â  Â  Â  Â  Â  Â  Â  Â  drawImageWithCorrectLayout(bgCtx, img, currentStageData);
Â  Â  Â  Â  Â  Â  Â  Â  await drawHeadlineText();
		Â  Â  const isStudentDrawingStage = currentStageData.studentInput === true && currentStageData.type !== 'explanation_with_mcq';

Â  Â  Â  Â  // Show or hide the minimap container based on the stage type
Â  Â  Â  Â  if (minimapContainer) {
Â  Â  Â  Â  Â  Â  if (isStudentDrawingStage) {
Â  Â  Â  Â  Â  Â  Â  Â  minimapContainer.classList.remove('minimap-hidden');
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  minimapContainer.classList.add('minimap-hidden');
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  setupStageContent();
Â  Â  Â  Â  Â  Â  Â  Â  resolve();
Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  img.onerror = async () => {
Â  Â  Â  Â  Â  Â  Â  Â  console.error("Failed to load stage image:", currentStageData.image);
Â  Â  Â  Â  Â  Â  Â  Â  await drawHeadlineText();
Â  Â  Â  Â  Â  Â  Â  Â  setupStageContent();
Â  Â  Â  Â  Â  Â  Â  Â  resolve();
Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  await drawHeadlineText();
Â  Â  Â  Â  Â  Â  setupStageContent();
Â  Â  Â  Â  Â  Â  resolve();
Â  Â  Â  Â  }
Â  Â  });
}Â  Â  Â 
	Â  function transitionToStage(newIndex) {
Â  Â  if (isTransitioning || isLessonLoading || !lessonStages.length) return;
Â  Â  isMcqAnsweredCorrectly = false;
Â  Â  // All feedback is now hidden either by the 'A' key or by advancing a stage.
Â  Â  hideOnCanvasFeedback();

Â  Â  selectedMcqIndex = null;
Â  Â  if (isReplayActive) closeReplayPlayer();
Â  Â  if (isThelobookActive) closeThelobook(true);
Â  Â  if (isPageGridVisible) closePageGridView();

Â  Â  if (currentReplayAnimationId) { cancelAnimationFrame(currentReplayAnimationId); currentReplayAnimationId = null; }
Â  Â  if (currentStageAudio && !currentStageAudio.paused) { currentStageAudio.pause(); currentStageAudio.onloadedmetadata = null; currentStageAudio.onended = null; }
Â  Â  isMediaScrubbingActive = false; currentStageDrawingData = null; currentStageTotalDuration = 0; internalPlaybackTime = 0; lastFrameTimestampForManualAdvance = 0;
Â  Â  if (stageProgressBarContainer) stageProgressBarContainer.classList.remove('visible');
Â  Â  if (stageProgressFill) stageProgressFill.style.width = '0%';

Â  Â  if (newIndex < 0 || newIndex >= lessonStages.length) {
Â  Â  Â  Â  if (newIndex >= lessonStages.length) {
Â  Â  Â  Â  Â  Â  displayLessonComplete();
Â  Â  Â  Â  }
Â  Â  Â  Â  return;
Â  Â  }
Â  Â  isTransitioning = true;
Â  Â  backgroundCanvas.classList.add('fade-out');
Â  Â  if (replayCanvas) replayCanvas.classList.add('fade-out');
Â  Â  if (mcqOptionsContainer) mcqOptionsContainer.style.opacity = 0;

Â  Â  const fadeDuration = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--fade-duration') || '0.3') * 1000;
Â  Â Â 
Â  Â  setTimeout(() => {
Â  Â  Â  Â  currentStageIndex = newIndex;
Â  Â  Â  Â  renderStageUI(currentStageIndex, false).then(() => {
Â  Â  Â  Â  Â  Â  backgroundCanvas.classList.remove('fade-out');
Â  Â  Â  Â  Â  Â  if (replayCanvas) replayCanvas.classList.remove('fade-out');
Â  Â  Â  Â  Â  Â  isTransitioning = false;
Â  Â  Â  Â  });
Â  Â  }, fadeDuration);
}
Â  Â  function nextStage() { transitionToStage(currentStageIndex + 1); }
Â  Â  function previousStage() { if (currentStageIndex > 0 && !isThelobookActive && !isPageGridVisible) transitionToStage(currentStageIndex - 1); }
Â  Â  // FULL UPDATED FUNCTION
async function displayLessonComplete() {
Â  Â  isTransitioning = true;
Â  Â  const TXT = getCurrentUIText();

Â  Â  // --- FIX: START THE UI TRANSITION IMMEDIATELY ---
Â  Â  if (isThelobookActive) closeThelobook(false);
Â  Â  if (isPageGridVisible) closePageGridView();
Â  Â  backgroundCanvas.classList.add('fade-out');
Â  Â  if (replayCanvas) replayCanvas.classList.add('fade-out');
Â  Â  if (mcqOptionsContainer) mcqOptionsContainer.style.display = 'none';
Â  Â  if (currentReplayAnimationId) {
Â  Â  Â  Â  cancelAnimationFrame(currentReplayAnimationId);
Â  Â  Â  Â  currentReplayAnimationId = null;
Â  Â  }
Â  Â  if (currentStageAudio && !currentStageAudio.paused) {
Â  Â  Â  Â  currentStageAudio.pause();
Â  Â  Â  Â  currentStageAudio.currentTime = 0;
Â  Â  }
Â  Â  isMediaScrubbingActive = false;
Â  Â  if (stageProgressBarContainer) stageProgressBarContainer.classList.remove('visible');

Â  Â  setTimeout(() => {
Â  Â  Â  Â  const cssWidth = backgroundCanvas.width / devicePixelRatio;
Â  Â  Â  Â  const cssHeight = backgroundCanvas.height / devicePixelRatio;
Â  Â  Â  Â  bgCtx.clearRect(0, 0, cssWidth, cssHeight);
Â  Â  Â  Â  const fontFamily = currentLang === 'en' ? "'Manrope', system-ui, sans-serif" : "'Montserrat Arm', system-ui, sans-serif";
Â  Â  Â  Â  bgCtx.font = `bold 24px ${fontFamily}`;
Â  Â  Â  Â  bgCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--success-green').trim();
Â  Â  Â  Â  bgCtx.textAlign = 'center';
Â  Â  Â  Â  bgCtx.textBaseline = 'middle';
Â  Â  Â  Â  bgCtx.fillText(TXT.lessonComplete, cssWidth / 2, cssHeight / 3);
Â  Â  Â  Â  clearUserCanvas();
Â  Â  Â  Â  if (replayCtx) replayCtx.clearRect(0, 0, replayCanvas.width / devicePixelRatio, replayCanvas.height / devicePixelRatio);

Â  Â  Â  Â  if (nextCheckBtn) nextCheckBtn.style.display = 'none';
Â  Â  Â  Â  if (prevBtn) prevBtn.style.display = 'none';
Â  Â  Â  Â  if (clearBtn) clearBtn.style.display = 'none';
Â  Â  Â  Â  if (thelobookBtn) thelobookBtn.style.display = 'none';
Â  Â  Â  Â  if (dashboardBtn) {
Â  Â  Â  Â  Â  Â  dashboardBtn.innerHTML = TXT.viewDashboard;
Â  Â  Â  Â  Â  Â  dashboardBtn.classList.add('visible');
Â  Â  Â  Â  }

Â  Â  Â  Â  if (colorIndicator) colorIndicator.style.display = 'none';
Â  Â  Â  Â  addChatMessage('AI', `ğŸ‰ ${TXT.lessonComplete}`);
Â  Â  Â  Â Â 
Â  Â  Â  Â  backgroundCanvas.classList.remove('fade-out');
Â  Â  Â  Â  if (replayCanvas) replayCanvas.classList.remove('fade-out');
Â  Â  Â  Â  isTransitioning = false;
Â  Â  }, parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--fade-duration') || '0.3') * 1000);

Â  Â  // --- DATABASE OPERATIONS IN THE BACKGROUND ---
Â  Â  const user = auth.currentUser;
Â  Â  const urlParams = new URLSearchParams(window.location.search);
Â  Â  const lessonFileName = urlParams.get('lessonFile');

Â  Â  if (user && lessonFileName) {
Â  Â  Â  Â  // Log analytics
Â  Â  Â  Â  if (lessonStartTime) {
Â  Â  Â  Â  Â  Â  const timeToCompleteSeconds = Math.round((Date.now() - lessonStartTime) / 1000);
Â  Â  Â  Â  Â  Â  db.collection("analytics_events").add({
Â  Â  Â  Â  Â  Â  Â  Â  type: "lesson_completed",
Â  Â  Â  Â  Â  Â  Â  Â  userId: user.uid,
Â  Â  Â  Â  Â  Â  Â  Â  lessonId: lessonFileName.replace('.json', ''),
Â  Â  Â  Â  Â  Â  Â  Â  courseId: "sat-math-prep",
Â  Â  Â  Â  Â  Â  Â  Â  timeToCompleteSeconds: timeToCompleteSeconds,
Â  Â  Â  Â  Â  Â  Â  Â  sessionScore: sessionPoints,
Â  Â  Â  Â  Â  Â  Â  Â  timestamp: firebase.firestore.FieldValue.serverTimestamp()
Â  Â  Â  Â  Â  Â  }).catch(e => console.error("Analytics event logging error:", e));
Â  Â  Â  Â  Â  Â  lessonStartTime = null;
Â  Â  Â  Â  }

Â  Â  Â  Â  // Update progress and streak
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  const topicId = lessonFileName.replace('.json', '');
Â  Â  Â  Â  Â  Â  const studentDocRef = db.collection('thelo-students').doc(user.uid);
Â  Â  Â  Â  Â  Â  const progressDocRef = studentDocRef.collection('progress').doc(topicId);
Â  Â  Â  Â  Â  Â  const progressDoc = await progressDocRef.get();
Â  Â  Â  Â  Â  Â  const wasAlreadyCompleted = progressDoc.exists;

Â  Â  Â  Â  Â  Â  await updateStudentProgress(user.uid, topicId, {
Â  Â  Â  Â  Â  Â  Â  Â  status: 'completed',
Â  Â  Â  Â  Â  Â  Â  Â  score: sessionPoints
Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  if (!wasAlreadyCompleted) {
Â  Â  Â  Â  Â  Â  Â  Â  await studentDocRef.update({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lessonsCompleted: firebase.firestore.FieldValue.increment(1)
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  await updateWeeklyStreak();

Â  Â  Â  Â  } catch (error) {
Â  Â  Â  Â  Â  Â  console.error("Error finalizing lesson completion in background:", error);
Â  Â  Â  Â  }
Â  Â  }
}		
	 /**
Â * Handles clicks on the main "Next" / "Check" / "Got It" button.
Â * This function is now the central point for evaluating all interactive stages.
Â */
/**
Â * Handles clicks on the main "Next" / "Check" / "Got It" button.
Â * This function is now the central point for evaluating all interactive stages.
Â */
/* ------------------------------------------------------------------
Â  Â REPLACE your current handleNextCheckClick() with everything below
Â  Â ------------------------------------------------------------------ */
/**
Â * Handles clicks on the main "Next" / "Check" / "Got It" button.
Â * This function is the central point for evaluating all interactive stages.
Â */
function handleNextCheckClick() {
Â  Â  if (isTransitioning || isLessonLoading || isThelobookActive || isPageGridVisible) {
Â  Â  Â  Â  return;
Â  Â  }
Â  Â  const TXT = getCurrentUIText();

Â  Â  if (currentStageIndex === -1 && lessonStages.length > 0) {
Â  Â  Â  Â  hideOnCanvasFeedback();
Â  Â  Â  Â  lessonStartTime = Date.now();
Â  Â  Â  Â  const user = auth.currentUser;
Â  Â  Â  Â  const lessonFile = new URLSearchParams(location.search).get('lessonFile');
Â  Â  Â  Â  if (user && lessonFile) {
Â  Â  Â  Â  Â  Â  db.collection('analytics_events').add({
Â  Â  Â  Â  Â  Â  Â  Â  type: 'lesson_started',
Â  Â  Â  Â  Â  Â  Â  Â  userId: user.uid,
Â  Â  Â  Â  Â  Â  Â  Â  lessonId: lessonFile.replace('.json', ''),
Â  Â  Â  Â  Â  Â  Â  Â  courseId: 'sat-math-prep',
Â  Â  Â  Â  Â  Â  Â  Â  timestamp: firebase.firestore.FieldValue.serverTimestamp()
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  }
Â  Â  Â  Â  transitionToStage(0);
Â  Â  Â  Â  return;
Â  Â  }

Â  Â  const mcq = currentStageData.optionsQuiz;
Â  Â  const isMCQStage =
Â  Â  Â  Â  currentStageData.type === 'explanation_with_mcq' &&
Â  Â  Â  Â  mcq &&
Â  Â  Â  Â  Array.isArray(mcq.choices) &&
Â  Â  Â  Â  mcq.choices.length > 0;

Â  Â  if (isMCQStage) {
Â  Â  Â  Â  document.body.classList.remove('mcq-active');

Â  Â  Â  Â  if (nextCheckBtn.textContent === TXT.next || nextCheckBtn.textContent === TXT.gotIt) {
Â  Â  Â  Â  Â  Â  nextStage();
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }

Â  Â  Â  Â  if (selectedMcqIndex === null) { return; }

Â  Â  Â  Â  const buttons = mcqOptionsContainer.querySelectorAll('.mcq-option-btn');
Â  Â  Â  Â  nextCheckBtn.disabled = true;

Â  Â  Â  Â  const correct = selectedMcqIndex === mcq.correctIndex;
Â  Â  Â  Â  const selectedButton = buttons[selectedMcqIndex];

Â  Â  Â  Â  if (correct) {
Â  Â  Â  Â  Â  Â  selectedButton.classList.remove('selected');
Â  Â  Â  Â  Â  Â  selectedButton.classList.add('correct');
			isMcqAnsweredCorrectly = true;
Â  Â  Â  Â  Â  Â  addChatMessage('AI', `ğŸ‰ ${mcq.feedbackCorrect || TXT.correct}`);
Â  Â  Â  Â  Â  Â  playRandomFeedback('approve');
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // The options now remain visible.

Â  Â  Â  Â  Â  Â  nextCheckBtn.textContent = TXT.next;
Â  Â  Â  Â  Â  Â  nextCheckBtn.classList.add('correct');
Â  Â  Â  Â  Â  Â  nextCheckBtn.disabled = false;

Â  Â  Â  Â  } else { // Incorrect answer
Â  Â  Â  Â  Â  Â  selectedButton.classList.remove('selected');
Â  Â  Â  Â  Â  Â  selectedButton.classList.add('incorrect');
Â  Â  Â  Â  Â  Â  addChatMessage('AI', `ğŸ¤” ${mcq.feedbackIncorrect || TXT.incorrect}`);
Â  Â  Â  Â  Â  Â  playRandomFeedback('disapprove');

Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  buttons.forEach(b => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  b.classList.remove('incorrect');
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  document.body.classList.add('mcq-active');
Â  Â  Â  Â  Â  Â  Â  Â  // The selection is NOT reset, allowing you to navigate from your last choice.
Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.disabled = false;
Â  Â  Â  Â  Â  Â  }, 1000);
Â  Â  Â  Â  }
Â  Â  Â  Â  return;
Â  Â  }

Â  Â  if (nextCheckBtn.textContent === TXT.gotIt) {
Â  Â  Â  Â  if (!stagesWithPointsAwarded.has(currentStageIndex)) {
Â  Â  Â  Â  Â  Â  stagesWithPointsAwarded.add(currentStageIndex);
Â  Â  Â  Â  Â  Â  stopCurrentStageAudio();
Â  Â  Â  Â  Â  Â  const pts = Math.floor(Math.random() * 4) + 6;
Â  Â  Â  Â  Â  Â  userPoints += pts;
Â  Â  Â  Â  Â  Â  sessionPoints += pts;
Â  Â  Â  Â  Â  Â  updateUserPointsInFirestore(pts);
Â  Â  Â  Â  Â  Â  updatePointsDisplay();
Â  Â  Â  Â  Â  Â  addChatMessage('AI', formatAIMessage('pointsGained', { points: pts }));
Â  Â  Â  Â  Â  Â  if (window.userInteracted) {
Â  Â  Â  Â  Â  Â  Â  Â  gotItSoundPlayer.currentTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  gotItSoundPlayer.play().catch(() => {});
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  if (isReplayActive) closeReplayPlayer();
Â  Â  Â  Â  nextStage();
Â  Â  Â  Â  return;
Â  Â  }

Â  Â  if (currentStageData.type === 'question_handwriting') {
Â  Â  Â  Â  checkHandwritingAnswer();
Â  Â  } else if (currentStageData.type === 'question_math_solution') {
Â  Â  Â  Â  checkMathDrawing();
Â  Â  } else {
Â  Â  Â  Â  nextStage();
Â  Â  }
}
	Â  function addChatImage(url) {
Â  Â  const wrapper = Object.assign(document.createElement('div'), {
Â  Â  Â  Â  className: 'ai-message chat-image-container'
Â  Â  });

Â  Â  const img = Object.assign(document.createElement('img'), {
Â  Â  Â  Â  className: 'chat-image',
Â  Â  Â  Â  src: url,
Â  Â  Â  Â  alt: 'Lesson Content Image',
Â  Â  Â  Â  style: 'opacity:0'
Â  Â  });

Â  Â  wrapper.appendChild(img);
Â  Â  chatArea.appendChild(wrapper);
Â  Â Â 
Â  Â  // Calculate target scroll position
Â  Â  const targetScrollTop = wrapper.offsetTop - chatArea.offsetTop;
Â  Â Â 
Â  Â  img.onload = () => {
Â  Â  Â  Â  // Fade in the image
Â  Â  Â  Â  img.style.transition = 'opacity .4s';
Â  Â  Â  Â  img.style.opacity = '1';
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Smooth scroll to position
Â  Â  Â  Â  chatArea.scrollTo({
Â  Â  Â  Â  top: targetScrollTop,
Â  Â  Â  Â  behavior: 'smooth'
Â  Â  Â  Â  });
Â  Â  };
Â  Â  }
Â  Â  // Find your addChatMessage function (around line 1774 or search for 'function addChatMessage(sender, rawMsg)')
// REPLACE your entire addChatMessage function with this one
/**
Â * Finds simple math notations in a string and converts them to KaTeX HTML.
Â * Supports:
Â * - `sqrt(content)` -> rendered square root
Â * - `base^exponent` -> rendered power
Â * - `(base)^exponent` -> rendered power with parentheses
Â * @param {string} text - The input string, potentially containing math.
Â * @returns {string} An HTML string with math portions rendered by KaTeX.
Â */
function parseAndRenderMath(text) {
Â  Â  if (!text || typeof text !== 'string') return '';

Â  Â  // This regex looks for one of three patterns using the OR | operator:
Â  Â  // 1. The full "sqrt(content)" expression, capturing the "content".
Â  Â  // 2. A parenthesized "(base)" followed by "^exponent", capturing "base" and "exponent".
Â  Â  // 3. A simple "base" word followed by "^exponent", capturing "base" and "exponent".
Â  Â  const mathRegex = /(\bsqrt\(([^)]+)\))|(\(([^)]+)\)\^(\w+))|(\b(\w+)\^(\w+)\b)/g;

Â  Â  return text.replace(mathRegex, (match, sqrtFull, sqrtContent, powerParenFull, powerParenBase, powerParenExp, powerWordFull, powerWordBase, powerWordExp) => {
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  // Case 1: Matched sqrt(content)
Â  Â  Â  Â  Â  Â  if (sqrtFull) {
Â  Â  Â  Â  Â  Â  Â  Â  return katex.renderToString(`\\sqrt{${sqrtContent}}`, { throwOnError: false, displayMode: false });
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  // Case 2: Matched (base)^exponent
Â  Â  Â  Â  Â  Â  if (powerParenFull) {
Â  Â  Â  Â  Â  Â  Â  Â  return katex.renderToString(`{(${powerParenBase})}^{${powerParenExp}}`, { throwOnError: false, displayMode: false });
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  // Case 3: Matched base^exponent
Â  Â  Â  Â  Â  Â  if (powerWordFull) {
Â  Â  Â  Â  Â  Â  Â  Â  return katex.renderToString(`${powerWordBase}^{${powerWordExp}}`, { throwOnError: false, displayMode: false });
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  Â  console.warn("KaTeX rendering failed for:", match, e);
Â  Â  Â  Â  Â  Â  return match; // In case of error, fall back to the original text.
Â  Â  Â  Â  }
Â  Â  Â  Â  return match; // Should not be reached, but good practice.
Â  Â  });
}
// REPLACE your entire addChatMessage function with this one

function addChatMessage(sender, rawMsg) {
Â  Â  if (isTabletMode) {
Â  Â  Â  Â  // Tablet toast logic remains the same
Â  Â  Â  Â  const isImportant = rawMsg.includes('ğŸ‰') || rawMsg.includes('ğŸ¤”') || rawMsg.includes('âš ï¸');
Â  Â  Â  Â  showToast(rawMsg, isImportant ? 5000 : 3500);
	Â  Â  showFeedback(rawMsg, 3500);
Â  Â  } else {
Â  Â  Â  Â  // Desktop/mobile terminal chat
Â  Â  Â  Â  const chatArea = document.getElementById('chat');
Â  Â  Â  Â  if (!chatArea) return;

Â  Â  Â  Â  const msg = rawMsg.replace(/^[\p{Extended_Pictographic}\uFE0F]+\s*/u, '');
Â  Â  Â  Â  const TXT = getCurrentUIText();
Â  Â  Â  Â  let emoji = 'ğŸ«§';

Â  Â  Â  Â  const isPoints = /points? gained/i.test(msg) || (TXT.pointsGained && msg.includes(TXT.pointsGained.split("{")[0].trim()));
Â  Â  Â  Â  const isWrong = msg.includes('Not quite') || (TXT.incorrect && msg.includes(TXT.incorrect)) || msg.includes('Incorrect') || msg.includes('Wrong');
Â  Â  Â  Â  const isCorrect = !isWrong && ((TXT.correct && msg.includes(TXT.correct)) || /^correct/i.test(msg));
Â  Â  Â  Â  const isWarning = msg.includes('âš ï¸') || (TXT.error && msg.includes(TXT.error));
Â  Â  Â  Â  const isWelcome = TXT.welcome && msg.includes(TXT.welcome);
Â  Â  Â  Â  const isChecking = TXT.checkingAI && msg.includes(TXT.checkingAI.split('<')[0]);

Â  Â  Â  Â  if(isWrong) emoji = 'ğŸ¤”';
Â  Â  Â  Â  else if (isCorrect || isPoints) emoji = 'ğŸ‰';
Â  Â  Â  Â  else if (isWarning || msg.includes('ğŸ›‘')) emoji = 'âš ï¸';
Â  Â  Â  Â  else if (isWelcome) emoji = 'ğŸ‘‹';
Â  Â  Â  Â  else if (isChecking) emoji = 'â³';
Â  Â  Â  Â Â 
Â  Â  Â  Â  // ======================= THE CHANGE IS HERE =======================
Â  Â  Â  Â  // Use our new function to parse the message for math before displaying it.
Â  Â  Â  Â  const finalHTML = parseAndRenderMath(msg);
Â  Â  Â  Â  // ================================================================

Â  Â  Â  Â  const bubble = document.createElement('div');
Â  Â  Â  Â  bubble.className = 'ai-message'; // Starts with opacity: 0
Â  Â  Â  Â Â 
Â  Â  Â  Â  // And now we use the processed HTML instead of the raw message.
Â  Â  Â  Â  bubble.innerHTML = `<span class="emoji" role="img" aria-label="icon">${emoji}</span> <span>${finalHTML}</span>`;
Â  Â  Â  Â  chatArea.appendChild(bubble);

Â  Â  Â  Â  // Force the browser to paint the initial state before animating
Â  Â  Â  Â  requestAnimationFrame(() => {
Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  bubble.classList.add('show');
Â  Â  Â  Â  Â  Â  Â  Â  chatArea.scrollTo({ top: chatArea.scrollHeight, behavior: 'smooth' });
Â  Â  Â  Â  Â  Â  }, 10);
Â  Â  Â  Â  });
Â  Â  }
}
	Â  /**
Â * Creates or updates a student's progress for a specific topic in Firestore.
Â * @param {string} userId - The authenticated user's UID.
Â * @param {string} topicId - The unique ID for the lesson (e.g., 'sat-linear-equations-one-var').
Â * @param {object} progressData - The data to save (e.g., { status: 'in-progress' }).
Â */
async function updateStudentProgress(userId, topicId, progressData) {
Â  if (!userId || !topicId) {
Â  Â  console.error("User ID or Topic ID is missing. Cannot save progress.");
Â  Â  return;
Â  }
Â Â 
Â  // The path to the specific progress document for this user and topic.
Â  const progressDocRef = db.collection('thelo-students').doc(userId).collection('progress').doc(topicId);
Â Â 
Â  // Add a timestamp to every update.
Â  const dataWithTimestamp = {
Â  Â  ...progressData,
Â  Â  lastAttempted: firebase.firestore.FieldValue.serverTimestamp()
Â  };

Â  try {
Â  Â  // Use setDoc with { merge: true } to create or update the document.
Â  Â  await progressDocRef.set(dataWithTimestamp, { merge: true });
Â  Â  console.log(`Progress for topic '${topicId}' updated:`, dataWithTimestamp);
Â  } catch (error) {
Â  Â  console.error("Error updating student progress:", error);
Â  }
}
Â  Â  function playAudio(audioElement){ return new Promise((resolve, reject) => { if (!audioElement || !(audioElement instanceof HTMLAudioElement)) { return reject(new Error("Invalid audio element")); } if (!window.userInteracted) { return resolve(); } audioElement.currentTime = 0; const playPromise = audioElement.play(); if(playPromise !== undefined) { playPromise.then(resolve).catch(error => { reject(error); }); } else { resolve(); } }); }
Â  Â  function playRandomFeedback(soundType){
Â  Â  Â  Â  if (!window.userInteracted || isThelobookActive || isPageGridVisible) return;
Â  Â  Â  Â  let soundArray;
Â  Â  Â  Â  if (currentLang === 'en') soundArray = (soundType === 'approve') ? approveSounds_en : disapproveSounds_en;
Â  Â  Â  Â  else soundArray = (soundType === 'approve') ? approveSounds_hy : disapproveSounds_hy;
Â  Â  Â  Â  if (soundArray && soundArray.length > 0) {
Â  Â  Â  Â  Â  Â  const availableSounds = soundArray.filter(sound => sound instanceof HTMLAudioElement);
Â  Â  Â  Â  Â  Â  if (availableSounds.length > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  const randomIndex = Math.floor(Math.random() * availableSounds.length);
Â  Â  Â  Â  Â  Â  Â  Â  playAudio(availableSounds[randomIndex]).catch(e => {});
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  }
Â  Â  function formatAIMessage(key, replacements = {}){
Â  Â  Â  Â  const TXT = getCurrentUIText(); let message = TXT[key] || `Missing text [${currentLang}]: ${key}`;
Â  Â  Â  Â  const escapeHTML = (str) => String(str).replace(/[&<>"']/g, match => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[match]));
Â  Â  Â  Â  for (const placeholder in replacements) {
Â  Â  Â  Â  Â  Â  const replacementValue = replacements[placeholder] !== undefined && replacements[placeholder] !== null ? String(replacements[placeholder]) : '';
Â  Â  Â  Â  Â  Â  message = message.replace(new RegExp(`{${placeholder}}`, 'g'), `<strong>${escapeHTML(replacementValue)}</strong>`);
Â  Â  Â  Â  }
Â  Â  Â  Â  return message;
Â  Â  }
Â  Â  Â  Â  Â  /* ========== NEW: Toast Notification Logic ========== */
function showToast(rawMsg, duration = 4000) {
Â  Â  const container = document.getElementById('toast-container');
Â  Â  if (!container) return;

Â  Â  // This part classifies the message to show the right icon
Â  Â  const msg = rawMsg.replace(/^[\p{Extended_Pictographic}\uFE0F]+\s*/u, '');
Â  Â  const TXT = getCurrentUIText();
Â  Â  let emoji = 'ğŸ«§';
Â  Â  let type = 'info';Â 

Â  Â  const isPointsÂ  = /points? gained/i.test(msg) || (TXT.pointsGained && msg.includes(TXT.pointsGained.split("{")[0].trim()));
Â  Â  const isWrongÂ  Â = msg.includes('Not quite') || (TXT.incorrect && msg.includes(TXT.incorrect)) || msg.includes('Incorrect') || msg.includes('Wrong');
Â  Â  const isCorrect = !isWrong && ((TXT.correct && msg.includes(TXT.correct)) || /^correct/i.test(msg));
Â  Â  const isWarning = msg.includes('âš ï¸') || (TXT.error && msg.includes(TXT.error));
Â  Â  const isWelcome = TXT.welcome && msg.includes(TXT.welcome);
Â  Â  const isChecking = TXT.checkingAI && msg.includes(TXT.checkingAI.split('<')[0]);

Â  Â  if (isWrong) { emoji = 'ğŸ¤”'; type = 'error'; }
Â  Â  else if (isCorrect || isPoints) { emoji = 'ğŸ‰'; type = 'success'; }
Â  Â  else if (isWarning || msg.includes('ğŸ›‘')) { emoji = 'âš ï¸'; type = 'warning'; }
Â  Â  else if (isWelcome) { emoji = 'ğŸ‘‹'; }
Â  Â  else if (isChecking) { emoji = 'â³'; }

Â  Â  // This part creates the toast element
Â  Â  const toast = document.createElement('div');
Â  Â  toast.className = `toast-message`;
Â  Â  toast.innerHTML = `<span class="emoji" role="img" aria-label="icon">${emoji}</span> <span>${msg}</span>`;
Â  Â Â 
Â  Â  // This is the inner function that handles removing the toast
Â  Â  const removeToast = () => {
Â  Â  Â  Â  // First, we add the 'exiting' class to trigger the CSS transition
Â  Â  Â  Â  toast.classList.add('exiting');
Â  Â  Â  Â Â 
Â  Â  Â  Â  // ===================================================================
Â  Â  Â  Â  // THE ONLY CHANGE IS ON THIS LINE:
Â  Â  Â  Â  // We now listen for 'transitionend' instead of 'animationend'.
Â  Â  Â  Â  // This tells the code to wait for our new collapse transition to finish.
Â  Â  Â  Â  toast.addEventListener('transitionend', () => {
Â  Â  Â  Â  Â  Â  toast.remove();
Â  Â  Â  Â  }, { once: true });
Â  Â  Â  Â  // ===================================================================
Â  Â  };

Â  Â  // This sets the timer to automatically dismiss the toast
Â  Â  const timeoutId = setTimeout(removeToast, duration);

Â  Â  // This lets the user click the toast to dismiss it early
Â  Â  toast.addEventListener('click', () => {
Â  Â  Â  Â  clearTimeout(timeoutId);
Â  Â  Â  Â  removeToast();
Â  Â  }, { once: true });

Â  Â  // This adds the toast to the page
Â  Â  container.appendChild(toast);

Â  Â  // This triggers the entry animation
Â  Â  requestAnimationFrame(() => {
Â  Â  Â  Â  toast.classList.add('show');
Â  Â  });
}
	Â  // Add this new function somewhere in your script, e.g., after the toast/tablet functions

// REPLACE your existing showFeedback function with this DEBUGGING version.

/**
Â * Pops up a transient feedback card in the centre of the screen.
Â * @param {string} rawMsgÂ  â€“Â  HTML-allowed message (e.g. "ğŸ‰ <strong>Correct!</strong>")
Â * @param {number} duration â€“ how long to stay visible (ms)
Â */

function showOnCanvasFeedback(message, type = 'info') {
Â  Â  if (!feedbackCtx) return;

Â  Â  // --- Configuration ---
Â  Â  const FADE_TIME = 400;
Â  Â  const MAX_WIDTH_PERCENTAGE = 0.70;
Â  Â  const TEXT_COLOR = '#111827';
Â  Â  const FONT_FAMILY = currentLang === 'en' ? "'Manrope', system-ui, sans-serif" : "'Montserrat Arm', system-ui, sans-serif";
Â  Â  const LINE_HEIGHT_MULTIPLIER = 1.2;

Â  Â  let maxFontSize = 48;
Â  Â  let minFontSize = 20;
Â  Â  let EMOJI = '';

Â  Â  if (type === 'success') {
Â  Â  Â  Â  maxFontSize = 72;
Â  Â  Â  Â  EMOJI = 'ğŸ‰ ';
Â  Â  }

Â  Â  const finalMessage = EMOJI + message;
Â  Â  const canvasWidth = feedbackCanvas.width / devicePixelRatio;
Â  Â  const canvasHeight = feedbackCanvas.height / devicePixelRatio;
Â  Â  const maxWidth = canvasWidth * MAX_WIDTH_PERCENTAGE;

Â  Â  const wrapText = (ctx, text, maxWidth) => {
Â  Â  Â  Â  const words = text.split(' ');
Â  Â  Â  Â  let lines = [];
Â  Â  Â  Â  let currentLine = words[0] || '';
Â  Â  Â  Â  for (let i = 1; i < words.length; i++) {
Â  Â  Â  Â  Â  Â  const word = words[i];
Â  Â  Â  Â  Â  Â  const width = ctx.measureText(currentLine + " " + word).width;
Â  Â  Â  Â  Â  Â  if (width < maxWidth) {
Â  Â  Â  Â  Â  Â  Â  Â  currentLine += " " + word;
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  lines.push(currentLine);
Â  Â  Â  Â  Â  Â  Â  Â  currentLine = word;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  lines.push(currentLine);
Â  Â  Â  Â  return lines;
Â  Â  };
Â  Â Â 
Â  Â  let currentFontSize = maxFontSize;
Â  Â  let lines = [];
Â  Â Â 
Â  Â  do {
Â  Â  Â  Â  feedbackCtx.font = `900 ${currentFontSize}px ${FONT_FAMILY}`;
Â  Â  Â  Â  lines = wrapText(feedbackCtx, finalMessage, maxWidth);
Â  Â  Â  Â  const longestWord = finalMessage.split(' ').reduce((a, b) => a.length > b.length ? a : b, '');
Â  Â  Â  Â  if (feedbackCtx.measureText(longestWord).width > maxWidth) {
Â  Â  Â  Â  Â  Â  Â currentFontSize--;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  }
Â  Â  } while (currentFontSize > minFontSize)
Â  Â Â 
Â  Â  feedbackCtx.font = `900 ${currentFontSize}px ${FONT_FAMILY}`;
Â  Â  lines = wrapText(feedbackCtx, finalMessage, maxWidth);
Â  Â Â 
Â  Â  const lineHeight = currentFontSize * LINE_HEIGHT_MULTIPLIER;
Â  Â  const totalTextHeight = lines.length * lineHeight;
Â  Â  let startY = (canvasHeight / 2) - (totalTextHeight / 2);

Â  Â  // FIX: Store the font family along with other details
Â  Â  lastFeedbackDetails = { lines, lineHeight, startY, fontSize: currentFontSize, fontFamily: FONT_FAMILY };

Â  Â  if (feedbackAnimationId) cancelAnimationFrame(feedbackAnimationId);
Â  Â  let startTime = null;
Â  Â Â 
Â  Â  const animate = (timestamp) => {
Â  Â  Â  Â  if (!startTime) startTime = timestamp;
Â  Â  Â  Â  const elapsed = timestamp - startTime;
Â  Â  Â  Â  feedbackCtx.clearRect(0, 0, canvasWidth, canvasHeight);
Â  Â  Â  Â  let currentOpacity = (elapsed < FADE_TIME) ? (elapsed / FADE_TIME) : 1.0;
Â  Â  Â  Â  feedbackCtx.globalAlpha = currentOpacity;
Â  Â  Â  Â  feedbackCtx.font = `900 ${currentFontSize}px ${FONT_FAMILY}`;
Â  Â  Â  Â  feedbackCtx.fillStyle = TEXT_COLOR;
Â  Â  Â  Â  feedbackCtx.textAlign = 'center';
Â  Â  Â  Â  feedbackCtx.textBaseline = 'top';
Â  Â  Â  Â  for (let i = 0; i < lines.length; i++) {
Â  Â  Â  Â  Â  Â  feedbackCtx.fillText(lines[i], canvasWidth / 2, startY + (i * lineHeight));
Â  Â  Â  Â  }
Â  Â  Â  Â  feedbackCtx.globalAlpha = 1.0;
Â  Â  Â  Â  if (elapsed < FADE_TIME) {
Â  Â  Â  Â  Â  Â  feedbackAnimationId = requestAnimationFrame(animate);
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  cancelAnimationFrame(feedbackAnimationId);
Â  Â  Â  Â  Â  Â  feedbackAnimationId = null;
Â  Â  Â  Â  }
Â  Â  };
Â  Â Â 
Â  Â  feedbackAnimationId = requestAnimationFrame(animate);
}
function hideOnCanvasFeedback() {
Â  Â  if (!feedbackCtx || !lastFeedbackDetails) return;

Â  Â  const FADE_TIME = 400;
Â  Â  const canvasWidth = feedbackCanvas.width / devicePixelRatio;
Â  Â  const canvasHeight = feedbackCanvas.height / devicePixelRatio;
Â  Â  const TEXT_COLOR = '#111827';
Â  Â Â 
Â  Â  // FIX: Retrieve the exact font family that was used to show the message
Â  Â  const { lines, lineHeight, startY, fontSize, fontFamily } = lastFeedbackDetails;

Â  Â  if (feedbackAnimationId) cancelAnimationFrame(feedbackAnimationId);
Â  Â  let startTime = null;

Â  Â  const animateFadeOut = (timestamp) => {
Â  Â  Â  Â  if (!startTime) startTime = timestamp;
Â  Â  Â  Â  const elapsed = timestamp - startTime;
Â  Â  Â  Â Â 
Â  Â  Â  Â  feedbackCtx.clearRect(0, 0, canvasWidth, canvasHeight);
Â  Â  Â  Â Â 
Â  Â  Â  Â  let currentOpacity = 1.0;
Â  Â  Â  Â  if (elapsed < FADE_TIME) {
Â  Â  Â  Â  Â  Â  currentOpacity = 1.0 - (elapsed / FADE_TIME);
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  lastFeedbackDetails = null;
Â  Â  Â  Â  Â  Â  cancelAnimationFrame(feedbackAnimationId);
Â  Â  Â  Â  Â  Â  feedbackAnimationId = null;
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }

Â  Â  Â  Â  feedbackCtx.globalAlpha = currentOpacity;
Â  Â  Â  Â  feedbackCtx.font = `900 ${fontSize}px ${fontFamily}`; // Use the stored font family
Â  Â  Â  Â  feedbackCtx.fillStyle = TEXT_COLOR;
Â  Â  Â  Â  feedbackCtx.textAlign = 'center';
Â  Â  Â  Â  feedbackCtx.textBaseline = 'top';
Â  Â  Â  Â Â 
Â  Â  Â  Â  for (let i = 0; i < lines.length; i++) {
Â  Â  Â  Â  Â  Â  feedbackCtx.fillText(lines[i], canvasWidth / 2, startY + (i * lineHeight));
Â  Â  Â  Â  }

Â  Â  Â  Â  feedbackCtx.globalAlpha = 1.0;

Â  Â  Â  Â  feedbackAnimationId = requestAnimationFrame(animateFadeOut);
Â  Â  };

Â  Â  feedbackAnimationId = requestAnimationFrame(animateFadeOut);
}
	Â  function checkTabletMode() {
Â  Â  // This media query should match the one in your CSS
Â  Â  const tabletQuery = window.matchMedia('(min-width: 769px) and (max-width: 1200px) and (pointer: coarse)');
Â  Â  const landscapeQuery = window.matchMedia('(min-width: 769px) and (max-width: 1200px) and (min-height: 500px)');

Â  Â  isTabletMode = tabletQuery.matches || landscapeQuery.matches;
Â  Â  console.log("Tablet Mode:", isTabletMode);
}
	function updateUserPointsInFirestore(pointsToAdd) {
Â  Â  Â  Â  const user = auth.currentUser;
Â  Â  Â  Â  if (!user) {
Â  Â  Â  Â  Â  Â  console.warn("Attempted to update points for a non-logged-in user.");
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }

Â  Â  Â  Â  const userDocRef = db.collection('thelo-students').doc(user.uid);

Â  Â  Â  Â  // Use FieldValue.increment for atomic updates to prevent race conditions
Â  Â  Â  Â  return userDocRef.update({
Â  Â  Â  Â  Â  Â  points: firebase.firestore.FieldValue.increment(pointsToAdd)
Â  Â  Â  Â  }).catch(error => {
Â  Â  Â  Â  Â  Â  console.error("Error updating points in Firestore: ", error);
Â  Â  Â  Â  });
Â  Â  }
	/* ===== ADD THIS FUNCTION: The Main Streak Logic ======================== */
async function updateWeeklyStreak() {
Â  Â  const user = auth.currentUser;
Â  Â  if (!user) return; // Only run for logged-in users

Â  Â  const userDocRef = db.collection('thelo-students').doc(user.uid);
Â  Â Â 
Â  Â  try {
Â  Â  Â  Â  const doc = await userDocRef.get();
Â  Â  Â  Â  const streakData = doc.exists && doc.data().streakData ? doc.data().streakData : {
Â  Â  Â  Â  Â  Â  currentStreak: 0,
Â  Â  Â  Â  Â  Â  longestStreak: 0,
Â  Â  Â  Â  Â  Â  lastActivityWeek: null
Â  Â  Â  Â  };

Â  Â  Â  Â  const thisWeekId = getISOWeekIdentifier(new Date());

Â  Â  Â  Â  // Scenario A: Already completed a lesson this week
Â  Â  Â  Â  if (thisWeekId === streakData.lastActivityWeek) {
Â  Â  Â  Â  Â  Â  console.log("Weekly streak already secured for:", thisWeekId);
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }

Â  Â  Â  Â  const prevWeekId = getPreviousWeekIdentifier(thisWeekId);
Â  Â  Â  Â  let newStreakData = { ...streakData };
Â  Â  Â  Â  let showCelebration = false;

Â  Â  Â  Â  // Scenario B: Streak Extended!
Â  Â  Â  Â  if (prevWeekId === streakData.lastActivityWeek) {
Â  Â  Â  Â  Â  Â  newStreakData.currentStreak += 1;
Â  Â  Â  Â  Â  Â  console.log(`Weekly streak extended to ${newStreakData.currentStreak} weeks!`);
Â  Â  Â  Â  Â  Â  showCelebration = true;
Â  Â  Â  Â  }Â 
Â  Â  Â  Â  // Scenario C: Streak Broken, new one starts
Â  Â  Â  Â  else {
Â  Â  Â  Â  Â  Â  newStreakData.currentStreak = 1;
Â  Â  Â  Â  Â  Â  console.log("New weekly streak started!");
Â  Â  Â  Â  Â  Â  showCelebration = true;
Â  Â  Â  Â  }

Â  Â  Â  Â  // Always update the last activity and check for a new record
Â  Â  Â  Â  newStreakData.lastActivityWeek = thisWeekId;
Â  Â  Â  Â  if (newStreakData.currentStreak > newStreakData.longestStreak) {
Â  Â  Â  Â  Â  Â  newStreakData.longestStreak = newStreakData.currentStreak;
Â  Â  Â  Â  }

Â  Â  Â  Â  // Save to Firestore and show the modal
Â  Â  Â  Â  await userDocRef.set({ streakData: newStreakData }, { merge: true });
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (showCelebration) {
Â  Â  Â  Â  Â  Â  showStreakCelebrationModal(newStreakData.currentStreak, newStreakData.currentStreak === newStreakData.longestStreak && newStreakData.currentStreak > 1);
Â  Â  Â  Â  }

Â  Â  } catch (error) {
Â  Â  Â  Â  console.error("Error updating weekly streak:", error);
Â  Â  }
}

function showStreakCelebrationModal(streakCount, isNewRecord) {
Â  Â  const modal = document.getElementById('streakModal');
Â  Â  const title = document.getElementById('streakModalTitle');
Â  Â  const body = document.getElementById('streakModalBody');
Â  Â  const closeBtn = document.getElementById('streakModalCloseBtn');
Â  Â  const confirmBtn = document.getElementById('streakModalConfirmBtn');

Â  Â  title.textContent = isNewRecord ? "New Record!" : "Weekly Streak Extended!";
Â  Â  body.textContent = `That's ${streakCount} week${streakCount > 1 ? 's' : ''} in a row. Amazing work!`;
Â  Â Â 
Â  Â  const hideModal = () => modal.classList.add('modal-hidden');
Â  Â Â 
Â  Â  closeBtn.onclick = hideModal;
Â  Â  confirmBtn.onclick = hideModal;

Â  Â  modal.classList.remove('modal-hidden');
}	
// ANALYTICS: Helper function to log handwriting check attempts
function logHandwritingAttempt(result) {
Â  Â  const user = auth.currentUser;
Â  Â  const urlParams = new URLSearchParams(window.location.search);
Â  Â  const lessonFileName = urlParams.get('lessonFile');

Â  Â  if (user && lessonFileName && currentStageData) {
Â  Â  Â  Â  db.collection("analytics_events").add({
Â  Â  Â  Â  Â  Â  type: "handwriting_check_attempt",
Â  Â  Â  Â  Â  Â  userId: user.uid,
Â  Â  Â  Â  Â  Â  lessonId: lessonFileName.replace('.json', ''),
Â  Â  Â  Â  Â  Â  stageIndex: currentStageIndex,
Â  Â  Â  Â  Â  Â  result: result, // "correct" or "incorrect"
Â  Â  Â  Â  Â  Â  timestamp: firebase.firestore.FieldValue.serverTimestamp()
Â  Â  Â  Â  });
Â  Â  }
}
	async function checkHandwritingAnswer() {
Â  Â  console.log("Auth state at time of call:", isAuthReady);
Â  Â  if (!isAuthReady || !auth.currentUser) {
Â  Â  Â  Â  addChatMessage('AI', formatAIMessage('authErrorVision'));
Â  Â  Â  Â  console.error("User is not authenticated. Cannot call AI function.");
Â  Â  Â  Â  return;
Â  Â  }

Â  Â  try {
Â  Â  Â  Â  await auth.currentUser.getIdToken(true); // Refresh token to ensure validity
Â  Â  } catch (error) {
Â  Â  Â  Â  console.error("Token refresh failed:", error);
Â  Â  Â  Â  addChatMessage('AI', "Authentication error. Please try logging in again.");
Â  Â  Â  Â  return;
Â  Â  }
Â  Â Â 
Â  Â  if (isThelobookActive || isPageGridVisible || nextCheckBtn.disabled || isTransitioning) return;

Â  Â  const TXT = getCurrentUIText();
Â  Â  nextCheckBtn.disabled = true;
Â  Â  nextCheckBtn.textContent = TXT.checking;
Â  Â  showOnCanvasFeedback(TXT.checking);
Â  Â Â 
Â  Â  let base64ImageData;
Â  Â  try {
Â  Â  Â  Â  const blankCanvas = document.createElement('canvas');
Â  Â  Â  Â  blankCanvas.width = canvas.width;
Â  Â  Â  Â  blankCanvas.height = canvas.height;
Â  Â  Â  Â  const imageDataUrl = captureCanvas.toDataURL('image/png');

Â  Â  Â  Â  if (imageDataUrl === blankCanvas.toDataURL()) {
Â  Â  Â  Â  Â  Â  throw new Error("BLANK_ANSWER");
Â  Â  Â  Â  }
Â  Â  Â  Â  base64ImageData = imageDataUrl;
Â  Â  } catch (error) {
Â  Â  Â  Â  addChatMessage('AI', formatAIMessage('drawActivityWarning'));
Â  Â  Â  Â  playRandomFeedback('disapprove');
Â  Â  Â  Â  nextCheckBtn.disabled = false;
Â  Â  Â  Â  nextCheckBtn.textContent = TXT.check;
Â  Â  Â  Â  return;
Â  Â  }
Â  Â Â 
Â  Â  const payload = {
Â  Â  Â  Â  imageBase64: base64ImageData,
Â  Â  Â  Â  problemText: "The user is writing a number to answer a question.",
Â  Â  Â  Â  correctAnswer: String(currentStageData.correctAnswerOcr),
Â  Â  Â  Â  customInstructions: `Analyze the user's handwritten number. The work is 'correct' ONLY IF the number in the image is clearly identifiable and matches the correct answer: ${currentStageData.correctAnswerOcr}. Otherwise, it is 'incorrect'.`,
Â  Â  Â  Â  language: currentLang
Â  Â  };

Â  Â  try {
Â  Â  Â  Â  const analyzeMathDrawing = firebase.functions().httpsCallable('analyzeMathDrawing');
Â  Â  Â  Â  const result = await analyzeMathDrawing(payload);
Â  Â  Â  Â  const { status, feedback } = result.data;
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (status === 'correct') {
Â  Â  Â  Â  Â  Â  showOnCanvasFeedback(feedback, undefined, 'success');
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  showOnCanvasFeedback(feedback);
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (status === 'correct') {
Â  Â  Â  Â  Â  Â  logHandwritingAttempt('correct');
Â  Â  Â  Â  Â  Â  const pointsGained = 10;
Â  Â  Â  Â  Â  Â  playRandomFeedback('approve');
Â  Â  Â  Â  Â  Â  userPoints += pointsGained;
Â  Â  Â  Â  Â  Â  sessionPoints += pointsGained;
Â  Â  Â  Â  Â  Â  updatePointsDisplay();
Â  Â  Â  Â  Â  Â  updateUserPointsInFirestore(pointsGained);
Â  Â  Â  Â  Â  Â  nextCheckBtn.classList.add('correct');
Â  Â  Â  Â  Â  Â  nextCheckBtn.textContent = TXT.correct;
Â  Â  Â  Â  Â  Â  setTimeout(nextStage, 2500);
Â  Â  Â  Â  } else {Â 
Â  Â  Â  Â  Â  Â  logHandwritingAttempt('incorrect');
Â  Â  Â  Â  Â  Â  playRandomFeedback('disapprove');
Â  Â  Â  Â  Â  Â  nextCheckBtn.classList.add('incorrect');
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.disabled = false;
Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.textContent = TXT.check;
Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.classList.remove('incorrect');
Â  Â  Â  Â  Â  Â  }, 1000);
Â  Â  Â  Â  }

Â  Â  } catch (error) {
Â  Â  Â  Â  console.error("Function call to analyzeMathDrawing failed:", error);
Â  Â  Â  Â  addChatMessage('AI', formatAIMessage('apiErrorGeneral', { errorMessage: error.message }));
Â  Â  Â  Â  playRandomFeedback('disapprove');
Â  Â  Â  Â  nextCheckBtn.disabled = false;
Â  Â  Â  Â  nextCheckBtn.textContent = TXT.check;
Â  Â  }
}
async function checkMathDrawing(isMcqContext = false) {
Â  Â  if (!auth.currentUser) {
Â  Â  Â  Â  console.error("User is not authenticated.");
Â  Â  Â  Â  addChatMessage('AI', 'âš ï¸ You must be logged in to use this feature.');
Â  Â  Â  Â  throw new Error("User not authenticated.");
Â  Â  }
Â  Â  try {
Â  Â  Â  Â  await auth.currentUser.getIdToken(true);
Â  Â  } catch (error) {
Â  Â  Â  Â  console.error("Token refresh failed:", error);
Â  Â  Â  Â  addChatMessage('AI', 'âš ï¸ Your session has expired. Please refresh and log in again.');
Â  Â  Â  Â  throw new Error("Token refresh failed.");
Â  Â  }

Â  Â  try {
Â  Â  Â  Â  const blankCanvasCheck = document.createElement('canvas');
Â  Â  Â  Â  blankCanvasCheck.width = canvas.width;
Â  Â  Â  Â  blankCanvasCheck.height = canvas.height;
Â  Â  Â  Â  if (canvas.toDataURL() === blankCanvasCheck.toDataURL()) {
Â  Â  Â  Â  Â  Â  addChatMessage('AI', "I can't check your work because nothing has been drawn yet. Please try solving the problem on the whiteboard first.");
Â  Â  Â  Â  Â  Â  throw new Error("No drawing found on canvas.");
Â  Â  Â  Â  }
Â  Â  } catch (e) {
Â  Â  Â  Â  console.error("Blank canvas check failed:", e.message);
Â  Â  Â  Â  throw e;
Â  Â  }

Â  Â  const TXT = getCurrentUIText();
Â  Â  nextCheckBtn.disabled = true;
Â  Â  nextCheckBtn.textContent = TXT.checking;
Â  Â Â 
Â  Â  await new Promise(resolve => setTimeout(resolve, 100));
Â  Â Â 
Â  Â  try {
Â  Â  Â  Â  let imageBase64;
Â  Â  Â  Â  if (isMcqContext) {
Â  Â  Â  Â  Â  Â  imageBase64 = canvas.toDataURL("image/png");
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  const compositeCanvas = document.createElement('canvas');
Â  Â  Â  Â  Â  Â  compositeCanvas.width = canvas.width;
Â  Â  Â  Â  Â  Â  compositeCanvas.height = canvas.height;
Â  Â  Â  Â  Â  Â  const compositeCtx = compositeCanvas.getContext('2d');
Â  Â  Â  Â  Â  Â  compositeCtx.drawImage(backgroundCanvas, 0, 0);
Â  Â  Â  Â  Â  Â  compositeCtx.drawImage(canvas, 0, 0);
Â  Â  Â  Â  Â  Â  imageBase64 = compositeCanvas.toDataURL("image/png");
Â  Â  Â  Â  }

Â  Â  Â  Â  const payload = {
Â  Â  Â  Â  Â  Â  imageBase64: imageBase64,
Â  Â  Â  Â  Â  Â  problemText: currentStageData.problemText || "No problem text provided.",
Â  Â  Â  Â  Â  Â  correctAnswer: currentStageData.correctAnswer || "No correct answer provided.",
Â  Â  Â  Â  Â  Â  solutionSteps: currentStageData.solutionSteps || "",
Â  Â  Â  Â  Â  Â  customInstructions: currentStageData.customInstructions || "",
Â  Â  Â  Â  Â  Â  language: currentLang
Â  Â  Â  Â  };

Â  Â  Â  Â  const analyzeMathDrawing = firebase.functions().httpsCallable('analyzeMathDrawing');
Â  Â  Â  Â  const result = await analyzeMathDrawing(payload);
Â  Â  Â  Â  const { status, feedback } = result.data;
	
Â  Â  Â  Â  if (status === 'correct') {
Â  Â  Â  Â  Â  Â  showOnCanvasFeedback(feedback, undefined, 'success');
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  showOnCanvasFeedback(feedback);
Â  Â  Â  Â  }

Â  Â  Â  Â  if (status === 'correct') {
Â  Â  Â  Â  Â  Â  playRandomFeedback('approve');
Â  Â  Â  Â  Â  Â  nextCheckBtn.classList.add('correct');
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  const pointsGained = 15;
Â  Â  Â  Â  Â  Â  userPoints += pointsGained;
Â  Â  Â  Â  Â  Â  sessionPoints += pointsGained;
Â  Â  Â  Â  Â  Â  updatePointsDisplay();
Â  Â  Â  Â  Â  Â  updateUserPointsInFirestore(pointsGained);

Â  Â  Â  Â  Â  Â  if (currentStageData.type === 'question_math_solution') {
Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.textContent = TXT.gotIt;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  nextCheckBtn.disabled = false;

Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  playRandomFeedback('disapprove');
Â  Â  Â  Â  Â  Â  nextCheckBtn.classList.add('incorrect');
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.disabled = false;
Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.textContent = TXT.check;
Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.classList.remove('incorrect');
Â  Â  Â  Â  Â  Â  }, 2000);
Â  Â  Â  Â  }

Â  Â  } catch (error) {
Â  Â  Â  Â  console.error("Math analysis failed:", error);
Â  Â  Â  Â  addChatMessage('AI', `âš ï¸ An error occurred during analysis: ${error.message}`);
Â  Â  Â  Â  playRandomFeedback('disapprove');
Â  Â  Â  Â Â 
Â  Â  Â  Â  nextCheckBtn.disabled = false;
Â  Â  Â  Â  nextCheckBtn.textContent = TXT.check;
Â  Â  Â  Â  nextCheckBtn.classList.remove('incorrect');
Â  Â  }
}
	Â  Â  /* ========== THELOBOOK FUNCTIONALITY ========== */
Â  Â  Â  Â  function updateThelobookPageControls() {
Â  Â  Â  Â  const TXT = getCurrentUIText();
Â  Â  Â  Â  const totalPages = Math.max(1, thelobookPages.length); // Ensure at least 1 for display

Â  Â  Â  Â  if (thelobookPageIndicatorEl && TXT && TXT.thelobookPageIndicator) {
Â  Â  Â  Â  Â  Â  thelobookPageIndicatorEl.textContent = TXT.thelobookPageIndicator
Â  Â  Â  Â  Â  Â  Â  Â  .replace('{currentPage}', currentThelobookPageIndex + 1)
Â  Â  Â  Â  Â  Â  Â  Â  .replace('{totalPages}', totalPages);
Â  Â  Â  Â  }

Â  Â  Â  Â  // Disable previous/next page buttons if at bounds or animating
Â  Â  Â  Â  if (thelobookPrevPageBtn) thelobookPrevPageBtn.disabled = (currentThelobookPageIndex === 0 || isPageSwitchingAnimation);
Â  Â  Â  Â  if (thelobookNextPageBtn) thelobookNextPageBtn.disabled = (currentThelobookPageIndex >= totalPages - 1 || isPageSwitchingAnimation);

Â  Â  Â  Â  // Disable Add Page button if limit is reached (32 pages) or animating
Â  Â  Â  Â  if (thelobookAddPageBtn) {
Â  Â  Â  Â  Â  Â  thelobookAddPageBtn.disabled = (thelobookPages.length >= PAGES_PER_GRID_BATCH || isPageSwitchingAnimation);
Â  Â  Â  Â  }

Â  Â  Â  Â  // Disable eraser/pages button if animating
Â  Â  Â  Â  if (thelobookEraserBtn) thelobookEraserBtn.disabled = isPageSwitchingAnimation;
Â  Â  Â  Â  if (thelobookPagesBtn) thelobookPagesBtn.disabled = isPageSwitchingAnimation;
Â  Â  }
Â  Â  function saveCurrentThelobookPageDrawing() {
Â  Â  Â  Â  if (!isThelobookActive || isPageSwitchingAnimation || !thelobookCtx || !thelobookCanvas || thelobookCanvas.width === 0 || thelobookCanvas.height === 0) {
Â  Â  Â  Â  Â  Â  // Optional: Log why saving was skipped
Â  Â  Â  Â  Â  Â  // console.warn("Save Thelobook: Conditions not met or canvas zero size", {isThelobookActive, isPageSwitchingAnimation, hasCtx: !!thelobookCtx, hasCanvas: !!thelobookCanvas, cW: thelobookCanvas?.width, cH: thelobookCanvas?.height });
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  if (currentThelobookPageIndex < 0) currentThelobookPageIndex = 0;
Â  Â  Â  Â  Â  Â  while (thelobookPages.length <= currentThelobookPageIndex) {
Â  Â  Â  Â  Â  Â  Â  Â  thelobookPages.push(null);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  // THE FIX IS HERE: Remove division by devicePixelRatio
Â  Â  Â  Â  Â  Â  thelobookPages[currentThelobookPageIndex] = thelobookCtx.getImageData(0, 0, thelobookCanvas.width, thelobookCanvas.height);
Â  Â  Â  Â  Â  Â  // console.log("Saved Thelobook page", currentThelobookPageIndex, "with bitmap dimensions:", thelobookCanvas.width, "x", thelobookCanvas.height);
Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  Â  console.error("Error saving Thelobook page:", e);
Â  Â  Â  Â  Â  Â  // Add more details if error occurs
Â  Â  Â  Â  Â  Â  // console.error("Canvas details at error: attr W/H", thelobookCanvas?.width, thelobookCanvas?.height, "style W/H", thelobookCanvas?.style.width, thelobookCanvas?.style.height, "DPR", devicePixelRatio);
Â  Â  Â  Â  }
Â  Â  }

Â  Â  function loadThelobookPageDrawing(pageIndex) {
Â  Â  Â  Â  if (thelobookCtx) {
Â  Â  Â  Â  Â  Â  thelobookCtx.clearRect(0, 0, thelobookCanvas.width / devicePixelRatio, thelobookCanvas.height / devicePixelRatio);
Â  Â  Â  Â  Â  Â  if (pageIndex >= 0 && pageIndex < thelobookPages.length && thelobookPages[pageIndex]) {
Â  Â  Â  Â  Â  Â  Â  Â  try { thelobookCtx.putImageData(thelobookPages[pageIndex], 0, 0); }
Â  Â  Â  Â  Â  Â  Â  Â  catch (e) { console.error("Error loading Thelobook page data:", e); }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  currentThelobookPageIndex = pageIndex;
Â  Â  Â  Â  updateThelobookPageControls();
Â  Â  }

Â  Â  function addThelobookNewPage() {
Â  Â  Â  Â  // Check if page creation limit is reached (PAGES_PER_GRID_BATCH is 32)
Â  Â  Â  Â  if (thelobookPages.length >= PAGES_PER_GRID_BATCH) {
Â  Â  Â  Â  Â  Â  const TXT = getCurrentUIText();
Â  Â  Â  Â  Â  Â  addChatMessage('AI', `âš ï¸ ${TXT.error}: Maximum of ${PAGES_PER_GRID_BATCH} pages allowed.`); // Provide user feedback
Â  Â  Â  Â  Â  Â  return; // Stop function execution
Â  Â  Â  Â  }

Â  Â  Â  Â  if (isPageSwitchingAnimation) return; // Check if already switching
Â  Â  Â  Â  saveCurrentThelobookPageDrawing(); // Save current page first
Â  Â  Â  Â  thelobookPages.push(null); // Add a new blank page placeholder
Â  Â  Â  Â  currentThelobookPageIndex = thelobookPages.length - 1; // Move to the new page
Â  Â  Â  Â  loadThelobookPageDrawing(currentThelobookPageIndex); // Load the (blank) new page
Â  Â  Â  Â  updateThelobookPageControls(); // Ensure controls are updated after adding a page
Â  Â  }

Â  Â  function changeThelobookPageSimple(direction) {
Â  Â  Â  Â  if (isPageSwitchingAnimation) return; // Prevent re-entrant calls

Â  Â  Â  Â  const oldPageIndex = currentThelobookPageIndex;
Â  Â  Â  Â  let newPageIndex = currentThelobookPageIndex + direction;
Â  Â  Â  Â  const totalPages = Math.max(1, thelobookPages.length);

Â  Â  Â  Â  // Bounds checking for newPageIndex
Â  Â  Â  Â  if (newPageIndex < 0) newPageIndex = 0;
Â  Â  Â  Â  if (newPageIndex >= totalPages) newPageIndex = totalPages - 1;

Â  Â  Â  Â  if (oldPageIndex !== newPageIndex) {
Â  Â  Â  Â  Â  Â  saveCurrentThelobookPageDrawing(); // **** MOVED: Save current page BEFORE disabling controls/animating ****

Â  Â  Â  Â  Â  Â  isPageSwitchingAnimation = true;
Â  Â  Â  Â  Â  Â  updateThelobookPageControls(); // Update controls to reflect "switching" state (e.g., disable buttons)

Â  Â  Â  Â  Â  Â  currentThelobookPageIndex = newPageIndex;
Â  Â  Â  Â  Â  Â  loadThelobookPageDrawing(currentThelobookPageIndex); // Load the new page (this also calls updateThelobookPageControls)

Â  Â  Â  Â  Â  Â  // Reset animation flag after a short delay/next frame to allow UI to settle
Â  Â  Â  Â  Â  Â  requestAnimationFrame(() => {
Â  Â  Â  Â  Â  Â  Â  Â  isPageSwitchingAnimation = false;
Â  Â  Â  Â  Â  Â  Â  Â  updateThelobookPageControls(); // Ensure controls are updated for the new page state
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  }
Â  Â  }
Â  Â  function toggleThelobookEraser() {
Â  Â  Â  Â  if (isPageSwitchingAnimation) return;
Â  Â  Â  Â  isThelobookEraserActive = !isThelobookEraserActive;
Â  Â  Â  Â  const TXT = getCurrentUIText();
Â  Â  Â  Â  if (thelobookEraserBtn) {
Â  Â  Â  Â  Â  Â  thelobookEraserBtn.textContent = isThelobookEraserActive ? 'ğŸ–‹ï¸' : 'âœï¸';
Â  Â  Â  Â  Â  Â  thelobookEraserBtn.title = isThelobookEraserActive ? TXT.thelobookPen : TXT.thelobookEraser;
Â  Â  Â  Â  Â  Â  thelobookEraserBtn.classList.toggle('active', isThelobookEraserActive);
Â  Â  Â  Â  }
Â  Â  Â  Â  if (thelobookCanvas) thelobookCanvas.classList.toggle('eraser-active', isThelobookEraserActive);
Â  Â  Â  Â  updateColorIndicator();
Â  Â  }

Â  Â  /* ---------------- helper: snapshot & pause media ---------------- */
Â  Â  function captureMediaState() {
Â  Â  Â  Â  mediaPlaybackTimeBeforeThelobook = internalPlaybackTime;
Â  Â  Â  Â  audioTimeBeforeThelobookÂ  Â  Â  Â = currentStageAudio ? currentStageAudio.currentTime : 0;
Â  Â  Â  Â  wasMediaPlayingBeforeThelobookÂ  = false;

Â  Â  Â  Â  if (currentStageAudio && !currentStageAudio.paused) {
Â  Â  Â  Â  currentStageAudio.pause();
Â  Â  Â  Â  wasMediaPlayingBeforeThelobook = true;
Â  Â  Â  Â  }

Â  Â  Â  Â  if (isMediaScrubbingActive) {
Â  Â  Â  Â  if (currentReplayAnimationId) cancelAnimationFrame(currentReplayAnimationId);
Â  Â  Â  Â  currentReplayAnimationId = null;
Â  Â  Â  Â  isMediaScrubbingActiveÂ  = false;
Â  Â  Â  Â  wasMediaPlayingBeforeThelobook = true;
Â  Â  Â  Â  }
Â  Â  Â  Â  stageProgressBarContainer?.classList.remove('visible');
Â  Â  }
Â  Â  /* ---------------- helper: resume or freeze ---------------------- */
Â  Â  function resumeMediaState() {
Â  Â  Â  Â  const atEnd =
Â  Â  Â  Â  currentStageTotalDuration > 0 &&
Â  Â  Â  Â  mediaPlaybackTimeBeforeThelobook >= currentStageTotalDuration - 0.05;

Â  Â  Â  Â  internalPlaybackTime = atEnd
Â  Â  Â  Â  ? currentStageTotalDuration
Â  Â  Â  Â  : mediaPlaybackTimeBeforeThelobook;

Â  Â  Â  Â  if (currentStageAudio) { // currentTime will be used by playStageAudio in resume mode
Â  Â  Â  Â  currentStageAudio.currentTime = audioTimeBeforeThelobook;
Â  Â  Â  Â  }

Â  Â  Â  Â  isMediaScrubbingActive = wasMediaPlayingBeforeThelobook && !atEnd;

Â  Â  Â  Â  if (atEnd && currentStageDrawingData && replayCtx && currentStageTotalDuration > 0) {
Â  Â  Â  Â  renderDrawingAtTime(currentStageTotalDuration, currentStageDrawingData, replayCtx);
Â  Â  Â  Â  updateMediaProgressBar(currentStageTotalDuration, currentStageTotalDuration);
Â  Â  Â  Â  stageProgressBarContainer?.classList.add('visible');
Â  Â  Â  Â  }
Â  Â  Â  Â  renderStageUI(currentStageIndex, true); // isResize = true indicates resume context
Â  Â  }

Â  Â  function openThelobook() {
Â  Â  // â€” early exits â€”
Â  Â  if (isThelobookActive || isPageGridVisible) return;

Â  Â  /*Â  MCQ stages are now allowed â€” guard removedÂ  */

Â  Â  isThelobookActiveÂ  Â  Â  = true;
Â  Â  isThelobookEraserActive = false;

Â  Â  const TXT = getCurrentUIText();

Â  Â  // pause audio / drawing playback and snapshot timing
Â  Â  captureMediaState();

Â  Â  // show notebook canvas & controls
Â  Â  thelobookCanvas.classList.remove('grid-underlay');
Â  Â  thelobookCanvas.classList.add('active');
Â  Â  thelobookControlsEl.classList.add('visible');

Â  Â  // ensure at least one page exists, then load current page
Â  Â  if (thelobookPages.length === 0) {
Â  Â  Â  Â  thelobookPages.push(null);
Â  Â  Â  Â  currentThelobookPageIndex = 0;
Â  Â  }
Â  Â  loadThelobookPageDrawing(currentThelobookPageIndex);

Â  Â  // switch input listeners
Â  Â  removeBoardDrawListeners();
Â  Â  addThelobookDrawListeners();
Â  Â  canvas.style.pointerEvents = 'none';

Â  Â  // update UI text / states
Â  Â  thelobookBtn.textContent = TXT.thelobookClose;
Â  Â  if (thelobookEraserBtn) {
Â  Â  Â  Â  thelobookEraserBtn.textContent = 'âœï¸';
Â  Â  Â  Â  thelobookEraserBtn.titleÂ  Â  Â  = TXT.thelobookEraser;
Â  Â  Â  Â  thelobookEraserBtn.classList.remove('active');
Â  Â  }
Â  Â  if (clearBtn)Â  clearBtn.disabledÂ  = true;
Â  Â  if (prevBtn)Â  Â prevBtn.disabledÂ  Â = true;
Â  Â  if (nextCheckBtn) nextCheckBtn.disabled = true;

Â  Â  updateColorIndicator();
Â  Â  updateThelobookPageControls();

Â  Â  /* â”€â”€ blur MCQ block if itâ€™s visible â”€â”€ */
Â  Â  if (mcqOptionsContainer &&
Â  Â  Â  Â  mcqOptionsContainer.style.display !== 'none') {
Â  Â  Â  Â  mcqOptionsContainer.classList.add('blurred-mcq');
Â  Â  }
}


function closeThelobook(savePage = true) {
Â  Â  if (!isThelobookActive) return;

Â  Â  /* â”€â”€ restore MCQ clarity â”€â”€ */
Â  Â  if (mcqOptionsContainer) {
Â  Â  Â  Â  mcqOptionsContainer.classList.remove('blurred-mcq');
Â  Â  }

Â  Â  Â  Â  if (savePage) saveCurrentThelobookPageDrawing();
Â  Â  Â  Â  isThelobookActive = false; const TXT = getCurrentUIText();

Â  Â  Â  Â  thelobookCanvas.classList.remove('active');
Â  Â  Â  Â  thelobookCanvas.classList.remove('grid-underlay');
Â  Â  Â  Â  thelobookControlsEl.classList.remove('visible');
Â  Â  Â  Â  removeThelobookDrawListeners(); addBoardDrawListeners();
Â  Â  Â  Â  thelobookBtn.textContent = TXT.thelobookOpen;
Â  Â  Â  Â Â 
Â  Â  Â  Â  resumeMediaState();
Â  Â  Â  Â Â 
Â  Â  Â  Â  // ======================= FIX STARTS HERE =======================
Â  Â  Â  Â  if (currentStageIndex === -1) {
Â  Â  Â  Â  Â  Â  // This is the edge case: lesson hasn't started.
Â  Â  Â  Â  Â  Â  // Manually re-enable the 'Start' button.
Â  Â  Â  Â  Â  Â  if (nextCheckBtn) nextCheckBtn.disabled = false;
Â  Â  Â  Â  }
Â  Â  Â  Â  // ======================== FIX ENDS HERE ========================

Â  Â  Â  Â  // The original logic can remain or be cleaned up, but the fix above is key.
Â  Â  Â  Â  if (currentStageData) {
Â  Â  Â  Â  Â  Â  // renderStageUI is called by resumeMediaState
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  updateColorIndicator();
Â  Â  Â  Â  Â  Â  canvas.style.pointerEvents = 'none';
Â  Â  Â  Â  }
Â  Â  Â  Â 
Â  Â  Â  Â  wasMediaPlayingBeforeThelobook = false;Â 
Â  Â  }
Â  Â // REPLACE your existing open/close calculator functions with these

// REPLACE your functions with these corrected versions

function openCalculator() {
Â  Â  if (isCalculatorActive || isThelobookActive || isPageGridVisible) return;
Â  Â  isCalculatorActive = true;

Â  Â  // The line that hid the terminal has been REMOVED from here.

Â  Â  // Pause lesson and capture state
Â  Â  captureMediaState();

Â  Â  // Set the src only when opening to load it
Â  Â  if(calculatorFrame.src === 'about:blank') {
Â  Â  Â  Â calculatorFrame.src = 'https://thelo.space/thelo-calculator/';
Â  Â  }
Â  Â Â 
Â  Â  // Show the overlay
Â  Â  calculatorOverlay.classList.remove('calculator-hidden');
Â  Â Â 
Â  Â  // Blur MCQs if they are visible
Â  Â  if (mcqOptionsContainer && mcqOptionsContainer.style.display !== 'none') {
Â  Â  Â  Â  mcqOptionsContainer.classList.add('blurred-mcq');
Â  Â  }

Â  Â  // Disable main controls
Â  Â  if (clearBtn)Â  clearBtn.disabledÂ  = true;
Â  Â  if (prevBtn)Â  Â prevBtn.disabledÂ  Â = true;
Â  Â  if (nextCheckBtn) nextCheckBtn.disabled = true;
}

function closeCalculator() {
Â  Â  if (!isCalculatorActive) return;
Â  Â  isCalculatorActive = false;
Â  Â Â 
Â  Â  // The line that showed the terminal has been REMOVED from here.
Â  Â Â 
Â  Â  // Hide the overlay
Â  Â  calculatorOverlay.classList.add('calculator-hidden');
Â  Â Â 
Â  Â  // Un-blur MCQs
Â  Â  if (mcqOptionsContainer) {
Â  Â  Â  Â  mcqOptionsContainer.classList.remove('blurred-mcq');
Â  Â  }
Â  Â Â 
Â  Â  // Resume lesson state
Â  Â  resumeMediaState();
}
function handleKeyDown(event) {
Â  Â  // 1. Universal Replay Seeking (Highest Priority)
Â  Â  if (currentStageTotalDuration > 0 && (event.key === 'ArrowLeft' || event.key === 'ArrowRight')) {
Â  Â  Â  Â  const isReplayActiveStage = currentStageData?.type === 'explanation_with_media' || currentStageData?.type === 'calculator_replay';
Â  Â  Â  Â  if (isReplayActiveStage || isMediaScrubbingActive) {
Â  Â  Â  Â  Â  Â  event.preventDefault(); isMediaScrubbingActive = true;
Â  Â  Â  Â  Â  Â  if (currentReplayAnimationId) { cancelAnimationFrame(currentReplayAnimationId); currentReplayAnimationId = null; }
Â  Â  Â  Â  Â  Â  const step = 5; const diff = event.key === 'ArrowLeft' ? -step : step;
Â  Â  Â  Â  Â  Â  let newTime = Math.max(0, Math.min(internalPlaybackTime + diff, currentStageTotalDuration));
Â  Â  Â  Â  Â  Â  internalPlaybackTime = newTime;
Â  Â  Â  Â  Â  Â  if (currentStageAudio) {
Â  Â  Â  Â  Â  Â  Â  Â  const audioTargetTime = Math.min(newTime, currentStageAudio.duration > 0.01 ? currentStageAudio.duration - 0.01 : 0);
Â  Â  Â  Â  Â  Â  Â  Â  currentStageAudio.currentTime = audioTargetTime;
Â  Â  Â  Â  Â  Â  Â  Â  if (window.userInteracted && currentStageAudio.paused && audioTargetTime < (currentStageAudio.duration - 0.01)) { currentStageAudio.play().catch(() => {}); }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  if (isReplayActive && replayFrame && replayFrame.contentWindow) { replayFrame.contentWindow.postMessage({ command: 'seekToTime', timeMs: newTime * 1000 }, '*'); }
Â  Â  Â  Â  Â  Â  if (currentStageDrawingData && replayCtx) { renderDrawingAtTime(newTime, currentStageDrawingData, replayCtx); }
Â  Â  Â  Â  Â  Â  updateMediaProgressBar(newTime, currentStageTotalDuration);
Â  Â  Â  Â  Â  Â  lastFrameTimestampForManualAdvance = 0; currentReplayAnimationId = requestAnimationFrame(mediaPlaybackLoop);
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }
Â  Â  }

Â  Â  // 2. Ignore inputs with modifiers or in text fields
Â  Â  if (event.ctrlKey || event.altKey || event.metaKey || ['INPUT', 'TEXTAREA'].includes(event.target.tagName.toUpperCase())) { return; }

Â  Â  // 3. Handle overlay key presses
Â  Â  if (isPageGridVisible) {
Â  Â  Â  Â  if (event.key.toLowerCase() === 'c') changePageGridBatch(1);
Â  Â  Â  Â  if (event.key.toLowerCase() === 'x') changePageGridBatch(-1);
Â  Â  Â  Â  if (event.key === 'Escape') closePageGridView();
Â  Â  Â  Â  return;
Â  Â  }
Â  Â  if (isCalculatorActive) {
Â  Â  Â  Â  if (event.key.toLowerCase() === 'f' || event.key === 'Escape') closeCalculator();
Â  Â  Â  Â  return;
Â  Â  }
Â  Â  if (isThelobookActive) {
Â  Â  Â  Â  if (event.key.toLowerCase() === 'b' || event.key === 'Escape') closeThelobook(true);
Â  Â  Â  Â  if (event.key.toLowerCase() === 'e') toggleThelobookEraser();
Â  Â  Â  Â  if (event.key.toLowerCase() === 'c') clearUserCanvas();
Â  Â  Â  Â  return;
Â  Â  }
Â  Â Â 
Â  Â  // 4. Handle MCQ-specific navigation
Â  Â  const mcqDetails = currentStageData ? currentStageData.optionsQuiz : null;
Â  Â  const isMcqActive = !!(currentStageData && currentStageData.type === "explanation_with_mcq" && mcqDetails && mcqDetails.choices);

Â  Â  if (isMcqActive && !isMcqAnsweredCorrectly) {
Â  Â  Â  Â  event.preventDefault();
Â  Â  Â  Â  const optionCount = mcqDetails.choices.length;
Â  Â  Â  Â  let newIndex = selectedMcqIndex;

Â  Â  Â  Â  if (event.key === 'ArrowRight') { newIndex = (selectedMcqIndex + 1) % optionCount; }Â 
Â  Â  Â  Â  else if (event.key === 'ArrowLeft') { newIndex = (selectedMcqIndex - 1 + optionCount) % optionCount; }
Â  Â  Â  Â Â 
Â  Â  Â  Â  updateMcqSelectionVisuals(newIndex);
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (event.key !== ' ' && event.key !== 'Enter') { return; }
Â  Â  }

Â  Â  // 5. Handle Confirmation Keys (Spacebar & Enter)
Â  Â  if (event.key === ' ' || event.key === 'Enter') {
Â  Â  Â  Â  event.preventDefault();
Â  Â  Â  Â  if (dashboardBtn && dashboardBtn.classList.contains('visible')) { dashboardBtn.click(); return; }
Â  Â  Â  Â  if (nextCheckBtn && !nextCheckBtn.disabled) { handleNextCheckClick(); }
Â  Â  }
Â  Â Â 
Â  Â  // 6. Handle General App Shortcuts
Â  Â  if (currentStageIndex >= 0 && !isTransitioning && !isLessonLoading && currentStageData) {
Â  Â  Â  Â  switch (event.key.toLowerCase()) {
Â  Â  Â  Â  Â  Â  case 'b': openThelobook(); event.preventDefault(); break;
Â  Â  Â  Â  Â  Â  case 'f': openCalculator(); event.preventDefault(); break;
Â  Â  Â  Â  Â  Â  case 'a': hideOnCanvasFeedback(); event.preventDefault(); break;
Â  Â  Â  Â  Â  Â  case 'c':
Â  Â  Â  Â  Â  Â  Â  Â  if (isStudentInputAllowed && !isMcqActive && clearBtn && clearBtn.style.display !== 'none' && !clearBtn.disabled) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  clearUserCanvas(); event.preventDefault();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  }
Â  Â  }
}	Â Â 
	Â  window.addEventListener('keydown', function(e) {
Â  if ((e.ctrlKey || e.metaKey) && (e.key === '+' || e.key === '-' || e.key === '=')) {
Â  Â  e.preventDefault();
Â  }
});

window.addEventListener('wheel', function(e) {
Â  if (e.ctrlKey) {
Â  Â  e.preventDefault();
Â  }
}, { passive: false });
	 // REPLACE the old clearUserCanvas function with this one
function clearUserCanvas() {
Â  Â  if (isPageGridVisible) return;

Â  Â  if (isThelobookActive) {
Â  Â  Â  Â  if (thelobookCtx) {
Â  Â  Â  Â  Â  Â  thelobookCtx.clearRect(0, 0, thelobookCanvas.width / devicePixelRatio, thelobookCanvas.height / devicePixelRatio);
Â  Â  Â  Â  Â  Â  if (currentThelobookPageIndex >= 0 && currentThelobookPageIndex < thelobookPages.length) {
Â  Â  Â  Â  Â  Â  Â  Â  thelobookPages[currentThelobookPageIndex] = null;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  return;
Â  Â  }

Â  Â  if (ctx) {
Â  Â  Â  Â  ctx.clearRect(0, 0, canvas.width / devicePixelRatio, canvas.height / devicePixelRatio);
Â  Â  }

Â  Â  userDrawingOccurred = false;

Â  Â  // --- ADD THIS ---
Â  Â  // Also clear the minimap canvas
Â  Â  if (minimapCtx) {
Â  Â  Â  Â  minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
Â  Â  }
}
Â  Â  // REPLACE your existing initApp function with this entire block

function initApp() {
Â  Â  // NEW: Add this check at the very top of the function
Â  Â 
Â  Â  // --- The rest of your original initApp function continues below ---
Â  Â Â 
Â  Â  console.log("KaTeX is ready. Initializing app.");
Â  Â  checkTabletMode();
Â  Â  const audioIdsToLoad = [
Â  Â  Â  Â  'audio_approve1_hy', 'audio_approve2_hy', 'audio_dis1_hy', 'audio_dis2_hy',
Â  Â  Â  Â  'audio_approve1_en', 'audio_approve2_en', 'audio_dis1_en', 'audio_dis2_en', 'gotItSound'
Â  Â  ];
Â  Â  audioIdsToLoad.forEach(id => {
Â  Â  Â  Â  const audio = document.getElementById(id);
Â  Â  Â  Â  if (audio) {
Â  Â  Â  Â  Â  Â  audioElements[id] = audio;
Â  Â  Â  Â  Â  Â  if (id.startsWith('audio_approve') && id.endsWith('_hy')) approveSounds_hy.push(audio);
Â  Â  Â  Â  Â  Â  if (id.startsWith('audio_dis') && id.endsWith('_hy')) disapproveSounds_hy.push(audio);
Â  Â  Â  Â  Â  Â  if (id.startsWith('audio_approve') && id.endsWith('_en')) approveSounds_en.push(audio);
Â  Â  Â  Â  Â  Â  if (id.startsWith('audio_dis') && id.endsWith('_en')) disapproveSounds_en.push(audio);
Â  Â  Â  Â  }
Â  Â  });
Â  Â  resizeCanvases();
Â  Â  addBoardDrawListeners();
Â  Â  window.addEventListener('mouseup', handleDrawingEnd);
Â  Â  window.addEventListener('mouseleave', handleDrawingEnd);
Â  Â  window.addEventListener('touchend', handleDrawingEnd);
Â  Â  window.addEventListener('touchcancel', handleDrawingEnd);

Â  Â  const urlParams = new URLSearchParams(window.location.search);
Â  Â  const lessonFileName = urlParams.get('lessonFile');
Â  Â  if (lessonFileName) {
Â  Â  Â  Â  const LESSONS_BASE_PATH = 'https://thelo.space/lessons/';
Â  Â  Â  Â  const cleanLFN = lessonFileName.startsWith('/') ? lessonFileName.substring(1) : lessonFileName;
Â  Â  Â  Â  loadLesson(LESSONS_BASE_PATH + cleanLFN.replace(/\.\.+/g, ''));
Â  Â  } else {
Â  Â  Â  Â  const TXT = getCurrentUIText();
Â  Â  Â  Â  addChatMessage('AI', formatAIMessage('lessonFileMissing'));
Â  Â  Â  Â  if(nextCheckBtn){nextCheckBtn.textContent = TXT.error; nextCheckBtn.disabled = true;}
Â  Â  Â  Â  if(prevBtn)prevBtn.disabled = true;
Â  Â  Â  Â  if(bgCtx && backgroundCanvas && backgroundCanvas.width > 0){
Â  Â  Â  Â  Â  Â  const cw = backgroundCanvas.width/(window.devicePixelRatio||1); const ch = backgroundCanvas.height/(window.devicePixelRatio||1);
Â  Â  Â  Â  Â  Â  bgCtx.clearRect(0,0,cw,ch); bgCtx.font = `20px 'Mardoto-Light', system-ui, sans-serif`;
Â  Â  Â  Â  Â  Â  bgCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--thelo-text').trim();
Â  Â  Â  Â  Â  Â  bgCtx.textAlign='center';bgCtx.textBaseline='middle';
Â  Â  Â  Â  Â  Â  wrapText(bgCtx, TXT.lessonLoadErrorGeneric, cw/2, ch/2, cw*0.8, 30);
Â  Â  Â  Â  }
Â  Â  }
Â  Â  const interactionListener = () => { if (window.userInteracted) return; window.userInteracted = true; Object.values(audioElements).forEach(a => { if(a.readyState < 1) a.load(); }); if(stageAudioPlayer && stageAudioPlayer.readyState < 1) stageAudioPlayer.load(); try { const tempAC = new (window.AudioContext || window.webkitAudioContext)(); if (tempAC.state === 'suspended') tempAC.resume().then(()=>tempAC.close()); else tempAC.close(); } catch(e){} document.body.removeEventListener('click', interactionListener); document.body.removeEventListener('keydown', interactionListener); document.body.removeEventListener('touchstart', interactionListener); };
Â  Â  document.body.addEventListener('click', interactionListener, { once: true });
Â  Â  document.body.addEventListener('keydown', interactionListener, { once: true });
Â  Â  document.body.addEventListener('touchstart', interactionListener, { once: true });
Â  Â  window.addEventListener('resize', resizeCanvases);
Â  Â  if (prevBtn) prevBtn.onclick = previousStage;
Â  Â  if (nextCheckBtn) nextCheckBtn.onclick = handleNextCheckClick;
Â  Â  const fullscreenBtn = document.getElementById('fullscreenBtn');
Â  Â  if (fullscreenBtn) {
Â  Â  Â  Â  fullscreenBtn.onclick = toggleFocusFullscreen;
Â  Â  }

Â  Â  if (clearBtn) clearBtn.onclick = clearUserCanvas;
Â  Â  if (thelobookBtn) thelobookBtn.onclick = () => { isThelobookActive ? closeThelobook(true) : openThelobook(); };

Â  Â  if (thelobookPrevPageBtn) thelobookPrevPageBtn.onclick = () => changeThelobookPageSimple(-1);
Â  Â  if (thelobookNextPageBtn) thelobookNextPageBtn.onclick = () => changeThelobookPageSimple(1);
Â  Â  if (thelobookEraserBtn) thelobookEraserBtn.onclick = toggleThelobookEraser;
Â  Â  if (thelobookAddPageBtn) thelobookAddPageBtn.onclick = addThelobookNewPage;
Â  Â  if (calculatorCloseBtn) calculatorCloseBtn.onclick = closeCalculator;
Â  Â  if (openCalculatorBtn) openCalculatorBtn.onclick = openCalculator;
Â  Â  if (dashboardBtn) {
Â  Â  Â  Â  dashboardBtn.onclick = () => {
Â  Â  Â  Â  Â  Â  window.location.href = 'https://thelo.space/sdashboard';
Â  Â  Â  Â  };
Â  Â  }

Â  Â  document.querySelectorAll('button').forEach(button => {
Â  Â  Â  Â  button.addEventListener('click', () => {
Â  Â  Â  Â  Â  Â  button.blur();
Â  Â  Â  Â  });
Â  Â  });

Â  Â  document.addEventListener('keydown', handleKeyDown);

Â  Â  window.addEventListener('beforeunload', () => {
Â  Â  Â  Â  const user = auth.currentUser;
Â  Â  Â  Â  if (user && lessonStartTime && currentStageIndex < lessonStages.length -1) {
Â  Â  Â  Â  Â  Â  const urlParams = new URLSearchParams(window.location.search);
Â  Â  Â  Â  Â  Â  const lessonFileName = urlParams.get('lessonFile');
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  navigator.sendBeacon('https://firestore.googleapis.com/v1/projects/physmathacademy-722b3/databases/(default)/documents/analytics_events', JSON.stringify({
Â  Â  Â  Â  Â  Â  Â  Â  fields: {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  type: { stringValue: 'lesson_abandoned' },
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  userId: { stringValue: user.uid },
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lessonId: { stringValue: lessonFileName.replace('.json', '') },
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lastCompletedStageIndex: { integerValue: currentStageIndex },
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  totalStagesInLesson: { integerValue: lessonStages.length },
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  timestamp: { timestampValue: new Date().toISOString() }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }));
Â  Â  Â  Â  }
Â  Â  });
}

Â  Â  if (typeof window.appInitialized === 'undefined') {
Â  Â  Â  Â  window.appInitialized = false;
Â  Â  }

Â  // This listener ensures the entire page, including all styles and fonts, is ready before the app starts.
document.addEventListener('DOMContentLoaded', async () => {

Â  Â  // Helper function to programmatically load KaTeX CSS
Â  Â  let isKatexCssInjected = false;
Â  Â  async function ensureKatexCssIsLoaded() {
Â  Â  Â  Â  if (isKatexCssInjected) return;
Â  Â  Â  Â  // This re-uses your existing function that cleverly embeds the fonts!
Â  Â  Â  Â  const cssText = await getKatexCSSWithEmbeddedFonts();
Â  Â  Â  Â  const style = document.createElement('style');
Â  Â  Â  Â  style.textContent = cssText;
Â  Â  Â  Â  document.head.appendChild(style);
Â  Â  Â  Â  isKatexCssInjected = true;
Â  Â  Â  Â  console.log('KaTeX CSS has been injected into the document head.');
Â  Â  }

Â  Â  // --- Start of App Initialization ---

Â  Â  console.log('DOM is ready. Checking for KaTeX library:', typeof katex);
Â  Â  if (typeof katex === 'undefined') {
Â  Â  Â  Â  console.error('CRITICAL: KaTeX library failed to load before app start.');
Â  Â  Â  Â  return;
Â  Â  }

Â  Â  try {
Â  Â  Â  Â  // 1. Force the CSS to load and be injected first.
Â  Â  Â  Â  await ensureKatexCssIsLoaded();

Â  Â  Â  Â  // 2. Now, wait for the browser to acknowledge all fonts are ready.
Â  Â  Â  Â  await document.fonts.ready;
Â  Â  Â  Â  console.log('All fonts are confirmed ready.');

Â  Â  Â  Â  // 3. Proceed with app initialization, confident that everything is loaded.
Â  Â  Â  Â  auth.onAuthStateChanged(user => {
Â  Â  Â  Â  Â  Â  const finishInitialization = () => {
Â  Â  Â  Â  Â  Â  Â  Â  if (!window.appInitialized) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  window.appInitialized = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  initApp();
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  updateAllUITexts();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  isAuthReady = true;
Â  Â  Â  Â  Â  Â  Â  Â  console.log("Authentication is now ready.");
Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â  if (user) {
Â  Â  Â  Â  Â  Â  Â  Â  console.log("User authenticated with UID:", user.uid);
Â  Â  Â  Â  Â  Â  Â  Â  const userDocRef = db.collection('thelo-students').doc(user.uid);

Â  Â  Â  Â  Â  Â  Â  Â  userDocRef.get().then(doc => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (doc.exists) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  userPoints = doc.data().points || 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  userPoints = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log("No points document found for user, starting at 0.");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  updatePointsDisplay();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  finishInitialization();
Â  Â  Â  Â  Â  Â  Â  Â  }).catch(error => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.error("Error fetching user points:", error);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  userPoints = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  updatePointsDisplay();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  finishInitialization();
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  userPoints = 0;
Â  Â  Â  Â  Â  Â  Â  Â  updatePointsDisplay();
Â  Â  Â  Â  Â  Â  Â  Â  console.log("User not authenticated.");
Â  Â  Â  Â  Â  Â  Â  Â  finishInitialization();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });

Â  Â  } catch (error) {
Â  Â  Â  Â  console.error('Styles or fonts failed to load, app initialization aborted:', error);
Â  Â  }
});
// Add this function somewhere logical, e.g., near updateUserPointsInFirestore
async function logDigitForTraining(recognizedValue, feedbackType) {
Â  Â  const user = auth.currentUser;
Â  Â  if (!user) {
Â  Â  Â  Â  console.warn("No user for digit logging. Skipping.");
Â  Â  Â  Â  return;
Â  Â  }

Â  Â  // Ensure the main canvas has content
Â  Â  if (!canvas || canvas.width === 0 || canvas.height === 0) {
Â  Â  Â  Â  console.warn("Main canvas is not ready or empty. Cannot log digit for training.");
Â  Â  Â  Â  return;
Â  Â  }

Â  Â  let base64ImageData;
Â  Â  try {
Â  Â  Â  Â  // Capture the content of the main canvas (which contains the blue ink)
Â  Â  Â  Â  base64ImageData = canvas.toDataURL('image/png');
Â  Â  } catch (e) {
Â  Â  Â  Â  console.error("Failed to get image data from canvas for logging:", e);
Â  Â  Â  Â  return;
Â  Â  }

Â  Â  const metadata = {
Â  Â  Â  Â  digit: String(recognizedValue),
Â  Â  Â  Â  recognizedByVision: currentStageData.correctAnswerOcr,
Â  Â  Â  Â  feedbackType: feedbackType,
Â  Â  Â  Â  timestamp: firebase.firestore.FieldValue.serverTimestamp(),
Â  Â  Â  Â  userId: user.uid,
Â  Â  Â  Â  lessonId: new URLSearchParams(window.location.search).get('lessonFile')?.replace('.json', '') || 'unknown',
Â  Â  Â  Â  stageIndex: currentStageIndex,
Â  Â  Â  Â  deviceType: isTabletMode ? 'tablet' : 'desktop',
Â  Â  Â  Â  userAgent: navigator.userAgent,
Â  Â  Â  Â  screenWidth: window.screen.width,
Â  Â  Â  Â  screenHeight: window.screen.height,
Â  Â  Â  Â  canvasWidth: canvas.width,
Â  Â  Â  Â  canvasHeight: canvas.height,
Â  Â  Â  Â  devicePixelRatio: window.devicePixelRatio || 1,
Â  Â  };

Â  Â  try {
Â  Â  Â  Â  // Send to a new collection specifically for training data
Â  Â  Â  Â  await db.collection('thelo-training-digits-demo').add({
Â  Â  Â  Â  Â  Â  imageData: base64ImageData,
Â  Â  Â  Â  Â  Â  metadata: metadata
Â  Â  Â  Â  });
Â  Â  Â  Â  console.log("Handwritten digit logged for training demo:", recognizedValue);
Â  Â  } catch (error) {
Â  Â  Â  Â  console.error("Error logging digit for training demo:", error);
Â  Â  }
}

</script>
</html>
