<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link rel="icon" href="https://thelo.space/img/thelofavicon.png" type="image/png">
    <link rel="apple-touch-icon" href="https://thelo.space/img/yarnicon.png">
    <title>thelo | Test Mode</title>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-functions-compat.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@300;400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<style>
 /* ===== NEW: Updated Design System ===== */
 :root {
  /* Core Palette */
  --thelo-blue: #2563eb;
  --thelo-blue-dark: #1d4ed8;
  --thelo-bg: #ffffff;
  --thelo-text: #111827;
  --thelo-text-light: #6b7280;
  --thelo-border: #e5e7eb;

  /* Status Colors */
  --success-green: #22c55e;
  --error-red: #ef4444;
  --accent-yellow: #f59e0b;

  /* UI Element Colors */
  --bg-white: #ffffff;
  --chat-ai-bg: #ffffff;

  /* Ink Colors */
  --ink-black: #000000;
  --ink-blue: var(--thelo-blue);

  /* Effects */
  --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
  --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
  --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);

  /* Transitions */
  --fade-duration: 0.3s;
  --animation-duration: 0.3s;
 }
 #loading-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: var(--thelo-bg);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 9999;
  opacity: 1;
  transition: opacity 0.5s ease-out;
 }
 #loading-overlay.hidden {
  opacity: 0;
  pointer-events: none;
 }
 #loading-svg {
  width: 150px;
  height: auto;
  animation: pulse-loader 1.5s infinite ease-in-out;
 }
 @keyframes pulse-loader {
  0% { transform: scale(1); opacity: 0.8; }
  50% { transform: scale(1.1); opacity: 1; }
  100% { transform: scale(1); opacity: 0.8; }
 }
 html {
  font-size: 16px;
  background: var(--thelo-bg);
 }
 body {
  margin: 0;
  min-height: 100vh;
  height: 100vh;
  font-family: 'Manrope', system-ui, -apple-system, sans-serif;
  font-weight: 400;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  background-color: var(--thelo-bg);
  color: var(--thelo-text);
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  -webkit-touch-callout: none;
 }
 #app { display: flex; flex-grow: 1; height: 100%; }
 #lessonArea {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  flex-direction: column;
  overflow: hidden;
 }
 #boardWrap {
  position: relative;
  flex-grow: 1;
  overflow: hidden;
  background-color: var(--thelo-bg);
  background-image: linear-gradient(to right, var(--thelo-border) 1px, transparent 1px),
   linear-gradient(to bottom, var(--thelo-border) 1px, transparent 1px);
  background-size: 40px 40px;
 }
 #backgroundCanvas,
 #board {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: block;
  background-color: transparent;
 }
 #backgroundCanvas {
  z-index: 1;
  pointer-events: none;
  opacity: 1;
  transition: opacity var(--fade-duration) ease-in-out;
 }
 #backgroundCanvas.fade-out {
  opacity: 0;
 }
 #board {
  z-index: 3;
  cursor: crosshair;
  touch-action: none;
 }
 #bottomBar {
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  background-color: transparent;
  box-sizing: border-box;
  padding: 1rem 1.5rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
  z-index: 20;
  transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1);
 }
 #button-group {
    display: flex;
    gap: 0.2rem; /* MODIFIED: Buttons are closer */
 }
 .control-btn {
  font-family: inherit;
  padding: 0.5rem 1rem;
  font-size: 0.9rem;
  font-weight: 500;
  border: none;
  border-radius: 0.5rem;
  color: var(--bg-white);
  cursor: pointer;
  transition: background-color 0.2s, transform 0.15s, box-shadow 0.2s;
  box-shadow: var(--shadow-md);
  touch-action: manipulation;
 }
 .control-btn:hover:not(:disabled) {
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
 }
 .control-btn:disabled {
  background-color: #9ca3af !important;
  cursor: not-allowed;
  opacity: 0.7;
 }
 #prevBtn { background-color: var(--accent-yellow); }
 #clearBtn { background-color: var(--error-red); }
 #submitBtn { background-color: var(--thelo-blue); }
 #submitBtn:hover:not(:disabled) { background-color: var(--thelo-blue-dark); }

 .bar-hidden-by-stylus {
  transform: translateY(150%);
  pointer-events: none;
 }
 html, body {
  cursor: none !important;
 }
 .no-cursor {
  cursor: none !important;
 }
 #bottom-logo-container {
  position: fixed;
  bottom: 1.25rem; /* MODIFIED: Logo is raised slightly */
  left: 50%;
  transform: translateX(-50%);
  z-index: 10000;
  pointer-events: none;
 }
 #bottom-logo-container img {
  display: block;
  height: 35px;
  width: auto;
 }
 #timerDisplay {
  background-color: rgba(255, 255, 255, 0.8);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  padding: 0.5rem 1.25rem;
  border-radius: 999px;
  font-size: 1.2rem;
  font-weight: 700;
  color: var(--thelo-text);
  box-shadow: var(--shadow-md);
  border: 1px solid var(--thelo-border);
 }
 #resultsScreen {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 50;
  background-color: var(--thelo-bg);
  display: none;
  flex-direction: column;
  align-items: center;
  padding: 2rem;
  box-sizing: border-box;
 }
 #resultsContainer {
  width: 100%;
  max-width: 800px;
  text-align: center;
 }
 #resultsHeader {
  border-bottom: 2px solid var(--thelo-border);
  padding-bottom: 1rem;
  margin-bottom: 1.5rem;
 }
 #resultsScore {
  font-size: 2.5rem;
  font-weight: 800;
  color: var(--thelo-blue);
 }
 #resultsTime {
  font-size: 1.2rem;
  color: var(--thelo-text-light);
 }
 #resultsFeedbackList {
  flex-grow: 1;
  width: 100%;
  overflow-y: auto;
  text-align: left;
 }
 .feedback-item {
  background-color: #f9fafb;
  border: 1px solid var(--thelo-border);
  border-radius: 0.75rem;
  padding: 1rem 1.5rem;
  margin-bottom: 1rem;
 }
 .feedback-item-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.5rem;
 }
 .feedback-item-header h3 {
  margin: 0;
  font-size: 1.1rem;
 }
 .feedback-item-header .status-correct {
  color: var(--success-green);
  font-weight: 700;
 }
 .feedback-item-header .status-incorrect {
  color: var(--error-red);
  font-weight: 700;
 }
 .feedback-item p {
  margin: 0;
  line-height: 1.6;
 }
 @media (max-width: 768px) {
     #bottomBar {
         flex-wrap: wrap;
         justify-content: center; /* Center items when they wrap */
         gap: 1rem;
     }
     .control-btn {
         padding: 0.6rem 0.8rem;
         font-size: 0.8rem;
     }
 }
 @media (min-width: 769px) and (max-width: 1200px) and (pointer: coarse) {
     #boardWrap {
         -webkit-user-select: none;
         -moz-user-select: none;
         -ms-user-select: none;
         user-select: none;
         -webkit-touch-callout: none;
     }
 }
</style>
</head>
<body>
    <div id="loading-overlay">
        <img id="loading-svg" src="https://thelo.space/img/bluethelo.svg" alt="Loading...">
    </div>
    <div id="app">
        <div id="lessonArea">
            <div id="boardWrap">
                <canvas id="backgroundCanvas"></canvas>
                <canvas id="board"></canvas>
            </div>
            <div id="bottomBar">
                <div id="timerDisplay">00:00</div>
                <div id="button-group">
                    <button id="prevBtn" class="control-btn"></button>
                    <button id="clearBtn" class="control-btn"></button>
                    <button id="submitBtn" class="control-btn"></button>
                </div>
            </div>
        </div>
    </div>
    <div id="resultsScreen">
        <div id="resultsContainer">
            <div id="resultsHeader">
                <h1>Test Complete!</h1>
                <div id="resultsScore">Score: 0 / 0 (0%)</div>
                <div id="resultsTime">Time Taken: 00:00</div>
            </div>
            <div id="resultsFeedbackList"></div>
        </div>
    </div>
    <div id="bottom-logo-container">
        <img src="https://thelo.space/img/bluethelo.svg" alt="Thelo Logo">
    </div>

<script>
    const firebaseConfig = { apiKey: "AIzaSyAbnPpcIt88B0jIAoLUdC71zmQDvR_fdu8", authDomain: "physmathacademy-722b3.firebaseapp.com", projectId: "physmathacademy-722b3", messagingSenderId: "1093640992262", appId: "1:1093640992262:web:35b1bf4d2364bcf745f587" };
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    /* ========== DOM Elements ========== */
    const loadingOverlay = document.getElementById('loading-overlay');
    const backgroundCanvas = document.getElementById('backgroundCanvas');
    const canvas = document.getElementById('board');
    const boardWrapper = document.getElementById('boardWrap');
    const prevBtn = document.getElementById('prevBtn');
    const submitBtn = document.getElementById('submitBtn');
    const clearBtn = document.getElementById('clearBtn');
    const timerDisplay = document.getElementById('timerDisplay');
    const resultsScreen = document.getElementById('resultsScreen');
    const bottomBar = document.getElementById('bottomBar');
    const bgCtx = backgroundCanvas.getContext('2d');
    const ctx = canvas.getContext('2d');

    /* ========== State Variables ========== */
    let testData = null;
    let currentStageIndex = -1;
    let currentStageData = null;
    let drawing = false;
    let lastPos = { x: 0, y: 0 };
    let userDrawingOccurred = false;
    let isTransitioning = false;
    let devicePixelRatio = window.devicePixelRatio || 1;
    let timerInterval = null;
    let testStartTime = null;
    let testResults = [];
    let isTabletMode = false;
    let buttonVanishTimer = null;

    /* ========== UI Text ========== */
    const UI_TEXT = {
        start: "Start Test",
        submit: "Submit Answer",
        checking: "Checking...",
        prev: "Previous",
        clear: "Clear",
        correct: "Correct",
        incorrect: "Incorrect"
    };
    
    // ===================================================================
    //  STYLING MATCH: KaTeX and Headline Rendering Functions from Main App
    // ===================================================================
    let katexCSSInlined = null;

    function abToBase64(ab) {
        const CHUNK = 0x8000;
        const bytes = new Uint8Array(ab);
        let binary = '';
        for (let i = 0; i < bytes.length; i += CHUNK) {
            binary += String.fromCharCode(...bytes.subarray(i, i + CHUNK));
        }
        return btoa(binary);
    }

    async function getKatexCSSWithEmbeddedFonts() {
        if (katexCSSInlined) return katexCSSInlined;
        const base = 'https://cdn.jsdelivr.net/npm/katex@0.16.10/dist';
        let css = await (await fetch(`${base}/katex.min.css`)).text();
        const fonts = ['KaTeX_Main-Regular.woff2', 'KaTeX_Main-Italic.woff2', 'KaTeX_Main-Bold.woff2', 'KaTeX_Math-Italic.woff2', 'KaTeX_AMS-Regular.woff2', 'KaTeX_Size1-Regular.woff2', 'KaTeX_Size2-Regular.woff2'];
        for (const name of fonts) {
            const url = `${base}/fonts/${name}`;
            const res = await fetch(url);
            const b64 = abToBase64(await res.arrayBuffer());
            const dataURL = `url(data:font/woff2;base64,${b64}) format("woff2")`;
            css = css.replace(new RegExp(`url\\([^)]*${name}[^)]*\\)\\s*format\\("woff2"\\)`, 'g'), dataURL);
        }
        katexCSSInlined = css;
        return katexCSSInlined;
    }

    async function ensureHeadlineFontsLoaded() {
        try {
            if (document.fonts && document.fonts.load) {
                await Promise.race([
                    (async () => {
                        await document.fonts.load(`24px "Manrope"`); // MODIFIED
                        await document.fonts.ready;
                    })(),
                    new Promise(res => setTimeout(res, 800))
                ]);
            }
        } catch (_) {}
    }

    async function renderComplexHeadline(bgCtx, headline, y, opts = {}) {
        if (!headline || !bgCtx) return;
        // MODIFIED: Increased font sizes
        const widthFraction = 0.88, yNudge = -14, fontSize = 24, mathFontSize = 26;
        const fontColor = getComputedStyle(document.documentElement).getPropertyValue('--thelo-text').trim() || '#111827';
        const katexCSS = await getKatexCSSWithEmbeddedFonts();
        const extraRules = `.katex, .katex .mathnormal { font-family: "KaTeX_Main", serif !important; }`;
        const segments = (headline.split(/(\/K[\s\S]*?K\/)/g) || []).filter(Boolean).map(p => p.startsWith('/K') && p.endsWith('K/') ? { type: 'math', content: p.replace(/^\/K\s*/, '').replace(/\s*K\/$/, '') } : { type: 'text', content: p });
        const measureHost = document.createElement('div');
        measureHost.style.cssText = 'position:absolute;visibility:hidden;left:-9999px;top:-9999px;';
        document.body.appendChild(measureHost);
        const tokens = [];
        for (const seg of segments) {
            if (seg.type === 'text') {
                const parts = seg.content.match(/(\s+|[^\s]+)/g) || [];
                for (const p of parts) {
                    tokens.push({ type: 'text', content: p, width: bgCtx.measureText(p).width, height: fontSize, isSpace: /^\s+$/.test(p) });
                }
                continue;
            }
            try {
                const html = katex.renderToString(seg.content, { throwOnError: false, output: 'html' });
                const style = document.createElement('style'); style.textContent = katexCSS; measureHost.appendChild(style);
                const tmp = document.createElement('div'); tmp.style.color = fontColor; tmp.style.fontSize = `${mathFontSize}px`; tmp.innerHTML = html; measureHost.appendChild(tmp);
                const rect = (tmp.querySelector('.katex') || tmp).getBoundingClientRect();
                tmp.remove();
                const PAD = 2; const w = Math.ceil(rect.width) + PAD; const h = Math.ceil(rect.height) + PAD;
                const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}"><style>${katexCSS}\n${extraRules}</style><foreignObject width="100%" height="100%"><div xmlns="http://www.w3.org/1999/xhtml" style="color:${fontColor};font-size:${mathFontSize}px;line-height:initial;display:inline-block;padding-right:${PAD/2}px;">${html}</div></foreignObject></svg>`;
                const dataUrl = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svg)));
                const image = new Image(); image.src = dataUrl; await image.decode();
                tokens.push({ type: 'math', image, width: w, height: h, drawW: w, drawH: h });
            } catch (e) {
                tokens.push({ type: 'text', content: seg.content, width: bgCtx.measureText(seg.content).width, height: fontSize, isSpace: false });
            }
        }
        measureHost.remove();
        const canvasW = bgCtx.canvas.width / devicePixelRatio;
        const maxWidth = canvasW * widthFraction;
        const lines = []; let line = { tokens: [], width: 0, height: fontSize };
        for (const t of tokens) {
            let width = t.width, height = t.height, drawW = t.drawW ?? t.width, drawH = t.drawH ?? t.height;
            if (t.type === 'math' && width > maxWidth) { const s = maxWidth / width; width = Math.floor(width * s); height = Math.floor(height * s); drawW *= s; drawH *= s; }
            const tok = { ...t, width, height, drawW, drawH };
            if (line.tokens.length && line.width + width > maxWidth) { lines.push(line); line = { tokens: [], width: 0, height: fontSize }; }
            if (!(line.tokens.length === 0 && tok.isSpace)) { line.tokens.push(tok); line.width += width; if (height > line.height) line.height = height; }
        }
        if (line.tokens.length) lines.push(line);
        const prevAlign = bgCtx.textAlign; const prevBase = bgCtx.textBaseline; const prevFill = bgCtx.fillStyle;
        bgCtx.fillStyle = fontColor; bgCtx.textAlign = 'left'; bgCtx.textBaseline = 'top';
        let curY = y + yNudge;
        for (const L of lines) {
            let x = (canvasW - L.width) / 2;
            for (const t of L.tokens) {
                const topY = curY + (L.height - t.height) / 2;
                if (t.type === 'text') bgCtx.fillText(t.content, x, topY); else bgCtx.drawImage(t.image, x, topY, t.drawW, t.drawH);
                x += t.width;
            }
            curY += L.height + 8;
        }
        bgCtx.textAlign = prevAlign; bgCtx.textBaseline = prevBase; bgCtx.fillStyle = prevFill;
    }
    
    // ===================================================================
    //  REST OF THE SCRIPT (with modifications for styling consistency)
    // ===================================================================
    function getBoundingBox(ctx, padding = 20 * (window.devicePixelRatio || 1)) {
        const canvas = ctx.canvas;
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        let minX = canvas.width, minY = canvas.height, maxX = -1, maxY = -1;
        for (let y = 0; y < canvas.height; y++) {
            for (let x = 0; x < canvas.width; x++) {
                if (data[(y * canvas.width + x) * 4 + 3] > 0) {
                    minX = Math.min(minX, x); minY = Math.min(minY, y);
                    maxX = Math.max(maxX, x); maxY = Math.max(maxY, y);
                }
            }
        }
        if (maxX === -1) return null;
        minX = Math.max(0, minX - padding); minY = Math.max(0, minY - padding);
        maxX = Math.min(canvas.width, maxX + padding); maxY = Math.min(canvas.height, maxY + padding);
        return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
    }

    async function loadTest(testJsonPath) {
        isTransitioning = true;
        try {
            const response = await fetch(testJsonPath);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            testData = await response.json();
            if (!testData || !Array.isArray(testData.stages)) throw new Error("Invalid test format.");
            document.title = testData.testTitle || "thelo | Test Mode";
            currentStageIndex = -1;
            testResults = [];
            updateAllUITexts();
            submitBtn.disabled = false;
            prevBtn.disabled = true;
        } catch (error) {
            console.error("Error loading test:", error);
            alert("Failed to load the test file. Please check the console for details.");
        } finally {
            isTransitioning = false;
            loadingOverlay.classList.add('hidden');
        }
    }

    function startTest() {
        if (currentStageIndex !== -1) return;
        testStartTime = Date.now();
        timerInterval = setInterval(updateTimerDisplay, 1000);
        transitionToStage(0);
    }

    function updateTimerDisplay() {
        const elapsed = Math.floor((Date.now() - testStartTime) / 1000);
        const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
        const seconds = (elapsed % 60).toString().padStart(2, '0');
        timerDisplay.textContent = `${minutes}:${seconds}`;
    }

    async function renderStageUI(index) {
        if (index < 0 || index >= testData.stages.length) return;
        currentStageData = testData.stages[index];
        currentStageIndex = index;
        bgCtx.clearRect(0, 0, backgroundCanvas.width / devicePixelRatio, backgroundCanvas.height / devicePixelRatio);
        clearUserCanvas();
        const headlineText = `Question ${index + 1}: ${currentStageData.headline || ''}`;
        if (headlineText && bgCtx.canvas.width > 0) {
            bgCtx.font = `24px 'Manrope', system-ui, sans-serif`; // MODIFIED
            await ensureHeadlineFontsLoaded();
            await renderComplexHeadline(bgCtx, headlineText, 65); // MODIFIED: Moved up
        }
        prevBtn.disabled = index === 0;
        submitBtn.disabled = false;
        submitBtn.textContent = UI_TEXT.submit;
        userDrawingOccurred = false;
    }

    function transitionToStage(newIndex) {
        if (isTransitioning) return;
        if (newIndex >= testData.stages.length) {
            finishTest();
            return;
        }
        isTransitioning = true;
        backgroundCanvas.classList.add('fade-out');
        setTimeout(() => {
            renderStageUI(newIndex).then(() => {
                backgroundCanvas.classList.remove('fade-out');
                isTransitioning = false;
            });
        }, parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--fade-duration') || '0.3') * 1000);
    }

    async function handleSubmitClick() {
        if (currentStageIndex === -1) {
            startTest();
            return;
        }
        if (!userDrawingOccurred) {
            alert("Please provide a solution before submitting.");
            return;
        }
        submitBtn.disabled = true;
        submitBtn.textContent = UI_TEXT.checking;
        const user = auth.currentUser;
        if (!user) {
            alert("You must be signed in to submit a test.");
            submitBtn.disabled = false; submitBtn.textContent = UI_TEXT.submit;
            return;
        }
        let base64ImageData;
        try {
            const box = getBoundingBox(ctx);
            if (!box) throw new Error("No drawing found to capture.");
            const cropCanvas = document.createElement('canvas');
            cropCanvas.width = box.width; cropCanvas.height = box.height;
            const cropCtx = cropCanvas.getContext('2d');
            cropCtx.fillStyle = '#FFFFFF'; cropCtx.fillRect(0, 0, cropCanvas.width, cropCanvas.height);
            cropCtx.drawImage(canvas, box.x, box.y, box.width, box.height, 0, 0, box.width, box.height);
            base64ImageData = cropCanvas.toDataURL("image/png");
        } catch (e) {
            console.error("Image capture error:", e);
            alert("Error capturing your solution. Please ensure something is drawn.");
            submitBtn.disabled = false; submitBtn.textContent = UI_TEXT.submit;
            return;
        }
        try {
            const analyzeMathDrawing = firebase.functions().httpsCallable('analyzeMathDrawing');
            const result = await analyzeMathDrawing({ imageBase64: base64ImageData, correctAnswer: currentStageData.correctAnswer, language: 'en' });
            const { status, feedback } = result.data;
            testResults.push({ question: currentStageData.headline, status, feedback });
            transitionToStage(currentStageIndex + 1);
        } catch (error) {
            console.error("AI analysis failed:", error);
            alert("There was an error checking your answer. Please try again.");
            submitBtn.disabled = false; submitBtn.textContent = UI_TEXT.submit;
        }
    }

    function finishTest() {
        clearInterval(timerInterval);
        const timeTaken = Math.floor((Date.now() - testStartTime) / 1000);
        document.getElementById('lessonArea').style.display = 'none';
        const correctAnswers = testResults.filter(r => r.status === 'correct').length;
        const totalQuestions = testData.stages.length;
        const scorePercentage = totalQuestions > 0 ? Math.round((correctAnswers / totalQuestions) * 100) : 0;
        document.getElementById('resultsScore').textContent = `Score: ${correctAnswers} / ${totalQuestions} (${scorePercentage}%)`;
        const minutes = Math.floor(timeTaken / 60).toString().padStart(2, '0');
        const seconds = (timeTaken % 60).toString().padStart(2, '0');
        document.getElementById('resultsTime').textContent = `Time Taken: ${minutes}:${seconds}`;
        const feedbackList = document.getElementById('resultsFeedbackList');
        feedbackList.innerHTML = '';
        testResults.forEach((result, index) => {
            const item = document.createElement('div');
            item.className = 'feedback-item';
            const statusClass = result.status === 'correct' ? 'status-correct' : 'status-incorrect';
            item.innerHTML = `<div class="feedback-item-header"><h3>Question ${index + 1}</h3><span class="${statusClass}">${result.status}</span></div><p><strong>AI Feedback:</strong> ${result.feedback}</p>`;
            feedbackList.appendChild(item);
        });
        resultsScreen.style.display = 'flex';
        const user = auth.currentUser;
        if (user) {
            const submitTestResults = firebase.functions().httpsCallable('submitTestResults');
            submitTestResults({ testId: new URLSearchParams(window.location.search).get('testFile')?.replace('.json', ''), score: correctAnswers, totalQuestions, timeTakenSeconds: timeTaken, results: testResults })
                .then(res => console.log("Test results saved!", res))
                .catch(err => console.error("Error saving test results:", err));
        }
    }

    function resizeCanvases() {
        checkTabletMode();
        if (!boardWrapper) return;
        const rect = boardWrapper.getBoundingClientRect();
        const cssWidth = Math.floor(rect.width); const cssHeight = Math.floor(rect.height);
        devicePixelRatio = window.devicePixelRatio || 1;
        const internalWidth = cssWidth * devicePixelRatio; const internalHeight = cssHeight * devicePixelRatio;
        [backgroundCanvas, canvas].forEach(c => {
            c.width = internalWidth; c.height = internalHeight;
            c.style.width = `${cssWidth}px`; c.style.height = `${cssHeight}px`;
        });
        setupContexts();
        if (currentStageIndex >= 0) renderStageUI(currentStageIndex);
    }

    function setupContexts() {
        [bgCtx, ctx].forEach(context => {
            context.resetTransform();
            context.scale(devicePixelRatio, devicePixelRatio);
        });
        ctx.lineWidth = 3; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.strokeStyle = '#000000';
    }

    function getPos(e, targetCanvas) {
        const rect = targetCanvas.getBoundingClientRect();
        let clientX, clientY;
        if (e.touches && e.touches.length > 0) { clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; }
        else if (e.changedTouches && e.changedTouches.length > 0) { clientX = e.changedTouches[0].clientX; clientY = e.changedTouches[0].clientY; }
        else { clientX = e.clientX; clientY = e.clientY; }
        if (typeof clientX !== 'number' || typeof clientY !== 'number') return null;
        return { x: clientX - rect.left, y: clientY - rect.top };
    }

    function handleDrawingStart(e) {
        if (isTabletMode && e.type.startsWith('touch')) {
            if (!Array.from(e.touches).some(t => t.touchType === 'stylus')) { e.preventDefault(); return; }
        }
        const pos = getPos(e, canvas);
        if (!pos) return;
        if (e.touches) e.preventDefault();
        drawing = true;
        if (e.pointerType === 'pen') canvas.classList.add('no-cursor');
        userDrawingOccurred = true;
        lastPos = pos;
        ctx.beginPath();
        ctx.moveTo(pos.x, pos.y);
    }

    function handleDrawingMove(e) {
        if (!drawing) return;
        if (isTabletMode) {
            if (buttonVanishTimer) clearTimeout(buttonVanishTimer);
            if (bottomBar && !bottomBar.classList.contains('bar-hidden-by-stylus')) {
                bottomBar.classList.add('bar-hidden-by-stylus');
            }
        }
        const pos = getPos(e, canvas);
        if (!pos) return;
        if (e.touches) e.preventDefault();
        const midPoint = { x: (lastPos.x + pos.x) / 2, y: (lastPos.y + pos.y) / 2 };
        ctx.quadraticCurveTo(lastPos.x, lastPos.y, midPoint.x, midPoint.y);
        ctx.stroke();
        ctx.moveTo(midPoint.x, midPoint.y);
        lastPos = pos;
    }

    function handleDrawingEnd(e) {
        canvas.classList.remove('no-cursor');
        if (isTabletMode) {
            if (buttonVanishTimer) clearTimeout(buttonVanishTimer);
            buttonVanishTimer = setTimeout(() => {
                if (bottomBar) bottomBar.classList.remove('bar-hidden-by-stylus');
            }, 500);
        }
        if (!drawing) return;
        drawing = false;
        ctx.lineTo(lastPos.x, lastPos.y);
        ctx.stroke();
        ctx.closePath();
    }
    
    function clearUserCanvas() {
        ctx.clearRect(0, 0, canvas.width / devicePixelRatio, canvas.height / devicePixelRatio);
        userDrawingOccurred = false;
    }

    function updateAllUITexts() {
        submitBtn.textContent = (currentStageIndex === -1) ? UI_TEXT.start : UI_TEXT.submit;
        prevBtn.textContent = UI_TEXT.prev;
        clearBtn.textContent = UI_TEXT.clear;
    }

    function checkTabletMode() {
        const tabletQuery = window.matchMedia('(min-width: 769px) and (max-width: 1200px) and (pointer: coarse)');
        const landscapeQuery = window.matchMedia('(min-width: 769px) and (max-width: 1200px) and (min-height: 500px)');
        isTabletMode = tabletQuery.matches || landscapeQuery.matches;
    }

    function initApp() {
        resizeCanvases();
        canvas.addEventListener('mousedown', handleDrawingStart);
        canvas.addEventListener('mousemove', handleDrawingMove);
        canvas.addEventListener('touchstart', handleDrawingStart, { passive: false });
        canvas.addEventListener('touchmove', handleDrawingMove, { passive: false });
        window.addEventListener('mouseup', handleDrawingEnd);
        window.addEventListener('mouseleave', handleDrawingEnd);
        window.addEventListener('touchend', handleDrawingEnd);
        window.addEventListener('touchcancel', handleDrawingEnd);
        prevBtn.onclick = () => transitionToStage(currentStageIndex - 1);
        submitBtn.onclick = handleSubmitClick;
        clearBtn.onclick = clearUserCanvas;
        window.addEventListener('resize', resizeCanvases);
        const urlParams = new URLSearchParams(window.location.search);
        const testFileName = urlParams.get('testFile');
        if (testFileName) {
            loadTest(`https://thelo.space/tests/${testFileName}`);
        } else {
            alert("No test file specified in the URL. Please add '?testFile=your-test.json'.");
            loadingOverlay.classList.add('hidden');
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        updateAllUITexts();
        auth.onAuthStateChanged(user => {
            initApp();
        });
    });
</script>
</body>
</html>
