<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Graphing Calculator</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.1/math.min.js"></script>
    <style>
        :root {
            --thelo-blue: #2563eb;
            --thelo-blue-dark: #1d4ed8;
            --thelo-bg: #f9fafb;
            --sidebar-bg: #ffffff;
            --thelo-text: #111827;
            --thelo-text-light: #6b7280;
            --thelo-border: #e5e7eb;
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        body {
            margin: 0;
            font-family: 'Manrope', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            display: flex;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            background-color: var(--thelo-bg);
            color: var(--thelo-text);
        }

        #sidebar {
            width: 340px;
            height: 100%;
            background-color: var(--sidebar-bg);
            border-right: 1px solid var(--thelo-border);
            box-shadow: var(--shadow-lg);
            z-index: 10;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease;
        }

        .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--thelo-border);
            flex-shrink: 0;
        }

        .sidebar-header h1 {
            margin: 0;
            font-size: 1.25rem;
        }

        #addFunctionBtn {
            background-color: var(--thelo-blue);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 0.5rem 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        #addFunctionBtn:hover {
            background-color: var(--thelo-blue-dark);
        }

        #functionListContainer {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1rem 1.5rem;
        }

        .function-input-group {
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
            gap: 0.75rem;
        }

        .function-color-dot {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 0 8px rgba(0,0,0,0.15);
            flex-shrink: 0;
        }

        .function-input-wrapper {
            display: flex;
            align-items: center;
            flex-grow: 1;
            border: 1px solid var(--thelo-border);
            border-radius: 8px;
            background-color: white;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        
        .function-input-wrapper:focus-within {
            border-color: var(--thelo-blue);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
        }

        .function-input-wrapper span {
            padding-left: 0.75rem;
            font-weight: 500;
            color: var(--thelo-text-light);
            user-select: none;
        }

        .function-input {
            width: 100%;
            padding: 12px;
            border: none;
            background: transparent;
            font-size: 1rem;
            font-family: 'Manrope', monospace;
        }

        .function-input:focus {
            outline: none;
        }

        .remove-function-btn {
            background: transparent;
            border: none;
            font-size: 1.5rem;
            color: var(--thelo-text-light);
            cursor: pointer;
            padding: 0 0.5rem;
            transition: color 0.2s;
        }
        .remove-function-btn:hover {
            color: #ef4444; /* Red on hover */
        }

        #canvasContainer {
            flex-grow: 1;
            position: relative;
        }

        #graphCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        
        #graphCanvas:active {
            cursor: grabbing;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }
            #sidebar {
                width: 100%;
                height: 45vh; /* Sidebar takes a portion of the height */
                border-right: none;
                border-bottom: 1px solid var(--thelo-border);
                box-shadow: none;
            }
            .sidebar-header h1 {
                font-size: 1.1rem;
            }
        }
    </style>
</head>
<body>

    <div id="sidebar">
        <div class="sidebar-header">
            <h1>Graphing Calculator</h1>
            <button id="addFunctionBtn">+ Function</button>
        </div>
        <div id="functionListContainer">
            <!-- Function inputs will be dynamically added here -->
        </div>
    </div>

    <div id="canvasContainer">
        <canvas id="graphCanvas"></canvas>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM ELEMENTS ---
            const canvas = document.getElementById('graphCanvas');
            const ctx = canvas.getContext('2d');
            const functionListContainer = document.getElementById('functionListContainer');
            const addFunctionBtn = document.getElementById('addFunctionBtn');

            // --- STATE MANAGEMENT ---
            let devicePixelRatio = window.devicePixelRatio || 1;
            const PLOT_COLORS = ['#2563eb', '#ef4444', '#22c55e', '#f59e0b', '#8b5cf6', '#d946ef', '#14b8a6'];
            
            let graphState = {
                originX: 0,
                originY: 0,
                scale: 40, // pixels per unit (increased for better default view)
                isPanning: false,
                panStart: { x: 0, y: 0 },
                functions: [] // { expression, color, compiled, id }
            };

            // --- INITIALIZATION ---
            function initialize() {
                resizeCanvas();
                addFunctionInput('sin(x)'); // Start with a default function
                setupEventListeners();
                requestAnimationFrame(plotAllFunctions);
            }

            function resizeCanvas() {
                const rect = canvas.parentElement.getBoundingClientRect();
                canvas.width = rect.width * devicePixelRatio;
                canvas.height = rect.height * devicePixelRatio;
                canvas.style.width = `${rect.width}px`;
                canvas.style.height = `${rect.height}px`;

                // Reset origin to center on resize
                graphState.originX = canvas.width / 2;
                graphState.originY = canvas.height / 2;
                
                requestAnimationFrame(plotAllFunctions);
            }

            // --- EVENT LISTENERS ---
            function setupEventListeners() {
                window.addEventListener('resize', resizeCanvas);
                addFunctionBtn.addEventListener('click', () => addFunctionInput());

                // Graph interaction listeners
                canvas.addEventListener('wheel', handleGraphZoom, { passive: false });
                canvas.addEventListener('mousedown', handleGraphPanStart);
                canvas.addEventListener('mousemove', handleGraphPanMove);
                window.addEventListener('mouseup', handleGraphPanEnd); // Listen on window to catch mouseup outside canvas
                canvas.addEventListener('mouseleave', handleGraphPanEnd);
            }

            // --- UI MANAGEMENT ---
            function addFunctionInput(expression = '') {
                const funcIndex = graphState.functions.length;
                const color = PLOT_COLORS[funcIndex % PLOT_COLORS.length];

                const newFunc = {
                    expression: expression,
                    color: color,
                    compiled: null,
                    id: `func-${Date.now()}`
                };
                graphState.functions.push(newFunc);

                const group = document.createElement('div');
                group.className = 'function-input-group';
                group.id = newFunc.id;
                group.innerHTML = `
                    <div class="function-color-dot" style="background-color: ${color};"></div>
                    <div class="function-input-wrapper">
                        <span>y=</span>
                        <input type="text" class="function-input" value="${expression}" placeholder="Enter function...">
                    </div>
                    <button class="remove-function-btn" title="Remove function">&times;</button>
                `;

                functionListContainer.appendChild(group);

                const input = group.querySelector('.function-input');
                input.addEventListener('input', compileAndPlotFunctions);
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        compileAndPlotFunctions();
                    }
                });

                const removeBtn = group.querySelector('.remove-function-btn');
                removeBtn.addEventListener('click', () => {
                    graphState.functions = graphState.functions.filter(f => f.id !== newFunc.id);
                    group.remove();
                    requestAnimationFrame(plotAllFunctions);
                });

                input.focus();
                compileAndPlotFunctions();
            }

            function compileAndPlotFunctions() {
                const inputs = functionListContainer.querySelectorAll('.function-input-group');
                inputs.forEach(group => {
                    const input = group.querySelector('.function-input');
                    const func = graphState.functions.find(f => f.id === group.id);
                    if (func) {
                        func.expression = input.value;
                        if (func.expression.trim()) {
                            try {
                                func.compiled = math.parse(func.expression).compile();
                            } catch (err) {
                                func.compiled = null;
                            }
                        } else {
                            func.compiled = null;
                        }
                    }
                });
                requestAnimationFrame(plotAllFunctions);
            }

            // --- GRAPH INTERACTION (ZOOM & PAN) ---
            function handleGraphZoom(e) {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left) * devicePixelRatio;
                const mouseY = (e.clientY - rect.top) * devicePixelRatio;

                const zoomFactor = e.deltaY < 0 ? 1.1 : 1 / 1.1;
                const mouseGraphX_before = (mouseX - graphState.originX) / graphState.scale;
                const mouseGraphY_before = (graphState.originY - mouseY) / graphState.scale;
                
                graphState.scale *= zoomFactor;

                const mouseGraphX_after = (mouseX - graphState.originX) / graphState.scale;
                const mouseGraphY_after = (graphState.originY - mouseY) / graphState.scale;

                graphState.originX += (mouseGraphX_after - mouseGraphX_before) * graphState.scale;
                graphState.originY -= (mouseGraphY_after - mouseGraphY_before) * graphState.scale;

                requestAnimationFrame(plotAllFunctions);
            }

            function handleGraphPanStart(e) {
                if (e.button !== 0) return;
                graphState.isPanning = true;
                graphState.panStart.x = e.clientX;
                graphState.panStart.y = e.clientY;
            }

            function handleGraphPanMove(e) {
                if (!graphState.isPanning) return;
                const dx = (e.clientX - graphState.panStart.x) * devicePixelRatio;
                const dy = (e.clientY - graphState.panStart.y) * devicePixelRatio;
                graphState.originX += dx;
                graphState.originY += dy;
                graphState.panStart.x = e.clientX;
                graphState.panStart.y = e.clientY;
                requestAnimationFrame(plotAllFunctions);
            }

            function handleGraphPanEnd() {
                graphState.isPanning = false;
            }

            // --- CORE DRAWING LOGIC ---
            function drawGraphGrid() {
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.restore();

                const baseGridUnits = 1;
                let dynamicGrid = baseGridUnits;
                while (dynamicGrid * graphState.scale < 40 * devicePixelRatio) dynamicGrid *= 2;
                while (dynamicGrid * graphState.scale > 80 * devicePixelRatio) dynamicGrid /= 2;

                ctx.strokeStyle = var(--thelo-border);
                ctx.lineWidth = 1 * devicePixelRatio;
                ctx.font = `${10 * devicePixelRatio}px 'Manrope'`;
                ctx.fillStyle = var(--thelo-text-light);
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Draw vertical lines and labels
                const startX = Math.floor(-graphState.originX / graphState.scale / dynamicGrid) * dynamicGrid;
                for (let x = startX; (x * graphState.scale + graphState.originX) < canvas.width; x += dynamicGrid) {
                    const px = x * graphState.scale + graphState.originX;
                    ctx.beginPath();
                    ctx.moveTo(px, 0);
                    ctx.lineTo(px, canvas.height);
                    ctx.stroke();
                    if (Math.abs(x) > 1e-9) { // Don't draw label for 0 on the axis line
                        ctx.fillText(x.toPrecision(2), px, graphState.originY + 15 * devicePixelRatio);
                    }
                }

                // Draw horizontal lines and labels
                const startY = Math.floor(graphState.originY / graphState.scale / dynamicGrid) * dynamicGrid;
                for (let y = startY; (graphState.originY - y * graphState.scale) < canvas.height; y -= dynamicGrid) {
                    const py = graphState.originY - y * graphState.scale;
                    ctx.beginPath();
                    ctx.moveTo(0, py);
                    ctx.lineTo(canvas.width, py);
                    ctx.stroke();
                     if (Math.abs(y) > 1e-9) {
                        ctx.save();
                        ctx.textAlign = 'right';
                        ctx.fillText(y.toPrecision(2), graphState.originX - 8 * devicePixelRatio, py);
                        ctx.restore();
                    }
                }

                // Draw main axes
                ctx.strokeStyle = var(--thelo-text-light);
                ctx.lineWidth = 2 * devicePixelRatio;
                ctx.beginPath();
                ctx.moveTo(0, graphState.originY);
                ctx.lineTo(canvas.width, graphState.originY);
                ctx.moveTo(graphState.originX, 0);
                ctx.lineTo(graphState.originX, canvas.height);
                ctx.stroke();
            }

            function plotAllFunctions() {
                drawGraphGrid();

                ctx.lineWidth = 2.5 * devicePixelRatio;
                
                graphState.functions.forEach(func => {
                    if (!func.compiled) return;

                    ctx.strokeStyle = func.color;
                    ctx.beginPath();
                    let firstPoint = true;

                    for (let pixelX = 0; pixelX < canvas.width; pixelX += 1) { // Step by pixel
                        const x = (pixelX - graphState.originX) / graphState.scale;
                        try {
                            const y = func.compiled.evaluate({ x: x });
                            if (!Number.isFinite(y)) {
                                firstPoint = true;
                                continue;
                            }
                            const pixelY = graphState.originY - (y * graphState.scale);
                            if (firstPoint) {
                                ctx.moveTo(pixelX, pixelY);
                                firstPoint = false;
                            } else {
                                ctx.lineTo(pixelX, pixelY);
                            }
                        } catch (err) {
                            firstPoint = true; // Start new path after an error (e.g., sqrt of negative)
                        }
                    }
                    ctx.stroke();
                });
            }

            // --- START THE APP ---
            initialize();
        });
    </script>
</body>
</html>
