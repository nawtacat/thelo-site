<!DOCTYPE html>
<html lang="hy">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link rel="icon" href="https://thelo.space/img/thelofavicon.png" type="image/png">
    <link rel="apple-touch-icon" href="https://thelo.space/img/yarnicon.png">
    <title>thelo</title>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
	<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-functions-compat.js"></script>
	<link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@300;400;500;700&display=swap" rel="stylesheet">
	<link rel="manifest" href="/manifest.json" />
  
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd" crossorigin="anonymous"></script>
<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">


<style>
 /* ===== NEW: Updated Design System ===== */
 :root {
    /* Core Palette */
    --thelo-blue: #2563eb;
    --thelo-blue-dark: #1d4ed8;
    --thelo-bg: #ffffff;
    --thelo-text: #111827;
    --thelo-text-light: #6b7280;
    --thelo-border: #e5e7eb;

    /* Status Colors */
    --success-green: #22c55e;
    --error-red: #ef4444;
    --accent-yellow: #f59e0b;

    /* UI Element Colors */
    --bg-white: #ffffff;
    --chat-ai-bg: #ffffff;

    /* Ink Colors */
    --ink-black: #000000;
    --ink-blue: var(--thelo-blue);

    /* Effects */
    --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
    --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);

    /* Transitions */
    --fade-duration: 0.3s;
    --animation-duration: 0.3s;
    --thelobook-page-transition-duration: 0.05s;
 }

 #loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: var(--thelo-bg); /* Use your existing background color */
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999; /* Ensure it's on top of all other content */
    opacity: 1;
    /* Add a transition for the fade-out effect */
    transition: opacity 0.5s ease-out;
}

#loading-overlay.hidden {
    opacity: 0;
    pointer-events: none; /* Prevents interaction while fading out */
}

#loading-svg {
    width: 150px; /* A larger logo as requested */
    height: auto;
    animation: pulse-loader 1.5s infinite ease-in-out;
}
/* Add this to your CSS */
 #fullscreenBtn {
    background-color: #6b7280; /* A neutral gray */
 }
/* This is the animation for the logo */
@keyframes pulse-loader {
    0% {
        transform: scale(1);
        opacity: 0.8;
    }
    50% {
        transform: scale(1.1);
        opacity: 1;
    }
    100% {
        transform: scale(1);
        opacity: 0.8;
    }
}

 /* ===== Font Definition (Unchanged as requested) ===== */
@font-face {
  font-family: 'Mardoto-Light';
  src: url('../../fonts/Mardoto-Light.ttf') format('truetype');
  font-weight: 300;
  font-style: normal;
  font-display: swap;
}
	/* --- Corrected Code --- */

@font-face {
  font-family: 'Montserrat Arm';
  src: url('../fonts/Montserratarm-Regular.otf') format('opentype');
  font-weight: 400; /* Regular */
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'Montserrat Arm';
  src: url('../fonts/Montserratarm-SemiBold.otf') format('opentype');
  font-weight: 600; /* SemiBold */
  font-style: normal;
  font-display: swap;
}
¬† ¬† @font-face {
¬† ¬† ¬† font-family: 'Montserrat Arm';
¬† ¬† ¬† src: url('../fonts/Montserratarm-ExtraBold.otf') format('opentype');
¬† ¬† ¬† font-weight: 800; /* ExtraBold */
¬† ¬† ¬† font-style: normal;
¬† ¬† ¬† font-display: swap;
¬† ¬† }

/* ===== Base Styles ===== */
html {
  font-size: 16px;
  background: var(--thelo-bg);
}
body {
¬† margin: 0;
¬† min-height: 100vh;
¬† height: 100vh;
¬† font-family: 'Montserrat Arm', system-ui, -apple-system, sans-serif;
  font-weight: 400;
¬† display: flex;
¬† flex-direction: column;
¬† overflow: hidden;
¬† background-color: var(--thelo-bg);
¬† color: var(--thelo-text);
¬† ¬†-webkit-user-select: none; /* Safari */
¬† -moz-user-select: none;¬† ¬† /* Firefox */
¬† -ms-user-select: none;¬† ¬† ¬†/* IE10+/Edge */
¬† user-select: none;¬† ¬† ¬† ¬† ¬†/* Standard */
¬† -webkit-touch-callout: none; /* iOS Safari */
}	/* ADD THIS RULE: Use Manrope font when the body has the 'lang-en' class */
body.lang-en {
  font-family: 'Manrope', system-ui, -apple-system, sans-serif;
}
	/* MCQ buttons blur when thelobook is active */
.blurred-mcq {
    filter: blur(4px);
    opacity: 0.55;
    pointer-events: none;      /* clicks still ignored */
    z-index: 5 !important;     /* sits below thelobookCanvas (z-15) */
    transition: filter .2s, opacity .2s;
}


 /* ===== Layout & App Structure ===== */

 #lessonArea {
    position: absolute; /* <--- NEW */
    top: 0;             /* <--- NEW */
    left: 0;            /* <--- NEW */
    right: 0;           /* <--- NEW */
    bottom: 0;          /* <--- NEW */
    display: flex;
    flex-direction: column;
    overflow: hidden;
    /* position: relative; can be removed or left, it doesn't matter now */
}
 #boardWrap {
    position: relative;
    flex-grow: 1;
    overflow: visible; /* Changed from hidden to visible */
    background-color: var(--thelo-bg);
    /* Grid background */
    background-image: linear-gradient(to right, var(--thelo-border) 1px, transparent 1px),
      linear-gradient(to bottom, var(--thelo-border) 1px, transparent 1px);
    background-size: 40px 40px;
 }

 /* ===== Canvases & Overlays ===== */
 #stageProgressBarContainer {
    position: absolute;
    top: 30.1px;
    left: 2%;
    width: 96%;
    height: 2px;
    background-color: #cccccc;
    border-radius: 2px;
    z-index: 10;
    opacity: 0;
    visibility: hidden;
    transition: opacity var(--fade-duration) ease-in-out, visibility 0s linear var(--fade-duration);
 }
 #stageProgressBarContainer.visible {
    opacity: 1;
    visibility: visible;
    transition: opacity var(--fade-duration) ease-in-out, visibility 0s linear 0s;
 }
 #stageProgressFill {
    height: 100%;
    background-color: #000000;
    width: 0%;
    border-radius: 2px;
    transition: width 0.05s linear;
 }

 #backgroundCanvas,
 #replayCanvas,
 #board,
 #finalAnswerCanvas,
 #thelobookCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: block;
    background-color: transparent;
 }
 #backgroundCanvas {
    z-index: 1;
    pointer-events: none;
    opacity: 1;
    transition: opacity var(--fade-duration) ease-in-out;
 }
 #backgroundCanvas.fade-out {
    opacity: 0;
 }
 #replayCanvas {
    z-index: 2;
    pointer-events: none;
    opacity: 1;
    transition: opacity var(--fade-duration) ease-in-out;
 }
 #replayCanvas.fade-out {
    opacity: 0;
 }
 #board {
	 opacity: 1;
¬† ¬† pointer-events: auto;¬† ¬† ¬† ¬† ¬† ¬†/* keep drawing events working */
¬† ¬† z-index: 3;
¬† ¬† cursor: none;
¬† ¬† touch-action: none;
¬†}
 #finalAnswerCanvas {
    z-index: 4;
    opacity: 0;
    pointer-events: none;
 }

 #thelobookCanvas {
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    z-index: 15;
    cursor: crosshair;
    touch-action: none;
    opacity: 0;
    visibility: hidden;
    transform: scale(0.95);
    transition: opacity var(--animation-duration) ease, visibility 0s linear var(--animation-duration),
      transform var(--animation-duration) ease;
 }
 #thelobookCanvas.active {
    opacity: 1;
    visibility: visible;
    transform: scale(1);
    transition-delay: 0s, 0s, 0s;
 }
 #thelobookCanvas.grid-underlay {
    opacity: 0.9 !important;
    transform: scale(1) !important;
 }
 #thelobookCanvas.eraser-active {
    cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="rgba(0,0,0,0.5)" d="M19.78,2.22a1,1,0,0,0-1.42,0L9.12,11.46a1,1,0,0,0,0,1.41L11.24,15A1,1,0,0,0,12.66,15L22.22,5.39A1,1,0,0,0,22.22,4L19.78,2.22ZM8.41,12.88,2,19.29V21a1,1,0,0,0,1,1H4.71l6.47-6.46-1.42-1.42A1,1,0,0,0,8.41,12.88Z"/></svg>')
      12 12, auto;
 }

 /* ===== UI Controls ===== */
 /* ===== MODIFIED for Fullscreen Grid ===== */
#bottomBar {
  position: absolute;          /* Take the bar out of the normal layout flow */
  bottom: 0;                   /* Pin it to the bottom of the viewport */
  left: 0;                     /* Pin it to the left */
  width: 100%;                 /* Make it stretch full-width */
  background-color: transparent; /* Let the grid background show through */
  box-sizing: border-box;      /* Ensures padding is included in the width */

  /* These existing rules remain to style the buttons inside */
  padding: 0.5rem 1rem 1rem 1rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
  z-index: 20;
  gap: 0.75rem;
  transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1);
}
 .control-btn {
    font-family: inherit;
    padding: 0.5rem 1rem;
    font-size: 0.9rem;
    font-weight: 500;
    border: none;
    border-radius: 0.5rem;
    color: var(--bg-white);
    cursor: pointer;
    transition: background-color 0.2s, transform 0.15s, box-shadow 0.2s;
    box-shadow: var(--shadow-md);
 }
 .control-btn:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: var(--shadow-lg);
 }
 .control-btn:disabled {
    background-color: #9ca3af !important;
    cursor: not-allowed;
    opacity: 0.7;
 }

 /* Button Colors */
 #prevBtn {
    background-color: var(--accent-yellow);
 }
 #thelobookBtn {
    background-color: var(--success-green);
 }
 #clearBtn {
    background-color: var(--error-red);
 }
 #nextCheckBtn {
    background-color: var(--thelo-blue);
 }
 #nextCheckBtn:hover:not(:disabled) {
    background-color: var(--thelo-blue-dark);
 }
 #nextCheckBtn.correct {
    background-color: var(--success-green);
 }
 #nextCheckBtn.incorrect {
    background-color: var(--error-red);
    animation: shake 0.5s ease-in-out;
 }
 @keyframes shake {
    0%,
    100% {
      transform: translateX(0);
    }
    25%,
    75% {
      transform: translateX(-5px);
    }
    50% {
      transform: translateX(5px);
    }
 }

 /* ===== MODIFIED for Floating Text ===== */
#colorIndicator,
#pointsDisplay {
  background-color: transparent; /* Remove the white box */
  border: none;                  /* Remove the border */
  box-shadow: none;              /* Remove the shadow */
  color: var(--thelo-text);      /* Use the main text color */
  font-size: 1rem;               /* Make text slightly larger for readability */
  font-weight: 500;
  padding: 0.5rem 1rem;          /* Keep padding to maintain spacing */
  white-space: nowrap;
}

 /* MCQ Buttons */
#mcqOptionsContainer {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 30;
    display: none;
    flex-direction: row;
    flex-wrap: wrap;
    justify-content: center;
    gap: 1rem;
    width: 90%;
    max-width: 1200px;
	transition: opacity var(--fade-duration) ease-in-out;
}

@media (max-width: 1024px) {
    .mcq-option-btn {
        font-size: 0.7rem;
    }
}
.mcq-option-btn {
    font-family: inherit;
    padding: 0.8rem 1.5rem;
    font-size: 1.1rem;
    font-weight: 600;
    border: 1px solid var(--thelo-border);
    background-color: #f9fafb;
    color: var(--thelo-text);
    border-radius: 0.75rem;
    cursor: pointer;
    transition: background-color 0.4s ease-out, border-color 0.4s ease-out, color 0.4s ease-out, transform 0.2s ease-out, box-shadow 0.2s ease-out;
    box-shadow: var(--shadow-sm);
    /* CHANGE: Let the button's width be determined by its content. */
    width: fit-content;
    /* CHANGE: Don't force the button to grow or have a specific basis. */
    flex: 0 1 auto;
    white-space: nowrap;
    transform: translateY(0);
}

.mcq-option-btn:hover:not(:disabled) {
    transform: translateY(-3px);
    box-shadow: var(--shadow-lg);
    color: var(--thelo-blue);
    border-color: #dbeafe;
}
.mcq-option-btn.correct {
    background-color: var(--success-green);
    color: white;
    border-color: var(--success-green);
 }
 .mcq-option-btn.incorrect {
    background-color: var(--error-red);
    color: white;
    border-color: var(--error-red);
 }
 .mcq-option-btn.correct-answer-shown {
    border-color: var(--success-green);
    border-width: 2px;
 }

 /* ===== Chat Column ===== */
 #chatCol {
    width: 320px;
    display: flex;
    flex-direction: column;
    background: var(--bg-white);
    border-left: 1px solid var(--thelo-border);
    padding: 1rem;
    height: 100%;
    box-sizing: border-box;
 }
 #terminalLogo {
    height: 60px;
    width: auto;
    display: block;
    align-self: center;
    margin: 0.5rem 0 1.5rem 0;
 }
 #chat {
    flex: 1;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: var(--thelo-border) transparent;
 }
 #chat::-webkit-scrollbar {
    width: 5px;
 }
 #chat::-webkit-scrollbar-thumb {
    background-color: var(--thelo-border);
    border-radius: 10px;
 }
.ai-message {
  background-color: var(--bg-white);
  border: 1px solid #f0f0f0;
  color: var(--thelo-text);
  padding: 0.75rem 1rem;
  border-radius: 0.75rem;
  margin-bottom: 0.75rem;
  max-width: 95%;
  align-self: flex-start;
  word-wrap: break-word;
  box-shadow: var(--shadow-sm);
  font-size: 0.9rem;
  line-height: 1.6;
  opacity: 0;
  transform: translateY(10px);
  transition: opacity 0.3s ease-out, transform 0.3s ease-out;
}

.ai-message.show {
  opacity: 1;
  transform: translateY(0);
}
.ai-message strong {
    color: var(--thelo-blue);
    font-weight: inherit;
 }
 .ai-message .emoji {
    margin-right: 0.5rem;
 }

#dashboardBtn {
    background-color: var(--thelo-blue);
}

#dashboardBtn:hover:not(:disabled) {
    background-color: var(--thelo-blue-dark);
}

#dashboardBtn.visible {
    display: inline-flex !important;
    animation: pulse-glow 2s infinite ease-in-out;
}

#bottomBar.bar-hidden-by-stylus {
    transform: translateY(150%);
    pointer-events: none;
}
	/* ADD THIS CSS: For the Streak Modal */
#streakModal {
    position: fixed;
    z-index: 100;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.6);
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0.3s;
}
#streakModal:not(.modal-hidden) {
    opacity: 1;
    visibility: visible;
}
.streak-modal-content {
    background-color: var(--thelo-bg);
    color: var(--thelo-text);
    padding: 2rem 3rem;
    border-radius: 1rem;
    text-align: center;
    box-shadow: var(--shadow-lg);
    position: relative;
    transform: scale(0.9);
    transition: transform 0.3s ease;
}
#streakModal:not(.modal-hidden) .streak-modal-content {
    transform: scale(1);
}
.streak-modal-icon {
    font-size: 4rem;
    line-height: 1;
    margin-bottom: 1rem;
}
.streak-modal-close {
    position: absolute;
    top: 0.5rem;
    right: 1rem;
    font-size: 1.75rem;
    font-weight: bold;
    color: var(--thelo-text-light);
    cursor: pointer;
}
#streakModalConfirmBtn {
    margin-top: 1.5rem;
    background-color: var(--accent-yellow);
}

@keyframes pulse-glow {
    0% {
        box-shadow: 0 0 5px rgba(37, 99, 235, 0.2), 0 0 7px rgba(37, 99, 235, 0.1);
    }
    50% {
        box-shadow: 0 0 15px rgba(37, 99, 235, 0.4), 0 0 25px rgba(37, 99, 235, 0.3);
    }
    100% {
        box-shadow: 0 0 5px rgba(37, 99, 235, 0.2), 0 0 7px rgba(37, 99, 235, 0.1);
    }
}

 /* ===== ADD THESE STYLES: For Image Terminal & Terminals ===== */
 #chat,
 #image-terminal {
    flex: 1;
    transition: opacity 0.3s ease-in-out;
    overflow: hidden;
    overflow-y: auto; /* Allow scrolling for chat */
 }
 #image-terminal {
    display: none; /* Start hidden */
    flex-direction: column;
    justify-content: flex-start;
    padding-top: 1rem;
    overflow: hidden; /* No scrollbar needed for image view */
 }
 #image-terminal-img-container img {
    max-width: 100%;
    border-radius: 0.75rem;
    box-shadow: var(--shadow-md);
 }
 #image-terminal-feedback {
    text-align: center;
    padding: 1.5rem 1rem;
    font-size: 1rem;
    font-weight: 500;
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
 }
 .terminal-hidden {
    opacity: 0 !important;
    display: none !important;
 }

 /* ===== ADD THESE STYLES: For Smarter MCQ Layouts ===== */
#mcqOptionsContainer.long-options {
    flex-direction: column;
    /* CHANGE: Center the shrink-to-fit buttons instead of stretching them. */
    align-items: center;
    width: fit-content;
    max-width: 92%;
    left: 50%;
    transform: translate(-50%, -50%);
}
 #mcqOptionsContainer.short-options {
    flex-direction: row;
    flex-wrap: wrap;
    align-items: center;
    width: fit-content;
    max-width: 92%;
    left: 50%;
    transform: translate(-50%, -50%);
}


 #mcqOptionsContainer.short-options .mcq-option-btn {
    padding: 1.2rem;
    font-size: 1rem;
    /* REMOVE (optional): This line prevents buttons from being very small. */
    /* min-width: 80px; */
    text-align: center;
}
 /* ===== Thelobook & Grid View ===== */
 #thelobookControls,
 #thelobookPageGridHeader,
 #closePageGridBtn {
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    background-color: rgba(255, 255, 255, 0.7);
    border-radius: 9999px; /* pill shape */
    box-shadow: var(--shadow-md);
    border: 1px solid var(--thelo-border);
 }
 #thelobookControls {
    position: absolute;
    bottom: 2rem;
    left: 50%;
    transform: translateX(-50%);
    z-index: 25;
    padding: 0.5rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s, visibility 0.2s;
 }
 #thelobookControls.visible {
    opacity: 1;
    visibility: visible;
 }
 #thelobookControls button {
    background: transparent;
    border: none;
    font-size: 1.25rem;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: background-color 0.2s;
 }
 #thelobookControls button:hover:not(:disabled) {
    background-color: rgba(0, 0, 0, 0.05);
 }
 #thelobookControls button.active {
    background-color: var(--thelo-blue);
    color: white;
 }

 #thelobookPageGridView {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 40;
    display: flex;
    flex-direction: column;
    padding: 2rem 1rem 1rem;
    box-sizing: border-box;
    opacity: 0;
    visibility: hidden;
    transform: scale(0.95);
    transition: opacity var(--animation-duration) ease, visibility 0s linear var(--animation-duration),
      transform var(--animation-duration) ease;
 }
 #thelobookPageGridView.visible {
    opacity: 1;
    visibility: visible;
    transform: scale(1);
    transition-delay: 0s;
 }

 #thelobookPageGridHeader {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    padding: 0.5rem 1.5rem;
    max-width: fit-content;
    align-self: center;
    gap: 1rem;
 }

 #pageGridBatchIndicator {
    white-space: nowrap;
 }

 #thelobookPageGridContentContainer {
    flex-grow: 1;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-content: flex-start;
    gap: 1rem;
    padding: 0.5rem;
    overflow-y: auto;
    max-height: calc(100vh - 150px);
 }

 .chat-image-container {
    padding: 0.5rem;
    background-color: transparent;
    border: none;
    box-shadow: none;
 }

 .chat-image {
    max-width: 100%;
    border-radius: 0.75rem;
    display: block;
    box-shadow: var(--shadow-md);
 }
 .page-thumbnail {
    border: 1px solid var(--thelo-border);
    box-shadow: var(--shadow-sm);
    border-radius: 0.5rem;
 }
 .page-thumbnail:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-md);
 }
 #closePageGridBtn {
    border-radius: 50%;
    width: 36px;
    height: 36px;
    font-size: 1.1rem;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
 }

 .page-grid-batch {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 1rem;
    width: 100%;
    transition: none;
 }

 @keyframes pageGridFadeIn {
    from {
      opacity: 0;
      transform: scale(0.95);
    }
    to {
      opacity: 1;
      transform: scale(1);
    }
 }

 #thelobookPageGridView.visible {
    animation: pageGridFadeIn var(--animation-duration) ease forwards;
 }

 #thelobookPageGridContentContainer:empty::before {
    content: 'No pages to display. Click "+" to add a new page.';
    color: var(--thelo-text-light);
    font-size: 1rem;
    text-align: center;
    margin-top: 2rem;
 }

 /* Responsive adjustments */
 @media (max-width: 768px) {
    #app {
      flex-direction: column-reverse;
    }
	 /* Inside your @media (max-width: 768px) rule... */

    #chatCol {
      width: 100%;
      height: 30vh;
      border-left: none;
      border-top: 1px solid var(--thelo-border);
    }
    #bottomBar {
      flex-wrap: wrap;
      justify-content: center;
    }
    #actionButtons {
      width: 100%;
      justify-content: center;
      order: 3;
    }
    #pointsDisplay,
    #colorIndicator {
      order: 1;
      margin-bottom: 0.5rem;
    }
    .control-btn {
      padding: 0.6rem 0.8rem;
      font-size: 0.8rem;
    }
    #stageProgressBarContainer {
      top: 0;
      height: 2px;
    }
 }

 /* By default, hide the calculator button in the bottom bar */
 #openCalculatorBtn {
     display: none;
     background-color: var(--thelo-blue); /* Give it the standard blue color */
 }
 
 #openCalculatorBtn:hover:not(:disabled) {
     background-color: var(--thelo-blue-dark); /* Add the standard hover effect */
 }

 /* ===== NEW: Tablet Immersive Mode ===== */
 @media (min-width: 769px) and (max-width: 1200px) and (pointer: coarse) {
    #openCalculatorBtn {
        display: inline-flex;
    }
    /* (pointer: coarse) is key for detecting touch-first devices like tablets */
	/* ===== ENHANCEMENT: Prevent Palm Selection on Canvas ===== */
    #boardWrap {
        /* Prevents the user from being able to select the canvas */
        -webkit-user-select: none; /* Safari */
        -moz-user-select: none;    /* Firefox */
        -ms-user-select: none;     /* IE */
        user-select: none;

        /* Disables the menu (copy/paste) that appears on long-press in Safari */
        -webkit-touch-callout: none;
    }

    #app {
        /* Keep the flex layout but hide the chat column */
        flex-direction: row;
    }

    #chatCol {
        /* Completely hide the terminal */
        display: none !important;
    }

    #lessonArea {
        /* Make the whiteboard take up the full screen width */
        width: 100%;
        flex-basis: 100%;
        border-left: none; /* Remove border that separated it from the chat */
    }
}
 /* ===== NEW: Toast Notification System for Tablets ===== */
#toast-container {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 1000;
    display: flex;
    flex-direction: column-reverse;
    align-items: center;
    gap: 10px;
    width: clamp(300px, 80%, 600px);
    pointer-events: none;
}

.toast-message {
    font-family: 'Manrope', system-ui, -apple-system, sans-serif;
    font-size: 1rem;
    font-weight: 500;
    color: var(--thelo-text);
    background-color: rgba(255, 255, 255, 0.85);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 12px 20px;
    border-radius: 12px;
    box-shadow: var(--shadow-lg);
    border: 1px solid rgba(0,0,0,0.05);
    display: flex;
    align-items: center;
    gap: 12px;
    pointer-events: all;
    cursor: pointer;
    overflow: hidden;
    max-height: 100px;
    margin-top: 10px;
    opacity: 0;
    transition: max-height 0.3s ease-in-out, opacity 0.3s ease-in-out, margin-top 0.3s ease-in-out, padding 0.3s ease-in-out;
}

.toast-message.show {
    animation: toast-in 0.5s cubic-bezier(0.21, 1.02, 0.73, 1) forwards;
}

.toast-message.exiting {
    max-height: 0;
    opacity: 0;
    padding-top: 0;
    padding-bottom: 0;
    margin-top: 0;
}

@keyframes toast-in {
    from {
        opacity: 0;
        transform: translateY(25px) scale(0.9);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

.toast-message .emoji {
    font-size: 1.5rem;
}

.toast-message.toast-success,
.toast-message.toast-error,
.toast-message.toast-warning {
    background-color: rgba(255, 255, 255, 0.6);
    color: var(--thelo-text);
}

/* You might also want a rule for landscape tablets without the pointer check */
@media (min-width: 769px) and (max-width: 1200px) and (min-height: 500px) {
    #openCalculatorBtn {
        display: inline-flex;
    }
   #chatCol {
        display: none !important;
    }

    #lessonArea {
        width: 100%;
        flex-basis: 100%;
        border-left: none;
    }
}
/* >>> add once, after the existing #mcqOptionsContainer rules <<< */
#mcqOptionsContainer.side-by-side {
    position: absolute;
    top: 50%;
    right: 4%;
    left: auto !important;
    transform: translateY(-50%);
    display: flex;
    flex-direction: column;
    gap: 1rem;
    width: 38vw;
    max-width: 420px;
}

/* make the buttons grow full width of the column */
#mcqOptionsContainer.side-by-side .mcq-option-btn{ /* CORRECTED HYPHEN */
    flex:0 0 auto;
    width:100%;
}
/* REPLACE the old #calculatorOverlay and #calculatorFrame rules with these */

/* ===== MODIFIED CALCULATOR STYLES ===== */

/* ===== FIXED: Transparent Overlay & Bottom-Aligned Calculator ===== */

#calculatorOverlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 50;
    display: flex;
    
    /* 1. Push calculator to the bottom */
    align-items: flex-end; 
    justify-content: center;
    padding-bottom: 15px; /* Add space from the bottom edge */
    box-sizing: border-box;

    /* 2. REMOVED BLUR & BACKGROUND COLOR */
    /* The overlay is now invisible, only the calculator box will be seen */
    background-color: transparent; 
    backdrop-filter: none;
    -webkit-backdrop-filter: none;

    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0s linear 0.3s;
    
    /* Optional: This allows you to click on the headline behind the overlay 
       while the calculator is open. */
    pointer-events: none; 
}

#calculatorFrame {
    width: 98%;
    /* 3. Shorten height to leave top 15-20% open for the headline */
    height: 80%; 
    
    border: none;
    border-radius: 1rem;
    box-shadow: var(--shadow-lg);
    background-color: white; /* Ensure the calculator itself is solid */
    
    /* Re-enable clicks on the calculator itself */
    pointer-events: auto; 
}	/* ADD THIS NEW RULE */
.terminal-hidden-by-calculator {
    display: none !important;
}

#calculatorOverlay:not(.calculator-hidden) {
    opacity: 1;
    visibility: visible;
    transition-delay: 0s;
}


#calculatorCloseBtn {
    position: absolute;
    top: 2rem;
    right: 2rem;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: none;
    background-color: rgba(255, 255, 255, 0.9); /* Increased opacity slightly for visibility */
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    font-size: 1.2rem;
    
    /* === THE FIX === */
    pointer-events: auto; 
    cursor: pointer;
    /* ================= */

    box-shadow: var(--shadow-md);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 60; /* Ensure it stays above the frame */
}	/* ===== NEW: Embedded Replay Player Styles ===== */

#replayPlayerContainer {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 5; /* Below UI controls, but above canvases */
    display: flex;
    align-items: center;
    justify-content: center;
    padding-top: 70px;
    box-sizing: border-box;
    opacity: 0;
    pointer-events: none;
    visibility: hidden;
    transform: scale(0.95);
    transition: opacity 0.3s ease, visibility 0s linear 0.3s, transform 0.3s ease;
}

#replayPlayerContainer:not(.replay-hidden) {
    opacity: 1;
    visibility: visible;
    transform: scale(1);
    transition-delay: 0s;
}
#replayFrame {
    width: 90%;
    height: 80%;
    max-width: 1200px;
    max-height: 700px;
    border: none;                  /* Removed border */
    border-radius: 1rem;
    box-shadow: none;              /* Removed shadow */
    background-color: transparent; /* Made transparent */
    pointer-events: auto;
}
	/* Add near your other .mcq-option-btn rules */
.mcq-option-btn.selected {
    border-color: var(--thelo-blue);
    background-color: #eff6ff; /* A light blue background */
    color: var(--thelo-blue);
    border-width: 2px;
    transform: translateY(-3px);
    box-shadow: var(--shadow-lg);
}
  .mcq-option-btn .katex { vertical-align: middle; }
	/* ===== NEW: Animated Feedback System ===== */
#feedbackOverlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 10000;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: none; /* Allows clicks to go through to the canvas below */
    transition: opacity 0.4s ease;
}

#feedbackOverlay.feedback-hidden {
    opacity: 0;
}

#feedbackBox {
    background-color: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    color: var(--thelo-text);
    padding: 2rem 3rem;
    border-radius: 1.5rem;
    text-align: center;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
    border: 1px solid rgba(0, 0, 0, 0.05);
    max-width: 80%;
    transform: scale(0.8);
    opacity: 0;
    transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.3s ease;
}

/* This is the state when the feedback is visible, triggering the animation */
#feedbackOverlay:not(.feedback-hidden) #feedbackBox {
    transform: scale(1);
    opacity: 1;
}

#feedbackEmoji {
    font-size: 4rem;
    line-height: 1;
    display: block;
    margin-bottom: 1rem;
}

#feedbackText {
    font-size: 1.5rem;
    font-weight: 500;
    line-height: 1.5;
    margin: 0;
}

#feedbackText strong {
    color: var(--thelo-blue);
    font-weight: 700;
}
	#feedbackOverlay:not(.feedback-hidden){
    opacity:1; visibility:visible;
}
/* hide cursor when a stylus is down */
.no-cursor {
    cursor: none !important;
}
.control-btn { touch-action: manipulation; }
/* ===== NEW: Fixed Bottom Logo ===== */
#bottom-logo-container {
  position: fixed;
  bottom: 1rem; /* Adjust vertical spacing from the bottom */
  left: 50%;
  transform: translateX(-50%);
  z-index: 10000; /* Ensures it's above the canvas but below modals */
  pointer-events: none; /* Allows clicks to pass through to elements underneath */
}

#bottom-logo-container img {
  display: block;
  height: 35px; /* Adjust the logo size as needed */
  width: auto; /* Makes the logo subtle and less distracting */
}
	html, body {
  cursor: none !important;
}
	/* ===== NEW: On-Canvas Feedback ===== */
#feedbackCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 5; /* Above the drawing board, below UI controls */
    pointer-events: none; /* Allows drawing to pass through */
}
	/* Force Armenian font on all key UI text elements when the language is not English */
body:not(.lang-en) .control-btn,
body:not(.lang-en) .mcq-option-btn,
body:not(.lang-en) #pointsDisplay,
body:not(.lang-en) #colorIndicator,
body:not(.lang-en) .mobile-menu-btn {
    font-family: 'Montserrat Arm', sans-serif !important;
    font-weight: 400 !important; /* Regular weight for UI elements */
}
  /* ===== NEW: MCQ Keyboard-Only Mode ===== */
body.mcq-active {
    cursor: none; /* Hide the system cursor */
}

body.mcq-active .mcq-option-btn {
    pointer-events: none; /* Disable all mouse/touch interactions on the buttons */
}

/* This makes the selected option more prominent without a cursor */
body.mcq-active .mcq-option-btn.selected {
    border-color: var(--thelo-blue);
    background-color: #dbeafe; /* A darker blue to show focus */
    color: #1e40af;
    transform: scale(1.05); /* Make it pop a bit */
    box-shadow: var(--shadow-lg);
}
	#thelobookBtn {
    display: none !important;
}
	/* Force cursor to be visible when this class is present */
body.cursor-visible {
    cursor: auto !important;
}
	/* Add this to your CSS for the fade-out effect */
#backgroundCanvas.dimmed-for-feedback {
    opacity: 0.05 !important; /* Almost invisible */
    filter: grayscale(100%);   /* Optional: removes color distraction */
    transition: opacity 0.4s ease, filter 0.4s ease;
}

/* ===== NEW: Mobile Mode Styles ===== */
body.mobile-mode #bottomBar,
body.mobile-mode #pointsDisplay,
body.mobile-mode #colorIndicator,
body.mobile-mode #openCalculatorBtn,
body.mobile-mode #bottom-logo-container {
    display: none !important;
}

body.mobile-mode #boardWrap {
    /* Ensure full screen touch area */
    touch-action: none;
}

#mobileMenu {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(255, 255, 255, 0.85);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    z-index: 2000;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 1rem;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0s linear 0.3s;
}

#mobileMenu.visible {
    opacity: 1;
    visibility: visible;
    transition-delay: 0s;
}

.mobile-menu-btn {
    font-family: inherit;
    font-size: 1.1rem;
    font-weight: 500;
    padding: 0.75rem 1.5rem;
    border-radius: 0.75rem;
    border: 1px solid var(--thelo-border);
    background-color: var(--bg-white);
    box-shadow: var(--shadow-md);
    color: var(--thelo-text);
    width: 80%;
    max-width: 300px;
    transition: transform 0.1s ease, box-shadow 0.1s ease;
}

.mobile-menu-btn:active {
    transform: scale(0.98);
    box-shadow: var(--shadow-sm);
}
</style>
</head>
<body>
    <div id="loading-overlay">
    </div>
    <div id="app">
        <div id="lessonArea">
            <div id="boardWrap">
                <div id="stageProgressBarContainer"><div id="stageProgressFill"></div></div>
                <canvas id="backgroundCanvas"></canvas>
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† <canvas id="replayCanvas"></canvas>
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† <canvas id="board"></canvas>
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† <canvas id="feedbackCanvas"></canvas>
		¬† ¬† <canvas id="boardCapture" style="display:none"></canvas>
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† <canvas id="thelobookCanvas"></canvas>
		<div id="calculatorOverlay" class="calculator-hidden">
                <iframe id="calculatorFrame" src="about:blank" allow="clipboard-write"></iframe>
                <button id="calculatorCloseBtn" title="Close Calculator">‚úï</button>
            </div>
		    <div id="replayPlayerContainer" class="replay-hidden">
			<iframe id="replayFrame" src="about:blank" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
		</div>
                <div id="thelobookControls">
                    <button id="thelobookPrevPageBtn" title="Previous Page">‚Äπ</button>
                    <span id="thelobookPageIndicator">Page 1 / 1</span>
                    <button id="thelobookNextPageBtn" title="Next Page">‚Ä∫</button>
                    <button id="thelobookEraserBtn" title="Eraser">‚úèÔ∏è</button>
                    <button id="thelobookAddPageBtn" title="Add New Page">+</button>
                </div>

                <div id="thelobookPageGridView">
                    <div id="thelobookPageGridHeader">
                        <span id="pageGridBatchIndicator">Pages 1-32</span>
                        <button id="closePageGridBtn" title="Close Grid">‚úï</button>
                    </div>
                    <div id="thelobookPageGridContentContainer">
                    </div>
                </div>
		    

                <div id="mcqOptionsContainer" style="display: none;"></div>
            </div>

            <div id="bottomBar">
                <div id="colorIndicator"></div>
                <div id="pointsDisplay"></div>
                <div id="actionButtons">
    <button id="prevBtn" class="control-btn"></button>
    <button id="openCalculatorBtn" class="control-btn" title="Open Calculator">Graph</button>
    <button id="thelobookBtn" class="control-btn"></button>
    
    <button id="clearBtn" class="control-btn"></button>
    <button id="nextCheckBtn" class="control-btn"></button>
    <button id="dashboardBtn" class="control-btn" style="display: none;"></button>
</div>
            </div>

            <div id="mobileMenu">
                <button id="mobileCheckBtn" class="mobile-menu-btn" style="color: var(--success-green);">Check</button>
                <button id="mobileNextBtn" class="mobile-menu-btn" style="color: var(--thelo-blue);">Next Stage</button>
                <button id="mobileEraseBtn" class="mobile-menu-btn" style="color: var(--error-red);">Erase</button>
                <button id="mobilePrevBtn" class="mobile-menu-btn" style="color: var(--thelo-text-light);">Previous Stage</button>
                <button id="mobileCloseBtn" class="mobile-menu-btn" style="color: var(--thelo-text);">Close Menu</button>
            </div>
        </div>
        
    </div>
    <div id="toast-container"></div>
    <div id="audioContainer" style="display: none;">
        <audio id="audio_approve1_hy" src="https://thelo.space/audio/approve1.ogg" preload="auto"></audio>
        <audio id="audio_approve2_hy" src="https://thelo.space/audio/approve2.ogg" preload="auto"></audio>
        <audio id="audio_dis1_hy" src="https://thelo.space/audio/dis1.ogg" preload="auto"></audio>
        <audio id="audio_dis2_hy" src="https://thelo.space/audio/dis2.ogg" preload="auto"></audio>
        <audio id="audio_approve1_en" src="https://thelo.space/audio/engcorr1.mp3" preload="auto"></audio>
        <audio id="audio_approve2_en" src="https://thelo.space/audio/engcorr2.mp3" preload="auto"></audio>
        <audio id="audio_dis1_en" src="https://thelo.space/audio/engwrong1.mp3" preload="auto"></audio>
        <audio id="audio_dis2_en" src="https://thelo.space/audio/engwrong2.mp3" preload="auto"></audio>
        <audio id="stageAudioPlayer"></audio>
        <audio id="gotItSound" src="https://thelo.space/audio/corr.mp3" preload="auto"></audio>
    </div>
	<div id="streakModal" class="modal-hidden">
    <div class="streak-modal-content">
        <span id="streakModalCloseBtn" class="streak-modal-close">&times;</span>
        <div class="streak-modal-icon">üî•</div>
        <h2 id="streakModalTitle"></h2>
        <p id="streakModalBody"></p>
        <button id="streakModalConfirmBtn" class="control-btn">Awesome!</button>
    </div>
		
</div>
	<div id="feedbackOverlay" class="feedback-hidden">
    <div id="feedbackBox">
        <span id="feedbackEmoji"></span>
        <p id="feedbackText"></p>
    </div>
</div>
	<div id="bottom-logo-container">
    <img src="https://thelo.space/img/bluethelo.svg" alt="Thelo Logo">
</div>
</body>
  <script>
    const firebaseConfig = { apiKey: "AIzaSyAbnPpcIt88B0jIAoLUdC71zmQDvR_fdu8", authDomain: "physmathacademy-722b3.firebaseapp.com", databaseURL: "https://physmathacademy-722b3-default-rtdb.firebaseio.com", projectId: "physmathacademy-722b3", storageBucket: "physmathacademy-722b3.appspot.com", messagingSenderId: "1093640992262", appId: "1:1093640992262:web:35b1bf4d2364bcf745f587" };
    firebase.initializeApp(firebaseConfig);


¬† ¬† const auth = firebase.auth();
    const db = firebase.firestore();

    // =================================================================
    //  NEW FIX: Set auth persistence to 'session' to work around
    //  potential browser storage restrictions.
    // =================================================================
    auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL)
        .catch((error) => {
            console.error("Auth persistence error:", error.code, error.message);
        });
    getKatexCSSWithEmbeddedFonts().catch(()=>{});
ensureHeadlineFontsLoaded().catch(()=>{});
    const INK_COLORS = { black: '#000000', blue: getComputedStyle(document.documentElement).getPropertyValue('--ink-blue').trim() || '#2563eb' };

    const UI_TEXT = {
        hy: {
            next: "’Ä’°’ª’∏÷Ä’§’®", gotIt: "’Ä’°’Ω’Ø’°÷Å’°!", check: "’ç’ø’∏÷Ç’£’•’¨", checking: "’ç’ø’∏÷Ç’£’æ’∏÷Ç’¥ ’ß...",
            correct: "’É’´’∑’ø ’ß÷â", incorrect: "’ç’≠’°’¨ ’ß", apiKeyInvalid: "API ’¢’°’∂’°’¨’´’∂ ’°’∂’æ’°’æ’•÷Ä ’ß",
            inkBlack: "‘≥’∏÷Ç’µ’∂’ù ’ç÷á", inkBlue: "‘≥’∏÷Ç’µ’∂’ù ‘ø’°’∫’∏÷Ç’µ’ø", loading: "‘≤’•’º’∂’æ’∏÷Ç’¥ ’ß...",
            clear: "’Ñ’°÷Ñ÷Ä’•’¨", start: "’ç’Ø’Ω’•’¨", prev: "’Ü’°’≠’∏÷Ä’§",
            welcome: "’à’≤’ª’∏÷Ç’õ’µ’∂÷â ’ç’•’≤’¥’´÷Ä ’ç’Ø’Ω’•’¨ ’§’°’Ω’® ’Ω’Ø’Ω’•’¨’∏÷Ç ’∞’°’¥’°÷Ä÷â",
            checkingAI: `’ç’ø’∏÷Ç’£’∏÷Ç’¥ ’•’¥ ÷Ñ’∏ <strong style="color:${INK_COLORS.blue};">’Ø’°’∫’∏÷Ç’µ’ø’∏’æ</strong> ’£÷Ä’æ’°’Æ ’∫’°’ø’°’Ω’≠’°’∂’®...`,
            blankBlueWarning: `‚ö†Ô∏è ‘ø’°÷Ä’Æ’•’Ω ’©’• ’∫’°’ø’°’Ω’≠’°’∂’® <strong style="color:${INK_COLORS.blue};">’Ø’°’∫’∏÷Ç’µ’ø’∏’æ</strong> ’π’•’Ω ’∂’∑’•’¨÷â ’ç’•’≤’¥’´÷Ä 'A' ’Ω’ø’•’≤’∂’® ’£’∏÷Ç’µ’∂’® ÷É’∏’≠’•’¨’∏÷Ç ’∞’°’¥’°÷Ä÷â`,
            noTextFound: `‚ö†Ô∏è <strong style="color:${INK_COLORS.blue};">‘ø’°’∫’∏÷Ç’µ’ø’∏’æ</strong> ’£÷Ä’æ’°’Æ’´÷Å ’ø’•÷Ñ’Ω’ø ’π’£’ø’∂’æ’•÷Å÷â ’ì’∏÷Ä’±’´÷Ä ’£÷Ä’•’¨ ’°’æ’•’¨’´ ’∫’°÷Ä’¶÷â`,
            noDigitsFound: `‚ö†Ô∏è ‘ø’°÷Ä’Æ’•’Ω ’©’• <strong style="color:${INK_COLORS.blue};">’Ø’°’∫’∏÷Ç’µ’ø’∏’æ</strong> ’©’´v ’π’•÷Ñ ’£÷Ä’•’¨÷â (’É’°’∂’°’π’æ’°’Æ ’ø’•÷Ñ’Ω’ø’ù {detectedText})`,
            correctAI: `üéâ ’É’´’∑’ø ’ß Google Vision-’´ ’Ø’°÷Ä’Æ’´÷Ñ’∏’æ÷â (‘¥’∏÷Ç÷Ñ ’£÷Ä’•’¨ ’ß’´÷Ñ <strong>{detectedAnswer}</strong>)`,
            incorrectAI: `ü§î ’ç’≠’°’¨ ’ß÷â Google Vision-’® <strong style="color:${INK_COLORS.blue};">’Ø’°’∫’∏÷Ç’µ’ø</strong> ’£÷Ä’æ’°’Æ÷Ñ’´÷Å ’Ø’°÷Ä’§’°÷Å <strong>{detectedAnswer}</strong>, ’¢’°’µ÷Å ’≥’´’∑’ø ’∫’°’ø’°’Ω’≠’°’∂’∂ ’ß <strong>{correctAnswer}</strong>÷â ’ì’∏÷Ä’±’´÷Ä ’Ø÷Ä’Ø’´’∂÷â`,
            parsingError: `‚ö†Ô∏è ’â’Ø’°÷Ä’∏’≤’°÷Å’° <strong style="color:${INK_COLORS.blue};">’Ø’°’∫’∏÷Ç’µ’ø</strong> ’£÷Ä’æ’°’Æ÷Ñ’´÷Å ’©’´’æ’® ’≥’°’∂’°’π’•’¨÷â (’É’°’∂’°’π’æ’°’Æ ’ø’•÷Ñ’Ω’ø’ù {detectedText})`,
            imageDataError: `‚ùå ’ç’≠’°’¨’ù ’π’∞’°’ª’∏’≤’æ’•÷Å ’Ω’ø’°’∂’°’¨ ’∂’Ø’°÷Ä’® ’£÷Ä’°’ø’°’≠’ø’°’Ø’´÷Å÷â ({errorMessage})`,
            apiErrorGeneral: `‚ùå ’ç’≠’°’¨ ’ø’•’≤’´ ’∏÷Ç’∂’•÷Å’°’æ ’Ω’ø’∏÷Ç’£’¥’°’∂ ’™’°’¥’°’∂’°’Ø÷â ({errorMessage})`,
            apiKeyPermissionError: '‚ùå ’ç’≠’°’¨’ù API ’¢’°’∂’°’¨’´’∂ ’°’∂’æ’°’æ’•÷Ä ’ß ’Ø’°’¥ ’©’∏÷Ç’µ’¨’ø’æ’∏÷Ç’©’µ’∏÷Ç’∂ ’π’∏÷Ç’∂’´÷â ’ç’ø’∏÷Ç’£’•÷Ñ ’¢’°’∂’°’¨’´’∂ ÷á ’∞’°’¥’∏’¶’æ’•÷Ñ, ’∏÷Ä Vision API-’∂ ’¥’´’°÷Å’æ’°’Æ ’ß÷â',
            apiBillingError: '‚ùå ’ç’≠’°’¨’ù ’Ä’°’∑’æ’°÷Ä’Ø’¥’°’∂ (billing) ’≠’∂’§’´÷Ä÷â ’ç’ø’∏÷Ç’£’•÷Ñ, ’∏÷Ä ’°’µ’∂ ’¥’´’°÷Å’æ’°’Æ ’ß ’±’•÷Ä Google Cloud ’∂’°’≠’°’£’Æ’´ ’∞’°’¥’°÷Ä÷â',
            apiKeyMissingWarning: 'üõë **‘ø‘±’ê‘µ’é’à’ê:** Google Vision API ’¢’°’∂’°’¨’´’∂ ’Ω’≠’°’¨ ’ß ’Ø’°’¥ ’¢’°÷Å’°’Ø’°’µ’∏÷Ç’¥ ’ß÷â ‘Ω’∂’§÷Ä’∏÷Ç’¥ ’•’∂÷Ñ ÷É’∏’≠’°÷Ä’´’∂’•’¨ ’°’µ’∂÷â ‘±’º’°’∂÷Å ’§÷Ä’°, ’±’•’º’°’£÷Ä’´ ’Ω’ø’∏÷Ç’£’∏÷Ç’¥’® ’π’´ ’°’∑’≠’°’ø’´÷â',
            lessonComplete: "‘¥’°’Ω’∂ ’°’æ’°÷Ä’ø’æ’°’Æ ’ß÷â ’á’°’ø ’¨’°’æ ’°’∑’≠’°’ø’°’∂÷Ñ÷â",
            drawActivityWarning: "‚ö†Ô∏è ‘Ω’∂’§÷Ä’∏÷Ç’¥ ’•’¥, ’∂’°’≠ ÷É’∏÷Ä’±’´÷Ä ’∂’Ø’°÷Ä’•’¨÷â",
            achievementsPrefix: "üèÜ ",
            blueInkErased: "‘ø’°’∫’∏÷Ç’µ’ø ’£÷Ä’æ’°’Æ÷Ñ’® (’∫’°’ø’°’Ω’≠’°’∂’®) ’¥’°÷Ñ÷Ä’æ’°’Æ ’ß÷â",
            authErrorVision: "‘±’æ’ø’∏÷Ä’´’¶’°÷Å’´’°’µ’´ ’Ω’≠’°’¨÷â ‘Ω’∂’§÷Ä’∏÷Ç’¥ ’•’∂÷Ñ ’¥’∏÷Ç’ø÷Ñ ’£’∏÷Ä’Æ’•’¨’ù ’°’µ’Ω ’£’∏÷Ä’Æ’°’º’∏÷Ç’µ’©’∂ ÷Ö’£’ø’°’£’∏÷Ä’Æ’•’¨’∏÷Ç ’∞’°’¥’°÷Ä÷â",
            lessonFileMissing: '’ç’≠’°’¨÷â ‘¥’°’Ω’´ ÷Ü’°’µ’¨’® ’∂’∑’æ’°’Æ ’π’ß URL-’∏÷Ç’¥÷â',
            lessonLoadErrorGeneric: "‘¥’°’Ω’® ’¢’•’º’∂’•’¨’∏÷Ç ’Ω’≠’°’¨÷â\n‘Ω’∂’§÷Ä’∏÷Ç’¥ ’•’∂÷Ñ ’æ’•÷Ä’°’§’°’º’∂’°’¨ ÷á ’∂’∏÷Ä’´÷Å ÷É’∏÷Ä’±’•’¨÷â",
            userNotAuthHandwriting: '‚ö†Ô∏è ’ï’£’ø’°’ø’•÷Ä’® ’∂’∏÷Ç’µ’∂’°’Ø’°’∂’°÷Å’æ’°’Æ ’π’ß: ‘Ω’∂’§÷Ä’∏÷Ç’¥ ’•’∂÷Ñ ’¥’∏÷Ç’ø÷Ñ ’£’∏÷Ä’Æ’•’¨ ’±’•’º’°’£÷Ä’´ ’æ’•÷Ä’¨’∏÷Ç’Æ’∏÷Ç’©’µ’°’∂ ’£’∏÷Ä’Æ’°’º’∏÷Ç’µ’©’∂ ÷Ö’£’ø’°’£’∏÷Ä’Æ’•’¨’∏÷Ç ’∞’°’¥’°÷Ä:',
            pointsGained: "+{points} ’¥’´’°’æ’∏÷Ä ’±’•’º÷Ñ ’¢’•÷Ä’æ’•÷Å÷â", error: "’ç’≠’°’¨", titleDefaultHy: "Thelo AI ‘≥÷Ä’°’ø’°’≠’ø’°’Ø",
            thelobookOpen: "‘π’•’¨’∏’£’´÷Ä÷Ñ", thelobookClose: "’ì’°’Ø’•’¨", thelobookInk: "‘≥’∏÷Ç’µ’∂’ù ’ç÷á (’Ü’∑’∏÷Ç’¥’∂’•÷Ä)",
            thelobookEraser: "’ã’∂’ª’´’π", thelobookPen: "‘≥÷Ä’´’π",
            closeMenu: "’ì’°’Ø’•’¨ ’¥’•’∂’µ’∏÷Ç’∂",
            nextStage: "’Ä’°’ª’∏÷Ä’§ ÷É’∏÷Ç’¨",
            prevStage: "’Ü’°’≠’∏÷Ä’§ ÷É’∏÷Ç’¨",
            thelobookDisabledMCQ: "‘π’•’¨’∏’£’´÷Ä÷Ñ’® ’∞’°’Ω’°’∂’•’¨’´ ’π’ß ’∞’°÷Ä÷Å’°’∑’°÷Ä’´ ’™’°’¥’°’∂’°’Ø÷â",
            thelobookPagesBtn: "‘∑’ª’•÷Ä",
            thelobookPageIndicator: "‘∑’ª {currentPage} / {totalPages}",
            pageGridBatchIndicator: "‘∑’ª’•÷Ä {startPage}-{endPage}",
            pageGridInstructions: "’ç’•’≤’¥’•÷Ñ 'C' ’∞’°’ª’∏÷Ä’§ ’≠’¥’¢’´ ’∞’°’¥’°÷Ä, 'X' ’∂’°’≠’∏÷Ä’§’´÷â",
            addPage: "‘±’æ’•’¨’°÷Å’∂’•’¨ ’ß’ª",
	    viewDashboard: "’è’•’Ω’∂’•’¨ ’°’º’°’ª’®’∂’©’°÷Å’®", // ADD THIS LINE
	    limitReached: "‘¥’∏÷Ç÷Ñ ’£’•÷Ä’°’¶’°’∂÷Å’•’¨ ’•÷Ñ ’±’•÷Ä ’°’¥’Ω’°’Ø’°’∂ ’æ’•÷Ä’¨’∏÷Ç’Æ’∏÷Ç’©’µ’∏÷Ç’∂’∂’•÷Ä’´ ’Ω’°’∞’¥’°’∂’°’π’°÷É’®÷â ‘Ω’∂’§÷Ä’∏÷Ç’¥ ’•’∂÷Ñ ÷É’∏÷Ä’±’•’¨ ’Ø÷Ä’Ø’´’∂ ’∞’°’ª’∏÷Ä’§ ’°’¥’´’Ω÷â"
},
		
       en: {
  next: "Next",
  gotIt: "Got it",
  check: "Check",
  checking: "Check",
  correct: "That's right!",
  incorrect: "Not quite.",

  apiKeyInvalid: "Your key doesn‚Äôt seem to be working. Please check and try again.",

  inkBlack: "Ink: Black",
  inkBlue: "Ink: Blue",
  loading: "Loading...",
  clear: "Clear",
  start: "Start",
  prev: "Previous",

  welcome: "Press Start to begin.",
  checkingAI: `Looking at your answer in <strong style="color:${INK_COLORS.blue};">blue</strong>...`,
  blankBlueWarning: `It looks like there's no answer in <strong style="color:${INK_COLORS.blue};">blue</strong>. Press 'A' to change your ink color.`,
  noTextFound: `I couldn‚Äôt find any writing in <strong style="color:${INK_COLORS.blue};">blue</strong>. Try writing a bit more clearly.`,
  noDigitsFound: `I didn‚Äôt see a number written in <strong style="color:${INK_COLORS.blue};">blue</strong>. (Detected text: {detectedText})`,

  correctAI: `Looks good to me! You wrote: <strong>{detectedAnswer}</strong>`,
  incorrectAI: `I saw <strong>{detectedAnswer}</strong>, but the correct answer is <strong>{correctAnswer}</strong>. Try again.`,
  parsingError: `I had trouble reading a number from your answer. (Detected: {detectedText})`,

  imageDataError: `Couldn't get the image from the board. ({errorMessage})`,
  apiErrorGeneral: `Something went wrong while checking your answer. ({errorMessage})`,
  apiKeyPermissionError: "Your key may be missing permissions. Make sure everything‚Äôs set up properly.",
  apiBillingError: "There seems to be a billing issue. Check your payment settings.",
  apiKeyMissingWarning: "Important: A valid key is missing. Handwriting checking won't work until it‚Äôs added.",

  lessonComplete: "Lesson complete! Nice work.",
  drawActivityWarning: "Please try drawing something first.",
  achievementsPrefix: "üèÜ ",

  blueInkErased: "Your blue ink answer has been erased.",
  authErrorVision: "Please log in to use this feature.",
  lessonFileMissing: "Lesson file not found. Check the link and try again.",
  lessonLoadErrorGeneric: "There was a problem loading the lesson. Please try again.",
  userNotAuthHandwriting: "You're not logged in. Please log in to use handwriting analysis.",

  pointsGained: "+{points} points earned!",
  error: "Error",
  titleDefaultEn: "Thelo AI Whiteboard",

  thelobookOpen: "thelobook",
  thelobookClose: "Close",
  closeMenu: "Close Menu",
  nextStage: "Next Stage",
  prevStage: "Previous Stage",
  thelobookInk: "Ink: Black (Notes)",
  thelobookEraser: "Eraser",
  thelobookPen: "Pen",
  thelobookDisabledMCQ: "thelobook is disabled during multiple choice questions.",
  thelobookPagesBtn: "Pages",
  thelobookPageIndicator: "Page {currentPage} of {totalPages}",
  pageGridBatchIndicator: "Pages {startPage}‚Äì{endPage}",
  pageGridInstructions: "Press 'C' for next batch, 'X' for previous batch.",
  addPage: "Add Page",

  viewDashboard: "View Your Progress",
  limitReached: "You've reached your monthly handwriting check limit. Try again next month.",
}

    };

    let currentLang = 'en';
    /* ========================================================================= */
/* ===== ADD THIS BLOCK: For Weekly Streak Calculation ===================== */

    let isMobileMode = false;
    let mobileCameraOffset = { x: 0, y: 0 };
    let mobileStrokes = [];
    let cachedStaticCanvas = null;
    let isMobileScrubbing = false;
    let mobileScrubStartX = 0;
    let mobileScrubStartTime = 0;

/* ========================================================================= */

/**
 * Calculates the ISO 8601 week number for a given date.
 * A week starts on Monday. This is robust against timezone issues.
 * @param {Date} date The date to calculate the week for.
 * @returns {string} The week identifier in "YYYY-Www" format (e.g., "2025-W26").
 */
function getISOWeekIdentifier(date) {
    // Create a new date object to avoid modifying the original
    const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
    // Set to the nearest Thursday: current date + 4 - current day number
    // Make Sunday's day number 7
    d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
    // Get first day of year
    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    // Calculate full weeks to nearest Thursday
    const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
    // Pad week number with a leading zero if needed
    const weekString = String(weekNo).padStart(2, '0');
    
    return `${d.getUTCFullYear()}-W${weekString}`;
}

/**
 * Gets the week identifier for the week immediately preceding the given one.
 * @param {string} weekId A week identifier like "2025-W26".
 * @returns {string} The previous week's identifier, e.g., "2025-W25".
 */
function getPreviousWeekIdentifier(weekId) {
    const [year, week] = weekId.split('-W').map(Number);
    if (week > 1) {
        const prevWeekString = String(week - 1).padStart(2, '0');
        return `${year}-W${prevWeekString}`;
    } else {
        // This is tricky: the last week of the previous year can be 52 or 53.
        // We'll calculate it based on the last day of the previous year.
        const lastDayOfPrevYear = new Date(year - 1, 11, 31);
        return getISOWeekIdentifier(lastDayOfPrevYear);
    }
}

    /* ========== DOM Elements ========== */
    const backgroundCanvas = document.getElementById('backgroundCanvas');
    const replayCanvas = document.getElementById('replayCanvas');
    const canvas = document.getElementById('board');
    const loadingOverlay = document.getElementById('loading-overlay'); // <-- ADD THIS
    const thelobookCanvas = document.getElementById('thelobookCanvas');
    const boardWrapper = document.getElementById('boardWrap');
    const stageAudioPlayer = document.getElementById('stageAudioPlayer');
    const gotItSoundPlayer = document.getElementById('gotItSound');
    const mcqOptionsContainer = document.getElementById('mcqOptionsContainer');
    const bottomBar = document.getElementById('bottomBar');
    const stageProgressBarContainer = document.getElementById('stageProgressBarContainer');
    const stageProgressFill = document.getElementById('stageProgressFill');
	  
	  const feedbackCanvas = document.getElementById('feedbackCanvas');
let feedbackCtx = null; // Will be initialized in setupContexts
let feedbackAnimationId = null; // To manage animations
	  let lastFeedbackDetails = null;
	  const feedbackOverlay = document.getElementById('feedbackOverlay');
const feedbackEmoji = document.getElementById('feedbackEmoji');
const feedbackText = document.getElementById('feedbackText');
let feedbackTimer = null; // To manage auto-hiding the message
	const imageTerminal = document.getElementById('image-terminal');
	const imageTerminalImgContainer = document.getElementById('image-terminal-img-container');
	const imageTerminalFeedback = document.getElementById('image-terminal-feedback');

    const bgCtx = backgroundCanvas.getContext('2d');
    let replayCtx = null;
    const ctx = canvas.getContext('2d');
	  const captureCanvas = document.getElementById('boardCapture');   // NEW
const captureCtx    = captureCanvas.getContext('2d');            // NEW
    let thelobookCtx = null;

    const prevBtn = document.getElementById('prevBtn');
    const nextCheckBtn = document.getElementById('nextCheckBtn');
	  /* mobile tap shim */
nextCheckBtn.addEventListener(
  'touchend',
  e => {
    e.preventDefault();      // stop the synthetic click
    nextCheckBtn.click();    // re-use the normal handler
  },
  { passive: false }
);

    const clearBtn = document.getElementById('clearBtn');
    const thelobookBtn = document.getElementById('thelobookBtn');
    const chatArea = document.getElementById('chat');
    const chatCol = document.getElementById('chatCol'); // <-- ADD THIS LINE
    const colorIndicator = document.getElementById('colorIndicator');
    if (colorIndicator){ colorIndicator.addEventListener('click', () => { toggleColor(); }); }
    const pointsDisplayElement = document.getElementById('pointsDisplay');
    const mobileMenu = document.getElementById('mobileMenu');
    const mobileCheckBtn = document.getElementById('mobileCheckBtn');
    const mobileNextBtn = document.getElementById('mobileNextBtn');
    const mobileEraseBtn = document.getElementById('mobileEraseBtn');
    const mobilePrevBtn = document.getElementById('mobilePrevBtn');
    const mobileCloseBtn = document.getElementById('mobileCloseBtn');
const dashboardBtn = document.getElementById('dashboardBtn'); // ADD THIS LINE

    const thelobookControlsEl = document.getElementById('thelobookControls');
    const thelobookPagesBtn = document.getElementById('thelobookPagesBtn');
    const thelobookPrevPageBtn = document.getElementById('thelobookPrevPageBtn');
    const thelobookNextPageBtn = document.getElementById('thelobookNextPageBtn');
    const thelobookPageIndicatorEl = document.getElementById('thelobookPageIndicator');
    const thelobookEraserBtn = document.getElementById('thelobookEraserBtn');
    const thelobookAddPageBtn = document.getElementById('thelobookAddPageBtn');
    const calculatorOverlay = document.getElementById('calculatorOverlay');
    const calculatorFrame = document.getElementById('calculatorFrame');
    const calculatorCloseBtn = document.getElementById('calculatorCloseBtn');
	const replayPlayerContainer = document.getElementById('replayPlayerContainer');
	const replayFrame = document.getElementById('replayFrame');
    const audioElements = {};
    const approveSounds_hy = []; const disapproveSounds_hy = [];
    const approveSounds_en = []; const disapproveSounds_en = [];

    /* ========== State Variables ========== */
    let isAuthReady = false;
	  let isInitialStageRendered = false;
	  let isMcqAnsweredCorrectly = false;
	  let selectedMcqIndex = null; // To store the selected MCQ option index
          let isTabletMode = false;
	let isCalculatorActive = false;
	let isReplayActive = false;
		let mousePoints = []; // <<< ADD THIS LINE
const IFRAME_UPDATE_INTERVAL = 40; // ms, throttles updates to 25 FPS (1000 / 40 = 25)
let lastIframeUpdateTime = 0;
	let isPageGridVisible = false; 
        let lessonStartTime = null;
    let lessonStagesRoot = null; let lessonStages = []; let isLessonLoading = false;
    let isImageModeActive = false;
    let currentStageIndex = -1; let currentStageData = null; let isStudentInputAllowed = false;
    let drawing = false; let lastPos = { x: 0, y: 0 };
    let userDrawingOccurred = false; let isTransitioning = false;
    let devicePixelRatio = window.devicePixelRatio || 1; window.userInteracted = false;
    let currentReplayAnimationId = null; let currentStageAudio = null; 
    let userPoints = 0;
    let sessionPoints = 0; // ADDED LINE: To track points for the current lesson session.
    let currentStageDrawingData = null; let currentStageTotalDuration = 0;
    let isMediaScrubbingActive = false; let internalPlaybackTime = 0; let lastFrameTimestampForManualAdvance = 0;
    let isThelobookActive = false; let wasMediaPlayingBeforeThelobook = false;
    let mediaPlaybackTimeBeforeThelobook = 0; let audioTimeBeforeThelobook = 0;
    let thelobookPages = []; let currentThelobookPageIndex = 0;
    let thelobookDrawListenersAttached = false;
    let isThelobookEraserActive = false;
    const THELOBOOK_ERASER_LINEWIDTH = 20;
    const THELOBOOK_PEN_LINEWIDTH = 3;
    let isPageSwitchingAnimation = false;
    const PAGES_PER_GRID_BATCH = 32;
    let tempFullPageCanvasForThumbnails = null;
    let buttonVanishTimer = null;
    let stagesWithPointsAwarded = new Set();
    /* ========== Language Functions ========== */
    function getCurrentUIText() { return UI_TEXT[currentLang] || UI_TEXT['hy']; }
    function updateAllUITexts() {
        const TXT = getCurrentUIText();
        document.documentElement.lang = currentLang;

        if (prevBtn) prevBtn.textContent = TXT.prev;
        if (clearBtn) clearBtn.textContent = TXT.clear;
        if (thelobookBtn) thelobookBtn.textContent = isThelobookActive ? TXT.thelobookClose : TXT.thelobookOpen;

        if (thelobookAddPageBtn) thelobookAddPageBtn.title = TXT.addPage;
        if (thelobookEraserBtn) thelobookEraserBtn.title = isThelobookEraserActive ? TXT.thelobookPen : TXT.thelobookEraser;
        if (thelobookPagesBtn) thelobookPagesBtn.title = TXT.thelobookPagesBtn;
        if (thelobookPrevPageBtn) thelobookPrevPageBtn.title = TXT.prevPage;
        if (thelobookNextPageBtn) thelobookNextPageBtn.title = TXT.nextPage;

        updateColorIndicator();
        updatePointsDisplay();
        if(isThelobookActive && !isPageGridVisible) updateThelobookPageControls();


        if (lessonStagesRoot && lessonStagesRoot.lessonTitle) {
            document.title = lessonStagesRoot.lessonTitle || TXT[`titleDefault${currentLang.charAt(0).toUpperCase() + currentLang.slice(1)}`];
        } else {
            document.title = TXT[`titleDefault${currentLang.charAt(0).toUpperCase() + currentLang.slice(1)}`];
        }
        
        if (currentStageIndex === -1 && lessonStages.length > 0 && nextCheckBtn) { nextCheckBtn.textContent = TXT.start; }
        else if (isLessonLoading && nextCheckBtn) { nextCheckBtn.textContent = TXT.loading; }
        else if (currentStageData && nextCheckBtn) {
                if (currentStageData.type === 'question_handwriting') {
                    if (nextCheckBtn.classList.contains('correct')) { nextCheckBtn.textContent = TXT.correct; }
                    else if (nextCheckBtn.classList.contains('incorrect')) { nextCheckBtn.textContent = TXT.check; }
                    else if (nextCheckBtn.textContent === UI_TEXT.hy.checking || nextCheckBtn.textContent === UI_TEXT.en.checking ) { /* Keep "Checking..." */ }
                    else { nextCheckBtn.textContent = TXT.check; }
                } else {
                    const mcqDetails = currentStageData.optionsQuiz;
                    const isMCQDisplayStage = currentStageData.type === "explanation_with_mcq" && mcqDetails && Array.isArray(mcqDetails.choices) && mcqDetails.choices.length > 0;
                    if (!isMCQDisplayStage) {
                        if (nextCheckBtn.classList.contains('correct')) { nextCheckBtn.textContent = TXT.correct; }
                        else { nextCheckBtn.textContent = TXT.gotIt; }
                    }
                }
        }

        // ===== NEW: Update Mobile Menu Buttons =====
        if (mobileCheckBtn) {
            // Sync mobile check button with the main action button logic
            if (nextCheckBtn) mobileCheckBtn.textContent = nextCheckBtn.textContent; 
            else mobileCheckBtn.textContent = TXT.check;
        }
        if (mobileNextBtn) mobileNextBtn.textContent = TXT.nextStage;
        if (mobileEraseBtn) mobileEraseBtn.textContent = TXT.clear;
        if (mobilePrevBtn) mobilePrevBtn.textContent = TXT.prevStage;
        if (mobileCloseBtn) mobileCloseBtn.textContent = TXT.closeMenu;
        // ===========================================

        if (currentStageData) {
            if (!isTransitioning && !isLessonLoading) renderStageUI(currentStageIndex, true);
        }
    }
    function setLanguage(lang) {
        const normalizedLang = (lang || '').trim().toLowerCase();
        if (UI_TEXT[normalizedLang]) {
            if (currentLang !== normalizedLang) { currentLang = normalizedLang; console.log(`Language set to: ${currentLang} by lesson file.`); }
            else { console.log(`Language already set to: ${currentLang}. Forcing UI text update.`); }
        } else {
            console.warn(`Language '${lang}' from lesson file not supported. Defaulting to 'hy'.`);
            currentLang = 'hy';
        }
        // Add or remove the language-specific class on the body
        if (currentLang === 'en') {
            document.body.classList.add('lang-en');
        } else {
            document.body.classList.remove('lang-en');
        }
        updateAllUITexts();
    }

    /* ========== Core App Functions ========== */
    function updatePointsDisplay() {
¬† ¬† ¬† ¬† const TXT = getCurrentUIText();
¬† ¬† ¬† ¬† // MODIFIED: This now uses sessionPoints for the on-screen display.
¬† ¬† ¬† ¬† if (pointsDisplayElement) pointsDisplayElement.textContent = `${TXT.achievementsPrefix}${sessionPoints}`;
¬† ¬† }
  async function loadLesson(lessonJsonPath) {
¬† ¬† if (isLessonLoading) return;
¬† ¬† isLessonLoading = true;
¬† ¬† if (prevBtn) prevBtn.disabled = true;
¬† ¬† if (dashboardBtn) dashboardBtn.style.display = 'none';
¬† ¬† if (isThelobookActive) closeThelobook(false);
¬† ¬† if (isPageGridVisible) closePageGridView();

¬† ¬† try {
¬† ¬† ¬† ¬† const response = await fetch(lessonJsonPath);
¬† ¬† ¬† ¬† if (!response.ok) throw new Error(`HTTP error! status: ${response.status} fetching ${lessonJsonPath}`);
¬† ¬† ¬† ¬† lessonStagesRoot = await response.json();
¬† ¬† ¬† ¬† if (!lessonStagesRoot || !Array.isArray(lessonStagesRoot.stages)) throw new Error("Invalid lesson format.");
        let lessonLang = lessonStagesRoot.lessonLanguage;
        if (typeof lessonLang === 'string') lessonLang = lessonLang.trim().toLowerCase();
        setLanguage(lessonLang || 'hy');
¬† ¬† ¬† ¬† let TXT = getCurrentUIText();
¬† ¬† ¬† ¬† lessonStages = lessonStagesRoot.stages;

        // FIX: Show the welcome message after a brief delay to prevent a font race condition.
        // The 'await ensureHeadlineFontsLoaded()' call has been removed.
        setTimeout(() => {
            showOnCanvasFeedback(TXT.welcome);
        }, 100); // 100ms delay is enough for the browser to settle.

¬† ¬† ¬† ¬† sessionPoints = 0;
¬† ¬† ¬† ¬† updatePointsDisplay();
¬† ¬† ¬† ¬†¬†
¬† ¬† ¬† ¬† stagesWithPointsAwarded = new Set();

¬† ¬† ¬† ¬† document.title = lessonStagesRoot.lessonTitle || TXT[`titleDefault${currentLang.charAt(0).toUpperCase() + currentLang.slice(1)}`];
¬† ¬† ¬† ¬† console.log(`Lesson loaded: ${lessonStages.length} stages. Language: ${currentLang}`);

¬† ¬† ¬† ¬† currentStageIndex = -1;
¬† ¬† ¬† ¬† currentStageData = null;
¬† ¬† ¬† ¬† isStudentInputAllowed = false;
¬† ¬† ¬† ¬† if (currentReplayAnimationId) cancelAnimationFrame(currentReplayAnimationId);
¬† ¬† ¬† ¬† currentReplayAnimationId = null;
¬† ¬† ¬† ¬† if (currentStageAudio && !currentStageAudio.paused) {
¬† ¬† ¬† ¬† ¬† ¬† currentStageAudio.pause();
¬† ¬† ¬† ¬† ¬† ¬† currentStageAudio.onloadedmetadata = null;
¬† ¬† ¬† ¬† ¬† ¬† currentStageAudio.onended = null;
¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† currentStageAudio = null;
¬† ¬† ¬† ¬† isMediaScrubbingActive = false;
¬† ¬† ¬† ¬† if (stageProgressBarContainer) stageProgressBarContainer.classList.remove('visible');
¬† ¬† ¬† ¬† if (bgCtx) bgCtx.clearRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
¬† ¬† ¬† ¬† if (replayCtx) replayCtx.clearRect(0, 0, replayCanvas.width, replayCanvas.height);
¬† ¬† ¬† ¬† if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
¬† ¬† ¬† ¬†¬†
¬† ¬† ¬† ¬† thelobookPages = [];
¬† ¬† ¬† ¬† currentThelobookPageIndex = 0;
¬† ¬† ¬† ¬† updateThelobookPageControls();

¬† ¬† } catch (error) {
¬† ¬† ¬† ¬† console.error("Error loading lesson:", error);
¬† ¬† ¬† ¬† let TXT = getCurrentUIText();
¬† ¬† ¬† ¬† addChatMessage('AI', `${formatAIMessage('error')}: ${error.message}`);
¬† ¬† } finally {
¬† ¬† ¬† ¬† isLessonLoading = false;

¬† ¬† ¬† ¬† if (lessonStages && lessonStages.length > 0) {
¬† ¬† ¬† ¬† ¬† ¬† if (nextCheckBtn) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† nextCheckBtn.disabled = false;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† nextCheckBtn.textContent = getCurrentUIText().start;
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† } else {
¬† ¬† ¬† ¬† ¬† ¬† if (nextCheckBtn) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† nextCheckBtn.textContent = getCurrentUIText().error;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† nextCheckBtn.disabled = true;
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† if (!UI_TEXT[currentLang]) currentLang = 'hy';
¬† ¬† ¬† ¬† updateAllUITexts();

¬† ¬† ¬† ¬† if (loadingOverlay) {
¬† ¬† ¬† ¬† ¬† ¬† loadingOverlay.classList.add('hidden');
¬† ¬† ¬† ¬† ¬† ¬† setTimeout(() => {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if(loadingOverlay) loadingOverlay.style.display = 'none';
¬† ¬† ¬† ¬† ¬† ¬† }, 500);
¬† ¬† ¬† ¬† }
¬† ¬† }
}
function resizeCanvases() {
    clearTimeout(window.resizeTimeout);
    window.resizeTimeout = setTimeout(() => {
        checkMobileMode();
        checkTabletMode();
        if (!boardWrapper) return;

        // Save the current drawing before it gets erased by the resize.
        let userDrawingData = null;
        if (userDrawingOccurred && canvas.width > 0 && canvas.height > 0) {
            userDrawingData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        }

        const rect = boardWrapper.getBoundingClientRect();
        const cssWidth = Math.max(1, Math.floor(rect.width));
        const cssHeight = Math.max(1, Math.floor(rect.height));
        devicePixelRatio = window.devicePixelRatio || 1;
        const internalWidth = Math.floor(cssWidth * devicePixelRatio);
        const internalHeight = Math.floor(cssHeight * devicePixelRatio);

        // This loop erases the canvases when it sets the new width/height.
        [backgroundCanvas, replayCanvas, canvas, thelobookCanvas, feedbackCanvas].forEach(c => {
            if (c) {
                c.width = internalWidth;
                c.height = internalHeight;
                c.style.width = `${cssWidth}px`;
                c.style.height = `${cssHeight}px`;
            }
        });
        
        setupContexts();

        // Restore the saved drawing onto the newly resized canvas.
        if (userDrawingData) {
            ctx.putImageData(userDrawingData, 0, 0);
        }

        // Redraw the rest of the UI.
        if (currentStageIndex >= 0 && lessonStages.length > 0) renderStageUI(currentStageIndex, true);
        
        if (isThelobookActive) {
            setTimeout(() => {
                if (isThelobookActive) loadThelobookPageDrawing(currentThelobookPageIndex);
            }, 50);
        }
        
        if(isPageGridVisible) renderPageGridBatch(currentPageGridBatch, false);

        if (isMobileMode) {
            redrawMobileBoard();
        }

        setupContexts();
    }, 150);
}
	  function setupContexts() {
    if (!backgroundCanvas || !replayCanvas || !canvas || !thelobookCanvas) return;
    
    replayCtx = replayCanvas.getContext('2d'); 
    thelobookCtx = thelobookCanvas.getContext('2d');
    
    [bgCtx, replayCtx, ctx, thelobookCtx].forEach(context => {
        if (context) { 
            context.resetTransform(); 
            context.scale(devicePixelRatio, devicePixelRatio); 
        }
    });
    
    bgCtx.lineWidth = 2; 
    bgCtx.strokeStyle = '#333'; 
    bgCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--thelo-text').trim();
    
    const fontFamily = currentLang === 'en' ? "'Manrope', system-ui, sans-serif" : "'Montserrat Arm', system-ui, sans-serif";
    bgCtx.font = `20px ${fontFamily}`; 
    bgCtx.textAlign = 'center'; 
    bgCtx.textBaseline = 'top';
    
    if (replayCtx) { 
        replayCtx.lineCap = 'round'; 
        replayCtx.lineJoin = 'round'; 
    }
    
    ctx.lineWidth = THELOBOOK_PEN_LINEWIDTH; 
    ctx.lineCap = 'round'; 
    ctx.lineJoin = 'round'; 
    ctx.strokeStyle = INK_COLORS.blue; // Hardcoded to blue
    
    if (thelobookCtx) {
        thelobookCtx.lineCap = 'round'; 
        thelobookCtx.lineJoin = 'round';
    }

    if (feedbackCanvas) {
        feedbackCtx = feedbackCanvas.getContext('2d');
        if (feedbackCtx) {
            feedbackCtx.resetTransform();
            feedbackCtx.scale(devicePixelRatio, devicePixelRatio);
        }
    }
    
    updateColorIndicator();
}
    function calculateDrawingDuration(drawingData){
        if (!drawingData || !drawingData.strokes || drawingData.strokes.length === 0) return 0;
        let maxTime = 0;
        drawingData.strokes.forEach(stroke => {
            let strokeEndTimeVal = 0;
            if (stroke.endTime !== undefined) { strokeEndTimeVal = stroke.endTime; }
            else if (stroke.points && stroke.points.length > 0) {
                const lastPoint = stroke.points[stroke.points.length - 1];
                strokeEndTimeVal = (stroke.startTime || 0) + (lastPoint.timeOffset || 0);
            } else { strokeEndTimeVal = (stroke.startTime || 0); }
            if (strokeEndTimeVal > maxTime) maxTime = strokeEndTimeVal;
        });
        return maxTime / 1000;
    }
    function renderDrawingAtTime(targetTimeInSeconds, drawingData, targetCtx){
        if (!targetCtx) return;
        const canvasWidth = targetCtx.canvas.width / devicePixelRatio;
        const canvasHeight = targetCtx.canvas.height / devicePixelRatio;
        targetCtx.clearRect(0, 0, canvasWidth, canvasHeight);

        if (!drawingData || !drawingData.strokes) return;

        drawingData.strokes.forEach(stroke => {
            const strokeStartTime = (stroke.startTime || 0) / 1000;
            if (targetTimeInSeconds < strokeStartTime) return;

            targetCtx.lineWidth = stroke.lineWidth || 2;
            targetCtx.strokeStyle = stroke.color || 'black';
            targetCtx.fillStyle = stroke.color || 'black';
            targetCtx.lineCap = 'round'; targetCtx.lineJoin = 'round';

            const points = stroke.points || [];
            if (points.length === 0) return;
            targetCtx.beginPath();
            let movedToFirstPoint = false;

            for (let i = 0; i < points.length; i++) {
                const point = points[i];
                const pointTimeAbsolute = strokeStartTime + ((point.timeOffset || 0) / 1000);
                if (pointTimeAbsolute > targetTimeInSeconds) break;

                if (!movedToFirstPoint) {
                    targetCtx.moveTo(point.normX * canvasWidth, point.normY * canvasHeight);
                    movedToFirstPoint = true;
                } else {
                    targetCtx.lineTo(point.normX * canvasWidth, point.normY * canvasHeight);
                }
                if (points.length === 1) {
                    targetCtx.closePath(); targetCtx.beginPath();
                    targetCtx.arc(point.normX * canvasWidth, point.normY * canvasHeight, (stroke.lineWidth || 2) / 2, 0, Math.PI * 2);
                    targetCtx.fill();
                    break;
                }
            }
            if (movedToFirstPoint && points.length > 1) targetCtx.stroke();
        });
    }
    function updateMediaProgressBar(effectiveTime, totalDuration){
        if (!stageProgressBarContainer) return;
        if (isMediaScrubbingActive && totalDuration > 0) {
            if (!stageProgressBarContainer.classList.contains('visible')) {
                stageProgressBarContainer.classList.add('visible');
            }
            const progress = (effectiveTime / totalDuration) * 100;
            stageProgressFill.style.width = `${Math.min(100, Math.max(0, progress))}%`;
        } else {
            // Keep progress bar visible if not scrubbing but playback is at the end (handled by new snippet in renderStageUI)
        if (!(internalPlaybackTime >= currentStageTotalDuration - 0.05 && currentStageTotalDuration > 0)) {
            stageProgressBarContainer.classList.remove('visible');
            stageProgressFill.style.width = '0%';
        }
        }
    }
   // In your MAIN app's <script> tag
// In your MAIN app's <script> tag - REPLACE this function

// In your MAIN app's <script> tag - REPLACE this function

// In your MAIN app's <script> tag - REPLACE this function
function mediaPlaybackLoop(timestamp) {
    // Exit if playback is no longer supposed to be active
    if (!isMediaScrubbingActive) {
        if (currentReplayAnimationId) cancelAnimationFrame(currentReplayAnimationId);
        currentReplayAnimationId = null;
        return;
    }

    // --- HYBRID TIME CALCULATION (Unchanged) ---
    const audioIsPlaying = currentStageAudio && !currentStageAudio.paused && !currentStageAudio.ended;
    if (audioIsPlaying) {
        internalPlaybackTime = currentStageAudio.currentTime;
        lastFrameTimestampForManualAdvance = timestamp; 
    } else {
        if (lastFrameTimestampForManualAdvance === 0) {
            lastFrameTimestampForManualAdvance = timestamp;
        }
        const deltaTime = (timestamp - lastFrameTimestampForManualAdvance) / 1000.0;
        internalPlaybackTime += deltaTime;
        lastFrameTimestampForManualAdvance = timestamp;
    }
    
    // Ensure playback stops precisely at the end (Unchanged)
    if (internalPlaybackTime >= currentStageTotalDuration) {
        internalPlaybackTime = currentStageTotalDuration;
        isMediaScrubbingActive = false; 
    }

    // --- UNIVERSAL UPDATES (Now with throttling) ---

    // Update the drawing replay on the main canvas (cheap, runs every frame)
    if (currentStageDrawingData && replayCtx) {
        renderDrawingAtTime(internalPlaybackTime, currentStageDrawingData, replayCtx);
    }

    // ======================== THE FIX ========================
    // Only update the expensive iframe if enough time has passed.
    if (isReplayActive && replayFrame.contentWindow && (timestamp - lastIframeUpdateTime > IFRAME_UPDATE_INTERVAL)) {
        replayFrame.contentWindow.postMessage({
            command: 'renderAtTime',
            timeMs: internalPlaybackTime * 1000
        }, '*');
        // Update the timestamp of the last update
        lastIframeUpdateTime = timestamp;
    }
    // =========================================================
    
    // Update the progress bar (cheap, runs every frame for smoothness)
    updateMediaProgressBar(internalPlaybackTime, currentStageTotalDuration);

    // Continue the loop
    currentReplayAnimationId = requestAnimationFrame(mediaPlaybackLoop);
}
function playStrokesAbsoluteTiming(strokeData, targetCtx, onFinished){
        if (isMediaScrubbingActive) { if (typeof onFinished === 'function') onFinished(); return; }
        if (currentReplayAnimationId) { cancelAnimationFrame(currentReplayAnimationId); currentReplayAnimationId = null; }
        if (!targetCtx || !strokeData || !strokeData.strokes || strokeData.strokes.length === 0) { if (typeof onFinished === 'function') onFinished(); return; }
        const targetWidth = targetCtx.canvas.width / devicePixelRatio;
        const targetHeight = targetCtx.canvas.height / devicePixelRatio;
        targetCtx.clearRect(0, 0, targetWidth, targetHeight);
        let currentStrokeIndex = 0, currentPointIndex = 0, animationStartTime = null, strokeSetupDone = false;
        function animateStrokes(timestamp) {
            if (!animationStartTime) animationStartTime = timestamp;
            const elapsedOverallTime = timestamp - animationStartTime;
            if (currentStrokeIndex >= strokeData.strokes.length) { if (typeof onFinished === 'function') onFinished(); currentReplayAnimationId = null; return; }
            const stroke = strokeData.strokes[currentStrokeIndex]; const points = stroke.points || [];
            const scheduledStrokeStartTime = stroke.startTime || 0; const scheduledStrokeEndTime = stroke.endTime === undefined ? Infinity : stroke.endTime;
            if (elapsedOverallTime < scheduledStrokeStartTime) { currentReplayAnimationId = requestAnimationFrame(animateStrokes); return; }
            if (elapsedOverallTime >= scheduledStrokeEndTime && currentPointIndex >= points.length) { currentStrokeIndex++; currentPointIndex = 0; strokeSetupDone = false; currentReplayAnimationId = requestAnimationFrame(animateStrokes); return; }
            if (!strokeSetupDone) { targetCtx.lineWidth = stroke.lineWidth || 2; targetCtx.strokeStyle = stroke.color || 'black'; targetCtx.fillStyle = stroke.color || 'black'; targetCtx.lineCap = 'round'; targetCtx.lineJoin = 'round'; targetCtx.beginPath(); if (points.length > 0) { targetCtx.moveTo(points[0].normX * targetWidth, points[0].normY * targetHeight); } strokeSetupDone = true; }
            const timeElapsedInStroke = elapsedOverallTime - scheduledStrokeStartTime; let processedPointInFrame = false;
            while (currentPointIndex < points.length && timeElapsedInStroke >= points[currentPointIndex].timeOffset) {
                const pt = points[currentPointIndex];
                if (points.length === 1 && currentPointIndex === 0) { targetCtx.arc(pt.normX * targetWidth, pt.normY * targetHeight, (stroke.lineWidth || 2) / 2, 0, Math.PI * 2); targetCtx.fill(); }
                else if (currentPointIndex > 0) { targetCtx.lineTo(pt.normX * targetWidth, pt.normY * targetHeight); processedPointInFrame = true; }
                else if (currentPointIndex === 0 && points.length > 1) { targetCtx.moveTo(pt.normX * targetWidth, pt.normY * targetHeight); }
                currentPointIndex++;
            }
            if (processedPointInFrame) { targetCtx.stroke(); }
            currentReplayAnimationId = requestAnimationFrame(animateStrokes);
        }
        currentReplayAnimationId = requestAnimationFrame(animateStrokes);
    }

   
   function updateColorIndicator() {
¬† ¬† const TXT = getCurrentUIText();
¬† ¬† if (colorIndicator) {
¬† ¬† ¬† ¬† let showIndicator = false;
¬† ¬† ¬† ¬† if (isThelobookActive && !isPageGridVisible) {
¬† ¬† ¬† ¬† ¬† ¬† colorIndicator.textContent = isThelobookEraserActive ? TXT.thelobookEraser : TXT.thelobookInk;
¬† ¬† ¬† ¬† ¬† ¬† showIndicator = true;
¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† colorIndicator.style.display = showIndicator ? 'inline-flex' : 'none';
¬† ¬† }
}
    function getPos(e, targetCanvas) {
        if (!targetCanvas) return null;
        const rect = targetCanvas.getBoundingClientRect(); let clientX, clientY;
        if (e.touches && e.touches.length > 0) { clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; }
        else if (e.changedTouches && e.changedTouches.length > 0) { clientX = e.changedTouches[0].clientX; clientY = e.changedTouches[0].clientY; }
        else { clientX = e.clientX; clientY = e.clientY; }
        if (typeof clientX !== 'number' || typeof clientY !== 'number') return null;
        return { x: clientX - rect.left, y: clientY - rect.top };
    }
// THIS IS THE NEW, UPDATED FUNCTION
// THIS IS THE NEW, UPDATED FUNCTION
function handleDrawingStart(e) {
    if (isMobileMode) {
        handleMobileTouchStart(e);
        return;
    }

	
¬† ¬† if (isTabletMode && e.type.startsWith('touch')) {
¬† ¬† ¬† ¬† const isStylusPresent = Array.from(e.touches).some(t => t.touchType === 'stylus');
¬† ¬† ¬† ¬† if (!isStylusPresent) {
¬† ¬† ¬† ¬† ¬† ¬† e.preventDefault();
¬† ¬† ¬† ¬† ¬† ¬† return;
¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† // The UI-hiding logic has been REMOVED from here.
¬† ¬† }

¬† ¬† const currentTargetCanvas = e.currentTarget;
¬† ¬† const activeCtx = isThelobookActive ? thelobookCtx : ctx;
¬† ¬† if (!activeCtx) return;
¬† ¬† if (isThelobookActive && currentTargetCanvas !== thelobookCanvas) return;
¬† ¬† if (!isThelobookActive && currentTargetCanvas !== canvas) return;
¬† ¬† if (!isStudentInputAllowed && !isThelobookActive) return;

¬† ¬† const pos = getPos(e, currentTargetCanvas);
¬† ¬† if (!pos) return;
¬† ¬† if (e.touches) e.preventDefault();

¬† ¬† drawing = true;
	canvas.classList.add('no-cursor'); // <-- THIS LINE IS NOW UPDATED
¬† ¬† if (!isThelobookActive) userDrawingOccurred = true;

¬† ¬† if (isThelobookActive) {
¬† ¬† ¬† ¬† activeCtx.lineWidth = isThelobookEraserActive ? THELOBOOK_ERASER_LINEWIDTH : THELOBOOK_PEN_LINEWIDTH;
¬† ¬† ¬† ¬† activeCtx.globalCompositeOperation = isThelobookEraserActive ? 'destination-out' : 'source-over';
¬† ¬† } else {
¬† ¬† ¬† ¬† activeCtx.lineWidth = THELOBOOK_PEN_LINEWIDTH;
¬† ¬† ¬† ¬† activeCtx.globalCompositeOperation = 'source-over';
¬† ¬† }

¬† ¬† lastPos = pos;
¬† ¬† activeCtx.beginPath();
¬† ¬† activeCtx.moveTo(pos.x, pos.y);
}
	function handleDrawingMove(e) {
    if (isMobileMode) {
        handleMobileTouchMove(e);
        return;
    }

    if (!drawing) return;

    if (isTabletMode) {
        if (buttonVanishTimer) clearTimeout(buttonVanishTimer);
        if (bottomBar && !bottomBar.classList.contains('bar-hidden-by-stylus')) {
            bottomBar.classList.add('bar-hidden-by-stylus');
        }
    }

    const currentTargetCanvas = e.currentTarget;
    const activeCtx = isThelobookActive ? thelobookCtx : ctx;
    if (!activeCtx) return;

    const pos = getPos(e, currentTargetCanvas);
    if (!pos) return;
    if (e.touches) e.preventDefault();

    const midPoint = { x: (lastPos.x + pos.x) / 2, y: (lastPos.y + pos.y) / 2 };

    activeCtx.quadraticCurveTo(lastPos.x, lastPos.y, midPoint.x, midPoint.y);
    activeCtx.stroke();
    activeCtx.moveTo(midPoint.x, midPoint.y);
    
    // Also draw to the capture canvas for AI processing
    if (captureCtx) {
        captureCtx.quadraticCurveTo(lastPos.x, lastPos.y, midPoint.x, midPoint.y);
        captureCtx.stroke();
    }

    lastPos = pos;
}
function handleDrawingEnd(e) {
    if (isMobileMode) {
        handleMobileTouchEnd(e);
        return;
    }

	canvas.classList.remove('no-cursor');
    if (isTabletMode) {
        if (buttonVanishTimer) clearTimeout(buttonVanishTimer);
        buttonVanishTimer = setTimeout(() => {
            if (bottomBar) bottomBar.classList.remove('bar-hidden-by-stylus');
        }, 500);
    }

    if (!drawing) return;
    drawing = false;

    const activeCtx = isThelobookActive ? thelobookCtx : ctx;
    if (!activeCtx) return;

    activeCtx.lineTo(lastPos.x, lastPos.y);
    activeCtx.stroke();
    activeCtx.closePath();
}

/* ===== NEW: Mobile Interaction Logic ===== */
let lastTapTime = 0;
let lastTapPos = { x: 0, y: 0 };
let isMobilePanning = false;
let mobilePanStart = { x: 0, y: 0 };
let mobileCameraStart = { x: 0, y: 0 };

function handleMobileTouchStart(e) {
    const now = Date.now();
    if (e.touches.length === 1) {
        const touch = e.touches[0];
        const dist = Math.hypot(touch.clientX - lastTapPos.x, touch.clientY - lastTapPos.y);

        if (now - lastTapTime < 300 && dist < 50) {
            // Double tap detected
            toggleMobileMenu();
            e.preventDefault();
            lastTapTime = 0;
            return;
        }
        lastTapTime = now;
        lastTapPos = { x: touch.clientX, y: touch.clientY };

        // Start Drawing
        if (!isStudentInputAllowed) {
            // Enable scrubbing if media is present
            if (currentStageTotalDuration > 0) {
                isMobileScrubbing = true;
                mobileScrubStartX = e.touches[0].clientX;
                mobileScrubStartTime = internalPlaybackTime;
                
                isMediaScrubbingActive = false;
                if (currentReplayAnimationId) {
                    cancelAnimationFrame(currentReplayAnimationId);
                    currentReplayAnimationId = null;
                }
                if (currentStageAudio && !currentStageAudio.paused) {
                    currentStageAudio.pause();
                }
            }
            return;
        }
        drawing = true;
        const rect = canvas.getBoundingClientRect();
        const x = touch.clientX - rect.left;
        const y = touch.clientY - rect.top;
        
        // Adjust for camera offset to get virtual coordinates
        const virtualX = x - mobileCameraOffset.x;
        const virtualY = y - mobileCameraOffset.y;

        lastPos = { x, y }; // Screen coords for immediate drawing
        
        // Start a new stroke record
        mobileStrokes.push({
            color: '#2563eb',
            points: [{ x: virtualX, y: virtualY }]
        });

        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.strokeStyle = '#2563eb';
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

    } else if (e.touches.length === 2) {
        // Start Panning
        isMobilePanning = true;
        drawing = false;
        mobilePanStart = {
            x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
            y: (e.touches[0].clientY + e.touches[1].clientY) / 2
        };
        mobileCameraStart = { ...mobileCameraOffset };
        lastTapTime = 0;
    }
}

function handleMobileTouchMove(e) {
    if (isMobilePanning && e.touches.length === 2) {
        e.preventDefault();
        const currentX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
        const currentY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
        
        const deltaX = currentX - mobilePanStart.x;
        const deltaY = currentY - mobilePanStart.y;

        mobileCameraOffset.x = mobileCameraStart.x + deltaX;
        mobileCameraOffset.y = mobileCameraStart.y + deltaY;

        requestAnimationFrame(redrawMobileBoard);
    } else if (isMobileScrubbing && e.touches.length === 1) {
        e.preventDefault();
        const deltaX = e.touches[0].clientX - mobileScrubStartX;
        const screenWidth = window.innerWidth;
        let newTime = mobileScrubStartTime + (deltaX / screenWidth) * currentStageTotalDuration;
        newTime = Math.max(0, Math.min(newTime, currentStageTotalDuration));
        internalPlaybackTime = newTime;

        if (currentStageDrawingData && replayCtx) {
            renderDrawingAtTime(internalPlaybackTime, currentStageDrawingData, replayCtx);
        }
        updateMediaProgressBar(internalPlaybackTime, currentStageTotalDuration);

        if (isReplayActive && replayFrame && replayFrame.contentWindow) {
            replayFrame.contentWindow.postMessage({ command: 'seekToTime', timeMs: internalPlaybackTime * 1000 }, '*');
        }
    } else if (drawing && e.touches.length === 1) {
        e.preventDefault();
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        const x = touch.clientX - rect.left;
        const y = touch.clientY - rect.top;

        // Invalidate double-tap if drawing stroke exceeds threshold
        if (Math.hypot(touch.clientX - lastTapPos.x, touch.clientY - lastTapPos.y) > 10) {
            lastTapTime = 0;
        }

        // Draw visually (screen coords)
        ctx.lineTo(x, y);
        ctx.stroke();

        // Record virtual coords
        const virtualX = x - mobileCameraOffset.x;
        const virtualY = y - mobileCameraOffset.y;
        if (mobileStrokes.length > 0) {
            mobileStrokes[mobileStrokes.length - 1].points.push({ x: virtualX, y: virtualY });
        }
        
        // Also draw to capture canvas (shifted)
        // Note: captureCanvas is usually 1:1 with board. 
        // If we want AI to see the drawing, we might need to redraw everything there too.
        // For now, let's rely on the visual canvas being correct.
    }
}

function handleMobileTouchEnd(e) {
    if (isMobileScrubbing) {
        isMobileScrubbing = false;
        if (currentStageAudio) {
            currentStageAudio.currentTime = internalPlaybackTime;
            if (internalPlaybackTime < currentStageTotalDuration - 0.1) {
                currentStageAudio.play().catch(()=>{});
            }
        }
        isMediaScrubbingActive = true;
        lastFrameTimestampForManualAdvance = 0;
        if (!currentReplayAnimationId) currentReplayAnimationId = requestAnimationFrame(mediaPlaybackLoop);
        return;
    }
    drawing = false;
    isMobilePanning = false;
    ctx.closePath();
}

function redrawMobileBoard() {
    if (!isMobileMode) return;
    
    // Clear visible canvases
    bgCtx.clearRect(0, 0, backgroundCanvas.width / devicePixelRatio, backgroundCanvas.height / devicePixelRatio);
    ctx.clearRect(0, 0, canvas.width / devicePixelRatio, canvas.height / devicePixelRatio);

    // Draw static content (cached) with offset
    if (cachedStaticCanvas) {
        const cssWidth = backgroundCanvas.width / devicePixelRatio;
        const cssHeight = backgroundCanvas.height / devicePixelRatio;
        bgCtx.drawImage(cachedStaticCanvas, mobileCameraOffset.x, mobileCameraOffset.y, cssWidth, cssHeight);
    }

    // Draw user strokes with offset
    ctx.save();
    ctx.translate(mobileCameraOffset.x, mobileCameraOffset.y);
    mobileStrokes.forEach(stroke => {
        ctx.beginPath();
        ctx.strokeStyle = stroke.color;
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        if (stroke.points.length > 0) {
            ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
            for (let i = 1; i < stroke.points.length; i++) {
                ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
            }
        }
        ctx.stroke();
    });
    ctx.restore();
}

function toggleMobileMenu() {
    const isVisible = mobileMenu.classList.contains('visible');
    if (isVisible) {
        mobileMenu.classList.remove('visible');
        // Unblur
        if (boardWrapper) boardWrapper.style.filter = 'none';
    } else {
        mobileMenu.classList.add('visible');
        // Blur
        if (boardWrapper) boardWrapper.style.filter = 'blur(5px)';
    }
}

    // REPLACE your old drawing functions with these three new versions
function addBoardDrawListeners() {
        canvas.addEventListener('mousedown', handleDrawingStart);
        canvas.addEventListener('mousemove', handleDrawingMove);
        canvas.addEventListener('touchstart', handleDrawingStart, { passive: false });
        canvas.addEventListener('touchmove', handleDrawingMove, { passive: false });
        canvas.addEventListener('touchend', handleDrawingEnd);
        canvas.addEventListener('touchcancel', handleDrawingEnd);
    }
    function removeBoardDrawListeners() {
        canvas.removeEventListener('mousedown', handleDrawingStart);
        canvas.removeEventListener('mousemove', handleDrawingMove);
        canvas.removeEventListener('touchstart', handleDrawingStart);
        canvas.removeEventListener('touchmove', handleDrawingMove);
        canvas.removeEventListener('touchend', handleDrawingEnd);
        canvas.removeEventListener('touchcancel', handleDrawingEnd);
    }
    function addThelobookDrawListeners() {
        if (thelobookDrawListenersAttached) return;
        thelobookCanvas.addEventListener('mousedown', handleDrawingStart);
        thelobookCanvas.addEventListener('mousemove', handleDrawingMove);
        thelobookCanvas.addEventListener('touchstart', handleDrawingStart, { passive: false });
        thelobookCanvas.addEventListener('touchmove', handleDrawingMove, { passive: false });
        thelobookCanvas.addEventListener('touchend', handleDrawingEnd);
        thelobookCanvas.addEventListener('touchcancel', handleDrawingEnd);
        thelobookDrawListenersAttached = true;
    }
    function removeThelobookDrawListeners() {
        if (!thelobookDrawListenersAttached) return;
        thelobookCanvas.removeEventListener('mousedown', handleDrawingStart);
        thelobookCanvas.removeEventListener('mousemove', handleDrawingMove);
        thelobookCanvas.removeEventListener('touchstart', handleDrawingStart);
        thelobookCanvas.removeEventListener('touchmove', handleDrawingMove);
        thelobookCanvas.removeEventListener('touchend', handleDrawingEnd);
        thelobookCanvas.removeEventListener('touchcancel', handleDrawingEnd);
        thelobookDrawListenersAttached = false;
    }

    function wrapText(context, text, x, y, maxWidth, lineHeight){
        const words = text.split(' '); let line = ''; let currentY = y; let lines = [];
        for(let n = 0; n < words.length; n++) {
            const testLine = line + words[n] + ' '; const metrics = context.measureText(testLine);
            const testWidth = metrics.width; const wordWidth = context.measureText(words[n]).width;
            if (wordWidth > maxWidth && line.trim() !== '') { context.fillText(line.trim(), x, currentY); lines.push(line.trim()); line = ''; currentY += lineHeight; }
            if (wordWidth > maxWidth) { context.fillText(words[n], x, currentY); lines.push(words[n]); line = ' '; currentY += lineHeight; }
            else if (testWidth > maxWidth && line.trim() !== '') { context.fillText(line.trim(), x, currentY); lines.push(line.trim()); line = words[n] + ' '; currentY += lineHeight; }
            else { line = testLine; }
        }
        if (line.trim() !== '') { context.fillText(line.trim(), x, currentY); lines.push(line.trim());} return lines.length * lineHeight;
    }
    /**
 * A cache for the fetched KaTeX stylesheet to avoid re-fetching.
 */
/**
 * A cache for the fetched KaTeX stylesheet to avoid re-fetching.
 */
/**
 * A cache for the fetched KaTeX stylesheet to avoid re-fetching.
 */
/**
 * A cache for the fetched KaTeX stylesheet to avoid re-fetching.
 */
let katexCSSInlined = null;

function abToBase64(ab) {
  const CHUNK = 0x8000;
  const bytes = new Uint8Array(ab);
  let binary = '';
  for (let i = 0; i < bytes.length; i += CHUNK) {
    binary += String.fromCharCode(...bytes.subarray(i, i + CHUNK));
  }
  return btoa(binary);
}

async function getKatexCSSWithEmbeddedFonts() {
  if (katexCSSInlined) return katexCSSInlined;

  const base = 'https://cdn.jsdelivr.net/npm/katex@0.16.10/dist';
  let css = await (await fetch(`${base}/katex.min.css`)).text();

  // Minimal set that covers typical inline math + delimiters
  const fonts = [
    'KaTeX_Main-Regular.woff2',
    'KaTeX_Main-Italic.woff2',
    'KaTeX_Main-Bold.woff2',
    'KaTeX_Math-Italic.woff2',
    'KaTeX_AMS-Regular.woff2',
    'KaTeX_Size1-Regular.woff2',
    'KaTeX_Size2-Regular.woff2'
  ];

  for (const name of fonts) {
    const url = `${base}/fonts/${name}`;
    const res = await fetch(url);
    const b64 = abToBase64(await res.arrayBuffer());
    const dataURL = `url(data:font/woff2;base64,${b64}) format("woff2")`;
    css = css.replace(
      new RegExp(`url\\([^)]*${name}[^)]*\\)\\s*format\\("woff2"\\)`, 'g'),
      dataURL
    );
  }

  katexCSSInlined = css;
  return katexCSSInlined;
}
// Wait until the UI font used for headline text is available
// Updated: More robust font loading check
async function ensureHeadlineFontsLoaded() {
    try {
        const families = ['KaTeX_Main', 'KaTeX_Math', 'Manrope', 'Montserrat Arm'];
        const loaders = [];

        // 1. Force the document to acknowledge the fonts exist
        if (document.fonts && document.fonts.load) {
            // Load the UI font
            const uiFamily = (currentLang === 'en') ? 'Manrope' : 'Montserrat Arm';
            loaders.push(document.fonts.load(`20px "${uiFamily}"`));
            
            // Load common KaTeX fonts explicitly
            loaders.push(document.fonts.load('20px "KaTeX_Main"'));
            loaders.push(document.fonts.load('italic 20px "KaTeX_Math"'));
        }

        // 2. Wait for specific font loads + global ready state
        await Promise.all(loaders);
        await document.fonts.ready; 

        // 3. Safety delay: Allow the layout engine to recalculate after font swap
        await new Promise(res => setTimeout(res, 50)); 
    } catch (e) {
        console.warn("Font loading check warning:", e);
    }
}
// Updated: Robust Mixed text + KaTeX renderer
async function renderComplexHeadline(bgCtx, headline, y, opts = {}) {
  if (!headline || !bgCtx) return;

  // Ensure fonts are ready before we start measuring anything
  await ensureHeadlineFontsLoaded();

  // ---- config ----
  const widthFraction = Math.min(Math.max(opts.widthFraction ?? 0.88, 0.5), 0.98);
  const yNudge = opts.yNudge ?? -14;
  const fontSize = 20;
  const mathFontSize = 22;

  const fontColor =
    getComputedStyle(document.documentElement)
      .getPropertyValue('--thelo-text')
      .trim() || '#111827';

  // KaTeX CSS with embedded fonts
  const katexCSS = await getKatexCSSWithEmbeddedFonts();

  const extraRules = `
    .katex, .katex .mathnormal { font-family: "KaTeX_Main", serif !important; }
    .katex .mathit, .katex .textit { font-family: "KaTeX_MathItalic", serif !important; }
    .katex .mathsf, .katex .textsf { font-family: "KaTeX_SansSerif", sans-serif !important; }
    .katex .mathtt, .katex .texttt { font-family: "KaTeX_Typewriter", monospace !important; }
  `;

  // ---- parse headline ----
  const segments = (headline.split(/(\/K[\s\S]*?K\/)/g) || [])
    .filter(Boolean)
    .map(p =>
      p.startsWith('/K') && p.endsWith('K/')
        ? { type: 'math', content: p.replace(/^\/K\s*/, '').replace(/\s*K\/$/, '') }
        : { type: 'text', content: p }
    );

  // Create measure host
  const measureHost = document.createElement('div');
  measureHost.style.position = 'absolute';
  measureHost.style.visibility = 'hidden';
  measureHost.style.left = '-9999px';
  measureHost.style.top = '-9999px';
  // CRITICAL: Force the measure host to be wide enough
  measureHost.style.whiteSpace = 'nowrap'; 
  measureHost.style.width = 'max-content';
  document.body.appendChild(measureHost);

  const tokens = [];
  
  for (const seg of segments) {
    if (seg.type === 'text') {
      const parts = seg.content.match(/(\s+|[^\s]+)/g) || [];
      for (const p of parts) {
        tokens.push({
          type: 'text',
          content: p,
          width: bgCtx.measureText(p).width,
          height: fontSize,
          isSpace: /^\s+$/.test(p)
        });
      }
      continue;
    }

    // math segment
    try {
      const html = katex.renderToString(seg.content, { throwOnError: false, output: 'html' });

      // Clean host for this token
      while (measureHost.firstChild) measureHost.removeChild(measureHost.firstChild);

      const style = document.createElement('style');
      style.textContent = katexCSS;
      measureHost.appendChild(style);

      const tmp = document.createElement('div');
      tmp.style.color = fontColor;
      tmp.style.fontSize = `${mathFontSize}px`;
      tmp.style.display = 'inline-block'; // Ensure tight wrap
      tmp.innerHTML = html;
      measureHost.appendChild(tmp);

      const katexEl = tmp.querySelector('.katex') || tmp;
      const rect = katexEl.getBoundingClientRect();

      // CRITICAL FIX: Robust Padding
      // If font loads late, rect might be narrow. We add a base padding PLUS 
      // a percentage safety buffer.
		const basePad = 4;  // Reduced from 15 to 4
const safetyBuffer = 2; // Fixed small buffer instead of percentage
      const w = Math.ceil(rect.width) + basePad + safetyBuffer;
      const h = Math.ceil(rect.height) + basePad;

      // Generate SVG with the calculated safer dimensions
      const svg = `
        <svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}">
          <style>${katexCSS}\n${extraRules}</style>
          <foreignObject width="100%" height="100%">
            <div xmlns="http://www.w3.org/1999/xhtml"
                 style="color:${fontColor};font-size:${mathFontSize}px;line-height:initial;display:inline-block;white-space:nowrap;padding:2px;">
              ${html}
            </div>
          </foreignObject>
        </svg>`;

      const dataUrl = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svg)));
      const image = new Image();
      image.src = dataUrl;
      await image.decode(); // Wait for image to be paint-ready

      tokens.push({ type: 'math', image, width: w, height: h, drawW: w, drawH: h });
    } catch (e) {
      const w = bgCtx.measureText(seg.content).width;
      tokens.push({ type: 'text', content: seg.content, width: w, height: fontSize, isSpace: false });
    }
  }

  measureHost.remove();

  // ---- build lines ----
  const canvasW = bgCtx.canvas.width / (window.devicePixelRatio || 1);
  const maxWidth = canvasW * widthFraction;
  
  // FIX: Enforce a standard line height (1.5x font size is a good standard)
  const fixedLineHeight = fontSize * 1.5;

  const lines = [];
  // Initialize line with the fixed height immediately
  let line = { tokens: [], width: 0, height: fixedLineHeight }; 

  for (const t of tokens) {
    let width = t.width, height = t.height, drawW = t.drawW ?? t.width, drawH = t.drawH ?? t.height;

    if (t.type === 'math' && width > maxWidth) {
      const s = maxWidth / width;
      width = Math.floor(width * s);
      height = Math.floor(height * s);
      drawW = t.drawW * s;
      drawH = t.drawH * s;
    }
    const tok = { ...t, width, height, drawW, drawH };

    if (line.tokens.length && line.width + width > maxWidth) {
      lines.push(line);
      // Reset new line to fixed height
      line = { tokens: [], width: 0, height: fixedLineHeight };
    }
    
    if (!(line.tokens.length === 0 && tok.isSpace)) {
      line.tokens.push(tok);
      line.width += width;
      // FIX: Removed the logic that expanded line.height based on content
    }
  }
  if (line.tokens.length) lines.push(line);

  // ---- render ----
  const prevAlign = bgCtx.textAlign;
  const prevBase = bgCtx.textBaseline;
  const prevFill = bgCtx.fillStyle;

  bgCtx.fillStyle = fontColor;
  bgCtx.textAlign = 'left';
  bgCtx.textBaseline = 'top';

  let curY = y + yNudge;
  for (const L of lines) {
    let x = (canvasW - L.width) / 2;
    for (const t of L.tokens) {
      // FIX: Center items based on the fixed line height
      const topY = curY + (fixedLineHeight - t.height) / 2;
      
      if (t.type === 'text') {
        bgCtx.fillText(t.content, x, topY);
      } else {
        bgCtx.drawImage(t.image, x, topY, t.drawW, t.drawH);
      }
      x += t.width;
    }
    // FIX: Advance Y by fixed height only (removed lineGap as it is built into the 1.5 multiplier)
    curY += fixedLineHeight; 
  }

  bgCtx.textAlign = prevAlign || 'center';
  bgCtx.textBaseline = prevBase || 'top';
  bgCtx.fillStyle = prevFill || fontColor;
}

	  function stopCurrentStageAudio(){ if (currentStageAudio && !currentStageAudio.paused) { currentStageAudio.pause(); console.log("Current stage audio paused.");} }

    function playStageAudio(
    audioSrc,
    onLoadedMetadataCallback,
    onEndedCallback,
    isResuming = false
    ) {
    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ early-out if a modal overlay is open ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    if (isThelobookActive || isPageGridVisible || isCalculatorActive) {
    if (onLoadedMetadataCallback) onLoadedMetadataCallback(0);
    if (onEndedCallback) onEndedCallback();
    return;
    }

    currentStageAudio = stageAudioPlayer; // make sure we‚Äôre pointing at the right element

    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ RESUME PATH ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        Only run this branch if we‚Äôre *resuming* and the element
        already has the same source.  We now compare the canonical
        absolute URLs instead of using `.includes()`. */
    if (
    isResuming &&
    currentStageAudio &&
    currentStageAudio.src &&
    new URL(currentStageAudio.src, document.baseURI).href ===
        new URL(audioSrc, document.baseURI).href
    ) {
    const audioEffectivelyAtEnd =
        currentStageAudio.duration > 0 &&
        audioTimeBeforeThelobook >= currentStageAudio.duration - 0.05;

    if (wasMediaPlayingBeforeThelobook && !audioEffectivelyAtEnd) {
        if (window.userInteracted && currentStageAudio.paused) {
        currentStageAudio
            .play()
            .catch((e) => console.warn("Resume audio play failed:", e));
        }
    }

    // wire callbacks (or call immediately if metadata already available)
    if (onLoadedMetadataCallback) {
        if (
        currentStageAudio.readyState >= HTMLMediaElement.HAVE_METADATA
        ) {
        onLoadedMetadataCallback(currentStageAudio.duration);
        } else {
        const tempMetaListener = () => {
            onLoadedMetadataCallback(currentStageAudio.duration);
            currentStageAudio.removeEventListener(
            "loadedmetadata",
            tempMetaListener
            );
        };
        currentStageAudio.addEventListener(
            "loadedmetadata",
            tempMetaListener
        );
        }
    }
    if (onEndedCallback) currentStageAudio.onended = onEndedCallback;
    return; // ‚Üê nothing else to do
    }

    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FULL (re-)INITIALISATION PATH ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    if (currentStageAudio && !currentStageAudio.paused) {
    currentStageAudio.pause();
    }
    if (currentStageAudio) {
    currentStageAudio.onloadedmetadata = null;
    currentStageAudio.onended = null;
    }

    if (!audioSrc) {
    if (onLoadedMetadataCallback) onLoadedMetadataCallback(0);
    if (onEndedCallback) onEndedCallback();
    return;
    }

    currentStageAudio.src = audioSrc;
    currentStageAudio.preload = "auto";

    let loadedMetaCalled = false;
    currentStageAudio.onloadedmetadata = () => {
    if (!loadedMetaCalled && onLoadedMetadataCallback) {
        loadedMetaCalled = true;
        onLoadedMetadataCallback(currentStageAudio.duration);
    }
    };
    if (onEndedCallback) currentStageAudio.onended = onEndedCallback;

    currentStageAudio.load();
    if (window.userInteracted) {
    const playPromise = currentStageAudio.play();
    if (playPromise) {
        playPromise.catch((error) => {
        console.warn("Audio play failed (full init):", error);
        if (onEndedCallback) onEndedCallback();
        });
    }
    } else {
    console.warn("Audio interaction needed for autoplay.");
    }
    }
// Render mixed text + /K ... K/ math into a target element (e.g., a button)
function renderMixedKaTeXInto(targetEl, src) {
  // Clear current content
  while (targetEl.firstChild) targetEl.removeChild(targetEl.firstChild);

  if (!src) return;

  const parts = src.split(/(\/K[\s\S]*?K\/)/g).filter(Boolean);

  for (const part of parts) {
    const isMath = part.startsWith('/K') && part.endsWith('K/');
    if (!isMath) {
      targetEl.appendChild(document.createTextNode(part));
      continue;
    }

    const expr = part.replace(/^\/K\s*/, '').replace(/\s*K\/$/, '');
    const span = document.createElement('span');

    try {
      // Render KaTeX directly into the span (no innerHTML injection)
      katex.render(expr, span, { throwOnError: false });

    } catch (e) {
      // Graceful fallback
      span.textContent = expr;
    }
    targetEl.appendChild(span);
  }
}

function displayMcq(mcqDetails){
    const choices = mcqDetails.choices;
    if (!mcqOptionsContainer || !mcqDetails || !Array.isArray(choices) || choices.length === 0) return;
    if (isPageGridVisible) closePageGridView();

    mcqOptionsContainer.innerHTML = '';
    document.body.classList.add('mcq-active'); // Activate keyboard-only CSS

    /* ===== Smart‚Äëlayout Logic (Unchanged) ===== */
    const isShort = choices.every(choice => choice.length < 10);
    mcqOptionsContainer.className = isShort ? 'short-options' : 'long-options';
    const isSideBySide = !!(currentStageData && currentStageData.image);
    mcqOptionsContainer.classList.toggle('side-by-side', isSideBySide);
    
    choices.forEach((optionText, index) => {
        const optionButton = document.createElement('button');
        optionButton.classList.add('mcq-option-btn');
        renderMixedKaTeXInto(optionButton, optionText);
        optionButton.dataset.index = index;
        // NO click listener
        mcqOptionsContainer.appendChild(optionButton);
    });

    mcqOptionsContainer.style.display = 'flex';
    mcqOptionsContainer.style.opacity = '1';

    // Set the initial selection to the first option
    updateMcqSelectionVisuals(0); 
}
/**
 * Updates the visual state of MCQ buttons based on the selected index.
 * @param {number} newIndex - The index of the MCQ option to select.
 */
function updateMcqSelectionVisuals(newIndex) {
    if (!mcqOptionsContainer) return;
    selectedMcqIndex = newIndex; // Update the global state

    const optionButtons = mcqOptionsContainer.querySelectorAll('.mcq-option-btn');
    optionButtons.forEach((btn, index) => {
        btn.classList.toggle('selected', index === newIndex);
    });
}  // Replace your old function with this simplified version
function handleMcqOptionClick(selectedIndex, mcqDetails){
    return; // Clicks are disabled
}/**
 * Toggles a distraction-free fullscreen mode that hides the browser's
 * default 'X' button on interaction.
 */
function toggleFocusFullscreen() {
    // Check if we are currently in any fullscreen mode
    if (!document.fullscreenElement) {
        // If not, request fullscreen for the whole page
        document.documentElement.requestFullscreen({
            navigationUI: 'hide' // This is the magic property!
        }).catch(err => {
            // Log any errors if the request fails
            console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
        });
    } else {
        // If we are in fullscreen, exit it
        if (document.exitFullscreen) {
            document.exitFullscreen();
        }
    }
}
	// REPLACE your entire renderStageUI function with this one
/**
 * Draws the stage image onto the background canvas with the correct layout,
 * positioning it to the side if MCQs are present, otherwise centering it.
 * @param {CanvasRenderingContext2D} bgCtx - The context of the background canvas.
 * @param {HTMLImageElement} img - The image to draw.
 * @param {object} currentStageData - The data for the current stage.
 */
function drawImageWithCorrectLayout(bgCtx, img, currentStageData) {
    const canvasWidth = bgCtx.canvas.width / devicePixelRatio;
    const canvasHeight = bgCtx.canvas.height / devicePixelRatio;
    
    // Determine if the stage also has an MCQ to display.
    const hasMcq = currentStageData.optionsQuiz && Array.isArray(currentStageData.optionsQuiz.choices);

    if (hasMcq) {
        // --- Side-by-Side Layout Logic ---
        const sidePad = canvasWidth * 0.04;      // 4% gutter
        const maxImgWidth = canvasWidth * 0.48;   // ~50% of board
        const maxImgHeight = canvasHeight * 0.85; // Leave vertical room
        const scale = Math.min(maxImgWidth / img.width, maxImgHeight / img.height);
        
        const scaledWidth = img.width * scale;
        const scaledHeight = img.height * scale;
        const x = sidePad; // Position on the left
        const y = (canvasHeight - scaledHeight) / 2; // Vertically centered
        bgCtx.drawImage(img, x, y, scaledWidth, scaledHeight);

    } else {
        // --- Default Centered Layout Logic ---
        const maxSizePercentage = 0.50;
        const maxContainerWidth = canvasWidth * maxSizePercentage;
        const maxContainerHeight = canvasHeight * maxSizePercentage;
        const scale = Math.min(maxContainerWidth / img.width, maxContainerHeight / img.height);
        
        const scaledWidth = img.width * scale;
        const scaledHeight = img.height * scale;
        const x = (canvasWidth - scaledWidth) / 2; // Horizontally centered
        const y = (canvasHeight - scaledHeight) / 2; // Vertically centered
        bgCtx.drawImage(img, x, y, scaledWidth, scaledHeight);
    }
}
/**
 * Opens the replay player, fetches the replay data, and sends it to the iframe.
 */
// In your MAIN app's <script> tag

function openReplayPlayer() {
    // Basic validation
    if (isReplayActive || !currentStageData || !currentStageData.replayDataUrl) {
        return;
    }
    isReplayActive = true;

    // Direct embed of the website URL
    const url = currentStageData.replayDataUrl;
    console.log("Embedding website:", url);
    
    // 1. Assign the source
    replayFrame.src = url;
    
    // 2. NEW: Automatically force focus to the iframe once it loads
    // This makes the iframe's internal keyboard shortcuts work immediately 
    // without requiring a click.
    replayFrame.onload = function() {
        // Short delay to ensure the browser is ready to accept the focus switch
        setTimeout(() => {
            if (replayFrame.contentWindow) {
                replayFrame.contentWindow.focus();
            }
        }, 100);
    };

    replayPlayerContainer.classList.remove('replay-hidden');

    // Disable the internal media scrubbing loop since we are handing control to the iframe
    isMediaScrubbingActive = false; 
    if (currentReplayAnimationId) {
        cancelAnimationFrame(currentReplayAnimationId);
        currentReplayAnimationId = null;
    }
}
	  function closeReplayPlayer() {
    if (!isReplayActive) return;
    isReplayActive = false;

    // CRITICAL: Stop the main app's animation loop
    if (currentReplayAnimationId) {
        cancelAnimationFrame(currentReplayAnimationId);
        currentReplayAnimationId = null;
    }
    isMediaScrubbingActive = false;

    replayPlayerContainer.classList.add('replay-hidden');
    replayFrame.src = 'about:blank';
}
// In your main HTML file, REPLACE your entire renderStageUI function with this one.
function renderStageUI(index, isResize = false) {
    return new Promise(async (resolve, reject) => {
        // 1. Basic Validation
        if (isLessonLoading || index < 0 || index >= lessonStages.length) {
            if (index < 0) {
                if (nextCheckBtn) { nextCheckBtn.disabled = true; nextCheckBtn.textContent = getCurrentUIText().start; }
                if (prevBtn) prevBtn.disabled = true;
                if (clearBtn && clearBtn.style) clearBtn.style.display = 'none';
                if (colorIndicator && colorIndicator.style) colorIndicator.style.display = 'none';
                if (mcqOptionsContainer && mcqOptionsContainer.style) mcqOptionsContainer.style.display = 'none';
            }
            return resolve();
        }

        const TXT = getCurrentUIText();
        
        // 2. Immediate Cleanup
        if (!isResize && isThelobookActive) closeThelobook(true);
        if (!isResize && isPageGridVisible) closePageGridView();
        if (!isResize) closeReplayPlayer();

        if (!isResize) {
            if (currentReplayAnimationId) { cancelAnimationFrame(currentReplayAnimationId); currentReplayAnimationId = null; }
            if (currentStageAudio && !currentStageAudio.paused) { currentStageAudio.pause(); currentStageAudio.currentTime = 0; currentStageAudio.onloadedmetadata = null; currentStageAudio.onended = null; }
            isMediaScrubbingActive = false; currentStageDrawingData = null; currentStageTotalDuration = 0; internalPlaybackTime = 0; lastFrameTimestampForManualAdvance = 0;
            if (stageProgressBarContainer) stageProgressBarContainer.classList.remove('visible');
            if (stageProgressFill) stageProgressFill.style.width = '0%';
        }

        currentStageData = lessonStages[index];
        currentStageIndex = index;
        isStudentInputAllowed = currentStageData.studentInput === true;

        if (mcqOptionsContainer) { mcqOptionsContainer.innerHTML = ''; mcqOptionsContainer.style.display = 'none'; }
        if (bgCtx) bgCtx.clearRect(0, 0, backgroundCanvas.width / devicePixelRatio, backgroundCanvas.height / devicePixelRatio);
        
        if (!isResize) {
            clearUserCanvas();
            if (replayCtx) replayCtx.clearRect(0, 0, replayCanvas.width / devicePixelRatio, replayCanvas.height / devicePixelRatio);
            mobileStrokes = []; // Clear mobile strokes on new stage
        }

        // --- Helper: Draw Headline (FIXED) ---
        // --- Helper: Draw Headline (FIXED WITH WARM-UP) ---
        // --- Helper: Draw Headline (FIXED WITH GHOST RENDER) ---
        async function drawHeadlineText() {
            const padding = isMobileMode ? 10 : 27;
            let headlineCurrentY = padding * 2;
            const headlineText = currentStageData.headline || '';

            if (headlineText && bgCtx) {
                const fontFamily = currentLang === 'en' ? "'Manrope', system-ui, sans-serif" : "'Montserrat Arm', system-ui, sans-serif";
                
                // 1. Re-apply the font setting
                bgCtx.font = `20px ${fontFamily}`;
                
                // 2. Wait for UI fonts
                if (document.fonts && document.fonts.load) {
                    try { await document.fonts.load(`20px ${fontFamily}`, headlineText); } 
                    catch (e) { console.warn("Font load wait skipped", e); }
                }

                // 3. Ensure global fonts (KaTeX) are ready
                await ensureHeadlineFontsLoaded();

                // === THE FIX: GHOST RENDER STRATEGY ===
                // If the headline contains Math (/K), we render it INVISIBLY first.
                // This forces the DOM element created inside renderComplexHeadline 
                // to calculate its true width with the KaTeX CSS applied.
                const hasMath = headlineText.includes('/K');

                if (hasMath) {
                    // Pass 1: Invisible "Ghost" Render to prime the layout engine
                    bgCtx.save();
                    bgCtx.globalAlpha = 0; // Invisible
                    await renderComplexHeadline(bgCtx, headlineText, headlineCurrentY + 10);
                    bgCtx.restore();

                    // Wait 50ms to let the browser apply CSS to the invisible elements we just measured
                    await new Promise(resolve => setTimeout(resolve, 50));
                } else {
                    // Small delay for standard text to ensure crispness
                    await new Promise(r => requestAnimationFrame(r));
                }

                // Pass 2: Final Visible Render
                // Now the metrics will be correct because the font cache is hot
                await renderComplexHeadline(bgCtx, headlineText, headlineCurrentY + 10);
            }
        }
        // --- Helper: Draw Image ---
        function drawImageWithCorrectLayout(bgCtx, img, currentStageData) {
            const canvasWidth = bgCtx.canvas.width / devicePixelRatio;
            const canvasHeight = bgCtx.canvas.height / devicePixelRatio;
            const hasMcq = currentStageData.optionsQuiz && Array.isArray(currentStageData.optionsQuiz.choices);

            if (hasMcq) {
                const sidePad = canvasWidth * 0.04;
                const maxImgWidth = canvasWidth * 0.48;
                const maxImgHeight = canvasHeight * 0.85;
                const scale = Math.min(maxImgWidth / img.width, maxImgHeight / img.height);
                bgCtx.drawImage(img, sidePad, (canvasHeight - (img.height * scale)) / 2, img.width * scale, img.height * scale);
            } else {
                const maxSizePercentage = 0.50;
                const maxContainerWidth = canvasWidth * maxSizePercentage;
                const maxContainerHeight = canvasHeight * maxSizePercentage;
                const scale = Math.min(maxContainerWidth / img.width, maxContainerHeight / img.height);
                bgCtx.drawImage(img, (canvasWidth - (img.width * scale)) / 2, (canvasHeight - (img.height * scale)) / 2, img.width * scale, img.height * scale);
            }
        }

        function forceSyncCanvasSize() {
            if (!boardWrapper) return;
            const rect = boardWrapper.getBoundingClientRect();
            const cssWidth = Math.max(1, Math.floor(rect.width));
            const cssHeight = Math.max(1, Math.floor(rect.height));
            
            if (Math.abs(backgroundCanvas.width - cssWidth * devicePixelRatio) > 2 || 
                Math.abs(backgroundCanvas.height - cssHeight * devicePixelRatio) > 2) {
                
                [backgroundCanvas, replayCanvas, canvas].forEach(c => {
                    if (c) {
                        c.width = Math.floor(cssWidth * devicePixelRatio);
                        c.height = Math.floor(cssHeight * devicePixelRatio);
                        c.style.width = `${cssWidth}px`;
                        c.style.height = `${cssHeight}px`;
                    }
                });
                setupContexts();
            }
        }

        function setupStageContent() {
            const mcqDetails = currentStageData.optionsQuiz;
            const isMCQDisplayStage = currentStageData.type === "explanation_with_mcq" && mcqDetails && Array.isArray(mcqDetails.choices) && mcqDetails.choices.length > 0;
            const isQuestionStage = currentStageData.type === 'question_handwriting' || currentStageData.type === 'question_math_solution' || isMCQDisplayStage;

            if (!isMCQDisplayStage && nextCheckBtn) {
                nextCheckBtn.style.display = 'inline-flex';
            }

            if (currentStageData.type === 'calculator_replay') {
                openReplayPlayer();
                if (!isResize) { internalPlaybackTime = 0; lastFrameTimestampForManualAdvance = 0; isMediaScrubbingActive = false; }
                
                const audioMetaPromise = new Promise((resolveAudio) => {
                    if (currentStageData.audioFile) {
                        playStageAudio(currentStageData.audioFile, (duration) => resolveAudio(duration || 0), () => { }, isResize);
                    } else { resolveAudio(0); }
                });

                audioMetaPromise.then((audioDuration) => {
                    currentStageTotalDuration = audioDuration;
                    if (currentStageTotalDuration > 0) {
                        isMediaScrubbingActive = true;
                        updateMediaProgressBar(internalPlaybackTime, currentStageTotalDuration);
                        if (stageProgressBarContainer) stageProgressBarContainer.classList.add('visible');
                        if (!currentReplayAnimationId) currentReplayAnimationId = requestAnimationFrame(mediaPlaybackLoop);
                    } else {
                        if (stageProgressBarContainer) stageProgressBarContainer.classList.remove('visible');
                    }
                }).catch(e => console.error("Error setting up embed stage:", e));

                if (nextCheckBtn) { nextCheckBtn.textContent = TXT.gotIt; nextCheckBtn.disabled = false; }
                if (clearBtn) clearBtn.style.display = 'none';

            } else if (isQuestionStage) {
                if (!isResize) isMediaScrubbingActive = false;
                if (stageProgressBarContainer) stageProgressBarContainer.classList.remove('visible');
                
                if (isMCQDisplayStage && mcqDetails) {
                    if (bottomBar) bottomBar.style.display = 'flex';
                    displayMcq(mcqDetails);
                    if (clearBtn) clearBtn.style.display = 'none';
                    if (nextCheckBtn) { nextCheckBtn.style.display = 'inline-flex'; nextCheckBtn.disabled = false; nextCheckBtn.textContent = TXT.check; }
                } else if (currentStageData.type === 'question_handwriting' || currentStageData.type === 'question_math_solution') {
                    if (bottomBar) bottomBar.style.display = 'flex';
                    if (nextCheckBtn) { nextCheckBtn.textContent = TXT.check; nextCheckBtn.disabled = false; }
                    if (clearBtn) clearBtn.style.display = 'inline-flex';
                }
                if (currentStageData.audioFile) { playStageAudio(currentStageData.audioFile, (d) => { }, () => { }, isResize); }
            } else {
                if (bottomBar) bottomBar.style.display = 'flex';
                if (mcqOptionsContainer) mcqOptionsContainer.style.display = 'none';
                const isDrawingInputStage = currentStageData.studentInput === true;
                if (clearBtn) clearBtn.style.display = isDrawingInputStage ? 'inline-flex' : 'none';
                
                if (currentStageData.audioFile || currentStageData.drawingRecord) {
                    if (!isResize) { isMediaScrubbingActive = true; lastFrameTimestampForManualAdvance = 0; internalPlaybackTime = 0; }
                    updateMediaProgressBar(internalPlaybackTime, currentStageTotalDuration > 0 ? currentStageTotalDuration : 1);
                    const audioMetaPromise = new Promise((resolveAudio) => {
                        if (currentStageData.audioFile) { playStageAudio(currentStageData.audioFile, (duration) => resolveAudio(duration || 0), () => { }, isResize); }
                        else { resolveAudio(0); }
                    });
                    
                    let drawingDataPromise;
                    if (currentStageData.drawingRecord) {
                        if (!isResize || !currentStageDrawingData) {
                            drawingDataPromise = fetch(currentStageData.drawingRecord).then(r => r.ok ? r.json() : Promise.reject(`HTTP ${r.status}`)).then(json => { if (!json || !json.strokes) throw "Bad drawing JSON"; currentStageDrawingData = json; return json; }).catch(e => { console.error("Failed to load drawing data:", e); currentStageDrawingData = null; return null; });
                        } else { drawingDataPromise = Promise.resolve(currentStageDrawingData); }
                    } else { currentStageDrawingData = null; drawingDataPromise = Promise.resolve(null); }
                    
                    Promise.all([audioMetaPromise, drawingDataPromise]).then(([audioDuration, loadedDrawingData]) => {
                        if (loadedDrawingData) currentStageDrawingData = loadedDrawingData;
                        const drawingAnimDuration = currentStageDrawingData ? calculateDrawingDuration(currentStageDrawingData) : 0;
                        currentStageTotalDuration = Math.max(audioDuration, drawingAnimDuration);
                        if (isMediaScrubbingActive && currentStageTotalDuration > 0) {
                            updateMediaProgressBar(internalPlaybackTime, currentStageTotalDuration);
                            if (stageProgressBarContainer) stageProgressBarContainer.classList.add('visible');
                            if (currentReplayAnimationId) cancelAnimationFrame(currentReplayAnimationId);
                            currentReplayAnimationId = requestAnimationFrame(mediaPlaybackLoop);
                        }
                    });
                } else {
                    isMediaScrubbingActive = false; if (stageProgressBarContainer) stageProgressBarContainer.classList.remove('visible');
                    currentStageAudio = null; currentStageDrawingData = null; currentStageTotalDuration = 0;
                    if (replayCtx) replayCtx.clearRect(0, 0, replayCanvas.width / devicePixelRatio, replayCanvas.height / devicePixelRatio);
                }
                if (nextCheckBtn) { nextCheckBtn.textContent = TXT.gotIt; nextCheckBtn.disabled = false; }
            }
            updateColorIndicator();
            canvas.style.pointerEvents = (isMobileMode || (isStudentInputAllowed && !isThelobookActive && !isPageGridVisible && !isReplayActive)) ? 'auto' : 'none';
            if (nextCheckBtn) { nextCheckBtn.classList.remove('correct', 'incorrect'); nextCheckBtn.style.backgroundColor = ''; }
            if (!isResize) userDrawingOccurred = false;
            if (prevBtn) prevBtn.disabled = (index === 0 || isThelobookActive || isPageGridVisible || isReplayActive);
            if (nextCheckBtn) {
                const isCorrectlyAnsweredHW = currentStageData.type === 'question_handwriting' && nextCheckBtn.classList.contains('correct');
                if (!isMCQDisplayStage) {
                    nextCheckBtn.disabled = (isThelobookActive || isPageGridVisible || isCorrectlyAnsweredHW || isReplayActive && !currentStageData.audioFile);
                }
            }
            if (clearBtn) clearBtn.disabled = (isThelobookActive || isPageGridVisible || isReplayActive);
        }

        // --- MAIN RENDERING LOGIC ---
        // Double RAF + special pre-warm for math question stages
        requestAnimationFrame(() => {
            requestAnimationFrame(async () => {
                forceSyncCanvasSize();

                if (currentStageData.image && bgCtx) {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.src = currentStageData.image;
                    
                    img.onload = async () => {
                        forceSyncCanvasSize(); 
                        drawImageWithCorrectLayout(bgCtx, img, currentStageData);
                        await drawHeadlineText();
                        
                        // Cache static content for mobile panning
                        if (isMobileMode) {
                            cachedStaticCanvas = document.createElement('canvas');
                            cachedStaticCanvas.width = backgroundCanvas.width;
                            cachedStaticCanvas.height = backgroundCanvas.height;
                            const cCtx = cachedStaticCanvas.getContext('2d');
                            cCtx.drawImage(backgroundCanvas, 0, 0);
                        }

                        setupStageContent();
                        resolve();
                    };
                    img.onerror = async () => {
                        console.error("Failed to load stage image:", currentStageData.image);
                        await drawHeadlineText();
                        setupStageContent();
                        
                        if (isMobileMode) {
                             // Cache even if image fails (headline only)
                             cachedStaticCanvas = document.createElement('canvas');
                             cachedStaticCanvas.width = backgroundCanvas.width;
                             cachedStaticCanvas.height = backgroundCanvas.height;
                             const cCtx = cachedStaticCanvas.getContext('2d');
                             cCtx.drawImage(backgroundCanvas, 0, 0);
                        }
                        resolve();
                    };
                } else {
                    await drawHeadlineText();
                    // No caching needed here if no image? Or yes for headline.
                    if (isMobileMode) {
                         cachedStaticCanvas = document.createElement('canvas');
                         cachedStaticCanvas.width = backgroundCanvas.width;
                         cachedStaticCanvas.height = backgroundCanvas.height;
                         const cCtx = cachedStaticCanvas.getContext('2d');
                         cCtx.drawImage(backgroundCanvas, 0, 0);
                    }
                    setupStageContent();
                    resolve();
                }
            });
        });
    });
}
	  function transitionToStage(newIndex) {
    if (isTransitioning || isLessonLoading || !lessonStages.length) return;
    
    isMcqAnsweredCorrectly = false;
    // All feedback is now hidden either by the 'A' key or by advancing a stage.
    mobileCameraOffset = { x: 0, y: 0 }; // Reset camera
    hideOnCanvasFeedback();

    selectedMcqIndex = null;
    if (isReplayActive) closeReplayPlayer();
    if (isThelobookActive) closeThelobook(true);
    if (isPageGridVisible) closePageGridView();

    if (currentReplayAnimationId) { cancelAnimationFrame(currentReplayAnimationId); currentReplayAnimationId = null; }
    if (currentStageAudio && !currentStageAudio.paused) { currentStageAudio.pause(); currentStageAudio.onloadedmetadata = null; currentStageAudio.onended = null; }
    isMediaScrubbingActive = false; currentStageDrawingData = null; currentStageTotalDuration = 0; internalPlaybackTime = 0; lastFrameTimestampForManualAdvance = 0;
    if (stageProgressBarContainer) stageProgressBarContainer.classList.remove('visible');
    if (stageProgressFill) stageProgressFill.style.width = '0%';

    if (newIndex < 0 || newIndex >= lessonStages.length) {
        if (newIndex >= lessonStages.length) {
            displayLessonComplete();
        }
        return;
    }
    isTransitioning = true;
    backgroundCanvas.classList.add('fade-out');
    if (replayCanvas) replayCanvas.classList.add('fade-out');
    if (mcqOptionsContainer) mcqOptionsContainer.style.opacity = 0;

    const fadeDuration = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--fade-duration') || '0.3') * 1000;
    
    setTimeout(() => {
        currentStageIndex = newIndex;
        renderStageUI(currentStageIndex, false).then(() => {
            backgroundCanvas.classList.remove('fade-out');
            if (replayCanvas) replayCanvas.classList.remove('fade-out');
            isTransitioning = false;
            
            // --- NEW FIX: FORCE FOCUS BACK TO CORE APP ---
            // This ensures that immediately after the slide changes, 
            // the main window grabs keyboard control.
            window.focus();
            if (document.activeElement && document.activeElement !== document.body) {
                document.activeElement.blur();
            }
            // ---------------------------------------------
        });
    }, fadeDuration);
}
    function nextStage() { transitionToStage(currentStageIndex + 1); }
    function previousStage() { if (currentStageIndex > 0 && !isThelobookActive && !isPageGridVisible) transitionToStage(currentStageIndex - 1); }
    // FULL UPDATED FUNCTION
async function displayLessonComplete() {
¬† ¬† isTransitioning = true;
¬† ¬† const TXT = getCurrentUIText();

¬† ¬† // --- FIX: START THE UI TRANSITION IMMEDIATELY ---
¬† ¬† if (isThelobookActive) closeThelobook(false);
¬† ¬† if (isPageGridVisible) closePageGridView();
¬† ¬† backgroundCanvas.classList.add('fade-out');
¬† ¬† if (replayCanvas) replayCanvas.classList.add('fade-out');
¬† ¬† if (mcqOptionsContainer) mcqOptionsContainer.style.display = 'none';
¬† ¬† if (currentReplayAnimationId) {
¬† ¬† ¬† ¬† cancelAnimationFrame(currentReplayAnimationId);
¬† ¬† ¬† ¬† currentReplayAnimationId = null;
¬† ¬† }
¬† ¬† if (currentStageAudio && !currentStageAudio.paused) {
¬† ¬† ¬† ¬† currentStageAudio.pause();
¬† ¬† ¬† ¬† currentStageAudio.currentTime = 0;
¬† ¬† }
¬† ¬† isMediaScrubbingActive = false;
¬† ¬† if (stageProgressBarContainer) stageProgressBarContainer.classList.remove('visible');

¬† ¬† setTimeout(() => {
¬† ¬† ¬† ¬† const cssWidth = backgroundCanvas.width / devicePixelRatio;
¬† ¬† ¬† ¬† const cssHeight = backgroundCanvas.height / devicePixelRatio;
¬† ¬† ¬† ¬† bgCtx.clearRect(0, 0, cssWidth, cssHeight);
¬† ¬† ¬† ¬† const fontFamily = currentLang === 'en' ? "'Manrope', system-ui, sans-serif" : "'Montserrat Arm', system-ui, sans-serif";
¬† ¬† ¬† ¬† bgCtx.font = `bold 24px ${fontFamily}`;
¬† ¬† ¬† ¬† bgCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--success-green').trim();
¬† ¬† ¬† ¬† bgCtx.textAlign = 'center';
¬† ¬† ¬† ¬† bgCtx.textBaseline = 'middle';
¬† ¬† ¬† ¬† bgCtx.fillText(TXT.lessonComplete, cssWidth / 2, cssHeight / 3);
¬† ¬† ¬† ¬† clearUserCanvas();
¬† ¬† ¬† ¬† if (replayCtx) replayCtx.clearRect(0, 0, replayCanvas.width / devicePixelRatio, replayCanvas.height / devicePixelRatio);

¬† ¬† ¬† ¬† if (nextCheckBtn) nextCheckBtn.style.display = 'none';
¬† ¬† ¬† ¬† if (prevBtn) prevBtn.style.display = 'none';
¬† ¬† ¬† ¬† if (clearBtn) clearBtn.style.display = 'none';
¬† ¬† ¬† ¬† if (thelobookBtn) thelobookBtn.style.display = 'none';
¬† ¬† ¬† ¬† if (dashboardBtn) {
¬† ¬† ¬† ¬† ¬† ¬† dashboardBtn.innerHTML = TXT.viewDashboard;
¬† ¬† ¬† ¬† ¬† ¬† dashboardBtn.classList.add('visible');
¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† if (colorIndicator) colorIndicator.style.display = 'none';
¬† ¬† ¬† ¬† addChatMessage('AI', `üéâ ${TXT.lessonComplete}`);
¬† ¬† ¬† ¬†¬†
¬† ¬† ¬† ¬† backgroundCanvas.classList.remove('fade-out');
¬† ¬† ¬† ¬† if (replayCanvas) replayCanvas.classList.remove('fade-out');
¬† ¬† ¬† ¬† isTransitioning = false;
¬† ¬† }, parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--fade-duration') || '0.3') * 1000);

¬† ¬† // --- DATABASE OPERATIONS IN THE BACKGROUND ---
¬† ¬† const user = auth.currentUser;
¬† ¬† const urlParams = new URLSearchParams(window.location.search);
¬† ¬† const lessonFileName = urlParams.get('lessonFile');

¬† ¬† if (user && lessonFileName) {
¬† ¬† ¬† ¬† // Log analytics
¬† ¬† ¬† ¬† if (lessonStartTime) {
¬† ¬† ¬† ¬† ¬† ¬† const timeToCompleteSeconds = Math.round((Date.now() - lessonStartTime) / 1000);
¬† ¬† ¬† ¬† ¬† ¬† db.collection("analytics_events").add({
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† type: "lesson_completed",
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† userId: user.uid,
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† lessonId: lessonFileName.replace('.json', ''),
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† courseId: "sat-math-prep",
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† timeToCompleteSeconds: timeToCompleteSeconds,
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† sessionScore: sessionPoints,
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† timestamp: firebase.firestore.FieldValue.serverTimestamp()
¬† ¬† ¬† ¬† ¬† ¬† }).catch(e => console.error("Analytics event logging error:", e));
¬† ¬† ¬† ¬† ¬† ¬† lessonStartTime = null;
¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† // Update progress and streak
¬† ¬† ¬† ¬† try {
¬† ¬† ¬† ¬† ¬† ¬† const topicId = lessonFileName.replace('.json', '');
¬† ¬† ¬† ¬† ¬† ¬† const studentDocRef = db.collection('thelo-students').doc(user.uid);
¬† ¬† ¬† ¬† ¬† ¬† const progressDocRef = studentDocRef.collection('progress').doc(topicId);
¬† ¬† ¬† ¬† ¬† ¬† const progressDoc = await progressDocRef.get();
¬† ¬† ¬† ¬† ¬† ¬† const wasAlreadyCompleted = progressDoc.exists;

¬† ¬† ¬† ¬† ¬† ¬† await updateStudentProgress(user.uid, topicId, {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† status: 'completed',
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† score: sessionPoints
¬† ¬† ¬† ¬† ¬† ¬† });

¬† ¬† ¬† ¬† ¬† ¬† if (!wasAlreadyCompleted) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† await studentDocRef.update({
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† lessonsCompleted: firebase.firestore.FieldValue.increment(1)
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† });
¬† ¬† ¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† ¬† ¬† await updateWeeklyStreak();

¬† ¬† ¬† ¬† } catch (error) {
¬† ¬† ¬† ¬† ¬† ¬† console.error("Error finalizing lesson completion in background:", error);
¬† ¬† ¬† ¬† }
¬† ¬† }
}		
	 /**
 * Handles clicks on the main "Next" / "Check" / "Got It" button.
 * This function is now the central point for evaluating all interactive stages.
 */
/**
¬†* Handles clicks on the main "Next" / "Check" / "Got It" button.
¬†* This function is now the central point for evaluating all interactive stages.
¬†*/
/* ------------------------------------------------------------------
   REPLACE your current handleNextCheckClick() with everything below
   ------------------------------------------------------------------ */
/**
 * Handles clicks on the main "Next" / "Check" / "Got It" button.
 * This function is the central point for evaluating all interactive stages.
 */
function handleNextCheckClick() {
    if (isTransitioning || isLessonLoading || isThelobookActive || isPageGridVisible) {
        return;
    }
    const TXT = getCurrentUIText();

    if (currentStageIndex === -1 && lessonStages.length > 0) {
        hideOnCanvasFeedback();
        lessonStartTime = Date.now();
        const user = auth.currentUser;
        const lessonFile = new URLSearchParams(location.search).get('lessonFile');
        if (user && lessonFile) {
            db.collection('analytics_events').add({
                type: 'lesson_started',
                userId: user.uid,
                lessonId: lessonFile.replace('.json', ''),
                courseId: 'sat-math-prep',
                timestamp: firebase.firestore.FieldValue.serverTimestamp()
            });
        }
        transitionToStage(0);
        return;
    }

    const mcq = currentStageData.optionsQuiz;
    const isMCQStage =
        currentStageData.type === 'explanation_with_mcq' &&
        mcq &&
        Array.isArray(mcq.choices) &&
        mcq.choices.length > 0;

    if (isMCQStage) {
        document.body.classList.remove('mcq-active');

        if (nextCheckBtn.textContent === TXT.next || nextCheckBtn.textContent === TXT.gotIt) {
            nextStage();
            return;
        }

        if (selectedMcqIndex === null) { return; }

        const buttons = mcqOptionsContainer.querySelectorAll('.mcq-option-btn');
        nextCheckBtn.disabled = true;

        const correct = selectedMcqIndex === mcq.correctIndex;
        const selectedButton = buttons[selectedMcqIndex];

        if (correct) {
            selectedButton.classList.remove('selected');
            selectedButton.classList.add('correct');
			isMcqAnsweredCorrectly = true;
            addChatMessage('AI', `üéâ ${mcq.feedbackCorrect || TXT.correct}`);
            playRandomFeedback('approve');
            
            // The options now remain visible.

            nextCheckBtn.textContent = TXT.next;
            nextCheckBtn.classList.add('correct');
            nextCheckBtn.disabled = false;

        } else { // Incorrect answer
            selectedButton.classList.remove('selected');
            selectedButton.classList.add('incorrect');
            addChatMessage('AI', `ü§î ${mcq.feedbackIncorrect || TXT.incorrect}`);
            playRandomFeedback('disapprove');

            setTimeout(() => {
                buttons.forEach(b => {
                    b.classList.remove('incorrect');
                });
                document.body.classList.add('mcq-active');
                // The selection is NOT reset, allowing you to navigate from your last choice.
                nextCheckBtn.disabled = false;
            }, 1000);
        }
        return;
    }

    if (nextCheckBtn.textContent === TXT.gotIt) {
        if (!stagesWithPointsAwarded.has(currentStageIndex)) {
            stagesWithPointsAwarded.add(currentStageIndex);
            stopCurrentStageAudio();
            const pts = Math.floor(Math.random() * 4) + 6;
            userPoints += pts;
            sessionPoints += pts;
            updateUserPointsInFirestore(pts);
            updatePointsDisplay();
            addChatMessage('AI', formatAIMessage('pointsGained', { points: pts }));
            if (window.userInteracted) {
                gotItSoundPlayer.currentTime = 0;
                gotItSoundPlayer.play().catch(() => {});
            }
        }
        if (isReplayActive) closeReplayPlayer();
        nextStage();
        return;
    }

    if (currentStageData.type === 'question_handwriting') {
        checkHandwritingAnswer();
    } else if (currentStageData.type === 'question_math_solution') {
        checkMathDrawing();
    } else {
        nextStage();
    }
}
	  function addChatImage(url) {
    const wrapper = Object.assign(document.createElement('div'), {
        className: 'ai-message chat-image-container'
    });

    const img = Object.assign(document.createElement('img'), {
        className: 'chat-image',
        src: url,
        alt: 'Lesson Content Image',
        style: 'opacity:0'
    });

    wrapper.appendChild(img);
    chatArea.appendChild(wrapper);
    
    // Calculate target scroll position
    const targetScrollTop = wrapper.offsetTop - chatArea.offsetTop;
    
    img.onload = () => {
        // Fade in the image
        img.style.transition = 'opacity .4s';
        img.style.opacity = '1';
        
        // Smooth scroll to position
        chatArea.scrollTo({
        top: targetScrollTop,
        behavior: 'smooth'
        });
    };
    }
    // Find your addChatMessage function (around line 1774 or search for 'function addChatMessage(sender, rawMsg)')
// ADD THIS NEW HELPER FUNCTION before `addChatMessage`
/**
 * Renders text containing math expressions into an HTML string with KaTeX.
 * - Handles explicit KaTeX delimiters like $...$
 * - Automatically converts simple fractions (e.g., 1/2)
 * - Automatically converts asterisks to multiplication dots (e.g., 2*3)
 * @param {string} text The text content to process.
 * @returns {string} The processed HTML string.
 */
function renderMathInText(text) {
    if (!text) return '';

    // Regex to find explicit $...$ delimiters.
    const regex = /(\$[\s\S]*?\$)/g;
    const parts = text.split(regex).filter(Boolean);
    let finalHTML = '';

    for (const part of parts) {
        if (part.startsWith('$') && part.endsWith('$')) {
            // This is an explicit KaTeX block
            const math = part.slice(1, -1).trim();
            try {
                finalHTML += katex.renderToString(math, { displayMode: false, throwOnError: false });
            } catch (e) {
                console.warn('KaTeX rendering failed for explicit math:', math, e);
                finalHTML += part; // Fallback to original text
            }
        } else {
            // This is plain text. Find simple math-like expressions and wrap them for KaTeX.
            // This regex finds fractions (e.g., 2/5) or expressions with asterisks.
            const processedPart = part.replace(/(\b\d+\/\d+\b)|(\*)/g, (match, fraction, asterisk) => {
                if (fraction) {
                    // It's a fraction, convert to \frac
                    return `$\\frac{${fraction.replace('/', '}{')}}$`;
                }
                if (asterisk) {
                    // It's a multiplication asterisk, convert to \cdot
                    return '$\\cdot$';
                }
                return match;
            });
            finalHTML += processedPart;
        }
    }
    return finalHTML;
}
// REPLACE your entire addChatMessage function with this one
/**
 * Finds simple math notations in a string and converts them to KaTeX HTML.
 * Supports:
 * - `sqrt(content)` -> rendered square root
 * - `base^exponent` -> rendered power
 * - `(base)^exponent` -> rendered power with parentheses
 * @param {string} text - The input string, potentially containing math.
 * @returns {string} An HTML string with math portions rendered by KaTeX.
 */
function parseAndRenderMath(text) {
    if (!text || typeof text !== 'string') return '';

    // This regex looks for one of three patterns using the OR | operator:
    // 1. The full "sqrt(content)" expression, capturing the "content".
    // 2. A parenthesized "(base)" followed by "^exponent", capturing "base" and "exponent".
    // 3. A simple "base" word followed by "^exponent", capturing "base" and "exponent".
    const mathRegex = /(\bsqrt\(([^)]+)\))|(\(([^)]+)\)\^(\w+))|(\b(\w+)\^(\w+)\b)/g;

    return text.replace(mathRegex, (match, sqrtFull, sqrtContent, powerParenFull, powerParenBase, powerParenExp, powerWordFull, powerWordBase, powerWordExp) => {
        try {
            // Case 1: Matched sqrt(content)
            if (sqrtFull) {
                return katex.renderToString(`\\sqrt{${sqrtContent}}`, { throwOnError: false, displayMode: false });
            }
            // Case 2: Matched (base)^exponent
            if (powerParenFull) {
                return katex.renderToString(`{(${powerParenBase})}^{${powerParenExp}}`, { throwOnError: false, displayMode: false });
            }
            // Case 3: Matched base^exponent
            if (powerWordFull) {
                return katex.renderToString(`${powerWordBase}^{${powerWordExp}}`, { throwOnError: false, displayMode: false });
            }
        } catch (e) {
            console.warn("KaTeX rendering failed for:", match, e);
            return match; // In case of error, fall back to the original text.
        }
        return match; // Should not be reached, but good practice.
    });
}
// REPLACE your entire addChatMessage function with this one

function addChatMessage(sender, rawMsg) {
¬† ¬† if (isTabletMode) {
¬† ¬† ¬† ¬† // Tablet toast logic remains the same
¬† ¬† ¬† ¬† const isImportant = rawMsg.includes('üéâ') || rawMsg.includes('ü§î') || rawMsg.includes('‚ö†Ô∏è');
¬† ¬† ¬† ¬† showToast(rawMsg, isImportant ? 5000 : 3500);
	    showFeedback(rawMsg, 3500);
¬† ¬† } else {
¬† ¬† ¬† ¬† // Desktop/mobile terminal chat
¬† ¬† ¬† ¬† const chatArea = document.getElementById('chat');
¬† ¬† ¬† ¬† if (!chatArea) return;

¬† ¬† ¬† ¬† const msg = rawMsg.replace(/^[\p{Extended_Pictographic}\uFE0F]+\s*/u, '');
¬† ¬† ¬† ¬† const TXT = getCurrentUIText();
¬† ¬† ¬† ¬† let emoji = 'ü´ß';

¬† ¬† ¬† ¬† const isPoints = /points? gained/i.test(msg) || (TXT.pointsGained && msg.includes(TXT.pointsGained.split("{")[0].trim()));
¬† ¬† ¬† ¬† const isWrong = msg.includes('Not quite') || (TXT.incorrect && msg.includes(TXT.incorrect)) || msg.includes('Incorrect') || msg.includes('Wrong');
¬† ¬† ¬† ¬† const isCorrect = !isWrong && ((TXT.correct && msg.includes(TXT.correct)) || /^correct/i.test(msg));
¬† ¬† ¬† ¬† const isWarning = msg.includes('‚ö†Ô∏è') || (TXT.error && msg.includes(TXT.error));
¬† ¬† ¬† ¬† const isWelcome = TXT.welcome && msg.includes(TXT.welcome);
¬† ¬† ¬† ¬† const isChecking = TXT.checkingAI && msg.includes(TXT.checkingAI.split('<')[0]);

¬† ¬† ¬† ¬† if(isWrong) emoji = 'ü§î';
¬† ¬† ¬† ¬† else if (isCorrect || isPoints) emoji = 'üéâ';
¬† ¬† ¬† ¬† else if (isWarning || msg.includes('üõë')) emoji = '‚ö†Ô∏è';
¬† ¬† ¬† ¬† else if (isWelcome) emoji = 'üëã';
¬† ¬† ¬† ¬† else if (isChecking) emoji = '‚è≥';
        
        // ======================= THE CHANGE IS HERE =======================
        // Use our new, more powerful function to render math before displaying.
        const finalHTML = renderMathInText(msg);
        // ================================================================

¬† ¬† ¬† ¬† const bubble = document.createElement('div');
¬† ¬† ¬† ¬† bubble.className = 'ai-message'; // Starts with opacity: 0
        
        // And now we use the processed HTML instead of the raw message.
¬† ¬† ¬† ¬† bubble.innerHTML = `<span class="emoji" role="img" aria-label="icon">${emoji}</span> <span>${finalHTML}</span>`;
¬† ¬† ¬† ¬† chatArea.appendChild(bubble);

¬† ¬† ¬† ¬† // Force the browser to paint the initial state before animating
¬† ¬† ¬† ¬† requestAnimationFrame(() => {
¬† ¬† ¬† ¬† ¬† ¬† setTimeout(() => {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† bubble.classList.add('show');
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† chatArea.scrollTo({ top: chatArea.scrollHeight, behavior: 'smooth' });
¬† ¬† ¬† ¬† ¬† ¬† }, 10);
¬† ¬† ¬† ¬† });
¬† ¬† }
}
	  /**
 * Creates or updates a student's progress for a specific topic in Firestore.
 * @param {string} userId - The authenticated user's UID.
 * @param {string} topicId - The unique ID for the lesson (e.g., 'sat-linear-equations-one-var').
 * @param {object} progressData - The data to save (e.g., { status: 'in-progress' }).
 */
async function updateStudentProgress(userId, topicId, progressData) {
  if (!userId || !topicId) {
    console.error("User ID or Topic ID is missing. Cannot save progress.");
    return;
  }
  
  // The path to the specific progress document for this user and topic.
  const progressDocRef = db.collection('thelo-students').doc(userId).collection('progress').doc(topicId);
  
  // Add a timestamp to every update.
  const dataWithTimestamp = {
    ...progressData,
    lastAttempted: firebase.firestore.FieldValue.serverTimestamp()
  };

  try {
    // Use setDoc with { merge: true } to create or update the document.
    await progressDocRef.set(dataWithTimestamp, { merge: true });
    console.log(`Progress for topic '${topicId}' updated:`, dataWithTimestamp);
  } catch (error) {
    console.error("Error updating student progress:", error);
  }
}
    function playAudio(audioElement){ return new Promise((resolve, reject) => { if (!audioElement || !(audioElement instanceof HTMLAudioElement)) { return reject(new Error("Invalid audio element")); } if (!window.userInteracted) { return resolve(); } audioElement.currentTime = 0; const playPromise = audioElement.play(); if(playPromise !== undefined) { playPromise.then(resolve).catch(error => { reject(error); }); } else { resolve(); } }); }
    function playRandomFeedback(soundType){
        if (!window.userInteracted || isThelobookActive || isPageGridVisible) return;
        let soundArray;
        if (currentLang === 'en') soundArray = (soundType === 'approve') ? approveSounds_en : disapproveSounds_en;
        else soundArray = (soundType === 'approve') ? approveSounds_hy : disapproveSounds_hy;
        if (soundArray && soundArray.length > 0) {
            const availableSounds = soundArray.filter(sound => sound instanceof HTMLAudioElement);
            if (availableSounds.length > 0) {
                const randomIndex = Math.floor(Math.random() * availableSounds.length);
                playAudio(availableSounds[randomIndex]).catch(e => {});
            }
        }
    }
    function formatAIMessage(key, replacements = {}){
        const TXT = getCurrentUIText(); let message = TXT[key] || `Missing text [${currentLang}]: ${key}`;
        const escapeHTML = (str) => String(str).replace(/[&<>"']/g, match => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[match]));
        for (const placeholder in replacements) {
            const replacementValue = replacements[placeholder] !== undefined && replacements[placeholder] !== null ? String(replacements[placeholder]) : '';
            message = message.replace(new RegExp(`{${placeholder}}`, 'g'), `<strong>${escapeHTML(replacementValue)}</strong>`);
        }
        return message;
    }
          /* ========== NEW: Toast Notification Logic ========== */
function showToast(rawMsg, duration = 4000) {
    const container = document.getElementById('toast-container');
    if (!container) return;

    // This part classifies the message to show the right icon
    const msg = rawMsg.replace(/^[\p{Extended_Pictographic}\uFE0F]+\s*/u, '');
    const TXT = getCurrentUIText();
    let emoji = 'ü´ß';
    let type = 'info'; 

    const isPoints  = /points? gained/i.test(msg) || (TXT.pointsGained && msg.includes(TXT.pointsGained.split("{")[0].trim()));
    const isWrong   = msg.includes('Not quite') || (TXT.incorrect && msg.includes(TXT.incorrect)) || msg.includes('Incorrect') || msg.includes('Wrong');
    const isCorrect = !isWrong && ((TXT.correct && msg.includes(TXT.correct)) || /^correct/i.test(msg));
    const isWarning = msg.includes('‚ö†Ô∏è') || (TXT.error && msg.includes(TXT.error));
    const isWelcome = TXT.welcome && msg.includes(TXT.welcome);
    const isChecking = TXT.checkingAI && msg.includes(TXT.checkingAI.split('<')[0]);

    if (isWrong) { emoji = 'ü§î'; type = 'error'; }
    else if (isCorrect || isPoints) { emoji = 'üéâ'; type = 'success'; }
    else if (isWarning || msg.includes('üõë')) { emoji = '‚ö†Ô∏è'; type = 'warning'; }
    else if (isWelcome) { emoji = 'üëã'; }
    else if (isChecking) { emoji = '‚è≥'; }

    // This part creates the toast element
    const toast = document.createElement('div');
    toast.className = `toast-message`;
    toast.innerHTML = `<span class="emoji" role="img" aria-label="icon">${emoji}</span> <span>${msg}</span>`;
    
    // This is the inner function that handles removing the toast
    const removeToast = () => {
        // First, we add the 'exiting' class to trigger the CSS transition
        toast.classList.add('exiting');
        
        // ===================================================================
        // THE ONLY CHANGE IS ON THIS LINE:
        // We now listen for 'transitionend' instead of 'animationend'.
        // This tells the code to wait for our new collapse transition to finish.
        toast.addEventListener('transitionend', () => {
            toast.remove();
        }, { once: true });
        // ===================================================================
    };

    // This sets the timer to automatically dismiss the toast
    const timeoutId = setTimeout(removeToast, duration);

    // This lets the user click the toast to dismiss it early
    toast.addEventListener('click', () => {
        clearTimeout(timeoutId);
        removeToast();
    }, { once: true });

    // This adds the toast to the page
    container.appendChild(toast);

    // This triggers the entry animation
    requestAnimationFrame(() => {
        toast.classList.add('show');
    });
}
	  // Add this new function somewhere in your script, e.g., after the toast/tablet functions

// REPLACE your existing showFeedback function with this DEBUGGING version.

/**
 * Pops up a transient feedback card in the centre of the screen.
 * @param {string} rawMsg  ‚Äì  HTML-allowed message (e.g. "üéâ <strong>Correct!</strong>")
 * @param {number} duration ‚Äì how long to stay visible (ms)
 */
function showOnCanvasFeedback(message, type = 'info') {
    if (!feedbackCtx) return;

    // --- NEW: Dim the background image so text pops ---
    if (backgroundCanvas) backgroundCanvas.classList.add('dimmed-for-feedback');
    // -------------------------------------------------

    // --- NEW: Hide strokes and enable interaction ---
    if (canvas) canvas.style.opacity = '0';
    if (feedbackCanvas) {
        feedbackCanvas.style.pointerEvents = 'auto';
        feedbackCanvas.onclick = () => hideOnCanvasFeedback();
    }
    // -------------------------------------------------

    const FADE_TIME = 400;
    const MAX_WIDTH_PERCENTAGE = 0.70;
    const TEXT_COLOR = '#111827';
    const FONT_FAMILY = currentLang === 'en' ? "'Manrope', system-ui, sans-serif" : "'Montserrat Arm', system-ui, sans-serif";
    const LINE_HEIGHT_MULTIPLIER = 1.2;
    const minFontSize = 20;

    let EMOJI = '';
    let baseFontSize = 48;

    if (type === 'success') {
        baseFontSize = 72;
        EMOJI = 'üéâ ';
    }

    const finalMessage = EMOJI + message;
    const len = finalMessage.length;

    let currentFontSize;
    if (len <= 15) {
        currentFontSize = baseFontSize * 3;
    } else if (len <= 40) {
        currentFontSize = baseFontSize * 2;
    } else if (len <= 80) {
        currentFontSize = baseFontSize * 1.3;
    } else {
        currentFontSize = baseFontSize;
    }

    currentFontSize = Math.max(minFontSize, Math.floor(currentFontSize));

    const canvasWidth = feedbackCanvas.width / devicePixelRatio;
    const canvasHeight = feedbackCanvas.height / devicePixelRatio;
    const maxWidth = canvasWidth * MAX_WIDTH_PERCENTAGE;
    const maxHeight = canvasHeight * 0.6;

    const wrapText = (ctx, text, maxWidth) => {
        const words = text.split(' ');
        let lines = [];
        let currentLine = words[0] || '';
        for (let i = 1; i < words.length; i++) {
            const word = words[i];
            const width = ctx.measureText(currentLine + " " + word).width;
            if (width < maxWidth) {
                currentLine += " " + word;
            } else {
                lines.push(currentLine);
                currentLine = word;
            }
        }
        lines.push(currentLine);
        return lines;
    };

    let lines = [];
    let lineHeight, totalTextHeight;

    while (currentFontSize >= minFontSize) {
        feedbackCtx.font = `900 ${currentFontSize}px ${FONT_FAMILY}`;
        lines = wrapText(feedbackCtx, finalMessage, maxWidth);
        
        lineHeight = currentFontSize * LINE_HEIGHT_MULTIPLIER;
        totalTextHeight = lines.length * lineHeight;

        const longestWord = finalMessage.split(' ').reduce((a, b) => a.length > b.length ? a : b, '');
        const longestWordWidth = feedbackCtx.measureText(longestWord).width;

        const tooWide = longestWordWidth > maxWidth;
        const tooTall = totalTextHeight > maxHeight;

        if (tooWide || tooTall) {
            currentFontSize = Math.floor(currentFontSize * 0.95);
            if (currentFontSize < minFontSize) {
                currentFontSize = minFontSize;
                break;
            }
        } else {
            break;
        }
    }

    if (currentFontSize === minFontSize) {
         feedbackCtx.font = `900 ${currentFontSize}px ${FONT_FAMILY}`;
         lines = wrapText(feedbackCtx, finalMessage, maxWidth);
         lineHeight = currentFontSize * LINE_HEIGHT_MULTIPLIER;
         totalTextHeight = lines.length * lineHeight;
    }

    let startY = (canvasHeight / 2) - (totalTextHeight / 2);
    lastFeedbackDetails = { lines, lineHeight, startY, fontSize: currentFontSize, fontFamily: FONT_FAMILY };

    if (feedbackAnimationId) cancelAnimationFrame(feedbackAnimationId);
    let startTime = null;
    
    const animate = (timestamp) => {
        if (!startTime) startTime = timestamp;
        const elapsed = timestamp - startTime;
        feedbackCtx.clearRect(0, 0, canvasWidth, canvasHeight);
        let currentOpacity = (elapsed < FADE_TIME) ? (elapsed / FADE_TIME) : 1.0;
        feedbackCtx.globalAlpha = currentOpacity;
        feedbackCtx.font = `900 ${currentFontSize}px ${FONT_FAMILY}`;
        feedbackCtx.fillStyle = TEXT_COLOR;
        feedbackCtx.textAlign = 'center';
        feedbackCtx.textBaseline = 'top';
        for (let i = 0; i < lines.length; i++) {
            feedbackCtx.fillText(lines[i], canvasWidth / 2, startY + (i * lineHeight));
        }
        feedbackCtx.globalAlpha = 1.0;
        if (elapsed < FADE_TIME) {
            feedbackAnimationId = requestAnimationFrame(animate);
        } else {
            cancelAnimationFrame(feedbackAnimationId);
            feedbackAnimationId = null;
        }
    };
    
    feedbackAnimationId = requestAnimationFrame(animate);
}
	  function hideOnCanvasFeedback() {
    if (!feedbackCtx || !lastFeedbackDetails) return;

    // --- NEW: Restore the background image ---
    if (backgroundCanvas) backgroundCanvas.classList.remove('dimmed-for-feedback');
    // -----------------------------------------

    // --- NEW: Restore strokes and disable interaction ---
    if (canvas) canvas.style.opacity = '1';
    if (feedbackCanvas) {
        feedbackCanvas.style.pointerEvents = 'none';
        feedbackCanvas.onclick = null;
    }
    // -------------------------------------------------

    const FADE_TIME = 400;
    const canvasWidth = feedbackCanvas.width / devicePixelRatio;
    const canvasHeight = feedbackCanvas.height / devicePixelRatio;
    const TEXT_COLOR = '#111827';
    
    const { lines, lineHeight, startY, fontSize, fontFamily } = lastFeedbackDetails;

    if (feedbackAnimationId) cancelAnimationFrame(feedbackAnimationId);
    let startTime = null;

    const animateFadeOut = (timestamp) => {
        if (!startTime) startTime = timestamp;
        const elapsed = timestamp - startTime;
        
        feedbackCtx.clearRect(0, 0, canvasWidth, canvasHeight);
        
        let currentOpacity = 1.0;
        if (elapsed < FADE_TIME) {
            currentOpacity = 1.0 - (elapsed / FADE_TIME);
        } else {
            lastFeedbackDetails = null;
            cancelAnimationFrame(feedbackAnimationId);
            feedbackAnimationId = null;
            return;
        }

        feedbackCtx.globalAlpha = currentOpacity;
        feedbackCtx.font = `900 ${fontSize}px ${fontFamily}`;
        feedbackCtx.fillStyle = TEXT_COLOR;
        feedbackCtx.textAlign = 'center';
        feedbackCtx.textBaseline = 'top';
        
        for (let i = 0; i < lines.length; i++) {
            feedbackCtx.fillText(lines[i], canvasWidth / 2, startY + (i * lineHeight));
        }

        feedbackCtx.globalAlpha = 1.0;

        feedbackAnimationId = requestAnimationFrame(animateFadeOut);
    };

    feedbackAnimationId = requestAnimationFrame(animateFadeOut);
}
	  function checkTabletMode() {
    // This media query should match the one in your CSS
    const tabletQuery = window.matchMedia('(min-width: 769px) and (max-width: 1200px) and (pointer: coarse)');
    const landscapeQuery = window.matchMedia('(min-width: 769px) and (max-width: 1200px) and (min-height: 500px)');

    isTabletMode = tabletQuery.matches || landscapeQuery.matches;
}

function checkMobileMode() {
    // Detect phones: small width + touch
    isMobileMode = window.matchMedia("(max-width: 768px)").matches && navigator.maxTouchPoints > 0;
    document.body.classList.toggle('mobile-mode', isMobileMode);
    console.log("Mobile Mode:", isMobileMode);
}
	function updateUserPointsInFirestore(pointsToAdd) {
        const user = auth.currentUser;
        if (!user) {
            console.warn("Attempted to update points for a non-logged-in user.");
            return;
        }

        const userDocRef = db.collection('thelo-students').doc(user.uid);

        // Use FieldValue.increment for atomic updates to prevent race conditions
        return userDocRef.update({
            points: firebase.firestore.FieldValue.increment(pointsToAdd)
        }).catch(error => {
            console.error("Error updating points in Firestore: ", error);
        });
    }
	/* ===== ADD THIS FUNCTION: The Main Streak Logic ======================== */
async function updateWeeklyStreak() {
    const user = auth.currentUser;
    if (!user) return; // Only run for logged-in users

    const userDocRef = db.collection('thelo-students').doc(user.uid);
    
    try {
        const doc = await userDocRef.get();
        const streakData = doc.exists && doc.data().streakData ? doc.data().streakData : {
            currentStreak: 0,
            longestStreak: 0,
            lastActivityWeek: null
        };

        const thisWeekId = getISOWeekIdentifier(new Date());

        // Scenario A: Already completed a lesson this week
        if (thisWeekId === streakData.lastActivityWeek) {
            console.log("Weekly streak already secured for:", thisWeekId);
            return;
        }

        const prevWeekId = getPreviousWeekIdentifier(thisWeekId);
        let newStreakData = { ...streakData };
        let showCelebration = false;

        // Scenario B: Streak Extended!
        if (prevWeekId === streakData.lastActivityWeek) {
            newStreakData.currentStreak += 1;
            console.log(`Weekly streak extended to ${newStreakData.currentStreak} weeks!`);
            showCelebration = true;
        } 
        // Scenario C: Streak Broken, new one starts
        else {
            newStreakData.currentStreak = 1;
            console.log("New weekly streak started!");
            showCelebration = true;
        }

        // Always update the last activity and check for a new record
        newStreakData.lastActivityWeek = thisWeekId;
        if (newStreakData.currentStreak > newStreakData.longestStreak) {
            newStreakData.longestStreak = newStreakData.currentStreak;
        }

        // Save to Firestore and show the modal
        await userDocRef.set({ streakData: newStreakData }, { merge: true });
        
        if (showCelebration) {
            showStreakCelebrationModal(newStreakData.currentStreak, newStreakData.currentStreak === newStreakData.longestStreak && newStreakData.currentStreak > 1);
        }

    } catch (error) {
        console.error("Error updating weekly streak:", error);
    }
}

function showStreakCelebrationModal(streakCount, isNewRecord) {
    const modal = document.getElementById('streakModal');
    const title = document.getElementById('streakModalTitle');
    const body = document.getElementById('streakModalBody');
    const closeBtn = document.getElementById('streakModalCloseBtn');
    const confirmBtn = document.getElementById('streakModalConfirmBtn');

    title.textContent = isNewRecord ? "New Record!" : "Weekly Streak Extended!";
    body.textContent = `That's ${streakCount} week${streakCount > 1 ? 's' : ''} in a row. Amazing work!`;
    
    const hideModal = () => modal.classList.add('modal-hidden');
    
    closeBtn.onclick = hideModal;
    confirmBtn.onclick = hideModal;

    modal.classList.remove('modal-hidden');
}	
// ANALYTICS: Helper function to log handwriting check attempts
function logHandwritingAttempt(result) {
    const user = auth.currentUser;
    const urlParams = new URLSearchParams(window.location.search);
    const lessonFileName = urlParams.get('lessonFile');

    if (user && lessonFileName && currentStageData) {
        db.collection("analytics_events").add({
            type: "handwriting_check_attempt",
            userId: user.uid,
            lessonId: lessonFileName.replace('.json', ''),
            stageIndex: currentStageIndex,
            result: result, // "correct" or "incorrect"
            timestamp: firebase.firestore.FieldValue.serverTimestamp()
        });
    }
}
function getMobileInkData(withBackground = false) {
    // Fallback if no strokes and no background request
    if (mobileStrokes.length === 0 && !withBackground) return canvas.toDataURL("image/png");
    
    // 1. Calculate Bounds (CSS pixels)
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    
    if (mobileStrokes.length > 0) {
        mobileStrokes.forEach(s => s.points.forEach(p => {
            if (p.x < minX) minX = p.x;
            if (p.y < minY) minY = p.y;
            if (p.x > maxX) maxX = p.x;
            if (p.y > maxY) maxY = p.y;
        }));
    }

    // If no strokes found, reset bounds
    if (minX === Infinity) {
        minX = 0; minY = 0; maxX = 0; maxY = 0;
    }

    let bgCssW = 0, bgCssH = 0;
    if (cachedStaticCanvas) {
        bgCssW = cachedStaticCanvas.width / devicePixelRatio;
        bgCssH = cachedStaticCanvas.height / devicePixelRatio;
    }

    if (withBackground && cachedStaticCanvas) {
        // Expand to include background at (0,0)
        minX = Math.min(minX, 0);
        minY = Math.min(minY, 0);
        maxX = Math.max(maxX, bgCssW);
        maxY = Math.max(maxY, bgCssH);
    } else {
        // Padding for strokes only
        const padding = 20;
        minX -= padding; minY -= padding;
        maxX += padding; maxY += padding;
    }

    // Ensure valid dimensions
    const width = Math.max(1, Math.ceil(maxX - minX));
    const height = Math.max(1, Math.ceil(maxY - minY));

    // Create High-DPI canvas
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = width * devicePixelRatio;
    tempCanvas.height = height * devicePixelRatio;
    const tCtx = tempCanvas.getContext('2d');

    // Scale and Translate
    tCtx.scale(devicePixelRatio, devicePixelRatio);
    tCtx.translate(-minX, -minY);

    // Draw Background
    if (withBackground && cachedStaticCanvas) {
        tCtx.drawImage(cachedStaticCanvas, 0, 0, bgCssW, bgCssH);
    }

    // Draw Strokes
    tCtx.lineCap = 'round';
    tCtx.lineJoin = 'round';
    
    mobileStrokes.forEach(stroke => {
        tCtx.beginPath();
        tCtx.strokeStyle = stroke.color;
        tCtx.lineWidth = 3;
        if (stroke.points.length > 0) {
            tCtx.moveTo(stroke.points[0].x, stroke.points[0].y);
            for (let i = 1; i < stroke.points.length; i++) {
                tCtx.lineTo(stroke.points[i].x, stroke.points[i].y);
            }
        }
        tCtx.stroke();
    });
    
    return tempCanvas.toDataURL("image/png");
}
	async function checkHandwritingAnswer() {
¬† ¬† console.log("Auth state at time of call:", isAuthReady);
¬† ¬† if (!isAuthReady || !auth.currentUser) {
¬† ¬† ¬† ¬† addChatMessage('AI', formatAIMessage('authErrorVision'));
¬† ¬† ¬† ¬† console.error("User is not authenticated. Cannot call AI function.");
¬† ¬† ¬† ¬† return;
¬† ¬† }

¬† ¬† try {
¬† ¬† ¬† ¬† await auth.currentUser.getIdToken(true); // Refresh token to ensure validity
¬† ¬† } catch (error) {
¬† ¬† ¬† ¬† console.error("Token refresh failed:", error);
¬† ¬† ¬† ¬† addChatMessage('AI', "Authentication error. Please try logging in again.");
¬† ¬† ¬† ¬† return;
¬† ¬† }
¬† ¬†¬†
¬† ¬† if (isThelobookActive || isPageGridVisible || nextCheckBtn.disabled || isTransitioning) return;

¬† ¬† const TXT = getCurrentUIText();
¬† ¬† nextCheckBtn.disabled = true;
¬† ¬† nextCheckBtn.textContent = TXT.checking;
¬† ¬† showOnCanvasFeedback(TXT.checking);
¬† ¬†¬†
¬† ¬† let base64ImageData;
¬† ¬† try {
        let imageDataUrl;
        if (isMobileMode) {
            if (mobileStrokes.length === 0) throw new Error("BLANK_ANSWER");
            imageDataUrl = getMobileInkData(false);
        } else {
            const blankCanvas = document.createElement('canvas');
            blankCanvas.width = canvas.width;
            blankCanvas.height = canvas.height;
            imageDataUrl = captureCanvas.toDataURL('image/png');
            if (imageDataUrl === blankCanvas.toDataURL()) throw new Error("BLANK_ANSWER");
        }
        base64ImageData = imageDataUrl;
¬† ¬† } catch (error) {
¬† ¬† ¬† ¬† addChatMessage('AI', formatAIMessage('drawActivityWarning'));
¬† ¬† ¬† ¬† playRandomFeedback('disapprove');
¬† ¬† ¬† ¬† nextCheckBtn.disabled = false;
¬† ¬† ¬† ¬† nextCheckBtn.textContent = TXT.check;
¬† ¬† ¬† ¬† return;
¬† ¬† }
¬† ¬†¬†
¬† ¬† const payload = {
¬† ¬† ¬† ¬† imageBase64: base64ImageData,
¬† ¬† ¬† ¬† problemText: "The user is writing a number to answer a question.",
¬† ¬† ¬† ¬† correctAnswer: String(currentStageData.correctAnswerOcr),
¬† ¬† ¬† ¬† customInstructions: `Analyze the user's handwritten number. The work is 'correct' ONLY IF the number in the image is clearly identifiable and matches the correct answer: ${currentStageData.correctAnswerOcr}. Otherwise, it is 'incorrect'.`,
¬† ¬† ¬† ¬† language: currentLang
¬† ¬† };

¬† ¬† try {
¬† ¬† ¬† ¬† const analyzeMathDrawing = firebase.functions().httpsCallable('analyzeMathDrawing');
¬† ¬† ¬† ¬† const result = await analyzeMathDrawing(payload);
¬† ¬† ¬† ¬† const { status, feedback } = result.data;
¬† ¬† ¬† ¬†¬†
¬† ¬† ¬† ¬† if (status === 'correct') {
¬† ¬† ¬† ¬† ¬† ¬† showOnCanvasFeedback(feedback, undefined, 'success');
¬† ¬† ¬† ¬† } else {
¬† ¬† ¬† ¬† ¬† ¬† showOnCanvasFeedback(feedback);
¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬†¬†
¬† ¬† ¬† ¬† if (status === 'correct') {
¬† ¬† ¬† ¬† ¬† ¬† logHandwritingAttempt('correct');
¬† ¬† ¬† ¬† ¬† ¬† const pointsGained = 10;
¬† ¬† ¬† ¬† ¬† ¬† playRandomFeedback('approve');
¬† ¬† ¬† ¬† ¬† ¬† userPoints += pointsGained;
¬† ¬† ¬† ¬† ¬† ¬† sessionPoints += pointsGained;
¬† ¬† ¬† ¬† ¬† ¬† updatePointsDisplay();
¬† ¬† ¬† ¬† ¬† ¬† updateUserPointsInFirestore(pointsGained);
¬† ¬† ¬† ¬† ¬† ¬† nextCheckBtn.classList.add('correct');
¬† ¬† ¬† ¬† ¬† ¬† nextCheckBtn.textContent = TXT.correct;
¬† ¬† ¬† ¬† ¬† ¬† setTimeout(nextStage, 2500);
¬† ¬† ¬† ¬† } else {¬†
¬† ¬† ¬† ¬† ¬† ¬† logHandwritingAttempt('incorrect');
¬† ¬† ¬† ¬† ¬† ¬† playRandomFeedback('disapprove');
¬† ¬† ¬† ¬† ¬† ¬† nextCheckBtn.classList.add('incorrect');
¬† ¬† ¬† ¬† ¬† ¬†¬†
¬† ¬† ¬† ¬† ¬† ¬† // After showing feedback, clear the canvas and reset the button
¬† ¬† ¬† ¬† ¬† ¬† setTimeout(() => {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† clearUserCanvas(); // <-- THIS IS THE NEW LINE
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† nextCheckBtn.disabled = false;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† nextCheckBtn.textContent = TXT.check;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† nextCheckBtn.classList.remove('incorrect');
¬† ¬† ¬† ¬† ¬† ¬† }, 1500); // Increased delay to 1.5 seconds
¬† ¬† ¬† ¬† }

¬† ¬† } catch (error) {
¬† ¬† ¬† ¬† console.error("Function call to analyzeMathDrawing failed:", error);
¬† ¬† ¬† ¬† addChatMessage('AI', formatAIMessage('apiErrorGeneral', { errorMessage: error.message }));
¬† ¬† ¬† ¬† playRandomFeedback('disapprove');
¬† ¬† ¬† ¬† nextCheckBtn.disabled = false;
¬† ¬† ¬† ¬† nextCheckBtn.textContent = TXT.check;
¬† ¬† }
}
async function checkMathDrawing(isMcqContext = false) {
    if (!auth.currentUser) {
        console.error("User is not authenticated.");
        addChatMessage('AI', '‚ö†Ô∏è You must be logged in to use this feature.');
        throw new Error("User not authenticated.");
    }

    // Refresh token to ensure validity
    try { await auth.currentUser.getIdToken(true); } 
    catch (e) { console.error(e); return; }

    const TXT = getCurrentUIText();
    nextCheckBtn.disabled = true;
    nextCheckBtn.textContent = TXT.checking;
    
    // Give UI time to update
    await new Promise(resolve => setTimeout(resolve, 50));
    
    try {
        // --- IMAGE 1: THE SOLUTION (Foreground) ---
        let userInkBase64;
        if (isMobileMode) {
            userInkBase64 = getMobileInkData(true);
        } else {
            userInkBase64 = canvas.toDataURL("image/png");
        }

        // --- IMAGE 2: THE CONTEXT (Background) ---
        let questionContextBase64 = null;
        if (currentStageData.image) {
            if (isMobileMode && cachedStaticCanvas) {
                questionContextBase64 = cachedStaticCanvas.toDataURL("image/png");
            } else if (backgroundCanvas) {
                questionContextBase64 = backgroundCanvas.toDataURL("image/png");
            }
        }

        const payload = {
            // Send distinct images
            userImage: userInkBase64,
            questionImage: questionContextBase64, 
            
            // Send text context
            problemText: currentStageData.problemText || "",
            correctAnswer: currentStageData.correctAnswer || "",
            solutionSteps: currentStageData.solutionSteps || "",
            customInstructions: currentStageData.customInstructions || "",
            language: currentLang
        };

        const analyzeMathDrawing = firebase.functions().httpsCallable('analyzeMathDrawing');
        const result = await analyzeMathDrawing(payload);
        const { status, feedback } = result.data;
    
        // --- Success/Failure Logic (Same as before) ---
        if (status === 'correct') {
            showOnCanvasFeedback(feedback, undefined, 'success');
            playRandomFeedback('approve');
            nextCheckBtn.classList.add('correct');
            
            // Add Points
            const pointsGained = 15;
            userPoints += pointsGained;
            sessionPoints += pointsGained;
            updatePointsDisplay();
            updateUserPointsInFirestore(pointsGained);

            if (currentStageData.type === 'question_math_solution') {
                nextCheckBtn.textContent = TXT.gotIt;
            }
            nextCheckBtn.disabled = false;
        } else {
             showOnCanvasFeedback(feedback);
             playRandomFeedback('disapprove');
             nextCheckBtn.classList.add('incorrect');
             
             setTimeout(() => {
                clearUserCanvas(); 
                nextCheckBtn.disabled = false;
                nextCheckBtn.textContent = TXT.check;
                nextCheckBtn.classList.remove('incorrect');
            }, 2500); // Give them time to read the feedback
        }

    } catch (error) {
        console.error("Math analysis failed:", error);
        addChatMessage('AI', `‚ö†Ô∏è Analysis error: ${error.message}`);
        playRandomFeedback('disapprove');
        nextCheckBtn.disabled = false;
        nextCheckBtn.textContent = TXT.check;
        nextCheckBtn.classList.remove('incorrect');
    }
}/* ========== THELOBOOK FUNCTIONALITY ========== */
        function updateThelobookPageControls() {
        const TXT = getCurrentUIText();
        const totalPages = Math.max(1, thelobookPages.length); // Ensure at least 1 for display

        if (thelobookPageIndicatorEl && TXT && TXT.thelobookPageIndicator) {
            thelobookPageIndicatorEl.textContent = TXT.thelobookPageIndicator
                .replace('{currentPage}', currentThelobookPageIndex + 1)
                .replace('{totalPages}', totalPages);
        }

        // Disable previous/next page buttons if at bounds or animating
        if (thelobookPrevPageBtn) thelobookPrevPageBtn.disabled = (currentThelobookPageIndex === 0 || isPageSwitchingAnimation);
        if (thelobookNextPageBtn) thelobookNextPageBtn.disabled = (currentThelobookPageIndex >= totalPages - 1 || isPageSwitchingAnimation);

        // Disable Add Page button if limit is reached (32 pages) or animating
        if (thelobookAddPageBtn) {
            thelobookAddPageBtn.disabled = (thelobookPages.length >= PAGES_PER_GRID_BATCH || isPageSwitchingAnimation);
        }

        // Disable eraser/pages button if animating
        if (thelobookEraserBtn) thelobookEraserBtn.disabled = isPageSwitchingAnimation;
        if (thelobookPagesBtn) thelobookPagesBtn.disabled = isPageSwitchingAnimation;
    }
    function saveCurrentThelobookPageDrawing() {
        if (!isThelobookActive || isPageSwitchingAnimation || !thelobookCtx || !thelobookCanvas || thelobookCanvas.width === 0 || thelobookCanvas.height === 0) {
            // Optional: Log why saving was skipped
            // console.warn("Save Thelobook: Conditions not met or canvas zero size", {isThelobookActive, isPageSwitchingAnimation, hasCtx: !!thelobookCtx, hasCanvas: !!thelobookCanvas, cW: thelobookCanvas?.width, cH: thelobookCanvas?.height });
            return;
        }
        try {
            if (currentThelobookPageIndex < 0) currentThelobookPageIndex = 0;
            while (thelobookPages.length <= currentThelobookPageIndex) {
                thelobookPages.push(null);
            }
            // THE FIX IS HERE: Remove division by devicePixelRatio
            thelobookPages[currentThelobookPageIndex] = thelobookCtx.getImageData(0, 0, thelobookCanvas.width, thelobookCanvas.height);
            // console.log("Saved Thelobook page", currentThelobookPageIndex, "with bitmap dimensions:", thelobookCanvas.width, "x", thelobookCanvas.height);
        } catch (e) {
            console.error("Error saving Thelobook page:", e);
            // Add more details if error occurs
            // console.error("Canvas details at error: attr W/H", thelobookCanvas?.width, thelobookCanvas?.height, "style W/H", thelobookCanvas?.style.width, thelobookCanvas?.style.height, "DPR", devicePixelRatio);
        }
    }

    function loadThelobookPageDrawing(pageIndex) {
        if (thelobookCtx) {
            thelobookCtx.clearRect(0, 0, thelobookCanvas.width / devicePixelRatio, thelobookCanvas.height / devicePixelRatio);
            if (pageIndex >= 0 && pageIndex < thelobookPages.length && thelobookPages[pageIndex]) {
                try { thelobookCtx.putImageData(thelobookPages[pageIndex], 0, 0); }
                catch (e) { console.error("Error loading Thelobook page data:", e); }
            }
        }
        currentThelobookPageIndex = pageIndex;
        updateThelobookPageControls();
    }

    function addThelobookNewPage() {
        // Check if page creation limit is reached (PAGES_PER_GRID_BATCH is 32)
        if (thelobookPages.length >= PAGES_PER_GRID_BATCH) {
            const TXT = getCurrentUIText();
            addChatMessage('AI', `‚ö†Ô∏è ${TXT.error}: Maximum of ${PAGES_PER_GRID_BATCH} pages allowed.`); // Provide user feedback
            return; // Stop function execution
        }

        if (isPageSwitchingAnimation) return; // Check if already switching
        saveCurrentThelobookPageDrawing(); // Save current page first
        thelobookPages.push(null); // Add a new blank page placeholder
        currentThelobookPageIndex = thelobookPages.length - 1; // Move to the new page
        loadThelobookPageDrawing(currentThelobookPageIndex); // Load the (blank) new page
        updateThelobookPageControls(); // Ensure controls are updated after adding a page
    }

    function changeThelobookPageSimple(direction) {
        if (isPageSwitchingAnimation) return; // Prevent re-entrant calls

        const oldPageIndex = currentThelobookPageIndex;
        let newPageIndex = currentThelobookPageIndex + direction;
        const totalPages = Math.max(1, thelobookPages.length);

        // Bounds checking for newPageIndex
        if (newPageIndex < 0) newPageIndex = 0;
        if (newPageIndex >= totalPages) newPageIndex = totalPages - 1;

        if (oldPageIndex !== newPageIndex) {
            saveCurrentThelobookPageDrawing(); // **** MOVED: Save current page BEFORE disabling controls/animating ****

            isPageSwitchingAnimation = true;
            updateThelobookPageControls(); // Update controls to reflect "switching" state (e.g., disable buttons)

            currentThelobookPageIndex = newPageIndex;
            loadThelobookPageDrawing(currentThelobookPageIndex); // Load the new page (this also calls updateThelobookPageControls)

            // Reset animation flag after a short delay/next frame to allow UI to settle
            requestAnimationFrame(() => {
                isPageSwitchingAnimation = false;
                updateThelobookPageControls(); // Ensure controls are updated for the new page state
            });
        }
    }
    function toggleThelobookEraser() {
        if (isPageSwitchingAnimation) return;
        isThelobookEraserActive = !isThelobookEraserActive;
        const TXT = getCurrentUIText();
        if (thelobookEraserBtn) {
            thelobookEraserBtn.textContent = isThelobookEraserActive ? 'üñãÔ∏è' : '‚úèÔ∏è';
            thelobookEraserBtn.title = isThelobookEraserActive ? TXT.thelobookPen : TXT.thelobookEraser;
            thelobookEraserBtn.classList.toggle('active', isThelobookEraserActive);
        }
        if (thelobookCanvas) thelobookCanvas.classList.toggle('eraser-active', isThelobookEraserActive);
        updateColorIndicator();
    }

    /* ---------------- helper: snapshot & pause media ---------------- */
    function captureMediaState() {
        mediaPlaybackTimeBeforeThelobook = internalPlaybackTime;
        audioTimeBeforeThelobook       = currentStageAudio ? currentStageAudio.currentTime : 0;
        wasMediaPlayingBeforeThelobook  = false;

        if (currentStageAudio && !currentStageAudio.paused) {
        currentStageAudio.pause();
        wasMediaPlayingBeforeThelobook = true;
        }

        if (isMediaScrubbingActive) {
        if (currentReplayAnimationId) cancelAnimationFrame(currentReplayAnimationId);
        currentReplayAnimationId = null;
        isMediaScrubbingActive  = false;
        wasMediaPlayingBeforeThelobook = true;
        }
        stageProgressBarContainer?.classList.remove('visible');
    }
    /* ---------------- helper: resume or freeze ---------------------- */
    function resumeMediaState() {
        const atEnd =
        currentStageTotalDuration > 0 &&
        mediaPlaybackTimeBeforeThelobook >= currentStageTotalDuration - 0.05;

        internalPlaybackTime = atEnd
        ? currentStageTotalDuration
        : mediaPlaybackTimeBeforeThelobook;

        if (currentStageAudio) { // currentTime will be used by playStageAudio in resume mode
        currentStageAudio.currentTime = audioTimeBeforeThelobook;
        }

        isMediaScrubbingActive = wasMediaPlayingBeforeThelobook && !atEnd;

        if (atEnd && currentStageDrawingData && replayCtx && currentStageTotalDuration > 0) {
        renderDrawingAtTime(currentStageTotalDuration, currentStageDrawingData, replayCtx);
        updateMediaProgressBar(currentStageTotalDuration, currentStageTotalDuration);
        stageProgressBarContainer?.classList.add('visible');
        }
        renderStageUI(currentStageIndex, true); // isResize = true indicates resume context
    }

    function openThelobook() {
    // ‚Äî early exits ‚Äî
    if (isThelobookActive || isPageGridVisible) return;

    /*  MCQ stages are now allowed ‚Äî guard removed  */

    isThelobookActive      = true;
    isThelobookEraserActive = false;

    const TXT = getCurrentUIText();

    // pause audio / drawing playback and snapshot timing
    captureMediaState();

    // show notebook canvas & controls
    thelobookCanvas.classList.remove('grid-underlay');
    thelobookCanvas.classList.add('active');
    thelobookControlsEl.classList.add('visible');

    // ensure at least one page exists, then load current page
    if (thelobookPages.length === 0) {
        thelobookPages.push(null);
        currentThelobookPageIndex = 0;
    }
    loadThelobookPageDrawing(currentThelobookPageIndex);

    // switch input listeners
    removeBoardDrawListeners();
    addThelobookDrawListeners();
    canvas.style.pointerEvents = 'none';

    // update UI text / states
    thelobookBtn.textContent = TXT.thelobookClose;
    if (thelobookEraserBtn) {
        thelobookEraserBtn.textContent = '‚úèÔ∏è';
        thelobookEraserBtn.title      = TXT.thelobookEraser;
        thelobookEraserBtn.classList.remove('active');
    }
    if (clearBtn)  clearBtn.disabled  = true;
    if (prevBtn)   prevBtn.disabled   = true;
    if (nextCheckBtn) nextCheckBtn.disabled = true;

    updateColorIndicator();
    updateThelobookPageControls();

    /* ‚îÄ‚îÄ blur MCQ block if it‚Äôs visible ‚îÄ‚îÄ */
    if (mcqOptionsContainer &&
        mcqOptionsContainer.style.display !== 'none') {
        mcqOptionsContainer.classList.add('blurred-mcq');
    }
}


function closeThelobook(savePage = true) {
    if (!isThelobookActive) return;

    /* ‚îÄ‚îÄ restore MCQ clarity ‚îÄ‚îÄ */
    if (mcqOptionsContainer) {
        mcqOptionsContainer.classList.remove('blurred-mcq');
    }

        if (savePage) saveCurrentThelobookPageDrawing();
        isThelobookActive = false; const TXT = getCurrentUIText();

        thelobookCanvas.classList.remove('active');
        thelobookCanvas.classList.remove('grid-underlay');
        thelobookControlsEl.classList.remove('visible');
        removeThelobookDrawListeners(); addBoardDrawListeners();
        thelobookBtn.textContent = TXT.thelobookOpen;
        
        resumeMediaState();
        
        // ======================= FIX STARTS HERE =======================
        if (currentStageIndex === -1) {
            // This is the edge case: lesson hasn't started.
            // Manually re-enable the 'Start' button.
            if (nextCheckBtn) nextCheckBtn.disabled = false;
        }
        // ======================== FIX ENDS HERE ========================

        // The original logic can remain or be cleaned up, but the fix above is key.
        if (currentStageData) {
            // renderStageUI is called by resumeMediaState
        } else {
            updateColorIndicator();
            canvas.style.pointerEvents = isMobileMode ? 'auto' : 'none';
        }
       
        wasMediaPlayingBeforeThelobook = false; 
    }
 function openCalculator() {
    if (isCalculatorActive || isThelobookActive || isPageGridVisible) return;
    isCalculatorActive = true;

    // Capture state before opening
    captureMediaState();

    // Load Desmos if empty
    if(calculatorFrame.src === 'about:blank') {
       calculatorFrame.src = 'https://www.desmos.com/calculator';
    }
    
    // Show overlay
    calculatorOverlay.classList.remove('calculator-hidden');
    
    // Blur MCQs
    if (mcqOptionsContainer && mcqOptionsContainer.style.display !== 'none') {
        mcqOptionsContainer.classList.add('blurred-mcq');
    }

    // Disable buttons
    if (clearBtn)  clearBtn.disabled  = true;
    if (prevBtn)   prevBtn.disabled   = true;
    if (nextCheckBtn) nextCheckBtn.disabled = true;

    // === NEW: Show the cursor ===
    document.body.classList.add('cursor-visible');
}

function closeCalculator() {
    if (!isCalculatorActive) return;
    isCalculatorActive = false;
    
    // Hide overlay
    calculatorOverlay.classList.add('calculator-hidden');
    
    // Un-blur MCQs
    if (mcqOptionsContainer) {
        mcqOptionsContainer.classList.remove('blurred-mcq');
    }
    
    // Resume lesson
    resumeMediaState();

    // === NEW: Hide the cursor again ===
    document.body.classList.remove('cursor-visible');
}
function handleKeyDown(event) {
    // 1. Universal Replay Seeking (Highest Priority)
    // FIX: Allow seeking if duration exists OR if we are in active replay mode (even with 0 duration)
    if ((currentStageTotalDuration > 0 || isReplayActive) && (event.key === 'ArrowLeft' || event.key === 'ArrowRight')) {
        
        const isReplayActiveStage = currentStageData?.type === 'explanation_with_media' || currentStageData?.type === 'calculator_replay';
        
        // === FIXED CONDITION ===
        // added "|| currentStageTotalDuration > 0"
        // This ensures that even if playback reached the end (setting isMediaScrubbingActive to false),
        // we can still use the arrows to go back because we know there is duration available.
        if (isReplayActiveStage || isMediaScrubbingActive || currentStageTotalDuration > 0) {
            event.preventDefault(); 
            isMediaScrubbingActive = true; // Reactivate the loop
            
            if (currentReplayAnimationId) { 
                cancelAnimationFrame(currentReplayAnimationId); 
                currentReplayAnimationId = null; 
            }
            
            const step = 5; 
            const diff = event.key === 'ArrowLeft' ? -step : step;
            
            // FIX: If duration is 0 (just a website embed), treat limit as Infinite so we don't get stuck at 0
            const maxTime = currentStageTotalDuration > 0 ? currentStageTotalDuration : Infinity;
            
            let newTime = Math.max(0, Math.min(internalPlaybackTime + diff, maxTime));
            internalPlaybackTime = newTime;
            
            // Sync Audio (if it exists)
            if (currentStageAudio) {
                const audioTargetTime = Math.min(newTime, currentStageAudio.duration > 0.01 ? currentStageAudio.duration - 0.01 : 0);
                if (isFinite(audioTargetTime)) { // Safety check
                     currentStageAudio.currentTime = audioTargetTime;
                     if (window.userInteracted && currentStageAudio.paused && audioTargetTime < (currentStageAudio.duration - 0.01)) { 
                         currentStageAudio.play().catch(() => {}); 
                     }
                }
            }
            
            // Send Command to Iframe
            if (isReplayActive && replayFrame && replayFrame.contentWindow) { 
                replayFrame.contentWindow.postMessage({ command: 'seekToTime', timeMs: newTime * 1000 }, '*'); 
            }
            
            // Sync Drawing (if it exists)
            if (currentStageDrawingData && replayCtx) { 
                renderDrawingAtTime(newTime, currentStageDrawingData, replayCtx); 
            }
            
            // Update UI
            updateMediaProgressBar(newTime, currentStageTotalDuration);
            lastFrameTimestampForManualAdvance = 0; 
            currentReplayAnimationId = requestAnimationFrame(mediaPlaybackLoop);
            return;
        }
    }

    // 2. Ignore inputs with modifiers or in text fields
    if (event.ctrlKey || event.altKey || event.metaKey || ['INPUT', 'TEXTAREA'].includes(event.target.tagName.toUpperCase())) { return; }

    // --- DEV FEATURE: Force Next Stage ---
    if (event.key.toLowerCase() === 's') {
        event.preventDefault();
        console.log("DEV: Force advancing to next stage via 'S' key.");
        nextStage();
        return; // Skip all other key handling
    }

    // 3. Handle overlay key presses
    if (isPageGridVisible) {
        if (event.key.toLowerCase() === 'c') changePageGridBatch(1);
        if (event.key.toLowerCase() === 'x') changePageGridBatch(-1);
        if (event.key === 'Escape') closePageGridView();
        return;
    }
    if (isCalculatorActive) {
        if (event.key.toLowerCase() === 'f' || event.key === 'Escape') closeCalculator();
        return;
    }
    if (isThelobookActive) {
        if (event.key.toLowerCase() === 'b' || event.key === 'Escape') closeThelobook(true);
        if (event.key.toLowerCase() === 'e') toggleThelobookEraser();
        if (event.key.toLowerCase() === 'c') clearUserCanvas();
        return;
    }
    
    // 4. Handle MCQ-specific navigation
    const mcqDetails = currentStageData ? currentStageData.optionsQuiz : null;
    const isMcqActive = !!(currentStageData && currentStageData.type === "explanation_with_mcq" && mcqDetails && mcqDetails.choices);

    if (isMcqActive && !isMcqAnsweredCorrectly) {
        // Only prevent default if we are actually using the arrows for MCQ
        if (event.key === 'ArrowRight' || event.key === 'ArrowLeft') {
             event.preventDefault();
             const optionCount = mcqDetails.choices.length;
             let newIndex = selectedMcqIndex;

             if (event.key === 'ArrowRight') { newIndex = (selectedMcqIndex + 1) % optionCount; } 
             else if (event.key === 'ArrowLeft') { newIndex = (selectedMcqIndex - 1 + optionCount) % optionCount; }
             
             updateMcqSelectionVisuals(newIndex);
             return;
        }
        
        if (event.key !== ' ' && event.key !== 'Enter') { return; }
    }

    // 5. Handle Confirmation Keys (Spacebar & Enter)
    if (event.key === ' ' || event.key === 'Enter') {
        event.preventDefault();
        if (dashboardBtn && dashboardBtn.classList.contains('visible')) { dashboardBtn.click(); return; }
        if (nextCheckBtn && !nextCheckBtn.disabled) { handleNextCheckClick(); }
    }
    
    // 6. Handle General App Shortcuts
    if (currentStageIndex >= 0 && !isTransitioning && !isLessonLoading && currentStageData) {
        switch (event.key.toLowerCase()) {
            case 'b': openThelobook(); event.preventDefault(); break;
            case 'f': openCalculator(); event.preventDefault(); break;
            case 'a': hideOnCanvasFeedback(); event.preventDefault(); break;
            case 'c':
                if (isStudentInputAllowed && !isMcqActive && clearBtn && clearBtn.style.display !== 'none' && !clearBtn.disabled) {
                    clearUserCanvas(); event.preventDefault();
                }
                break;
        }
    }
}
	  window.addEventListener('keydown', function(e) {
  if ((e.ctrlKey || e.metaKey) && (e.key === '+' || e.key === '-' || e.key === '=')) {
    e.preventDefault();
  }
});

window.addEventListener('wheel', function(e) {
  if (e.ctrlKey) {
    e.preventDefault();
  }
}, { passive: false });
	function clearUserCanvas() {
    if (isPageGridVisible) return;

    if (isThelobookActive) {
        if (thelobookCtx) {
            thelobookCtx.clearRect(0, 0, thelobookCanvas.width / devicePixelRatio, thelobookCanvas.height / devicePixelRatio);
            if (currentThelobookPageIndex >= 0 && currentThelobookPageIndex < thelobookPages.length) {
                thelobookPages[currentThelobookPageIndex] = null;
            }
        }
        return;
    }

    if (ctx) {
        ctx.clearRect(0, 0, canvas.width / devicePixelRatio, canvas.height / devicePixelRatio);
    }
    mobileStrokes = []; // Clear mobile history
    
    // Also clear the capture canvas used for AI
    if (captureCtx && captureCanvas) {
         captureCtx.clearRect(0, 0, captureCanvas.width, captureCanvas.height);
    }

    userDrawingOccurred = false;
}
    // REPLACE your existing initApp function with this entire block

function initApp() {
	// Listen for Spacebar signal from the Iframe
    window.addEventListener('message', (event) => {
        if (event.data === 'TRIGGER_SPACE_ACTION') {
            // 1. Steal focus back to the main window
            window.focus(); 
            
            // 2. Trigger the main action button
            if (dashboardBtn && dashboardBtn.classList.contains('visible')) {
                dashboardBtn.click();
            } else if (nextCheckBtn && !nextCheckBtn.disabled) {
                handleNextCheckClick();
            }
        }
    });
    // NEW: Add this check at the very top of the function
   
    // --- The rest of your original initApp function continues below ---
    
    console.log("KaTeX is ready. Initializing app.");
    checkTabletMode();
    checkMobileMode();
    const audioIdsToLoad = [
        'audio_approve1_hy', 'audio_approve2_hy', 'audio_dis1_hy', 'audio_dis2_hy',
        'audio_approve1_en', 'audio_approve2_en', 'audio_dis1_en', 'audio_dis2_en', 'gotItSound'
    ];
    audioIdsToLoad.forEach(id => {
        const audio = document.getElementById(id);
        if (audio) {
            audioElements[id] = audio;
            if (id.startsWith('audio_approve') && id.endsWith('_hy')) approveSounds_hy.push(audio);
            if (id.startsWith('audio_dis') && id.endsWith('_hy')) disapproveSounds_hy.push(audio);
            if (id.startsWith('audio_approve') && id.endsWith('_en')) approveSounds_en.push(audio);
            if (id.startsWith('audio_dis') && id.endsWith('_en')) disapproveSounds_en.push(audio);
        }
    });
    resizeCanvases();
    addBoardDrawListeners();
    window.addEventListener('mouseup', handleDrawingEnd);
    window.addEventListener('mouseleave', handleDrawingEnd);
    window.addEventListener('touchend', handleDrawingEnd);
    window.addEventListener('touchcancel', handleDrawingEnd);

    const urlParams = new URLSearchParams(window.location.search);
    const lessonFileName = urlParams.get('lessonFile');
    if (lessonFileName) {
        const LESSONS_BASE_PATH = 'https://thelo.space/lessons/';
        const cleanLFN = lessonFileName.startsWith('/') ? lessonFileName.substring(1) : lessonFileName;
        loadLesson(LESSONS_BASE_PATH + cleanLFN.replace(/\.\.+/g, ''));
    } else {
        const TXT = getCurrentUIText();
        addChatMessage('AI', formatAIMessage('lessonFileMissing'));
        if(nextCheckBtn){nextCheckBtn.textContent = TXT.error; nextCheckBtn.disabled = true;}
        if(prevBtn)prevBtn.disabled = true;
        if(bgCtx && backgroundCanvas && backgroundCanvas.width > 0){
            const cw = backgroundCanvas.width/(window.devicePixelRatio||1); const ch = backgroundCanvas.height/(window.devicePixelRatio||1);
            bgCtx.clearRect(0,0,cw,ch); bgCtx.font = `20px 'Mardoto-Light', system-ui, sans-serif`;
            bgCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--thelo-text').trim();
            bgCtx.textAlign='center';bgCtx.textBaseline='middle';
            wrapText(bgCtx, TXT.lessonLoadErrorGeneric, cw/2, ch/2, cw*0.8, 30);
        }
    }
    const interactionListener = () => { if (window.userInteracted) return; window.userInteracted = true; Object.values(audioElements).forEach(a => { if(a.readyState < 1) a.load(); }); if(stageAudioPlayer && stageAudioPlayer.readyState < 1) stageAudioPlayer.load(); try { const tempAC = new (window.AudioContext || window.webkitAudioContext)(); if (tempAC.state === 'suspended') tempAC.resume().then(()=>tempAC.close()); else tempAC.close(); } catch(e){} document.body.removeEventListener('click', interactionListener); document.body.removeEventListener('keydown', interactionListener); document.body.removeEventListener('touchstart', interactionListener); };
    document.body.addEventListener('click', interactionListener, { once: true });
    document.body.addEventListener('keydown', interactionListener, { once: true });
    document.body.addEventListener('touchstart', interactionListener, { once: true });
    window.addEventListener('resize', resizeCanvases);
    if (prevBtn) prevBtn.onclick = previousStage;
    if (nextCheckBtn) nextCheckBtn.onclick = handleNextCheckClick;
    const fullscreenBtn = document.getElementById('fullscreenBtn');
    if (fullscreenBtn) {
        fullscreenBtn.onclick = toggleFocusFullscreen;
    }

    if (clearBtn) clearBtn.onclick = clearUserCanvas;
    if (thelobookBtn) thelobookBtn.onclick = () => { isThelobookActive ? closeThelobook(true) : openThelobook(); };

    if (thelobookPrevPageBtn) thelobookPrevPageBtn.onclick = () => changeThelobookPageSimple(-1);
    if (thelobookNextPageBtn) thelobookNextPageBtn.onclick = () => changeThelobookPageSimple(1);
    if (thelobookEraserBtn) thelobookEraserBtn.onclick = toggleThelobookEraser;
    if (thelobookAddPageBtn) thelobookAddPageBtn.onclick = addThelobookNewPage;
    if (calculatorCloseBtn) calculatorCloseBtn.onclick = closeCalculator;
    if (openCalculatorBtn) openCalculatorBtn.onclick = openCalculator;
    
    // Mobile Menu Listeners
    if (mobileCheckBtn) mobileCheckBtn.onclick = () => { toggleMobileMenu(); handleNextCheckClick(); };
    if (mobileNextBtn) mobileNextBtn.onclick = () => { toggleMobileMenu(); nextStage(); };
    if (mobileEraseBtn) mobileEraseBtn.onclick = () => { toggleMobileMenu(); clearUserCanvas(); };
    if (mobilePrevBtn) mobilePrevBtn.onclick = () => { 
        toggleMobileMenu(); 
        if (currentStageIndex > 0) transitionToStage(currentStageIndex - 1); 
    };
    if (mobileCloseBtn) mobileCloseBtn.onclick = toggleMobileMenu;


    if (dashboardBtn) {
        dashboardBtn.onclick = () => {
            window.location.href = 'https://thelo.space/sdashboard';
        };
    }

    document.querySelectorAll('button').forEach(button => {
        button.addEventListener('click', () => {
            button.blur();
        });
    });

    document.addEventListener('keydown', handleKeyDown);

    window.addEventListener('beforeunload', () => {
        const user = auth.currentUser;
        if (user && lessonStartTime && currentStageIndex < lessonStages.length -1) {
            const urlParams = new URLSearchParams(window.location.search);
            const lessonFileName = urlParams.get('lessonFile');
            
            navigator.sendBeacon('https://firestore.googleapis.com/v1/projects/physmathacademy-722b3/databases/(default)/documents/analytics_events', JSON.stringify({
                fields: {
                    type: { stringValue: 'lesson_abandoned' },
                    userId: { stringValue: user.uid },
                    lessonId: { stringValue: lessonFileName.replace('.json', '') },
                    lastCompletedStageIndex: { integerValue: currentStageIndex },
                    totalStagesInLesson: { integerValue: lessonStages.length },
                    timestamp: { timestampValue: new Date().toISOString() }
                }
            }));
        }
    });
}

    if (typeof window.appInitialized === 'undefined') {
        window.appInitialized = false;
    }

  // This listener ensures the entire page, including all styles and fonts, is ready before the app starts.
document.addEventListener('DOMContentLoaded', async () => {

    // Helper function to programmatically load KaTeX CSS
    let isKatexCssInjected = false;
    async function ensureKatexCssIsLoaded() {
        if (isKatexCssInjected) return;
        // This re-uses your existing function that cleverly embeds the fonts!
        const cssText = await getKatexCSSWithEmbeddedFonts();
        const style = document.createElement('style');
        style.textContent = cssText;
        document.head.appendChild(style);
        isKatexCssInjected = true;
        console.log('KaTeX CSS has been injected into the document head.');
    }

    // --- Start of App Initialization ---

    console.log('DOM is ready. Checking for KaTeX library:', typeof katex);
    if (typeof katex === 'undefined') {
        console.error('CRITICAL: KaTeX library failed to load before app start.');
        return;
    }

    try {
        // 1. Force the CSS to load and be injected first.
        await ensureKatexCssIsLoaded();

        // 2. Now, wait for the browser to acknowledge all fonts are ready.
        await document.fonts.ready;
        console.log('All fonts are confirmed ready.');

        // 3. Proceed with app initialization, confident that everything is loaded.
        auth.onAuthStateChanged(user => {
            const finishInitialization = () => {
                if (!window.appInitialized) {
                    window.appInitialized = true;
                    initApp();
                } else {
                    updateAllUITexts();
                }
                isAuthReady = true;
                console.log("Authentication is now ready.");
            };

            if (user) {
                console.log("User authenticated with UID:", user.uid);
                const userDocRef = db.collection('thelo-students').doc(user.uid);

                userDocRef.get().then(doc => {
                    if (doc.exists) {
                        userPoints = doc.data().points || 0;
                    } else {
                        userPoints = 0;
                        console.log("No points document found for user, starting at 0.");
                    }
                    updatePointsDisplay();
                    finishInitialization();
                }).catch(error => {
                    console.error("Error fetching user points:", error);
                    userPoints = 0;
                    updatePointsDisplay();
                    finishInitialization();
                });
            } else {
                userPoints = 0;
                updatePointsDisplay();
                console.log("User not authenticated.");
                finishInitialization();
            }
        });

    } catch (error) {
        console.error('Styles or fonts failed to load, app initialization aborted:', error);
    }
});
// Add this function somewhere logical, e.g., near updateUserPointsInFirestore
async function logDigitForTraining(recognizedValue, feedbackType) {
¬† ¬† const user = auth.currentUser;
¬† ¬† if (!user) {
¬† ¬† ¬† ¬† console.warn("No user for digit logging. Skipping.");
¬† ¬† ¬† ¬† return;
¬† ¬† }

¬† ¬† // Ensure the main canvas has content
¬† ¬† if (!canvas || canvas.width === 0 || canvas.height === 0) {
¬† ¬† ¬† ¬† console.warn("Main canvas is not ready or empty. Cannot log digit for training.");
¬† ¬† ¬† ¬† return;
¬† ¬† }

¬† ¬† let base64ImageData;
¬† ¬† try {
¬† ¬† ¬† ¬† // Capture the content of the main canvas (which contains the blue ink)
        if (isMobileMode) {
            base64ImageData = getMobileInkData(false);
        } else {
            base64ImageData = canvas.toDataURL('image/png');
        }
¬† ¬† } catch (e) {
¬† ¬† ¬† ¬† console.error("Failed to get image data from canvas for logging:", e);
¬† ¬† ¬† ¬† return;
¬† ¬† }

¬† ¬† const metadata = {
¬† ¬† ¬† ¬† digit: String(recognizedValue),
¬† ¬† ¬† ¬† recognizedByVision: currentStageData.correctAnswerOcr,
¬† ¬† ¬† ¬† feedbackType: feedbackType,
¬† ¬† ¬† ¬† timestamp: firebase.firestore.FieldValue.serverTimestamp(),
¬† ¬† ¬† ¬† userId: user.uid,
¬† ¬† ¬† ¬† lessonId: new URLSearchParams(window.location.search).get('lessonFile')?.replace('.json', '') || 'unknown',
¬† ¬† ¬† ¬† stageIndex: currentStageIndex,
¬† ¬† ¬† ¬† deviceType: isTabletMode ? 'tablet' : 'desktop',
¬† ¬† ¬† ¬† userAgent: navigator.userAgent,
¬† ¬† ¬† ¬† screenWidth: window.screen.width,
¬† ¬† ¬† ¬† screenHeight: window.screen.height,
¬† ¬† ¬† ¬† canvasWidth: canvas.width,
¬† ¬† ¬† ¬† canvasHeight: canvas.height,
¬† ¬† ¬† ¬† devicePixelRatio: window.devicePixelRatio || 1,
¬† ¬† };

¬† ¬† try {
¬† ¬† ¬† ¬† // Send to a new collection specifically for training data
¬† ¬† ¬† ¬† await db.collection('thelo-training-digits-demo').add({
¬† ¬† ¬† ¬† ¬† ¬† imageData: base64ImageData,
¬† ¬† ¬† ¬† ¬† ¬† metadata: metadata
¬† ¬† ¬† ¬† });
¬† ¬† ¬† ¬† console.log("Handwritten digit logged for training demo:", recognizedValue);
¬† ¬† } catch (error) {
¬† ¬† ¬† ¬† console.error("Error logging digit for training demo:", error);
¬† ¬† }
}

</script>
</html>
