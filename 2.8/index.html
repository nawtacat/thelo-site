<!DOCTYPE html>
<html lang="hy">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link rel="icon" href="https://thelo.space/img/thelofavicon.png" type="image/png">
    <link rel="apple-touch-icon" href="https://thelo.space/img/yarnicon.png">
    <title>thelo</title>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
	<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-functions-compat.js"></script>
	<link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@300;400;500;700&display=swap" rel="stylesheet">
	<link rel="manifest" href="/manifest.json" />
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">


<style>
  /* ===== NEW: Updated Design System ===== */
  :root {
    /* Core Palette */
    --thelo-blue: #2563eb;
    --thelo-blue-dark: #1d4ed8;
    --thelo-bg: #ffffff;
    --thelo-text: #111827;
    --thelo-text-light: #6b7280;
    --thelo-border: #e5e7eb;

    /* Status Colors */
    --success-green: #22c55e;
    --error-red: #ef4444;
    --accent-yellow: #f59e0b;

    /* UI Element Colors */
    --bg-white: #ffffff;
    --chat-ai-bg: #ffffff;

    /* Ink Colors */
    --ink-black: #000000;
    --ink-blue: var(--thelo-blue);

    /* Effects */
    --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
    --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);

    /* Transitions */
    --fade-duration: 0.3s;
    --animation-duration: 0.3s;
    --thelobook-page-transition-duration: 0.05s;
  }
  #loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: var(--thelo-bg); /* Use your existing background color */
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999; /* Ensure it's on top of all other content */
    opacity: 1;
    /* Add a transition for the fade-out effect */
    transition: opacity 0.5s ease-out;
}

#loading-overlay.hidden {
    opacity: 0;
    pointer-events: none; /* Prevents interaction while fading out */
}

#loading-svg {
    width: 150px; /* A larger logo as requested */
    height: auto;
    animation: pulse-loader 1.5s infinite ease-in-out;
}

/* This is the animation for the logo */
@keyframes pulse-loader {
    0% {
        transform: scale(1);
        opacity: 0.8;
    }
    50% {
        transform: scale(1.1);
        opacity: 1;
    }
    100% {
        transform: scale(1);
        opacity: 0.8;
    }
}

  /* ===== Font Definition (Unchanged as requested) ===== */
  /* ===== Font Definition (Unchanged as requested) ===== */
@font-face {
  font-family: 'Mardoto-Light';
  src: url('../../fonts/Mardoto-Light.ttf') format('truetype');
  font-weight: 300;
  font-style: normal;
  font-display: swap;
}

/* ===== Base Styles ===== */
html {
  font-size: 16px;
  background: var(--thelo-bg);
}
body {
  margin: 0;
  min-height: 100vh;
  height: 100vh;
  font-family: 'Mardoto-Light', system-ui, -apple-system, sans-serif;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  background-color: var(--thelo-bg);
  color: var(--thelo-text);
   -webkit-user-select: none; /* Safari */
  -moz-user-select: none;    /* Firefox */
  -ms-user-select: none;     /* IE10+/Edge */
  user-select: none;         /* Standard */
  -webkit-touch-callout: none; /* iOS Safari */
}
	/* ADD THIS RULE: Use Manrope font when the body has the 'lang-en' class */
body.lang-en {
  font-family: 'Manrope', system-ui, -apple-system, sans-serif;
}
	/* MCQ buttons blur when thelobook is active *//* ---------- AFTER ---------- */
.blurred-mcq {
    filter: blur(4px);
    opacity: 0.55;
    pointer-events: none;        /* clicks still ignored */
    z-index: 5 !important;       /* sits below thelobookCanvas (z-15) */
    transition: filter .2s, opacity .2s;
}


  /* ===== Layout & App Structure ===== */
  #app {
    display: flex;
    height: 100%;
    width: 100%;
    position: relative;
    flex-grow: 1;
  }
  #lessonArea {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    position: relative;
  }
  #boardWrap {
    position: relative;
    flex-grow: 1;
    overflow: visible; /* Changed from hidden to visible */
    background-color: var(--thelo-bg);
    /* Grid background */
    background-image: linear-gradient(to right, var(--thelo-border) 1px, transparent 1px),
      linear-gradient(to bottom, var(--thelo-border) 1px, transparent 1px);
    background-size: 40px 40px;
  }

  /* ===== Canvases & Overlays ===== */
  #stageProgressBarContainer {
    position: absolute;
    top: 30.1px;
    left: 2%;
    width: 96%;
    height: 2px;
    background-color: #cccccc;
    border-radius: 2px;
    z-index: 10;
    opacity: 0;
    visibility: hidden;
    transition: opacity var(--fade-duration) ease-in-out, visibility 0s linear var(--fade-duration);
  }
  #stageProgressBarContainer.visible {
    opacity: 1;
    visibility: visible;
    transition: opacity var(--fade-duration) ease-in-out, visibility 0s linear 0s;
  }
  #stageProgressFill {
    height: 100%;
    background-color: #000000;
    width: 0%;
    border-radius: 2px;
    transition: width 0.05s linear;
  }

  #backgroundCanvas,
  #replayCanvas,
  #board,
  #finalAnswerCanvas,
  #thelobookCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: block;
    background-color: transparent;
  }
  #backgroundCanvas {
    z-index: 1;
    pointer-events: none;
    opacity: 1;
    transition: opacity var(--fade-duration) ease-in-out;
  }
  #backgroundCanvas.fade-out {
    opacity: 0;
  }
  #replayCanvas {
    z-index: 2;
    pointer-events: none;
    opacity: 1;
    transition: opacity var(--fade-duration) ease-in-out;
  }
  #replayCanvas.fade-out {
    opacity: 0;
  }
  #board {
    z-index: 3;
    cursor: crosshair;
    touch-action: none;
  }
  #finalAnswerCanvas {
    z-index: 4;
    opacity: 0;
    pointer-events: none;
  }

  #thelobookCanvas {
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    z-index: 15;
    cursor: crosshair;
    touch-action: none;
    opacity: 0;
    visibility: hidden;
    transform: scale(0.95);
    transition: opacity var(--animation-duration) ease, visibility 0s linear var(--animation-duration),
      transform var(--animation-duration) ease;
  }
  #thelobookCanvas.active {
    opacity: 1;
    visibility: visible;
    transform: scale(1);
    transition-delay: 0s, 0s, 0s;
  }
  #thelobookCanvas.grid-underlay {
    opacity: 0.9 !important;
    transform: scale(1) !important;
  }
  #thelobookCanvas.eraser-active {
    cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="rgba(0,0,0,0.5)" d="M19.78,2.22a1,1,0,0,0-1.42,0L9.12,11.46a1,1,0,0,0,0,1.41L11.24,15A1,1,0,0,0,12.66,15L22.22,5.39A1,1,0,0,0,22.22,4L19.78,2.22ZM8.41,12.88,2,19.29V21a1,1,0,0,0,1,1H4.71l6.47-6.46-1.42-1.42A1,1,0,0,0,8.41,12.88Z"/></svg>')
      12 12, auto;
  }

  /* ===== UI Controls ===== */
  #bottomBar {
    position: absolute;
    bottom: 1rem;
    left: 1rem;
    right: 1rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    z-index: 20;
    gap: 0.75rem;
  }
  .control-btn {
    font-family: inherit;
    padding: 0.5rem 1rem;
    font-size: 0.9rem;
    font-weight: 500;
    border: none;
    border-radius: 0.5rem;
    color: var(--bg-white);
    cursor: pointer;
    transition: background-color 0.2s, transform 0.15s, box-shadow 0.2s;
    box-shadow: var(--shadow-md);
  }
  .control-btn:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: var(--shadow-lg);
  }
  .control-btn:disabled {
    background-color: #9ca3af !important;
    cursor: not-allowed;
    opacity: 0.7;
  }

  /* Button Colors */
  #prevBtn {
    background-color: var(--accent-yellow);
  }
  #thelobookBtn {
    background-color: var(--success-green);
  }
  #clearBtn {
    background-color: var(--error-red);
  }
  #nextCheckBtn {
    background-color: var(--thelo-blue);
  }
  #nextCheckBtn:hover:not(:disabled) {
    background-color: var(--thelo-blue-dark);
  }
  #nextCheckBtn.correct {
    background-color: var(--success-green);
  }
  #nextCheckBtn.incorrect {
    background-color: var(--error-red);
    animation: shake 0.5s ease-in-out;
  }
  @keyframes shake {
    0%,
    100% {
      transform: translateX(0);
    }
    25%,
    75% {
      transform: translateX(-5px);
    }
    50% {
      transform: translateX(5px);
    }
  }

  #colorIndicator,
  #pointsDisplay {
    background-color: var(--bg-white);
    border: 1px solid var(--thelo-border);
    color: var(--thelo-text);
    padding: 0.5rem 1rem;
    border-radius: 0.5rem;
    font-size: 0.85rem;
    font-weight: 500;
    box-shadow: var(--shadow-sm);
    white-space: nowrap;
  }

  /* MCQ Buttons */
  /* ===== UPDATED: MCQ Buttons ===== */
/* ---------- AFTER ---------- */
#mcqOptionsContainer {
    position: absolute;
    top: 50%;
    left: 50%; /* <-- CHANGE: Center the container */
    transform: translate(-50%, -50%); /* <-- CHANGE: Proper centering */
    z-index: 30;
    display: none;
    flex-direction: row;
    flex-wrap: wrap;
    justify-content: center; /* Can be center or flex-start */
    gap: 1rem;
    width: 90%; /* <-- CHANGE: Use a percentage for width */
    max-width: 1200px; /* <-- Optional: A sensible max-width for very large screens */
}

@media (max-width: 1024px) {
    .mcq-option-btn {
        font-size: 0.7rem;   /* or any size you prefer */
    }
}/* ===== NEW: Cozy Thelo MCQ Buttons ===== */
/* ===== NEW: Cozy Thelo MCQ Buttons ===== */
.mcq-option-btn {
    font-family: inherit;
    padding: 0.8rem 1.5rem;
    font-size: 1.1rem;
    font-weight: 600; /* Bolder font for better readability */
    border: 1px solid var(--thelo-border);
    background-color: #f9fafb; /* Softer, off-white background */
    color: var(--thelo-text);
    border-radius: 0.75rem;
    cursor: pointer;
    transition: all 0.2s ease-in-out; /* Smoother transition */
    box-shadow: var(--shadow-sm); /* A more subtle shadow */
    width: 100%;
    flex: 1 0 100%;
    white-space: nowrap;
    transform: translateY(0); /* Sits flush by default */
}

.mcq-option-btn:hover:not(:disabled) {
    transform: translateY(-3px); /* Lifts up on hover */
    box-shadow: var(--shadow-lg); /* A more prominent shadow on lift */
    color: var(--thelo-blue); /* Text becomes brand blue */
    border-color: #dbeafe; /* A very light blue border */
}
.mcq-option-btn.correct {
    background-color: var(--success-green);
    color: white;
    border-color: var(--success-green);
  }
  .mcq-option-btn.incorrect {
    background-color: var(--error-red);
    color: white;
    border-color: var(--error-red);
  }
  .mcq-option-btn.correct-answer-shown {
    border-color: var(--success-green);
    border-width: 2px;
  }

  /* ===== Chat Column ===== */
  #chatCol {
    width: 320px;
    display: flex;
    flex-direction: column;
    background: var(--bg-white);
    border-left: 1px solid var(--thelo-border);
    padding: 1rem;
    height: 100%;
    box-sizing: border-box;
  }
  #terminalLogo {
    height: 60px; /* UPDATED: Larger logo */
    width: auto;
    display: block;
    align-self: center;
    margin: 0.5rem 0 1.5rem 0;
  }
  #chat {
    flex: 1;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: var(--thelo-border) transparent;
  }
  #chat::-webkit-scrollbar {
    width: 5px;
  }
  #chat::-webkit-scrollbar-thumb {
    background-color: var(--thelo-border);
    border-radius: 10px;
  }
.ai-message {
  /* Your existing styles for ai-message */
  background-color: var(--bg-white);
  border: 1px solid #f0f0f0;
  color: var(--thelo-text);
  padding: 0.75rem 1rem;
  border-radius: 0.75rem;
  margin-bottom: 0.75rem;
  max-width: 95%;
  align-self: flex-start;
  word-wrap: break-word;
  box-shadow: var(--shadow-sm);
  font-size: 0.9rem;
  line-height: 1.6;

  /* --- NEW: Fade-in styles --- */
  opacity: 0; /* Start invisible */
  transform: translateY(10px); /* Slightly move from below */
  transition: opacity 0.3s ease-out, transform 0.3s ease-out; /* Smooth transition */
}

.ai-message.show {
  opacity: 1; /* Fade in to fully visible */
  transform: translateY(0); /* Move to its natural position */
} 
.ai-message strong {
    color: var(--thelo-blue);
    font-weight: inherit; /* This makes the weight consistent */
  }
  .ai-message .emoji {
    margin-right: 0.5rem;
  }

  /* ===== ADD THIS: For the new Dashboard button ===== */
#dashboardBtn {
    background-color: var(--thelo-blue); /* Use the primary brand color */
}

#dashboardBtn:hover:not(:disabled) {
    background-color: var(--thelo-blue-dark);
}

#dashboardBtn.visible {
    display: inline-flex !important;
    animation: pulse-glow 2s infinite ease-in-out;
}
/* ===== UI Controls ===== */
#bottomBar {
    position: absolute;
    bottom: 1rem;
    left: 1rem;
    right: 1rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    z-index: 20;
    gap: 0.75rem;
    /* ADD THIS LINE for smooth animation */
    transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1);
}

/* ADD THIS NEW RULE to define the hidden state */
#bottomBar.bar-hidden-by-stylus {
    transform: translateY(150%);
    pointer-events: none;
}
	/* ADD THIS CSS: For the Streak Modal */
#streakModal {
    position: fixed;
    z-index: 100;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.6);
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0.3s;
}
#streakModal:not(.modal-hidden) {
    opacity: 1;
    visibility: visible;
}
.streak-modal-content {
    background-color: var(--thelo-bg);
    color: var(--thelo-text);
    padding: 2rem 3rem;
    border-radius: 1rem;
    text-align: center;
    box-shadow: var(--shadow-lg);
    position: relative;
    transform: scale(0.9);
    transition: transform 0.3s ease;
}
#streakModal:not(.modal-hidden) .streak-modal-content {
    transform: scale(1);
}
.streak-modal-icon {
    font-size: 4rem;
    line-height: 1;
    margin-bottom: 1rem;    
}
.streak-modal-close {
    position: absolute;
    top: 0.5rem;
    right: 1rem;
    font-size: 1.75rem;
    font-weight: bold;
    color: var(--thelo-text-light);
    cursor: pointer;
}
#streakModalConfirmBtn {
    margin-top: 1.5rem;
    background-color: var(--accent-yellow);
}

@keyframes pulse-glow {
    0% {
        box-shadow: 0 0 5px rgba(37, 99, 235, 0.2), 0 0 7px rgba(37, 99, 235, 0.1);
    }
    50% {
        box-shadow: 0 0 15px rgba(37, 99, 235, 0.4), 0 0 25px rgba(37, 99, 235, 0.3);
    }
    100% {
        box-shadow: 0 0 5px rgba(37, 99, 235, 0.2), 0 0 7px rgba(37, 99, 235, 0.1);
    }
}

  /* ===== ADD THESE STYLES: For Image Terminal & Terminals ===== */
  #chat,
  #image-terminal {
    flex: 1;
    transition: opacity 0.3s ease-in-out;
    overflow: hidden;
    overflow-y: auto; /* Allow scrolling for chat */
  }
  #image-terminal {
    display: none; /* Start hidden */
    flex-direction: column;
    justify-content: flex-start;
    padding-top: 1rem;
    overflow: hidden; /* No scrollbar needed for image view */
  }
  #image-terminal-img-container img {
    max-width: 100%;
    border-radius: 0.75rem;
    box-shadow: var(--shadow-md);
  }
  #image-terminal-feedback {
    text-align: center;
    padding: 1.5rem 1rem;
    font-size: 1rem;
    font-weight: 500;
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
  }
  .terminal-hidden {
    opacity: 0 !important;
    display: none !important;
  }

  /* ===== ADD THESE STYLES: For Smarter MCQ Layouts ===== */
#mcqOptionsContainer.long-options {
    flex-direction: column;
    align-items: stretch;

    /* --- NEW FIT-TO-CONTENT LOGIC --- */

    /* This is the key change. It makes the container only as wide as its content needs to be. */
    width: fit-content; 
    
    /* A good practice to prevent it from overflowing on very small screens. */
    max-width: 92%; 

    /* This keeps the perfectly-sized container centered on the screen. */
    left: 50%;
    transform: translate(-50%, -50%); 
}
  #mcqOptionsContainer.short-options {
    flex-direction: row;
    flex-wrap: wrap;
    align-items: center;

    /* üëá Copy the fit-to-content layout logic from .long-options */
    width: fit-content;
    max-width: 92%;
    left: 50%;
    transform: translate(-50%, -50%);
}


  #mcqOptionsContainer.short-options .mcq-option-btn {
    padding: 1.2rem;
    font-size: 1rem;
    min-width: 80px;
    text-align: center;
  }

  /* ===== Thelobook & Grid View ===== */
  #thelobookControls,
  #thelobookPageGridHeader,
  #closePageGridBtn {
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    background-color: rgba(255, 255, 255, 0.7);
    border-radius: 9999px; /* pill shape */
    box-shadow: var(--shadow-md);
    border: 1px solid var(--thelo-border);
  }
  #thelobookControls {
    position: absolute;
    bottom: 2rem;
    left: 50%;
    transform: translateX(-50%);
    z-index: 25;
    padding: 0.5rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s, visibility 0.2s;
  }
  #thelobookControls.visible {
    opacity: 1;
    visibility: visible;
  }
  #thelobookControls button {
    background: transparent;
    border: none;
    font-size: 1.25rem;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: background-color 0.2s;
  }
  #thelobookControls button:hover:not(:disabled) {
    background-color: rgba(0, 0, 0, 0.05);
  }
  #thelobookControls button.active {
    background-color: var(--thelo-blue);
    color: white;
  }

  #thelobookPageGridView {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 40;
    display: flex;
    flex-direction: column;
    padding: 2rem 1rem 1rem; /* Increased top padding to push it down from the roof */
    box-sizing: border-box;
    opacity: 0;
    visibility: hidden;
    transform: scale(0.95);
    transition: opacity var(--animation-duration) ease, visibility 0s linear var(--animation-duration),
      transform var(--animation-duration) ease;
  }
  #thelobookPageGridView.visible {
    opacity: 1;
    visibility: visible;
    transform: scale(1);
    transition-delay: 0s;
  }

  #thelobookPageGridHeader {
    display: flex;
    justify-content: space-between; /* This correctly separates the text and button */
    align-items: center;
    margin-bottom: 1rem;
    padding: 0.5rem 1.5rem; /* Increased horizontal padding to prevent overlap */
    max-width: fit-content; /* Allow width to fit content and padding, not fixed 300px */
    align-self: center; /* Centers the header pill horizontally */
    gap: 1rem; /* Added gap between content and close button */
  }

  #pageGridBatchIndicator {
    white-space: nowrap; /* Prevent the text from wrapping unnecessarily */
  }

  #thelobookPageGridContentContainer {
    flex-grow: 1;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-content: flex-start;
    gap: 1rem;
    padding: 0.5rem;
    overflow-y: auto;
    max-height: calc(100vh - 150px);
    /* Removed background, border, and shadow to create a "natural background" effect */
  }

  .chat-image-container {
    padding: 0.5rem; /* Give a little space around the image */
    background-color: transparent;
    border: none;
    box-shadow: none;
  }

  .chat-image {
    max-width: 100%;
    border-radius: 0.75rem; /* Match the rounding of other elements */
    display: block; /* Prevents extra space below the image */
    box-shadow: var(--shadow-md); /* Add a subtle shadow to lift it */
  }
  .page-thumbnail {
    border: 1px solid var(--thelo-border);
    box-shadow: var(--shadow-sm);
    border-radius: 0.5rem;
  }
  .page-thumbnail:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-md);
  }
  #closePageGridBtn {
    border-radius: 50%;
    width: 36px;
    height: 36px;
    font-size: 1.1rem;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0; /* Ensure the close button doesn't shrink */
  }

  /* Animations for batch switching (removed, as no batches are allowed) */
  .page-grid-batch {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 1rem;
    width: 100%; /* Ensure it takes full width of content container */
    transition: none; /* No transition for batch switching */
  }

  /* Removed specific batch animation classes as they are no longer needed */

  @keyframes pageGridFadeIn {
    from {
      opacity: 0;
      transform: scale(0.95);
    }
    to {
      opacity: 1;
      transform: scale(1);
    }
  }

  #thelobookPageGridView.visible {
    animation: pageGridFadeIn var(--animation-duration) ease forwards;
  }

  /* Specific styling for the 'No Pages' scenario */
  #thelobookPageGridContentContainer:empty::before {
    content: 'No pages to display. Click "+" to add a new page.';
    color: var(--thelo-text-light);
    font-size: 1rem;
    text-align: center;
    margin-top: 2rem;
  }

  /* Responsive adjustments */
  @media (max-width: 768px) {
    #app {
      flex-direction: column-reverse;
    }
    #chatCol {
      width: 100%;
      height: 30vh;
      border-left: none;
      border-top: 1px solid var(--thelo-border);
    }
    #bottomBar {
      flex-wrap: wrap;
      justify-content: center;
    }
    #actionButtons {
      width: 100%;
      justify-content: center;
      order: 3;
    }
    #pointsDisplay,
    #colorIndicator {
      order: 1;
      margin-bottom: 0.5rem;
    }
    .control-btn {
      padding: 0.6rem 0.8rem;
      font-size: 0.8rem;
    }
    #stageProgressBarContainer {
      top: 0;
      height: 2px;
    }
  }
  /* ===== NEW: Tablet Immersive Mode ===== */
@media (min-width: 769px) and (max-width: 1200px) and (pointer: coarse) {
    /* (pointer: coarse) is key for detecting touch-first devices like tablets */
	/* ===== ENHANCEMENT: Prevent Palm Selection on Canvas ===== */
#boardWrap {
    /* Prevents the user from being able to select the canvas */
    -webkit-user-select: none; /* Safari */
    -moz-user-select: none;    /* Firefox */
    -ms-user-select: none;     /* IE */
    user-select: none;

    /* Disables the menu (copy/paste) that appears on long-press in Safari */
    -webkit-touch-callout: none;
}

    #app {
        /* Keep the flex layout but hide the chat column */
        flex-direction: row;
    }

    #chatCol {
        /* Completely hide the terminal */
        display: none !important;
    }

    #lessonArea {
        /* Make the whiteboard take up the full screen width */
        width: 100%;
        flex-basis: 100%;
        border-left: none; /* Remove border that separated it from the chat */
    }
  
}
  /* ===== NEW: Toast Notification System for Tablets ===== */
#toast-container {
    position: fixed;
    bottom: 20px; /* CHANGED from top */
    left: 50%;
    transform: translateX(-50%);
    z-index: 1000; /* Ensure it's on top of everything */
    display: flex;
    flex-direction: column-reverse; /* ADDED: To stack messages upwards */
    align-items: center;
    gap: 10px;
    width: clamp(300px, 80%, 600px); /* Responsive width */
    pointer-events: none; /* Clicks pass through the container */
}

.toast-message {
    font-family: 'Manrope', system-ui, -apple-system, sans-serif;
    font-size: 1rem;
    font-weight: 500;
    color: var(--thelo-text);
    background-color: rgba(255, 255, 255, 0.85);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 12px 20px;
    border-radius: 12px;
    box-shadow: var(--shadow-lg);
    border: 1px solid rgba(0,0,0,0.05);
    display: flex;
    align-items: center;
    gap: 12px; /* This gap for internal items (icon and text) is fine */
    pointer-events: all;
    cursor: pointer;
    
    /* --- Properties for the new smooth collapse animation --- */
    overflow: hidden; /* Hides the text as the toast's height shrinks */
    max-height: 100px; /* Starting height to animate from. Adjust if toasts are ever taller. */
    margin-top: 10px; /* This replaces the container's 'gap' and can be animated */
    opacity: 0; /* Toasts start invisible */
    
    /* Define the smooth transitions for exiting */
    transition: max-height 0.3s ease-in-out, opacity 0.3s ease-in-out, margin-top 0.3s ease-in-out, padding 0.3s ease-in-out;
}

/* This class will trigger the pop-in keyframe animation */
.toast-message.show {
    animation: toast-in 0.5s cubic-bezier(0.21, 1.02, 0.73, 1) forwards;
}

/* This new class will trigger the smooth collapse transition */
.toast-message.exiting {
    max-height: 0;
    opacity: 0;
    padding-top: 0;
    padding-bottom: 0;
    margin-top: 0;
}

/* This animation is for the entry of the toast */
@keyframes toast-in {
    from {
        opacity: 0;
        transform: translateY(25px) scale(0.9);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

.toast-message .emoji {
    font-size: 1.5rem;
}

/* Color coding for different message types */
.toast-message.toast-success {
    background-color: rgba(255, 255, 255, 0.6); /* New transparent white background */
¬† ¬† color: var(--thelo-text);   
}
.toast-message.toast-error {
    background-color: rgba(255, 255, 255, 0.6); /* New transparent white background */
¬† ¬† color: var(--thelo-text);   
}
.toast-message.toast-warning {
    background-color: rgba(255, 255, 255, 0.6); /* New transparent white background */
¬† ¬† color: var(--thelo-text);   
}

/* You might also want a rule for landscape tablets without the pointer check */
@media (min-width: 769px) and (max-width: 1200px) and (min-height: 500px) {
     #chatCol {
        display: none !important;
    }

    #lessonArea {
        width: 100%;
        flex-basis: 100%;
        border-left: none;
    }
}
/* >>> add once, after the existing #mcqOptionsContainer rules <<<  */
#mcqOptionsContainer.side-by-side {
    position: absolute;
    top: 50%;
    right: 4%;

    /* override the old centre‚Äëalignment props */
    left: auto !important;          /* kill ‚Äúleft:50%‚Äù                 */
    transform: translateY(-50%);    /* kill old translateX(-50%) part  */

    display: flex;
    flex-direction: column;
    gap: 1rem;

    width: 38vw;
    max-width: 420px;
}

/* make the buttons grow full width of the column */
#mcqOptionsContainer.side‚Äëby‚Äëside .mcq-option-btn{
    flex:0 0 auto;
    width:100%;
}
/* REPLACE the old #calculatorOverlay and #calculatorFrame rules with these */

#calculatorOverlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 50;
    display: flex;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    background-color: rgba(255, 255, 255, 0.5); /* Soft white background */
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0s linear 0.3s;
}

#calculatorFrame {
    /* This makes the iframe fill most of the overlay */
    width: 98%;
    height: 98%;
    border: none; /* The overlay provides the visual boundary */
    border-radius: 1rem;
    box-shadow: var(--shadow-lg);
}
/* ADD THIS NEW RULE */
.terminal-hidden-by-calculator {
    display: none !important;
}

#calculatorOverlay:not(.calculator-hidden) {
    opacity: 1;
    visibility: visible;
    transition-delay: 0s;
}


#calculatorCloseBtn {
    position: absolute;
    top: 2rem;
    right: 2rem;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: none;
    background-color: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    font-size: 1.2rem;
    cursor: pointer;
    box-shadow: var(--shadow-md);
    display: flex;
    align-items: center;
    justify-content: center;
}
	/* ===== NEW: Embedded Replay Player Styles ===== */

#replayPlayerContainer {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 5; /* Below UI controls, but above canvases */
    display: flex;
    align-items: center;
    justify-content: center;
    
    /* This pushes the iframe down from the top to leave space for the headline */
    padding-top: 70px; 
    box-sizing: border-box;

    /* Animation for smooth appearance */
    opacity: 0;
    visibility: hidden;
    transform: scale(0.95);
    transition: opacity 0.3s ease, visibility 0s linear 0.3s, transform 0.3s ease;
}

#replayPlayerContainer:not(.replay-hidden) {
    opacity: 1;
    visibility: visible;
    transform: scale(1);
    transition-delay: 0s;
}

#replayFrame {
    width: 90%;
    height: 80%;
    max-width: 1200px;
    max-height: 700px;
    border: 1px solid rgba(0, 0, 0, 0.05); /* A slightly darker, more subtle border */
    border-radius: 1rem;
    box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.07); /* The new inset shadow */
    background-color: var(--thelo-bg); /* Ensures it has a solid background */
}
</style>
</head>
<body>
    <div id="loading-overlay">
        <img src="https://thelo.space/img/bluethelo.svg" alt="Loading Thelo..." id="loading-svg">
    </div>
    <div id="app">
        <div id="lessonArea">
            <div id="boardWrap">
                <div id="stageProgressBarContainer"><div id="stageProgressFill"></div></div>
                <canvas id="backgroundCanvas"></canvas>
                <canvas id="replayCanvas"></canvas>
                <canvas id="board"></canvas>
                <canvas id="finalAnswerCanvas"></canvas>
                <canvas id="thelobookCanvas"></canvas>
		<div id="calculatorOverlay" class="calculator-hidden">
                <iframe id="calculatorFrame" src="about:blank" allow="clipboard-write"></iframe>
                <button id="calculatorCloseBtn" title="Close Calculator">‚úï</button>
            </div>
		    <div id="replayPlayerContainer" class="replay-hidden">
			<iframe id="replayFrame" src="about:blank"></iframe>
		</div>
                <div id="thelobookControls">
                    <button id="thelobookPrevPageBtn" title="Previous Page">‚Äπ</button>
                    <span id="thelobookPageIndicator">Page 1 / 1</span>
                    <button id="thelobookNextPageBtn" title="Next Page">‚Ä∫</button>
                    <button id="thelobookEraserBtn" title="Eraser">‚úèÔ∏è</button>
                    <button id="thelobookAddPageBtn" title="Add New Page">+</button>
                </div>

                <div id="thelobookPageGridView">
                    <div id="thelobookPageGridHeader">
                        <span id="pageGridBatchIndicator">Pages 1-32</span>
                        <button id="closePageGridBtn" title="Close Grid">‚úï</button>
                    </div>
                    <div id="thelobookPageGridContentContainer">
                    </div>
                </div>

                <div id="mcqOptionsContainer" style="display: none;"></div>
            </div>

            <div id="bottomBar">
                <div id="colorIndicator"></div>
                <div id="pointsDisplay"></div>
                <div id="actionButtons">
    <button id="prevBtn" class="control-btn"></button>
    <button id="thelobookBtn" class="control-btn"></button>
    <button id="clearBtn" class="control-btn"></button>
    <button id="nextCheckBtn" class="control-btn"></button>
    <button id="dashboardBtn" class="control-btn" style="display: none;"></button>
</div>
            </div>
        </div>
        <div id="chatCol">
            <img src="https://thelo.space/img/bluethelo.svg" alt="Thelo AI Logo" id="terminalLogo">
            <div id="chat"></div>
			<div id="image-terminal" class="terminal-hidden">
				<div id="image-terminal-img-container"></div>
				<div id="image-terminal-feedback"></div>
			</div>
        </div>
    </div>
    <div id="toast-container"></div>
    <div id="audioContainer" style="display: none;">
        <audio id="audio_approve1_hy" src="https://pha.am/audios/approve1.ogg" preload="auto"></audio>
        <audio id="audio_approve2_hy" src="https://pha.am/audios/approve2.ogg" preload="auto"></audio>
        <audio id="audio_dis1_hy" src="https://pha.am/audios/dis1.ogg" preload="auto"></audio>
        <audio id="audio_dis2_hy" src="https://pha.am/audios/dis2.ogg" preload="auto"></audio>
        <audio id="audio_approve1_en" src="https://pha.am/audios/engcorr1.wav" preload="auto"></audio>
        <audio id="audio_approve2_en" src="https://pha.am/audios/engcorr2.wav" preload="auto"></audio>
        <audio id="audio_dis1_en" src="https://pha.am/audios/engwrong1.wav" preload="auto"></audio>
        <audio id="audio_dis2_en" src="https://pha.am/audios/engwrong2.wav" preload="auto"></audio>
        <audio id="stageAudioPlayer"></audio>
        <audio id="gotItSound" src="https://pha.am/audios/corr.mp3" preload="auto"></audio>
    </div>
        <script>
    const firebaseConfig = { apiKey: "AIzaSyAbnPpcIt88B0jIAoLUdC71zmQDvR_fdu8", authDomain: "physmathacademy-722b3.firebaseapp.com", databaseURL: "https://physmathacademy-722b3-default-rtdb.firebaseio.com", projectId: "physmathacademy-722b3", storageBucket: "physmathacademy-722b3.appspot.com", messagingSenderId: "1093640992262", appId: "1:1093640992262:web:35b1bf4d2364bcf745f587" };
    firebase.initializeApp(firebaseConfig);


¬† ¬† const auth = firebase.auth();
    const db = firebase.firestore();

    // =================================================================
    //  NEW FIX: Set auth persistence to 'session' to work around
    //  potential browser storage restrictions.
    // =================================================================
    auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL)
        .catch((error) => {
            console.error("Auth persistence error:", error.code, error.message);
        });

    const INK_COLORS = { black: '#000000', blue: getComputedStyle(document.documentElement).getPropertyValue('--ink-blue').trim() || '#2563eb' };

    const UI_TEXT = {
        hy: {
            next: "’Ä’°’ª’∏÷Ä’§’®", gotIt: "’Ä’°’Ω’Ø’°÷Å’°!", check: "’ç’ø’∏÷Ç’£’•’¨", checking: "’ç’ø’∏÷Ç’£’æ’∏÷Ç’¥ ’ß...",
            correct: "’É’´’∑’ø ’ß÷â", incorrect: "’ç’≠’°’¨ ’ß", apiKeyInvalid: "API ’¢’°’∂’°’¨’´’∂ ’°’∂’æ’°’æ’•÷Ä ’ß",
            inkBlack: "‘≥’∏÷Ç’µ’∂’ù ’ç÷á", inkBlue: "‘≥’∏÷Ç’µ’∂’ù ‘ø’°’∫’∏÷Ç’µ’ø", loading: "‘≤’•’º’∂’æ’∏÷Ç’¥ ’ß...",
            clear: "’Ñ’°÷Ñ÷Ä’•’¨", start: "’ç’Ø’Ω’•’¨", prev: "’Ü’°’≠’∏÷Ä’§",
            welcome: "’à’≤’ª’∏÷Ç’õ’µ’∂÷â ’ç’•’≤’¥’´÷Ä ’ç’Ø’Ω’•’¨ ’§’°’Ω’® ’Ω’Ø’Ω’•’¨’∏÷Ç ’∞’°’¥’°÷Ä÷â ’ç’•’≤’¥’´÷Ä <strong>'A'</strong> ’Ø’°’∫’∏÷Ç’µ’ø’∏’æ ’¥’´’°’µ’∂ ’∫’°’ø’°’Ω’≠’°’∂’® ’∂’∑’•’¨’∏÷Ç ’∞’°’¥’°÷Ä÷â",
            checkingAI: `’ç’ø’∏÷Ç’£’∏÷Ç’¥ ’•’¥ ÷Ñ’∏ <strong style="color:${INK_COLORS.blue};">’Ø’°’∫’∏÷Ç’µ’ø’∏’æ</strong> ’£÷Ä’æ’°’Æ ’∫’°’ø’°’Ω’≠’°’∂’®...`,
            blankBlueWarning: `‚ö†Ô∏è ‘ø’°÷Ä’Æ’•’Ω ’©’• ’∫’°’ø’°’Ω’≠’°’∂’® <strong style="color:${INK_COLORS.blue};">’Ø’°’∫’∏÷Ç’µ’ø’∏’æ</strong> ’π’•’Ω ’∂’∑’•’¨÷â ’ç’•’≤’¥’´÷Ä 'A' ’Ω’ø’•’≤’∂’® ’£’∏÷Ç’µ’∂’® ÷É’∏’≠’•’¨’∏÷Ç ’∞’°’¥’°÷Ä÷â`,
            noTextFound: `‚ö†Ô∏è <strong style="color:${INK_COLORS.blue};">‘ø’°’∫’∏÷Ç’µ’ø’∏’æ</strong> ’£÷Ä’æ’°’Æ’´÷Å ’ø’•÷Ñ’Ω’ø ’π’£’ø’∂’æ’•÷Å÷â ’ì’∏÷Ä’±’´÷Ä ’£÷Ä’•’¨ ’°’æ’•’¨’´ ’∫’°÷Ä’¶÷â`,
            noDigitsFound: `‚ö†Ô∏è ‘ø’°÷Ä’Æ’•’Ω ’©’• <strong style="color:${INK_COLORS.blue};">’Ø’°’∫’∏÷Ç’µ’ø’∏’æ</strong> ’©’´v ’π’•÷Ñ ’£÷Ä’•’¨÷â (’É’°’∂’°’π’æ’°’Æ ’ø’•÷Ñ’Ω’ø’ù {detectedText})`,
            correctAI: `üéâ ’É’´’∑’ø ’ß Google Vision-’´ ’Ø’°÷Ä’Æ’´÷Ñ’∏’æ÷â (‘¥’∏÷Ç÷Ñ ’£÷Ä’•’¨ ’ß’´÷Ñ <strong>{detectedAnswer}</strong>)`,
            incorrectAI: `ü§î ’ç’≠’°’¨ ’ß÷â Google Vision-’® <strong style="color:${INK_COLORS.blue};">’Ø’°’∫’∏÷Ç’µ’ø</strong> ’£÷Ä’æ’°’Æ÷Ñ’´÷Å ’Ø’°÷Ä’§’°÷Å <strong>{detectedAnswer}</strong>, ’¢’°’µ÷Å ’≥’´’∑’ø ’∫’°’ø’°’Ω’≠’°’∂’∂ ’ß <strong>{correctAnswer}</strong>÷â ’ì’∏÷Ä’±’´÷Ä ’Ø÷Ä’Ø’´’∂÷â`,
            parsingError: `‚ö†Ô∏è ’â’Ø’°÷Ä’∏’≤’°÷Å’° <strong style="color:${INK_COLORS.blue};">’Ø’°’∫’∏÷Ç’µ’ø</strong> ’£÷Ä’æ’°’Æ÷Ñ’´÷Å ’©’´’æ’® ’≥’°’∂’°’π’•’¨÷â (’É’°’∂’°’π’æ’°’Æ ’ø’•÷Ñ’Ω’ø’ù {detectedText})`,
            imageDataError: `‚ùå ’ç’≠’°’¨’ù ’π’∞’°’ª’∏’≤’æ’•÷Å ’Ω’ø’°’∂’°’¨ ’∂’Ø’°÷Ä’® ’£÷Ä’°’ø’°’≠’ø’°’Ø’´÷Å÷â ({errorMessage})`,
            apiErrorGeneral: `‚ùå ’ç’≠’°’¨ ’ø’•’≤’´ ’∏÷Ç’∂’•÷Å’°’æ ’Ω’ø’∏÷Ç’£’¥’°’∂ ’™’°’¥’°’∂’°’Ø÷â ({errorMessage})`,
            apiKeyPermissionError: '‚ùå ’ç’≠’°’¨’ù API ’¢’°’∂’°’¨’´’∂ ’°’∂’æ’°’æ’•÷Ä ’ß ’Ø’°’¥ ’©’∏÷Ç’µ’¨’ø’æ’∏÷Ç’©’µ’∏÷Ç’∂ ’π’∏÷Ç’∂’´÷â ’ç’ø’∏÷Ç’£’•÷Ñ ’¢’°’∂’°’¨’´’∂ ÷á ’∞’°’¥’∏’¶’æ’•÷Ñ, ’∏÷Ä Vision API-’∂ ’¥’´’°÷Å’æ’°’Æ ’ß÷â',
            apiBillingError: '‚ùå ’ç’≠’°’¨’ù ’Ä’°’∑’æ’°÷Ä’Ø’¥’°’∂ (billing) ’≠’∂’§’´÷Ä÷â ’ç’ø’∏÷Ç’£’•÷Ñ, ’∏÷Ä ’°’µ’∂ ’¥’´’°÷Å’æ’°’Æ ’ß ’±’•÷Ä Google Cloud ’∂’°’≠’°’£’Æ’´ ’∞’°’¥’°÷Ä÷â',
            apiKeyMissingWarning: 'üõë **‘ø‘±’ê‘µ’é’à’ê:** Google Vision API ’¢’°’∂’°’¨’´’∂ ’Ω’≠’°’¨ ’ß ’Ø’°’¥ ’¢’°÷Å’°’Ø’°’µ’∏÷Ç’¥ ’ß÷â ‘Ω’∂’§÷Ä’∏÷Ç’¥ ’•’∂÷Ñ ÷É’∏’≠’°÷Ä’´’∂’•’¨ ’°’µ’∂÷â ‘±’º’°’∂÷Å ’§÷Ä’°, ’±’•’º’°’£÷Ä’´ ’Ω’ø’∏÷Ç’£’∏÷Ç’¥’® ’π’´ ’°’∑’≠’°’ø’´÷â',
            lessonComplete: "‘¥’°’Ω’∂ ’°’æ’°÷Ä’ø’æ’°’Æ ’ß÷â ’á’°’ø ’¨’°’æ ’°’∑’≠’°’ø’°’∂÷Ñ÷â",
            drawActivityWarning: "‚ö†Ô∏è ‘Ω’∂’§÷Ä’∏÷Ç’¥ ’•’¥, ’∂’°’≠ ÷É’∏÷Ä’±’´÷Ä ’∂’Ø’°÷Ä’•’¨÷â",
            achievementsPrefix: "üìö ",
            blueInkErased: "‘ø’°’∫’∏÷Ç’µ’ø ’£÷Ä’æ’°’Æ÷Ñ’® (’∫’°’ø’°’Ω’≠’°’∂’®) ’¥’°÷Ñ÷Ä’æ’°’Æ ’ß÷â",
            authErrorVision: "‘±’æ’ø’∏÷Ä’´’¶’°÷Å’´’°’µ’´ ’Ω’≠’°’¨÷â ‘Ω’∂’§÷Ä’∏÷Ç’¥ ’•’∂÷Ñ ’¥’∏÷Ç’ø÷Ñ ’£’∏÷Ä’Æ’•’¨’ù ’°’µ’Ω ’£’∏÷Ä’Æ’°’º’∏÷Ç’µ’©’∂ ÷Ö’£’ø’°’£’∏÷Ä’Æ’•’¨’∏÷Ç ’∞’°’¥’°÷Ä÷â",
            lessonFileMissing: '’ç’≠’°’¨÷â ‘¥’°’Ω’´ ÷Ü’°’µ’¨’® ’∂’∑’æ’°’Æ ’π’ß URL-’∏÷Ç’¥÷â',
            lessonLoadErrorGeneric: "‘¥’°’Ω’® ’¢’•’º’∂’•’¨’∏÷Ç ’Ω’≠’°’¨÷â\n‘Ω’∂’§÷Ä’∏÷Ç’¥ ’•’∂÷Ñ ’æ’•÷Ä’°’§’°’º’∂’°’¨ ÷á ’∂’∏÷Ä’´÷Å ÷É’∏÷Ä’±’•’¨÷â",
            userNotAuthHandwriting: '‚ö†Ô∏è ’ï’£’ø’°’ø’•÷Ä’® ’∂’∏÷Ç’µ’∂’°’Ø’°’∂’°÷Å’æ’°’Æ ’π’ß: ‘Ω’∂’§÷Ä’∏÷Ç’¥ ’•’∂÷Ñ ’¥’∏÷Ç’ø÷Ñ ’£’∏÷Ä’Æ’•’¨ ’±’•’º’°’£÷Ä’´ ’æ’•÷Ä’¨’∏÷Ç’Æ’∏÷Ç’©’µ’°’∂ ’£’∏÷Ä’Æ’°’º’∏÷Ç’µ’©’∂ ÷Ö’£’ø’°’£’∏÷Ä’Æ’•’¨’∏÷Ç ’∞’°’¥’°÷Ä:',
            pointsGained: "+{points} ’¥’´’°’æ’∏÷Ä ’±’•’º÷Ñ ’¢’•÷Ä’æ’•÷Å÷â", error: "’ç’≠’°’¨", titleDefaultHy: "Thelo AI ‘≥÷Ä’°’ø’°’≠’ø’°’Ø",
            thelobookOpen: "‘π’•’¨’∏’£’´÷Ä÷Ñ", thelobookClose: "’ì’°’Ø’•’¨", thelobookInk: "‘≥’∏÷Ç’µ’∂’ù ’ç÷á (’Ü’∑’∏÷Ç’¥’∂’•÷Ä)",
            thelobookEraser: "’ã’∂’ª’´’π", thelobookPen: "‘≥÷Ä’´’π",
            thelobookDisabledMCQ: "‘π’•’¨’∏’£’´÷Ä÷Ñ’® ’∞’°’Ω’°’∂’•’¨’´ ’π’ß ’∞’°÷Ä÷Å’°’∑’°÷Ä’´ ’™’°’¥’°’∂’°’Ø÷â",
            thelobookPagesBtn: "‘∑’ª’•÷Ä",
            thelobookPageIndicator: "‘∑’ª {currentPage} / {totalPages}",
            pageGridBatchIndicator: "‘∑’ª’•÷Ä {startPage}-{endPage}",
            pageGridInstructions: "’ç’•’≤’¥’•÷Ñ 'C' ’∞’°’ª’∏÷Ä’§ ’≠’¥’¢’´ ’∞’°’¥’°÷Ä, 'X' ’∂’°’≠’∏÷Ä’§’´÷â",
            addPage: "‘±’æ’•’¨’°÷Å’∂’•’¨ ’ß’ª",
	    viewDashboard: "’è’•’Ω’∂’•’¨ ’°’º’°’ª’®’∂’©’°÷Å’®", // ADD THIS LINE
	    limitReached: "‘¥’∏÷Ç÷Ñ ’£’•÷Ä’°’¶’°’∂÷Å’•’¨ ’•÷Ñ ’±’•÷Ä ’°’¥’Ω’°’Ø’°’∂ ’æ’•÷Ä’¨’∏÷Ç’Æ’∏÷Ç’©’µ’∏÷Ç’∂’∂’•÷Ä’´ ’Ω’°’∞’¥’°’∂’°’π’°÷É’®÷â ‘Ω’∂’§÷Ä’∏÷Ç’¥ ’•’∂÷Ñ ÷É’∏÷Ä’±’•’¨ ’Ø÷Ä’Ø’´’∂ ’∞’°’ª’∏÷Ä’§ ’°’¥’´’Ω÷â"
},
		
       en: {
  next: "Next",
  gotIt: "Got it",
  check: "Check Answer",
  checking: "Checking your answer...",
  correct: "That's right!",
  incorrect: "Not quite.",

  apiKeyInvalid: "Your key doesn‚Äôt seem to be working. Please check and try again.",

  inkBlack: "Ink: Black",
  inkBlue: "Ink: Blue",
  loading: "Loading...",
  clear: "Clear",
  start: "Start",
  prev: "Previous",

  welcome: "Welcome! Press Start to begin. To write your answer in blue, press <strong>'A'</strong>.",
  checkingAI: `Looking at your answer in <strong style="color:${INK_COLORS.blue};">blue</strong>...`,
  blankBlueWarning: `It looks like there's no answer in <strong style="color:${INK_COLORS.blue};">blue</strong>. Press 'A' to change your ink color.`,
  noTextFound: `I couldn‚Äôt find any writing in <strong style="color:${INK_COLORS.blue};">blue</strong>. Try writing a bit more clearly.`,
  noDigitsFound: `I didn‚Äôt see a number written in <strong style="color:${INK_COLORS.blue};">blue</strong>. (Detected text: {detectedText})`,

  correctAI: `Looks good to me! You wrote: <strong>{detectedAnswer}</strong>`,
  incorrectAI: `I saw <strong>{detectedAnswer}</strong>, but the correct answer is <strong>{correctAnswer}</strong>. Try again.`,
  parsingError: `I had trouble reading a number from your answer. (Detected: {detectedText})`,

  imageDataError: `Couldn't get the image from the board. ({errorMessage})`,
  apiErrorGeneral: `Something went wrong while checking your answer. ({errorMessage})`,
  apiKeyPermissionError: "Your key may be missing permissions. Make sure everything‚Äôs set up properly.",
  apiBillingError: "There seems to be a billing issue. Check your payment settings.",
  apiKeyMissingWarning: "Important: A valid key is missing. Handwriting checking won't work until it‚Äôs added.",

  lessonComplete: "Lesson complete! Nice work.",
  drawActivityWarning: "Please try drawing something first.",
  achievementsPrefix: "üèÜ ",

  blueInkErased: "Your blue ink answer has been erased.",
  authErrorVision: "Please log in to use this feature.",
  lessonFileMissing: "Lesson file not found. Check the link and try again.",
  lessonLoadErrorGeneric: "There was a problem loading the lesson. Please try again.",
  userNotAuthHandwriting: "You're not logged in. Please log in to use handwriting analysis.",

  pointsGained: "+{points} points earned!",
  error: "Error",
  titleDefaultEn: "Thelo AI Whiteboard",

  thelobookOpen: "thelobook",
  thelobookClose: "Close",
  thelobookInk: "Ink: Black (Notes)",
  thelobookEraser: "Eraser",
  thelobookPen: "Pen",
  thelobookDisabledMCQ: "thelobook is disabled during multiple choice questions.",
  thelobookPagesBtn: "Pages",
  thelobookPageIndicator: "Page {currentPage} of {totalPages}",
  pageGridBatchIndicator: "Pages {startPage}‚Äì{endPage}",
  pageGridInstructions: "Press 'C' for next batch, 'X' for previous batch.",
  addPage: "Add Page",

  viewDashboard: "View Your Progress",
  limitReached: "You've reached your monthly handwriting check limit. Try again next month.",
}

    };

    let currentLang = 'en';
    /* ========================================================================= */
/* ===== ADD THIS BLOCK: For Weekly Streak Calculation ===================== */
/* ========================================================================= */

/**
 * Calculates the ISO 8601 week number for a given date.
 * A week starts on Monday. This is robust against timezone issues.
 * @param {Date} date The date to calculate the week for.
 * @returns {string} The week identifier in "YYYY-Www" format (e.g., "2025-W26").
 */
function getISOWeekIdentifier(date) {
    // Create a new date object to avoid modifying the original
    const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
    // Set to the nearest Thursday: current date + 4 - current day number
    // Make Sunday's day number 7
    d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
    // Get first day of year
    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    // Calculate full weeks to nearest Thursday
    const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
    // Pad week number with a leading zero if needed
    const weekString = String(weekNo).padStart(2, '0');
    
    return `${d.getUTCFullYear()}-W${weekString}`;
}

/**
 * Gets the week identifier for the week immediately preceding the given one.
 * @param {string} weekId A week identifier like "2025-W26".
 * @returns {string} The previous week's identifier, e.g., "2025-W25".
 */
function getPreviousWeekIdentifier(weekId) {
    const [year, week] = weekId.split('-W').map(Number);
    if (week > 1) {
        const prevWeekString = String(week - 1).padStart(2, '0');
        return `${year}-W${prevWeekString}`;
    } else {
        // This is tricky: the last week of the previous year can be 52 or 53.
        // We'll calculate it based on the last day of the previous year.
        const lastDayOfPrevYear = new Date(year - 1, 11, 31);
        return getISOWeekIdentifier(lastDayOfPrevYear);
    }
}

    /* ========== DOM Elements ========== */
    const backgroundCanvas = document.getElementById('backgroundCanvas');
    const replayCanvas = document.getElementById('replayCanvas');
    const canvas = document.getElementById('board');
    const loadingOverlay = document.getElementById('loading-overlay'); // <-- ADD THIS
    const finalAnswerCanvas = document.getElementById('finalAnswerCanvas');
    const thelobookCanvas = document.getElementById('thelobookCanvas');
    const boardWrapper = document.getElementById('boardWrap');
    const stageAudioPlayer = document.getElementById('stageAudioPlayer');
    const gotItSoundPlayer = document.getElementById('gotItSound');
    const mcqOptionsContainer = document.getElementById('mcqOptionsContainer');
    const bottomBar = document.getElementById('bottomBar');
    const stageProgressBarContainer = document.getElementById('stageProgressBarContainer');
    const stageProgressFill = document.getElementById('stageProgressFill');
	const imageTerminal = document.getElementById('image-terminal');
	const imageTerminalImgContainer = document.getElementById('image-terminal-img-container');
	const imageTerminalFeedback = document.getElementById('image-terminal-feedback');

    const bgCtx = backgroundCanvas.getContext('2d');
    let replayCtx = null;
    const ctx = canvas.getContext('2d');
    const finalCtx = finalAnswerCanvas.getContext('2d');
    let thelobookCtx = null;

    const prevBtn = document.getElementById('prevBtn');
    const nextCheckBtn = document.getElementById('nextCheckBtn');
    const clearBtn = document.getElementById('clearBtn');
    const thelobookBtn = document.getElementById('thelobookBtn');
    const chatArea = document.getElementById('chat');
    const chatCol = document.getElementById('chatCol'); // <-- ADD THIS LINE
    const colorIndicator = document.getElementById('colorIndicator');
    if (colorIndicator){ colorIndicator.addEventListener('click', () => { toggleColor(); }); }
    const pointsDisplayElement = document.getElementById('pointsDisplay');
const dashboardBtn = document.getElementById('dashboardBtn'); // ADD THIS LINE

    const thelobookControlsEl = document.getElementById('thelobookControls');
    const thelobookPagesBtn = document.getElementById('thelobookPagesBtn');
    const thelobookPrevPageBtn = document.getElementById('thelobookPrevPageBtn');
    const thelobookNextPageBtn = document.getElementById('thelobookNextPageBtn');
    const thelobookPageIndicatorEl = document.getElementById('thelobookPageIndicator');
    const thelobookEraserBtn = document.getElementById('thelobookEraserBtn');
    const thelobookAddPageBtn = document.getElementById('thelobookAddPageBtn');
    const calculatorOverlay = document.getElementById('calculatorOverlay');
    const calculatorFrame = document.getElementById('calculatorFrame');
    const calculatorCloseBtn = document.getElementById('calculatorCloseBtn');
	const replayPlayerContainer = document.getElementById('replayPlayerContainer');
	const replayFrame = document.getElementById('replayFrame');
    const audioElements = {};
    const approveSounds_hy = []; const disapproveSounds_hy = [];
    const approveSounds_en = []; const disapproveSounds_en = [];

    /* ========== State Variables ========== */
    let isAuthReady = false;
          let isTabletMode = false;
	let isCalculatorActive = false;
	let isReplayActive = false;
	let isPageGridVisible = false; 
        let lessonStartTime = null;
    let lessonStagesRoot = null; let lessonStages = []; let isLessonLoading = false;
    let isImageModeActive = false;
    let currentStageIndex = -1; let currentStageData = null; let isStudentInputAllowed = false;
    let drawing = false; let lastPos = { x: 0, y: 0 }; let currentColor = 'black';
    let userDrawingOccurred = false; let isTransitioning = false;
    let devicePixelRatio = window.devicePixelRatio || 1; window.userInteracted = false;
    let currentReplayAnimationId = null; let currentStageAudio = null; 
    let userPoints = 0;
    let sessionPoints = 0; // ADDED LINE: To track points for the current lesson session.
    let currentStageDrawingData = null; let currentStageTotalDuration = 0;
    let isMediaScrubbingActive = false; let internalPlaybackTime = 0; let lastFrameTimestampForManualAdvance = 0;
    let isThelobookActive = false; let wasMediaPlayingBeforeThelobook = false;
    let mediaPlaybackTimeBeforeThelobook = 0; let audioTimeBeforeThelobook = 0;
    let thelobookPages = []; let currentThelobookPageIndex = 0;
    let thelobookDrawListenersAttached = false;
    let isThelobookEraserActive = false;
    const THELOBOOK_ERASER_LINEWIDTH = 20;
    const THELOBOOK_PEN_LINEWIDTH = 3;
    let isPageSwitchingAnimation = false;
    const PAGES_PER_GRID_BATCH = 32;
    let tempFullPageCanvasForThumbnails = null;
    let buttonVanishTimer = null;
    let stagesWithPointsAwarded = new Set();
    let mousePoints = []; // <<< ADD THIS LINE
    /* ========== Language Functions ========== */
    function getCurrentUIText() { return UI_TEXT[currentLang] || UI_TEXT['hy']; }
    function updateAllUITexts() {
        const TXT = getCurrentUIText();
        document.documentElement.lang = currentLang;

        if (prevBtn) prevBtn.textContent = TXT.prev;
        if (clearBtn) clearBtn.textContent = TXT.clear;
        if (thelobookBtn) thelobookBtn.textContent = isThelobookActive ? TXT.thelobookClose : TXT.thelobookOpen;

        if (thelobookAddPageBtn) thelobookAddPageBtn.title = TXT.addPage;
        if (thelobookEraserBtn) thelobookEraserBtn.title = isThelobookEraserActive ? TXT.thelobookPen : TXT.thelobookEraser;
        if (thelobookPagesBtn) thelobookPagesBtn.title = TXT.thelobookPagesBtn;
        if (thelobookPrevPageBtn) thelobookPrevPageBtn.title = TXT.prevPage;
        if (thelobookNextPageBtn) thelobookNextPageBtn.title = TXT.nextPage;

        updateColorIndicator();
        updatePointsDisplay();
        if(isThelobookActive && !isPageGridVisible) updateThelobookPageControls();


        if (lessonStagesRoot && lessonStagesRoot.lessonTitle) {
            document.title = lessonStagesRoot.lessonTitle || TXT[`titleDefault${currentLang.charAt(0).toUpperCase() + currentLang.slice(1)}`];
        } else {
            document.title = TXT[`titleDefault${currentLang.charAt(0).toUpperCase() + currentLang.slice(1)}`];
        }
        
        if (currentStageIndex === -1 && lessonStages.length > 0 && nextCheckBtn) { nextCheckBtn.textContent = TXT.start; }
        else if (isLessonLoading && nextCheckBtn) { nextCheckBtn.textContent = TXT.loading; }
        else if (currentStageData && nextCheckBtn) {
                if (currentStageData.type === 'question_handwriting') {
                    if (nextCheckBtn.classList.contains('correct')) { nextCheckBtn.textContent = TXT.correct; }
                    else if (nextCheckBtn.classList.contains('incorrect')) { nextCheckBtn.textContent = TXT.check; }
                    else if (nextCheckBtn.textContent === UI_TEXT.hy.checking || nextCheckBtn.textContent === UI_TEXT.en.checking ) { /* Keep "Checking..." */ }
                    else { nextCheckBtn.textContent = TXT.check; }
                } else {
                    const mcqDetails = currentStageData.optionsQuiz;
                    const isMCQDisplayStage = currentStageData.type === "explanation_with_mcq" && mcqDetails && Array.isArray(mcqDetails.choices) && mcqDetails.choices.length > 0;
                    if (!isMCQDisplayStage) {
                        if (nextCheckBtn.classList.contains('correct')) { nextCheckBtn.textContent = TXT.correct; }
                        else { nextCheckBtn.textContent = TXT.gotIt; }
                    }
                }
        }

        if (currentStageData) {
            if (!isTransitioning && !isLessonLoading) renderStageUI(currentStageIndex, true);
        }
    }
    function setLanguage(lang) {
¬† ¬† ¬† ¬† if (UI_TEXT[lang]) {
¬† ¬† ¬† ¬† ¬† ¬† if (currentLang !== lang) { currentLang = lang; console.log(`Language set to: ${currentLang} by lesson file.`); }
¬† ¬† ¬† ¬† ¬† ¬† else { console.log(`Language already set to: ${currentLang}. Forcing UI text update.`); }
¬† ¬† ¬† ¬† } else {
¬† ¬† ¬† ¬† ¬† ¬† console.warn(`Language ${lang} from lesson file not supported. Defaulting to 'hy'.`);
¬† ¬† ¬† ¬† ¬† ¬† currentLang = 'hy';
¬† ¬† ¬† ¬† }
		// Add or remove the language-specific class on the body
		if (currentLang === 'en') {
			document.body.classList.add('lang-en');
		} else {
			document.body.classList.remove('lang-en');
		}
		updateAllUITexts();
¬† ¬† }

    /* ========== Core App Functions ========== */
    function updatePointsDisplay() {
¬† ¬† ¬† ¬† const TXT = getCurrentUIText();
¬† ¬† ¬† ¬† // MODIFIED: This now uses sessionPoints for the on-screen display.
¬† ¬† ¬† ¬† if (pointsDisplayElement) pointsDisplayElement.textContent = `${TXT.achievementsPrefix}${sessionPoints}`;
¬† ¬† }
    async function loadLesson(lessonJsonPath) {
    if (isLessonLoading) return;
    isLessonLoading = true;
    if (prevBtn) prevBtn.disabled = true;
    if (dashboardBtn) dashboardBtn.style.display = 'none';
    if (isThelobookActive) closeThelobook(false);
    if (isPageGridVisible) closePageGridView();

    try {
        const response = await fetch(lessonJsonPath);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status} fetching ${lessonJsonPath}`);
        lessonStagesRoot = await response.json();
        if (!lessonStagesRoot || !Array.isArray(lessonStagesRoot.stages)) throw new Error("Invalid lesson format.");
        const lessonLang = lessonStagesRoot.lessonLanguage || 'hy';
        setLanguage(lessonLang);
        let TXT = getCurrentUIText();
        lessonStages = lessonStagesRoot.stages;

        // The single, correct welcome message call:
        if (chatArea.children.length > 0) chatArea.innerHTML = '';
        addChatMessage('AI', formatAIMessage('welcome'));

        sessionPoints = 0;
        updatePointsDisplay();
        
        // Reset the tracking for which stages have awarded points
        stagesWithPointsAwarded = new Set();

        document.title = lessonStagesRoot.lessonTitle || TXT[`titleDefault${currentLang.charAt(0).toUpperCase() + currentLang.slice(1)}`];
        console.log(`Lesson loaded: ${lessonStages.length} stages. Language: ${currentLang}`);

        // Reset stage-related variables
        currentStageIndex = -1;
        currentStageData = null;
        isStudentInputAllowed = false;
        if (currentReplayAnimationId) cancelAnimationFrame(currentReplayAnimationId);
        currentReplayAnimationId = null;
        if (currentStageAudio && !currentStageAudio.paused) {
            currentStageAudio.pause();
            currentStageAudio.onloadedmetadata = null;
            currentStageAudio.onended = null;
        }
        currentStageAudio = null;
        isMediaScrubbingActive = false;
        if (stageProgressBarContainer) stageProgressBarContainer.classList.remove('visible');
        if (bgCtx) bgCtx.clearRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
        if (replayCtx) replayCtx.clearRect(0, 0, replayCanvas.width, replayCanvas.height);
        if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (finalCtx) {
            finalCtx.fillStyle = "#FFFFFF";
            finalCtx.fillRect(0, 0, finalAnswerCanvas.width, finalAnswerCanvas.height);
        }
        thelobookPages = [];
        currentThelobookPageIndex = 0;
        updateThelobookPageControls();

    } catch (error) {
        console.error("Error loading lesson:", error);
        let TXT = getCurrentUIText();
        addChatMessage('AI', `${formatAIMessage('error')}: ${error.message}`);
    } finally {
        isLessonLoading = false;

        // NEW, ROBUST BUTTON LOGIC:
        if (lessonStages && lessonStages.length > 0) {
            // Success! Lesson loaded.
            if (nextCheckBtn) {
                nextCheckBtn.disabled = false;
                nextCheckBtn.textContent = getCurrentUIText().start;
            }
        } else {
            // Failure! Lesson did not load.
            if (nextCheckBtn) {
                nextCheckBtn.textContent = getCurrentUIText().error;
                nextCheckBtn.disabled = true;
            }
        }

        if (!UI_TEXT[currentLang]) currentLang = 'hy';
        updateAllUITexts();

        // Hide the loading overlay
        if (loadingOverlay) {
            loadingOverlay.classList.add('hidden');
            // Set display to none after the fade-out transition completes
            setTimeout(() => {
                if(loadingOverlay) loadingOverlay.style.display = 'none';
            }, 500); // This duration MUST match your CSS transition duration
        }
    }
}
    // REPLACE your old resizeCanvases function with this one.

function resizeCanvases() {
    clearTimeout(window.resizeTimeout);
    window.resizeTimeout = setTimeout(() => {
        checkTabletMode();
        if (!boardWrapper) return;

        // <<< STEP 1: Save the current drawings before they get erased.
        let userDrawingData = null;
        let finalAnswerData = null;

        // Only save if a drawing has actually occurred to avoid errors.
        if (userDrawingOccurred && canvas.width > 0 && canvas.height > 0) {
            userDrawingData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            finalAnswerData = finalCtx.getImageData(0, 0, finalAnswerCanvas.width, finalAnswerCanvas.height);
        }

        const rect = boardWrapper.getBoundingClientRect();
        const cssWidth = Math.max(1, Math.floor(rect.width)); 
        const cssHeight = Math.max(1, Math.floor(rect.height));
        devicePixelRatio = window.devicePixelRatio || 1;
        const internalWidth = Math.floor(cssWidth * devicePixelRatio); 
        const internalHeight = Math.floor(cssHeight * devicePixelRatio);
        
        // This loop erases the canvases when it sets the new width/height.
        [backgroundCanvas, replayCanvas, canvas, finalAnswerCanvas, thelobookCanvas].forEach(c => {
            if (c) { 
                c.width = internalWidth; 
                c.height = internalHeight; 
                c.style.width = `${cssWidth}px`; 
                c.style.height = `${cssHeight}px`; 
            }
        });
        
        setupContexts();

        // <<< STEP 2: Restore the saved drawings onto the newly resized (and cleared) canvases.
        if (userDrawingData) {
            ctx.putImageData(userDrawingData, 0, 0);
        }
        if (finalAnswerData) {
            finalCtx.putImageData(finalAnswerData, 0, 0);
        }

        // Redraw the rest of the UI (this part of your code was already correct).
        if (currentStageIndex >= 0 && lessonStages.length > 0) renderStageUI(currentStageIndex, true);
        
        if (isThelobookActive) {
            setTimeout(() => {
                if (isThelobookActive) loadThelobookPageDrawing(currentThelobookPageIndex);
            }, 50);
        }
        
        if(isPageGridVisible) renderPageGridBatch(currentPageGridBatch, false);

    }, 150);
}
    function setupContexts() {
        if (!backgroundCanvas || !replayCanvas || !canvas || !finalAnswerCanvas || !thelobookCanvas) return;
        replayCtx = replayCanvas.getContext('2d'); thelobookCtx = thelobookCanvas.getContext('2d');
        [bgCtx, replayCtx, ctx, finalCtx, thelobookCtx].forEach(context => {
            if (context) { context.resetTransform(); context.scale(devicePixelRatio, devicePixelRatio); }
        });
        bgCtx.lineWidth = 2; bgCtx.strokeStyle = '#333'; bgCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--thelo-text').trim();
        const fontFamily = currentLang === 'en' ? "'Manrope', system-ui, sans-serif" : "'Mardoto-Light', system-ui, sans-serif";
¬† ¬† ¬† ¬† bgCtx.font = `20px ${fontFamily}`; bgCtx.textAlign = 'center'; bgCtx.textBaseline = 'top';
        if (replayCtx) { replayCtx.lineCap = 'round'; replayCtx.lineJoin = 'round'; }
        ctx.lineWidth = THELOBOOK_PEN_LINEWIDTH; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.strokeStyle = INK_COLORS[currentColor];
        finalCtx.lineWidth = 6; finalCtx.lineCap = 'round'; finalCtx.lineJoin = 'round'; finalCtx.strokeStyle = INK_COLORS.black;
        if (thelobookCtx) {
            thelobookCtx.lineCap = 'round'; thelobookCtx.lineJoin = 'round';
        }
        updateColorIndicator();
    }

    function calculateDrawingDuration(drawingData){
        if (!drawingData || !drawingData.strokes || drawingData.strokes.length === 0) return 0;
        let maxTime = 0;
        drawingData.strokes.forEach(stroke => {
            let strokeEndTimeVal = 0;
            if (stroke.endTime !== undefined) { strokeEndTimeVal = stroke.endTime; }
            else if (stroke.points && stroke.points.length > 0) {
                const lastPoint = stroke.points[stroke.points.length - 1];
                strokeEndTimeVal = (stroke.startTime || 0) + (lastPoint.timeOffset || 0);
            } else { strokeEndTimeVal = (stroke.startTime || 0); }
            if (strokeEndTimeVal > maxTime) maxTime = strokeEndTimeVal;
        });
        return maxTime / 1000;
    }
    function renderDrawingAtTime(targetTimeInSeconds, drawingData, targetCtx){
        if (!targetCtx) return;
        const canvasWidth = targetCtx.canvas.width / devicePixelRatio;
        const canvasHeight = targetCtx.canvas.height / devicePixelRatio;
        targetCtx.clearRect(0, 0, canvasWidth, canvasHeight);

        if (!drawingData || !drawingData.strokes) return;

        drawingData.strokes.forEach(stroke => {
            const strokeStartTime = (stroke.startTime || 0) / 1000;
            if (targetTimeInSeconds < strokeStartTime) return;

            targetCtx.lineWidth = stroke.lineWidth || 2;
            targetCtx.strokeStyle = stroke.color || 'black';
            targetCtx.fillStyle = stroke.color || 'black';
            targetCtx.lineCap = 'round'; targetCtx.lineJoin = 'round';

            const points = stroke.points || [];
            if (points.length === 0) return;
            targetCtx.beginPath();
            let movedToFirstPoint = false;

            for (let i = 0; i < points.length; i++) {
                const point = points[i];
                const pointTimeAbsolute = strokeStartTime + ((point.timeOffset || 0) / 1000);
                if (pointTimeAbsolute > targetTimeInSeconds) break;

                if (!movedToFirstPoint) {
                    targetCtx.moveTo(point.normX * canvasWidth, point.normY * canvasHeight);
                    movedToFirstPoint = true;
                } else {
                    targetCtx.lineTo(point.normX * canvasWidth, point.normY * canvasHeight);
                }
                if (points.length === 1) {
                    targetCtx.closePath(); targetCtx.beginPath();
                    targetCtx.arc(point.normX * canvasWidth, point.normY * canvasHeight, (stroke.lineWidth || 2) / 2, 0, Math.PI * 2);
                    targetCtx.fill();
                    break;
                }
            }
            if (movedToFirstPoint && points.length > 1) targetCtx.stroke();
        });
    }
    function updateMediaProgressBar(effectiveTime, totalDuration){
        if (!stageProgressBarContainer) return;
        if (isMediaScrubbingActive && totalDuration > 0) {
            if (!stageProgressBarContainer.classList.contains('visible')) {
                stageProgressBarContainer.classList.add('visible');
            }
            const progress = (effectiveTime / totalDuration) * 100;
            stageProgressFill.style.width = `${Math.min(100, Math.max(0, progress))}%`;
        } else {
            // Keep progress bar visible if not scrubbing but playback is at the end (handled by new snippet in renderStageUI)
        if (!(internalPlaybackTime >= currentStageTotalDuration - 0.05 && currentStageTotalDuration > 0)) {
            stageProgressBarContainer.classList.remove('visible');
            stageProgressFill.style.width = '0%';
        }
        }
    }
    // REPLACE your entire mediaPlaybackLoop function in the core app with this one.
function mediaPlaybackLoop(timestamp) {
    if (!isMediaScrubbingActive) {
        if(currentReplayAnimationId) cancelAnimationFrame(currentReplayAnimationId);
        currentReplayAnimationId = null;
        return;
    }

    let effectiveTime;
    const audioIsActuallyPlaying = currentStageAudio && !currentStageAudio.paused && !currentStageAudio.ended;

    if (audioIsActuallyPlaying) {
        effectiveTime = currentStageAudio.currentTime;
        internalPlaybackTime = effectiveTime;
        lastFrameTimestampForManualAdvance = timestamp || performance.now();
    } else {
        if (lastFrameTimestampForManualAdvance === 0) lastFrameTimestampForManualAdvance = timestamp || performance.now();
        const deltaTime = ((timestamp || performance.now()) - lastFrameTimestampForManualAdvance) / 1000.0;

        if (internalPlaybackTime < currentStageTotalDuration) {
            internalPlaybackTime += deltaTime;
        }
        internalPlaybackTime = Math.min(internalPlaybackTime, currentStageTotalDuration);
        effectiveTime = internalPlaybackTime;
        lastFrameTimestampForManualAdvance = timestamp || performance.now();
    }
    
    effectiveTime = Math.max(0, Math.min(effectiveTime, currentStageTotalDuration));

    // NEW: If this is a calculator replay, send a seek command to the iframe on every frame.
    if (currentStageData && currentStageData.type === 'calculator_replay' && replayFrame.contentWindow) {
        replayFrame.contentWindow.postMessage({
            command: 'seek',
            time: effectiveTime * 1000 // Convert time from seconds to milliseconds for the player
        }, '*');
    }

    // This part handles the original drawing replays
    if (currentStageDrawingData && replayCtx) {
        renderDrawingAtTime(effectiveTime, currentStageDrawingData, replayCtx);
    } else if (replayCtx) {
        replayCtx.clearRect(0, 0, replayCanvas.width / devicePixelRatio, replayCanvas.height / devicePixelRatio);
    }
    
    updateMediaProgressBar(effectiveTime, currentStageTotalDuration);

    if (effectiveTime >= currentStageTotalDuration - 0.02 && currentStageTotalDuration > 0) {
        // Final render at the end of the timeline
        if (currentStageDrawingData && replayCtx) {
            renderDrawingAtTime(currentStageTotalDuration, currentStageDrawingData, replayCtx);
        }
        // NEW: Send a final seek command for the calculator replay to ensure it lands on the last frame
        if (currentStageData && currentStageData.type === 'calculator_replay' && replayFrame.contentWindow) {
             replayFrame.contentWindow.postMessage({ command: 'seek', time: currentStageTotalDuration * 1000 }, '*');
        }

        updateMediaProgressBar(currentStageTotalDuration, currentStageTotalDuration);
        isMediaScrubbingActive = false;
        if(currentReplayAnimationId) cancelAnimationFrame(currentReplayAnimationId);
        currentReplayAnimationId = null;
        return;
    }

    currentReplayAnimationId = requestAnimationFrame(mediaPlaybackLoop);
}
    function playStrokesAbsoluteTiming(strokeData, targetCtx, onFinished){
        if (isMediaScrubbingActive) { if (typeof onFinished === 'function') onFinished(); return; }
        if (currentReplayAnimationId) { cancelAnimationFrame(currentReplayAnimationId); currentReplayAnimationId = null; }
        if (!targetCtx || !strokeData || !strokeData.strokes || strokeData.strokes.length === 0) { if (typeof onFinished === 'function') onFinished(); return; }
        const targetWidth = targetCtx.canvas.width / devicePixelRatio;
        const targetHeight = targetCtx.canvas.height / devicePixelRatio;
        targetCtx.clearRect(0, 0, targetWidth, targetHeight);
        let currentStrokeIndex = 0, currentPointIndex = 0, animationStartTime = null, strokeSetupDone = false;
        function animateStrokes(timestamp) {
            if (!animationStartTime) animationStartTime = timestamp;
            const elapsedOverallTime = timestamp - animationStartTime;
            if (currentStrokeIndex >= strokeData.strokes.length) { if (typeof onFinished === 'function') onFinished(); currentReplayAnimationId = null; return; }
            const stroke = strokeData.strokes[currentStrokeIndex]; const points = stroke.points || [];
            const scheduledStrokeStartTime = stroke.startTime || 0; const scheduledStrokeEndTime = stroke.endTime === undefined ? Infinity : stroke.endTime;
            if (elapsedOverallTime < scheduledStrokeStartTime) { currentReplayAnimationId = requestAnimationFrame(animateStrokes); return; }
            if (elapsedOverallTime >= scheduledStrokeEndTime && currentPointIndex >= points.length) { currentStrokeIndex++; currentPointIndex = 0; strokeSetupDone = false; currentReplayAnimationId = requestAnimationFrame(animateStrokes); return; }
            if (!strokeSetupDone) { targetCtx.lineWidth = stroke.lineWidth || 2; targetCtx.strokeStyle = stroke.color || 'black'; targetCtx.fillStyle = stroke.color || 'black'; targetCtx.lineCap = 'round'; targetCtx.lineJoin = 'round'; targetCtx.beginPath(); if (points.length > 0) { targetCtx.moveTo(points[0].normX * targetWidth, points[0].normY * targetHeight); } strokeSetupDone = true; }
            const timeElapsedInStroke = elapsedOverallTime - scheduledStrokeStartTime; let processedPointInFrame = false;
            while (currentPointIndex < points.length && timeElapsedInStroke >= points[currentPointIndex].timeOffset) {
                const pt = points[currentPointIndex];
                if (points.length === 1 && currentPointIndex === 0) { targetCtx.arc(pt.normX * targetWidth, pt.normY * targetHeight, (stroke.lineWidth || 2) / 2, 0, Math.PI * 2); targetCtx.fill(); }
                else if (currentPointIndex > 0) { targetCtx.lineTo(pt.normX * targetWidth, pt.normY * targetHeight); processedPointInFrame = true; }
                else if (currentPointIndex === 0 && points.length > 1) { targetCtx.moveTo(pt.normX * targetWidth, pt.normY * targetHeight); }
                currentPointIndex++;
            }
            if (processedPointInFrame) { targetCtx.stroke(); }
            currentReplayAnimationId = requestAnimationFrame(animateStrokes);
        }
        currentReplayAnimationId = requestAnimationFrame(animateStrokes);
    }

    function toggleColor() {
        if (isThelobookActive || isPageGridVisible) return;
        currentColor = (currentColor === 'black') ? 'blue' : 'black';
        if(ctx) ctx.strokeStyle = INK_COLORS[currentColor];
        updateColorIndicator();
    }
    function updateColorIndicator() {
        const TXT = getCurrentUIText();
        if(colorIndicator) {
            let showIndicator = false;
            if (isThelobookActive && !isPageGridVisible) {
                colorIndicator.textContent = isThelobookEraserActive ? TXT.thelobookEraser : TXT.thelobookInk;
                showIndicator = true;
            } else if (currentStageData && !isPageGridVisible && !isThelobookActive) {
                    const mcqDetails = currentStageData.optionsQuiz;
                    const isMCQDisplayStage = currentStageData.type === "explanation_with_mcq" && mcqDetails && Array.isArray(mcqDetails.choices) && mcqDetails.choices.length > 0;
                if ((currentStageData.type === 'question_handwriting' || currentStageData.studentInput === true) && !isMCQDisplayStage) {
                    colorIndicator.textContent = (currentColor === 'blue') ? TXT.inkBlue : TXT.inkBlack;
                    showIndicator = true;
                }
            }
            colorIndicator.style.display = showIndicator ? 'inline-flex' : 'none';
        }
        if(canvas) canvas.classList.toggle('blue-mode', currentColor === 'blue' && !isThelobookActive && !isPageGridVisible);
    }
    function getPos(e, targetCanvas) {
        if (!targetCanvas) return null;
        const rect = targetCanvas.getBoundingClientRect(); let clientX, clientY;
        if (e.touches && e.touches.length > 0) { clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; }
        else if (e.changedTouches && e.changedTouches.length > 0) { clientX = e.changedTouches[0].clientX; clientY = e.changedTouches[0].clientY; }
        else { clientX = e.clientX; clientY = e.clientY; }
        if (typeof clientX !== 'number' || typeof clientY !== 'number') return null;
        return { x: clientX - rect.left, y: clientY - rect.top };
    }

    function handleDrawingStart(e) {
    // For tablets, we ONLY allow drawing to start if a stylus is the input.
    if (isTabletMode && e.type.startsWith('touch')) {
        const isStylusPresent = Array.from(e.touches).some(t => t.touchType === 'stylus');

        if (!isStylusPresent) {
            e.preventDefault();
            return;
        }

        // If a stylus is drawing, cancel any pending timer to show the bar.
        if (buttonVanishTimer) {
            clearTimeout(buttonVanishTimer);
        }
        // Immediately hide the bottom bar.
        if (bottomBar) bottomBar.classList.add('bar-hidden-by-stylus');
    }

    // This part of the code is now only reachable by a stylus on a tablet, or a mouse on desktop.
    const currentTargetCanvas = e.currentTarget;
    const activeCtx = isThelobookActive ? thelobookCtx : ctx;
    if (!activeCtx) return;
    if (isThelobookActive && currentTargetCanvas !== thelobookCanvas) return;
    if (!isThelobookActive && currentTargetCanvas !== canvas) return;
    if (!isStudentInputAllowed && !isThelobookActive) return;

    const pos = getPos(e, currentTargetCanvas);
    if (!pos) return;
    if (e.touches) e.preventDefault();
    drawing = true;
    if (!isThelobookActive) userDrawingOccurred = true;
    lastPos = pos;

    if (isThelobookActive) {
        activeCtx.lineWidth = isThelobookEraserActive ? THELOBOOK_ERASER_LINEWIDTH : THELOBOOK_PEN_LINEWIDTH;
        activeCtx.globalCompositeOperation = isThelobookEraserActive ? 'destination-out' : 'source-over';
        if (!isThelobookActive) activeCtx.strokeStyle = INK_COLORS.black;
    } else {
        activeCtx.lineWidth = THELOBOOK_PEN_LINEWIDTH;
        activeCtx.globalCompositeOperation = 'source-over';
    }

    activeCtx.beginPath();
    activeCtx.moveTo(pos.x, pos.y);
    if (!isThelobookActive && currentColor === 'blue') {
        finalCtx.strokeStyle = INK_COLORS.blue;
        finalCtx.beginPath();
        finalCtx.moveTo(pos.x, pos.y);
    }
}
   function handleDrawingStart(e) {
    // This logic now ONLY applies the smoothing for mouse events on non-tablets.
    // The 'touch' events for the iPad will bypass this completely.
    if (!isTabletMode && e.type.startsWith('mouse')) {
        mousePoints = []; // Reset the points buffer for a new line
    }

    // For tablets, we ONLY allow drawing to start if a stylus is the input.
    if (isTabletMode && e.type.startsWith('touch')) {
        const isStylusPresent = Array.from(e.touches).some(t => t.touchType === 'stylus');
        if (!isStylusPresent) {
            e.preventDefault();
            return;
        }
        if (buttonVanishTimer) clearTimeout(buttonVanishTimer);
        if (bottomBar) bottomBar.classList.add('bar-hidden-by-stylus');
    }

    const currentTargetCanvas = e.currentTarget;
    const activeCtx = isThelobookActive ? thelobookCtx : ctx;
    if (!activeCtx) return;
    if (isThelobookActive && currentTargetCanvas !== thelobookCanvas) return;
    if (!isThelobookActive && currentTargetCanvas !== canvas) return;
    if (!isStudentInputAllowed && !isThelobookActive) return;

    const pos = getPos(e, currentTargetCanvas);
    if (!pos) return;
    if (e.touches) e.preventDefault();

    drawing = true;
    if (!isThelobookActive) userDrawingOccurred = true;
    lastPos = pos;

    // Add the first point to our mouse buffer if using a mouse
    if (!isTabletMode && e.type.startsWith('mouse')) {
        mousePoints.push(pos);
    }
    
    if (isThelobookActive) {
        activeCtx.lineWidth = isThelobookEraserActive ? THELOBOOK_ERASER_LINEWIDTH : THELOBOOK_PEN_LINEWIDTH;
        activeCtx.globalCompositeOperation = isThelobookEraserActive ? 'destination-out' : 'source-over';
    } else {
        activeCtx.lineWidth = THELOBOOK_PEN_LINEWIDTH;
        activeCtx.globalCompositeOperation = 'source-over';
    }

    // The rest of your original logic for starting a path can be simplified
    // as the new handleDrawingMove will take care of drawing.
    activeCtx.beginPath();
    activeCtx.moveTo(pos.x, pos.y);
    if (!isThelobookActive && currentColor === 'blue') {
        finalCtx.strokeStyle = INK_COLORS.blue;
        finalCtx.beginPath();
        finalCtx.moveTo(pos.x, pos.y);
    }
}

function handleDrawingMove(e) {
    if (!drawing) return;

    const currentTargetCanvas = e.currentTarget;
    const activeCtx = isThelobookActive ? thelobookCtx : ctx;
    if (!activeCtx) return;
    if (isThelobookActive && currentTargetCanvas !== thelobookCanvas) return;
    if (!isThelobookActive && currentTargetCanvas !== canvas) return;
    if (!isStudentInputAllowed && !isThelobookActive) return;

    const pos = getPos(e, currentTargetCanvas);
    if (!pos) return;
    if (e.touches) e.preventDefault();

    const isMouseEvent = e.type.startsWith('mouse');

    if (!isTabletMode && isMouseEvent) {
        // --- NEW & CORRECTED DESKTOP SMOOTHING LOGIC ---
        
        // Add the new point to our buffer
        mousePoints.push(pos);
        
        // Not enough points for a curve yet, so just connect with a line
        if (mousePoints.length < 3) {
            activeCtx.lineTo(pos.x, pos.y);
            activeCtx.stroke(); // Stroke the segment
            activeCtx.beginPath(); // Begin a new path
            activeCtx.moveTo(pos.x, pos.y); // Move to the new position
            
            if (!isThelobookActive && currentColor === 'blue') {
                finalCtx.lineTo(pos.x, pos.y);
                finalCtx.stroke();
                finalCtx.beginPath();
                finalCtx.moveTo(pos.x, pos.y);
            }
            return;
        }

        // Calculate the start and end points for the curve segment
        const p1 = mousePoints[mousePoints.length - 2];
        const p2 = mousePoints[mousePoints.length - 1];
        const midPoint = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };

        // Draw a quadratic curve from the last midpoint to the new midpoint
        // The actual mouse point (p1) becomes the control point, "pulling" the curve.
        activeCtx.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);
        activeCtx.stroke();
        activeCtx.beginPath();
        activeCtx.moveTo(midPoint.x, midPoint.y);

        if (!isThelobookActive && currentColor === 'blue') {
            finalCtx.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);
            finalCtx.stroke();
            finalCtx.beginPath();
            finalCtx.moveTo(midPoint.x, midPoint.y);
        }

    } else {
        // --- ORIGINAL IPAD/TOUCH/STYLUS LOGIC (UNCHANGED) ---
        activeCtx.lineTo(pos.x, pos.y);
        activeCtx.stroke();
        activeCtx.beginPath();
        activeCtx.moveTo(pos.x, pos.y);

        if (!isThelobookActive && currentColor === 'blue') {
             if (finalCtx.strokeStyle.toLowerCase() !== INK_COLORS.blue.toLowerCase()) finalCtx.strokeStyle = INK_COLORS.blue;
             finalCtx.lineTo(pos.x, pos.y);
             finalCtx.stroke();
             finalCtx.beginPath();
             finalCtx.moveTo(pos.x, pos.y);
        }
    }

    lastPos = pos; // Update last known position
}

function handleDrawingEnd(e) {
    if (isTabletMode) {
        if (buttonVanishTimer) clearTimeout(buttonVanishTimer);
        buttonVanishTimer = setTimeout(() => {
            if (bottomBar) bottomBar.classList.remove('bar-hidden-by-stylus');
        }, 500);
    }
    
    if (!drawing) return;

    const isMouseEvent = e.type.startsWith('mouse');
    const activeCtx = isThelobookActive ? thelobookCtx : ctx;
    if (!activeCtx) return;

    // --- Draw the final line segment to the mouse's last position ---
    activeCtx.lineTo(lastPos.x, lastPos.y);
    activeCtx.stroke();

    if (!isThelobookActive && currentColor === 'blue') {
        finalCtx.lineTo(lastPos.x, lastPos.y);
        finalCtx.stroke();
    }

    drawing = false;
    activeCtx.beginPath(); // Reset for the next stroke

     // Clear the points buffer
     if (!isTabletMode && isMouseEvent) {
        mousePoints = [];
    }
}    function addBoardDrawListeners() {
        canvas.addEventListener('mousedown', handleDrawingStart);
        canvas.addEventListener('mousemove', handleDrawingMove);
        canvas.addEventListener('touchstart', handleDrawingStart, { passive: false });
        canvas.addEventListener('touchmove', handleDrawingMove, { passive: false });
        canvas.addEventListener('touchend', handleDrawingEnd);
        canvas.addEventListener('touchcancel', handleDrawingEnd);
    }
    function removeBoardDrawListeners() {
        canvas.removeEventListener('mousedown', handleDrawingStart);
        canvas.removeEventListener('mousemove', handleDrawingMove);
        canvas.removeEventListener('touchstart', handleDrawingStart);
        canvas.removeEventListener('touchmove', handleDrawingMove);
        canvas.removeEventListener('touchend', handleDrawingEnd);
        canvas.removeEventListener('touchcancel', handleDrawingEnd);
    }
    function addThelobookDrawListeners() {
        if (thelobookDrawListenersAttached) return;
        thelobookCanvas.addEventListener('mousedown', handleDrawingStart);
        thelobookCanvas.addEventListener('mousemove', handleDrawingMove);
        thelobookCanvas.addEventListener('touchstart', handleDrawingStart, { passive: false });
        thelobookCanvas.addEventListener('touchmove', handleDrawingMove, { passive: false });
        thelobookCanvas.addEventListener('touchend', handleDrawingEnd);
        thelobookCanvas.addEventListener('touchcancel', handleDrawingEnd);
        thelobookDrawListenersAttached = true;
    }
    function removeThelobookDrawListeners() {
        if (!thelobookDrawListenersAttached) return;
        thelobookCanvas.removeEventListener('mousedown', handleDrawingStart);
        thelobookCanvas.removeEventListener('mousemove', handleDrawingMove);
        thelobookCanvas.removeEventListener('touchstart', handleDrawingStart);
        thelobookCanvas.removeEventListener('touchmove', handleDrawingMove);
        thelobookCanvas.removeEventListener('touchend', handleDrawingEnd);
        thelobookCanvas.removeEventListener('touchcancel', handleDrawingEnd);
        thelobookDrawListenersAttached = false;
    }

    function wrapText(context, text, x, y, maxWidth, lineHeight){
        const words = text.split(' '); let line = ''; let currentY = y; let lines = [];
        for(let n = 0; n < words.length; n++) {
            const testLine = line + words[n] + ' '; const metrics = context.measureText(testLine);
            const testWidth = metrics.width; const wordWidth = context.measureText(words[n]).width;
            if (wordWidth > maxWidth && line.trim() !== '') { context.fillText(line.trim(), x, currentY); lines.push(line.trim()); line = ''; currentY += lineHeight; }
            if (wordWidth > maxWidth) { context.fillText(words[n], x, currentY); lines.push(words[n]); line = ' '; currentY += lineHeight; }
            else if (testWidth > maxWidth && line.trim() !== '') { context.fillText(line.trim(), x, currentY); lines.push(line.trim()); line = words[n] + ' '; currentY += lineHeight; }
            else { line = testLine; }
        }
        if (line.trim() !== '') { context.fillText(line.trim(), x, currentY); lines.push(line.trim());} return lines.length * lineHeight;
    }
    function stopCurrentStageAudio(){ if (currentStageAudio && !currentStageAudio.paused) { currentStageAudio.pause(); console.log("Current stage audio paused.");} }

    function playStageAudio(
    audioSrc,
    onLoadedMetadataCallback,
    onEndedCallback,
    isResuming = false
    ) {
    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ early-out if a modal overlay is open ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    if (isThelobookActive || isPageGridVisible || isCalculatorActive) {
    if (onLoadedMetadataCallback) onLoadedMetadataCallback(0);
    if (onEndedCallback) onEndedCallback();
    return;
    }

    currentStageAudio = stageAudioPlayer; // make sure we‚Äôre pointing at the right element

    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ RESUME PATH ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        Only run this branch if we‚Äôre *resuming* and the element
        already has the same source.  We now compare the canonical
        absolute URLs instead of using `.includes()`. */
    if (
    isResuming &&
    currentStageAudio &&
    currentStageAudio.src &&
    new URL(currentStageAudio.src, document.baseURI).href ===
        new URL(audioSrc, document.baseURI).href
    ) {
    const audioEffectivelyAtEnd =
        currentStageAudio.duration > 0 &&
        audioTimeBeforeThelobook >= currentStageAudio.duration - 0.05;

    if (wasMediaPlayingBeforeThelobook && !audioEffectivelyAtEnd) {
        if (window.userInteracted && currentStageAudio.paused) {
        currentStageAudio
            .play()
            .catch((e) => console.warn("Resume audio play failed:", e));
        }
    }

    // wire callbacks (or call immediately if metadata already available)
    if (onLoadedMetadataCallback) {
        if (
        currentStageAudio.readyState >= HTMLMediaElement.HAVE_METADATA
        ) {
        onLoadedMetadataCallback(currentStageAudio.duration);
        } else {
        const tempMetaListener = () => {
            onLoadedMetadataCallback(currentStageAudio.duration);
            currentStageAudio.removeEventListener(
            "loadedmetadata",
            tempMetaListener
            );
        };
        currentStageAudio.addEventListener(
            "loadedmetadata",
            tempMetaListener
        );
        }
    }
    if (onEndedCallback) currentStageAudio.onended = onEndedCallback;
    return; // ‚Üê nothing else to do
    }

    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FULL (re-)INITIALISATION PATH ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    if (currentStageAudio && !currentStageAudio.paused) {
    currentStageAudio.pause();
    }
    if (currentStageAudio) {
    currentStageAudio.onloadedmetadata = null;
    currentStageAudio.onended = null;
    }

    if (!audioSrc) {
    if (onLoadedMetadataCallback) onLoadedMetadataCallback(0);
    if (onEndedCallback) onEndedCallback();
    return;
    }

    currentStageAudio.src = audioSrc;
    currentStageAudio.preload = "auto";

    let loadedMetaCalled = false;
    currentStageAudio.onloadedmetadata = () => {
    if (!loadedMetaCalled && onLoadedMetadataCallback) {
        loadedMetaCalled = true;
        onLoadedMetadataCallback(currentStageAudio.duration);
    }
    };
    if (onEndedCallback) currentStageAudio.onended = onEndedCallback;

    currentStageAudio.load();
    if (window.userInteracted) {
    const playPromise = currentStageAudio.play();
    if (playPromise) {
        playPromise.catch((error) => {
        console.warn("Audio play failed (full init):", error);
        if (onEndedCallback) onEndedCallback();
        });
    }
    } else {
    console.warn("Audio interaction needed for autoplay.");
    }
    }

	function displayMcq(mcqDetails){
    const choices = mcqDetails.choices;
    if (!mcqOptionsContainer || !mcqDetails ||
        !Array.isArray(choices) || choices.length === 0) return;
    if (isPageGridVisible) closePageGridView();

    mcqOptionsContainer.innerHTML = '';

    /* ===== Smart‚Äëlayout ===== */
    const isShort = choices.every(choice => choice.length < 10);
    mcqOptionsContainer.className = isShort ? 'short-options' : 'long-options';

    /* <<‚Äî‚Äë‚Äë‚Äë  ADD THESE TWO LINES  ‚Äë‚Äë‚Äë‚Äë‚Äë‚Äë‚Äë‚Äë‚Äë‚Äë‚Äë‚Äë‚Äë‚Äë‚Äë‚Äë‚Äë‚Äë‚Äë‚Äë>> */
    const isSideBySide = !!(currentStageData && currentStageData.image);
    mcqOptionsContainer.classList.toggle('side-by-side', isSideBySide);
    /* --------------------------------------------------- */

    choices.forEach((optionText, index) => {
        const optionButton = document.createElement('button');
        optionButton.classList.add('mcq-option-btn');
        optionButton.textContent  = optionText;
        optionButton.dataset.index = index;
        optionButton.addEventListener(
            'click',
            () => handleMcqOptionClick(index, mcqDetails)
        );
        mcqOptionsContainer.appendChild(optionButton);
    });

    mcqOptionsContainer.style.display = 'flex';
    mcqOptionsContainer.style.opacity = '1';
}

	
    function handleMcqOptionClick(selectedIndex, mcqDetails){
    stopCurrentStageAudio();
    const TXT = getCurrentUIText();

    if (!mcqOptionsContainer) return;

    const optionButtons = mcqOptionsContainer.querySelectorAll('.mcq-option-btn');
    optionButtons.forEach(btn => btn.disabled = true);

    const selectedButton = optionButtons[selectedIndex];
    const isCorrectAnswer = parseInt(selectedButton.dataset.index) === mcqDetails.correctIndex;

    let feedbackMessageForChat; // This variable will hold the message sent to the chat
    if (isCorrectAnswer) {
¬† ¬† ¬† ¬† selectedButton.classList.add('correct');

¬† ¬† ¬† ¬† playRandomFeedback('approve');
¬† ¬† ¬† ¬† userPoints += 5; // This updates the permanent score
¬† ¬† ¬† ¬† sessionPoints += 5; // ADDED: This updates the score for this lesson
¬† ¬† ¬† ¬† updatePointsDisplay();
	updateUserPointsInFirestore(5);
¬† ¬† ¬† ¬† // Construct the message to include points
¬† ¬† ¬† ¬† const baseFeedback = mcqDetails.feedbackCorrect || TXT.correct;
¬† ¬† ¬† ¬† feedbackMessageForChat = `${baseFeedback} ${formatAIMessage('pointsGained', { points: 5 })}`;

¬† ¬† }
    
	    else {
        selectedButton.classList.add('incorrect');
        const correctButton = optionButtons[mcqDetails.correctIndex];
        if (correctButton) correctButton.classList.add('correct-answer-shown');

        feedbackMessageForChat = mcqDetails.feedbackIncorrect || TXT.incorrect;

        const correctTextOptions = mcqDetails.choices;
        const correctButtonText = correctTextOptions[mcqDetails.correctIndex];
        if (feedbackMessageForChat.includes('{correctText}')) {
            const tempDiv = document.createElement('div');
            tempDiv.textContent = correctButtonText;
            feedbackMessageForChat = feedbackMessageForChat.replace('{correctText}', tempDiv.innerHTML);
        }
        playRandomFeedback('disapprove');
    }

    addChatMessage('AI', feedbackMessageForChat); // Use the new variable for the chat message
    setTimeout(nextStage, 2500);
}

	// REPLACE your entire renderStageUI function with this one
/**
 * Draws the stage image onto the background canvas with the correct layout,
 * positioning it to the side if MCQs are present, otherwise centering it.
 * @param {CanvasRenderingContext2D} bgCtx - The context of the background canvas.
 * @param {HTMLImageElement} img - The image to draw.
 * @param {object} currentStageData - The data for the current stage.
 */
function drawImageWithCorrectLayout(bgCtx, img, currentStageData) {
    const canvasWidth = bgCtx.canvas.width / devicePixelRatio;
    const canvasHeight = bgCtx.canvas.height / devicePixelRatio;
    
    // Determine if the stage also has an MCQ to display.
    const hasMcq = currentStageData.optionsQuiz && Array.isArray(currentStageData.optionsQuiz.choices);

    if (hasMcq) {
        // --- Side-by-Side Layout Logic ---
        const sidePad = canvasWidth * 0.04;      // 4% gutter
        const maxImgWidth = canvasWidth * 0.48;   // ~50% of board
        const maxImgHeight = canvasHeight * 0.85; // Leave vertical room
        const scale = Math.min(maxImgWidth / img.width, maxImgHeight / img.height);
        
        const scaledWidth = img.width * scale;
        const scaledHeight = img.height * scale;
        const x = sidePad; // Position on the left
        const y = (canvasHeight - scaledHeight) / 2; // Vertically centered
        bgCtx.drawImage(img, x, y, scaledWidth, scaledHeight);

    } else {
        // --- Default Centered Layout Logic ---
        const maxSizePercentage = 0.50;
        const maxContainerWidth = canvasWidth * maxSizePercentage;
        const maxContainerHeight = canvasHeight * maxSizePercentage;
        const scale = Math.min(maxContainerWidth / img.width, maxContainerHeight / img.height);
        
        const scaledWidth = img.width * scale;
        const scaledHeight = img.height * scale;
        const x = (canvasWidth - scaledWidth) / 2; // Horizontally centered
        const y = (canvasHeight - scaledHeight) / 2; // Vertically centered
        bgCtx.drawImage(img, x, y, scaledWidth, scaledHeight);
    }
}
/**
 * Opens the replay player, fetches the replay data, and sends it to the iframe.
 */
async function openReplayPlayer() {
    if (isReplayActive || !currentStageData || !currentStageData.replayDataUrl) {
        console.warn("No replay data URL found for this stage.");
        return;
    }
    isReplayActive = true;

    const playerURL = 'https://thelo.space/replay'; // The URL of your automated player

    const sendDataToPlayer = (replayActions) => {
        if (replayFrame.contentWindow) {
            replayFrame.contentWindow.postMessage({
                meta: { source: 'thelo-lesson' },
                actions: replayActions
            }, '*');
            console.log("Replay data sent to player iframe.");
        }
    };

    try {
        // Fetch the external replay data file
        const response = await fetch(currentStageData.replayDataUrl);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

        const replayJson = await response.json();
        const replayActions = replayJson.actions;

        if (!replayActions) throw new Error("Could not find 'actions' in replay JSON.");

        // Load the iframe and send data once it's ready
        replayFrame.src = playerURL;
        replayFrame.onload = () => sendDataToPlayer(replayActions);

        replayPlayerContainer.classList.remove('replay-hidden');

    } catch (error) {
        console.error("Failed to load or send replay data:", error);
        addChatMessage('AI', 'Error: Could not load the interactive replay.');
        isReplayActive = false; // Reset on failure
    }
}

/**
 * Closes the replay player and clears its content.
 */
function closeReplayPlayer() {
    if (!isReplayActive) return;
    isReplayActive = false;
    replayPlayerContainer.classList.add('replay-hidden');
    // Reset the iframe src to stop playback and free up resources
    replayFrame.src = 'about:blank';
}
// REPLACE your entire renderStageUI function with this one
/**
 * Renders all visual and interactive elements for a given lesson stage.
 * This function handles content loading, media playback setup, and UI state management.
 * @param {number} index - The index of the stage to render from the lessonStages array.
 * @param {boolean} [isResize=false] - A flag to indicate if the call is due to a window resize, to prevent re-fetching data.
 * @returns {Promise<void>} A promise that resolves when the stage has been fully rendered.
 */
function renderStageUI(index, isResize = false) {
    return new Promise((resolve) => {
        if (isLessonLoading || index < 0 || index >= lessonStages.length) {
            if (index < 0) {
                if (nextCheckBtn) { nextCheckBtn.disabled = true; nextCheckBtn.textContent = getCurrentUIText().start; }
                if (prevBtn) prevBtn.disabled = true;
                if (clearBtn) clearBtn.style.display = 'none';
                if (colorIndicator) colorIndicator.style.display = 'none';
                if (mcqOptionsContainer) mcqOptionsContainer.style.display = 'none';
            }
            return resolve();
        }
        
        const TXT = getCurrentUIText();
        if (!isResize) {
            if (isThelobookActive) closeThelobook(true);
            if (isPageGridVisible) closePageGridView();
            if (isReplayActive) closeReplayPlayer();
        }

        if (!isResize) {
            if (currentReplayAnimationId) { cancelAnimationFrame(currentReplayAnimationId); currentReplayAnimationId = null; }
            if (currentStageAudio && !currentStageAudio.paused) { currentStageAudio.pause(); currentStageAudio.currentTime = 0; currentStageAudio.onloadedmetadata = null; currentStageAudio.onended = null; }
            isMediaScrubbingActive = false; currentStageDrawingData = null; currentStageTotalDuration = 0; internalPlaybackTime = 0; lastFrameTimestampForManualAdvance = 0;
            if (stageProgressBarContainer) stageProgressBarContainer.classList.remove('visible');
            if (stageProgressFill) stageProgressFill.style.width = '0%';
        }
        
        currentStageData = lessonStages[index];
        currentStageIndex = index;
        isStudentInputAllowed = currentStageData.studentInput === true;
        currentColor = 'black';
        if (ctx) ctx.strokeStyle = INK_COLORS[currentColor];

        if (mcqOptionsContainer) { mcqOptionsContainer.innerHTML = ''; mcqOptionsContainer.style.display = 'none'; }
        
        if (bgCtx) bgCtx.clearRect(0, 0, backgroundCanvas.width / devicePixelRatio, backgroundCanvas.height / devicePixelRatio);
        if (!isResize) {
            clearUserCanvas();
            if (replayCtx) replayCtx.clearRect(0, 0, replayCanvas.width / devicePixelRatio, replayCanvas.height / devicePixelRatio);
        }

        function setupStageContent() {
            const mcqDetails = currentStageData.optionsQuiz;
            const isMCQDisplayStage = currentStageData.type === "explanation_with_mcq" && mcqDetails && Array.isArray(mcqDetails.choices) && mcqDetails.choices.length > 0;
            const isQuestionStage = currentStageData.type === 'question_handwriting' || isMCQDisplayStage;

            if (currentStageData.type === 'calculator_replay') {
                if (!isResize) {
                    isMediaScrubbingActive = true;
                    internalPlaybackTime = 0;
                    lastFrameTimestampForManualAdvance = 0;

                    fetch(currentStageData.replayDataUrl)
                        .then(res => res.json())
                        .then(data => {
                            const actions = data.actions || [];
                            if (replayFrame && replayFrame.contentWindow) {
                                replayFrame.contentWindow.postMessage({ actions: actions }, '*');
                            }
                            const totalDurationMs = actions
                                .filter(a => a.action === 'delay')
                                .reduce((sum, a) => sum + a.ms, 0);
                            currentStageTotalDuration = totalDurationMs / 1000;
                            if (isMediaScrubbingActive && currentStageTotalDuration > 0) {
                                if(stageProgressBarContainer) stageProgressBarContainer.classList.add('visible');
                                if (currentReplayAnimationId) cancelAnimationFrame(currentReplayAnimationId);
                                currentReplayAnimationId = requestAnimationFrame(mediaPlaybackLoop);
                            }
                        })
                        .catch(err => {
                            console.error("Failed to load or process replay data:", err);
                            isMediaScrubbingActive = false;
                        });
                }
                if (currentStageData.audioFile) {
                    playStageAudio(currentStageData.audioFile, () => {}, () => {}, isResize);
                }
                if (nextCheckBtn) {
                    nextCheckBtn.textContent = TXT.gotIt;
                    nextCheckBtn.disabled = false;
                }
                if (clearBtn) clearBtn.style.display = 'none';
                if (replayPlayerContainer) replayPlayerContainer.classList.remove('replay-hidden');
            
            } else if (isQuestionStage) {
                if (!isResize) isMediaScrubbingActive = false;
                if(stageProgressBarContainer) stageProgressBarContainer.classList.remove('visible');
                if (isMCQDisplayStage && mcqDetails) {
                    if (bottomBar) bottomBar.style.display = 'flex'; displayMcq(mcqDetails);
                    if(clearBtn) clearBtn.style.display = 'none';
                    if(nextCheckBtn) nextCheckBtn.disabled = true;
                } else if (currentStageData.type === 'question_handwriting') {
                    if (bottomBar) bottomBar.style.display = 'flex';
                    if(nextCheckBtn) { nextCheckBtn.textContent = TXT.check; nextCheckBtn.disabled = false; }
                    if(clearBtn) clearBtn.style.display = 'inline-flex';
                }
                if (currentStageData.audioFile) { playStageAudio(currentStageData.audioFile, (d) => {}, () => {}, isResize); }
            } else {
                if (bottomBar) bottomBar.style.display = 'flex';
                if (mcqOptionsContainer) mcqOptionsContainer.style.display = 'none';
                const isDrawingInputStage = currentStageData.studentInput === true;
                if (clearBtn) clearBtn.style.display = isDrawingInputStage ? 'inline-flex' : 'none';

                if (currentStageData.audioFile || currentStageData.drawingRecord) {
                    if (!isResize) {
                        isMediaScrubbingActive = true;
                        internalPlaybackTime = 0;
                        lastFrameTimestampForManualAdvance = 0;
                    }
                    updateMediaProgressBar(internalPlaybackTime, currentStageTotalDuration > 0 ? currentStageTotalDuration : 1);
                    
                    const audioMetaPromise = new Promise((resolve) => {
                        if (currentStageData.audioFile) {
                            playStageAudio(currentStageData.audioFile, (duration) => resolve(duration || 0), () => {}, isResize);
                        } else { resolve(0); }
                    });
                    
                    let drawingDataPromise;
                    if (currentStageData.drawingRecord) {
                        if (!isResize || !currentStageDrawingData) {
                            drawingDataPromise = fetch(currentStageData.drawingRecord).then(r => r.ok ? r.json() : Promise.reject(`HTTP ${r.status}`)).then(json => { if (!json || !json.strokes) throw "Bad drawing JSON"; currentStageDrawingData = json; return json; }).catch(e => { console.error("Failed to load drawing data:", e); currentStageDrawingData = null; return null; });
                        } else { drawingDataPromise = Promise.resolve(currentStageDrawingData); }
                    } else { currentStageDrawingData = null; drawingDataPromise = Promise.resolve(null); }

                    Promise.all([audioMetaPromise, drawingDataPromise]).then(([audioDuration, loadedDrawingData]) => {
                        if (loadedDrawingData) currentStageDrawingData = loadedDrawingData;
                        const drawingAnimDuration = currentStageDrawingData ? calculateDrawingDuration(currentStageDrawingData) : 0;
                        currentStageTotalDuration = Math.max(audioDuration, drawingAnimDuration);
                        
                        if (isMediaScrubbingActive && currentStageTotalDuration > 0) {
                            updateMediaProgressBar(internalPlaybackTime, currentStageTotalDuration);
                            if (stageProgressBarContainer) stageProgressBarContainer.classList.add('visible');
                            if (currentReplayAnimationId) cancelAnimationFrame(currentReplayAnimationId);
                            currentReplayAnimationId = requestAnimationFrame(mediaPlaybackLoop);
                        }
                    });
                } else {
                    isMediaScrubbingActive = false; if(stageProgressBarContainer) stageProgressBarContainer.classList.remove('visible');
                    currentStageAudio = null; currentStageDrawingData = null; currentStageTotalDuration = 0;
                    if (replayCtx) replayCtx.clearRect(0, 0, replayCanvas.width / devicePixelRatio, replayCanvas.height / devicePixelRatio);
                }
                if(nextCheckBtn) { nextCheckBtn.textContent = TXT.gotIt; nextCheckBtn.disabled = false; }
            }

            updateColorIndicator();
            canvas.style.pointerEvents = (isStudentInputAllowed && !isThelobookActive && !isPageGridVisible) ? 'auto' : 'none';
            if(nextCheckBtn) { nextCheckBtn.classList.remove('correct', 'incorrect'); nextCheckBtn.style.backgroundColor = ''; }
            if (!isResize) userDrawingOccurred = false;
            if(prevBtn) prevBtn.disabled = (index === 0 || isThelobookActive || isPageGridVisible);
            if(nextCheckBtn) {
                const isCorrectlyAnsweredHW = currentStageData.type === 'question_handwriting' && nextCheckBtn.classList.contains('correct');
                nextCheckBtn.disabled = (isThelobookActive || isPageGridVisible || (isMCQDisplayStage && mcqDetails) || isCorrectlyAnsweredHW);
            }
            if(clearBtn) clearBtn.disabled = (isThelobookActive || isPageGridVisible);
        }
        
        function drawHeadlineText() {
            const padding = 27;
            const cssWidthForText = backgroundCanvas.width / devicePixelRatio;
            const maxWidth = cssWidthForText * 0.8;
            const textX = cssWidthForText / 2;
            let headlineCurrentY = padding * 2;
            const lineHeight = 30;
            let headlineText = currentStageData.headline || '';

            if (headlineText && bgCtx && (bgCtx.canvas.width > 0)) {
                const fontFamily = currentLang === 'en' ? "'Manrope', system-ui, sans-serif" : "'Mardoto-Light', system-ui, sans-serif";
                bgCtx.font = `20px ${fontFamily}`;
                bgCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--thelo-text').trim();
                bgCtx.textAlign = 'center';
                bgCtx.textBaseline = 'top';
                const plainHeadlineText = headlineText.replace(/<strong>(.*?)<\/strong>/gi, '$1');
                wrapText(bgCtx, plainHeadlineText, textX, headlineCurrentY, maxWidth, lineHeight);
            }
        }
        
        if (currentStageData.image && bgCtx) {
            const img = new Image();
            img.src = currentStageData.image;
            img.onload = () => {
                drawImageWithCorrectLayout(bgCtx, img, currentStageData);
                drawHeadlineText();
                setupStageContent();
                resolve();
            };
            img.onerror = () => {
                console.error("Failed to load stage image:", currentStageData.image);
                drawHeadlineText();
                setupStageContent();
                resolve();
            };
        } else {
            drawHeadlineText();
            setupStageContent();
            resolve();
        }
    });
}
          function transitionToStage(newIndex) {
    if (isTransitioning || isLessonLoading || !lessonStages.length) return;
		  if (isReplayActive) closeReplayPlayer();
    if (isThelobookActive) closeThelobook(true);
    if (isPageGridVisible) closePageGridView();

    if (currentReplayAnimationId) { cancelAnimationFrame(currentReplayAnimationId); currentReplayAnimationId = null; }
    if (currentStageAudio && !currentStageAudio.paused) { currentStageAudio.pause(); currentStageAudio.onloadedmetadata = null; currentStageAudio.onended = null; }
    isMediaScrubbingActive = false; currentStageDrawingData = null; currentStageTotalDuration = 0; internalPlaybackTime = 0; lastFrameTimestampForManualAdvance = 0;
    if (stageProgressBarContainer) stageProgressBarContainer.classList.remove('visible');
    if (stageProgressFill) stageProgressFill.style.width = '0%';

    if (newIndex < 0 || newIndex >= lessonStages.length) {
        if (newIndex >= lessonStages.length) {
            displayLessonComplete();
        }
        return;
    }
    isTransitioning = true;
    backgroundCanvas.classList.add('fade-out');
    if (replayCanvas) replayCanvas.classList.add('fade-out');
    if (mcqOptionsContainer) mcqOptionsContainer.style.opacity = 0;

    // --- KEY CHANGE: Replace setTimeout with .then() ---
    const fadeDuration = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--fade-duration') || '0.3') * 1000;
    
    setTimeout(() => {
        currentStageIndex = newIndex;
        // renderStageUI now returns a promise. We wait for it to resolve.
        renderStageUI(currentStageIndex, false).then(() => {
            // This code now runs ONLY AFTER the stage content (including images) is ready.
            backgroundCanvas.classList.remove('fade-out');
            if (replayCanvas) replayCanvas.classList.remove('fade-out');
            isTransitioning = false;
        });
    }, fadeDuration); // We still wait for the fade-out to finish before preparing the new scene.
}
    function nextStage() { transitionToStage(currentStageIndex + 1); }
    function previousStage() { if (currentStageIndex > 0 && !isThelobookActive && !isPageGridVisible) transitionToStage(currentStageIndex - 1); }
    // FULL UPDATED FUNCTION
async function displayLessonComplete() {
    isTransitioning = true;
    const TXT = getCurrentUIText();

    // --- FIX: START THE UI TRANSITION IMMEDIATELY ---
    // This part of the code handles the visual change and is no longer
    // waiting for the database operations to finish.

    if (isThelobookActive) closeThelobook(false);
    if (isPageGridVisible) closePageGridView();
    backgroundCanvas.classList.add('fade-out');
    if (replayCanvas) replayCanvas.classList.add('fade-out');
    if (mcqOptionsContainer) mcqOptionsContainer.style.display = 'none';
    if (currentReplayAnimationId) {
        cancelAnimationFrame(currentReplayAnimationId);
        currentReplayAnimationId = null;
    }
    if (currentStageAudio && !currentStageAudio.paused) {
        currentStageAudio.pause();
        currentStageAudio.currentTime = 0;
    }
    isMediaScrubbingActive = false;
    if (stageProgressBarContainer) stageProgressBarContainer.classList.remove('visible');

    setTimeout(() => {
        const cssWidth = backgroundCanvas.width / devicePixelRatio;
        const cssHeight = backgroundCanvas.height / devicePixelRatio;
        bgCtx.clearRect(0, 0, cssWidth, cssHeight);
        const fontFamily = currentLang === 'en' ? "'Manrope', system-ui, sans-serif" : "'Mardoto-Light', system-ui, sans-serif";
        bgCtx.font = `bold 24px ${fontFamily}`;
        bgCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--success-green').trim();
        bgCtx.textAlign = 'center';
        bgCtx.textBaseline = 'middle';
        bgCtx.fillText(TXT.lessonComplete, cssWidth / 2, cssHeight / 3);
        clearUserCanvas();
        if (replayCtx) replayCtx.clearRect(0, 0, replayCanvas.width / devicePixelRatio, replayCanvas.height / devicePixelRatio);

        if (nextCheckBtn) nextCheckBtn.style.display = 'none';
        if (prevBtn) prevBtn.style.display = 'none';
        if (clearBtn) clearBtn.style.display = 'none';
        if (thelobookBtn) thelobookBtn.style.display = 'none';
        if (dashboardBtn) {
            dashboardBtn.innerHTML = TXT.viewDashboard;
            dashboardBtn.classList.add('visible');
        }

        if (colorIndicator) colorIndicator.style.display = 'none';
        addChatMessage('AI', `üéâ ${TXT.lessonComplete}`);
        
        backgroundCanvas.classList.remove('fade-out');
        if (replayCanvas) replayCanvas.classList.remove('fade-out');
        isTransitioning = false;
    }, parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--fade-duration') || '0.3') * 1000);


    // --- FIX: RUN ALL DATABASE OPERATIONS IN THE BACKGROUND ---
    // This code now runs *after* the UI transition has already been scheduled.
    // It no longer blocks the user from seeing the result.

    const user = auth.currentUser;
    const urlParams = new URLSearchParams(window.location.search);
    const lessonFileName = urlParams.get('lessonFile');

    if (user && lessonFileName) {
        // Log analytics
        if (lessonStartTime) {
            const timeToCompleteSeconds = Math.round((Date.now() - lessonStartTime) / 1000);
            db.collection("analytics_events").add({
                type: "lesson_completed",
                userId: user.uid,
                lessonId: lessonFileName.replace('.json', ''),
                courseId: "sat-math-prep",
                timeToCompleteSeconds: timeToCompleteSeconds,
                sessionScore: sessionPoints,
                timestamp: firebase.firestore.FieldValue.serverTimestamp()
            }).catch(e => console.error("Analytics event logging error:", e));
            lessonStartTime = null;
        }

        // Update progress and streak
        try {
            const topicId = lessonFileName.replace('.json', '');
            const studentDocRef = db.collection('thelo-students').doc(user.uid);
            const progressDocRef = studentDocRef.collection('progress').doc(topicId);
            const progressDoc = await progressDocRef.get();
            const wasAlreadyCompleted = progressDoc.exists;

            await updateStudentProgress(user.uid, topicId, {
                status: 'completed',
                score: sessionPoints
            });

            if (!wasAlreadyCompleted) {
                await studentDocRef.update({
                    lessonsCompleted: firebase.firestore.FieldValue.increment(1)
                });
            }

            // The streak update can now happen here, independently.
            updateWeeklyStreak();

        } catch (error) {
            console.error("Error finalizing lesson completion in background:", error);
        }
    }
}		function handleNextCheckClick() {
    if (isTransitioning || isLessonLoading || isThelobookActive || isPageGridVisible) return;
    const TXT = getCurrentUIText();

    // Handle the initial "Start" button click (no changes here)
    if (currentStageIndex === -1 && lessonStages.length > 0) {
        lessonStartTime = Date.now();
        const user = auth.currentUser;
        const urlParams = new URLSearchParams(window.location.search);
        const lessonFileName = urlParams.get('lessonFile');
        if (user && lessonFileName) {
            db.collection("analytics_events").add({
                type: "lesson_started",
                userId: user.uid,
                lessonId: lessonFileName.replace('.json', ''),
                courseId: "sat-math-prep",
                timestamp: firebase.firestore.FieldValue.serverTimestamp()
            });
        }
        transitionToStage(0);
        return;
    }

    const mcqDetails = currentStageData.optionsQuiz;
    const isMCQStage = currentStageData.type === "explanation_with_mcq" && mcqDetails && Array.isArray(mcqDetails.choices) && mcqDetails.choices.length > 0;
    if (isMCQStage) return;

    // --- FIX: UNIFIED LOGIC FOR ALL "GOT IT" STAGES ---
    if (nextCheckBtn.textContent === TXT.gotIt) {
        
        // 1. Award points and play sound if this stage hasn't been rewarded yet.
        if (!stagesWithPointsAwarded.has(currentStageIndex)) {
            stagesWithPointsAwarded.add(currentStageIndex);
            stopCurrentStageAudio();
            
            const randomPoints = Math.floor(Math.random() * (9 - 6 + 1)) + 6;
            userPoints += randomPoints;
            sessionPoints += randomPoints;
            updateUserPointsInFirestore(randomPoints);
            updatePointsDisplay();
            addChatMessage('AI', formatAIMessage('pointsGained', { points: randomPoints }));
            
            // This restores the sound effect
            if (window.userInteracted && gotItSoundPlayer) {
                gotItSoundPlayer.currentTime = 0;
                gotItSoundPlayer.play().catch(e => {});
            }
        }

        // 2. If an interactive replay was active, close it.
        if (isReplayActive) {
            closeReplayPlayer();
        }

        // 3. Always advance to the next stage.
        nextStage();
        return;
    }
    
    // Logic for 'Check' scenarios (handwriting question stages)
    if (currentStageData.type === 'question_handwriting') {
        checkHandwritingAnswer();
    } else {
        nextStage();
    }
}
		function clearUserCanvas() {
        if (isPageGridVisible) return;
        if (isThelobookActive) {
            if (thelobookCtx) {
                thelobookCtx.clearRect(0,0, thelobookCanvas.width/devicePixelRatio, thelobookCanvas.height/devicePixelRatio);
                if (currentThelobookPageIndex >= 0 && currentThelobookPageIndex < thelobookPages.length) {
                    thelobookPages[currentThelobookPageIndex] = null;
                }
            }
            return;
        }
        if(ctx) ctx.clearRect(0, 0, canvas.width / devicePixelRatio, canvas.height / devicePixelRatio);
        if(finalCtx) { finalCtx.fillStyle = '#FFFFFF'; finalCtx.fillRect(0, 0, finalAnswerCanvas.width / devicePixelRatio, finalAnswerCanvas.height / devicePixelRatio); }
        userDrawingOccurred = false;
    }
            // REPLACE your existing addChatImage function with this one
    function addChatImage(url) {
    const wrapper = Object.assign(document.createElement('div'), {
        className: 'ai-message chat-image-container'
    });

    const img = Object.assign(document.createElement('img'), {
        className: 'chat-image',
        src: url,
        alt: 'Lesson Content Image',
        style: 'opacity:0'
    });

    wrapper.appendChild(img);
    chatArea.appendChild(wrapper);
    
    // Calculate target scroll position
    const targetScrollTop = wrapper.offsetTop - chatArea.offsetTop;
    
    img.onload = () => {
        // Fade in the image
        img.style.transition = 'opacity .4s';
        img.style.opacity = '1';
        
        // Smooth scroll to position
        chatArea.scrollTo({
        top: targetScrollTop,
        behavior: 'smooth'
        });
    };
    }
    // Find your addChatMessage function (around line 1774 or search for 'function addChatMessage(sender, rawMsg)')
// REPLACE your entire addChatMessage function with this one

function addChatMessage(sender, rawMsg) {
¬† ¬† if (isTabletMode) {
¬† ¬† ¬† ¬† // Tablet toast logic remains the same
¬† ¬† ¬† ¬† const isImportant = rawMsg.includes('üéâ') || rawMsg.includes('ü§î') || rawMsg.includes('‚ö†Ô∏è');
¬† ¬† ¬† ¬† showToast(rawMsg, isImportant ? 5000 : 3500);
¬† ¬† } else {
¬† ¬† ¬† ¬† // Desktop/mobile terminal chat
¬† ¬† ¬† ¬† const chatArea = document.getElementById('chat');
¬† ¬† ¬† ¬† if (!chatArea) return;

¬† ¬† ¬† ¬† const msg = rawMsg.replace(/^[\p{Extended_Pictographic}\uFE0F]+\s*/u, '');
¬† ¬† ¬† ¬† const TXT = getCurrentUIText();
¬† ¬† ¬† ¬† let emoji = 'ü´ß';

¬† ¬† ¬† ¬† const isPoints = /points? gained/i.test(msg) || (TXT.pointsGained && msg.includes(TXT.pointsGained.split("{")[0].trim()));
¬† ¬† ¬† ¬† const isWrong = msg.includes('Not quite') || (TXT.incorrect && msg.includes(TXT.incorrect)) || msg.includes('Incorrect') || msg.includes('Wrong');
¬† ¬† ¬† ¬† const isCorrect = !isWrong && ((TXT.correct && msg.includes(TXT.correct)) || /^correct/i.test(msg));
¬† ¬† ¬† ¬† const isWarning = msg.includes('‚ö†Ô∏è') || (TXT.error && msg.includes(TXT.error));
¬† ¬† ¬† ¬† const isWelcome = TXT.welcome && msg.includes(TXT.welcome);
¬† ¬† ¬† ¬† const isChecking = TXT.checkingAI && msg.includes(TXT.checkingAI.split('<')[0]);

¬† ¬† ¬† ¬† if(isWrong) emoji = 'ü§î';
¬† ¬† ¬† ¬† else if (isCorrect || isPoints) emoji = 'üéâ';
¬† ¬† ¬† ¬† else if (isWarning || msg.includes('üõë')) emoji = '‚ö†Ô∏è';
¬† ¬† ¬† ¬† else if (isWelcome) emoji = 'üëã';
¬† ¬† ¬† ¬† else if (isChecking) emoji = '‚è≥';

¬† ¬† ¬† ¬† const bubble = document.createElement('div');
¬† ¬† ¬† ¬† bubble.className = 'ai-message'; // Starts with opacity: 0
¬† ¬† ¬† ¬† bubble.innerHTML = `<span class="emoji" role="img" aria-label="icon">${emoji}</span> <span>${msg}</span>`;
¬† ¬† ¬† ¬† chatArea.appendChild(bubble);

¬† ¬† ¬† ¬† // ===================================================================
¬† ¬† ¬† ¬† // ===== THE FIX: Forcing the browser to paint the initial state =====
¬† ¬† ¬† ¬† // ===================================================================
¬† ¬† ¬† ¬† requestAnimationFrame(() => {
¬† ¬† ¬† ¬† ¬† ¬† // This nested timeout ensures the class addition happens in a separate
¬† ¬† ¬† ¬† ¬† ¬† // task, after the browser has painted the invisible element.
¬† ¬† ¬† ¬† ¬† ¬† setTimeout(() => {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† bubble.classList.add('show');
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // Scroll into view after the animation starts.
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† chatArea.scrollTo({ top: chatArea.scrollHeight, behavior: 'smooth' });
¬† ¬† ¬† ¬† ¬† ¬† }, 10); // A tiny delay is all that's needed.
¬† ¬† ¬† ¬† });
¬† ¬† }
}    /**
 * Creates or updates a student's progress for a specific topic in Firestore.
 * @param {string} userId - The authenticated user's UID.
 * @param {string} topicId - The unique ID for the lesson (e.g., 'sat-linear-equations-one-var').
 * @param {object} progressData - The data to save (e.g., { status: 'in-progress' }).
 */
async function updateStudentProgress(userId, topicId, progressData) {
  if (!userId || !topicId) {
    console.error("User ID or Topic ID is missing. Cannot save progress.");
    return;
  }
  
  // The path to the specific progress document for this user and topic.
  const progressDocRef = db.collection('thelo-students').doc(userId).collection('progress').doc(topicId);
  
  // Add a timestamp to every update.
  const dataWithTimestamp = {
    ...progressData,
    lastAttempted: firebase.firestore.FieldValue.serverTimestamp()
  };

  try {
    // Use setDoc with { merge: true } to create or update the document.
    await progressDocRef.set(dataWithTimestamp, { merge: true });
    console.log(`Progress for topic '${topicId}' updated:`, dataWithTimestamp);
  } catch (error) {
    console.error("Error updating student progress:", error);
  }
}
    function playAudio(audioElement){ return new Promise((resolve, reject) => { if (!audioElement || !(audioElement instanceof HTMLAudioElement)) { return reject(new Error("Invalid audio element")); } if (!window.userInteracted) { return resolve(); } audioElement.currentTime = 0; const playPromise = audioElement.play(); if(playPromise !== undefined) { playPromise.then(resolve).catch(error => { reject(error); }); } else { resolve(); } }); }
    function playRandomFeedback(soundType){
        if (!window.userInteracted || isThelobookActive || isPageGridVisible) return;
        let soundArray;
        if (currentLang === 'en') soundArray = (soundType === 'approve') ? approveSounds_en : disapproveSounds_en;
        else soundArray = (soundType === 'approve') ? approveSounds_hy : disapproveSounds_hy;
        if (soundArray && soundArray.length > 0) {
            const availableSounds = soundArray.filter(sound => sound instanceof HTMLAudioElement);
            if (availableSounds.length > 0) {
                const randomIndex = Math.floor(Math.random() * availableSounds.length);
                playAudio(availableSounds[randomIndex]).catch(e => {});
            }
        }
    }
    function formatAIMessage(key, replacements = {}){
        const TXT = getCurrentUIText(); let message = TXT[key] || `Missing text [${currentLang}]: ${key}`;
        const escapeHTML = (str) => String(str).replace(/[&<>"']/g, match => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[match]));
        for (const placeholder in replacements) {
            const replacementValue = replacements[placeholder] !== undefined && replacements[placeholder] !== null ? String(replacements[placeholder]) : '';
            message = message.replace(new RegExp(`{${placeholder}}`, 'g'), `<strong>${escapeHTML(replacementValue)}</strong>`);
        }
        return message;
    }
          /* ========== NEW: Toast Notification Logic ========== */
function showToast(rawMsg, duration = 4000) {
    const container = document.getElementById('toast-container');
    if (!container) return;

    // This part classifies the message to show the right icon
    const msg = rawMsg.replace(/^[\p{Extended_Pictographic}\uFE0F]+\s*/u, '');
    const TXT = getCurrentUIText();
    let emoji = 'ü´ß';
    let type = 'info'; 

    const isPoints  = /points? gained/i.test(msg) || (TXT.pointsGained && msg.includes(TXT.pointsGained.split("{")[0].trim()));
    const isWrong   = msg.includes('Not quite') || (TXT.incorrect && msg.includes(TXT.incorrect)) || msg.includes('Incorrect') || msg.includes('Wrong');
    const isCorrect = !isWrong && ((TXT.correct && msg.includes(TXT.correct)) || /^correct/i.test(msg));
    const isWarning = msg.includes('‚ö†Ô∏è') || (TXT.error && msg.includes(TXT.error));
    const isWelcome = TXT.welcome && msg.includes(TXT.welcome);
    const isChecking = TXT.checkingAI && msg.includes(TXT.checkingAI.split('<')[0]);

    if (isWrong) { emoji = 'ü§î'; type = 'error'; }
    else if (isCorrect || isPoints) { emoji = 'üéâ'; type = 'success'; }
    else if (isWarning || msg.includes('üõë')) { emoji = '‚ö†Ô∏è'; type = 'warning'; }
    else if (isWelcome) { emoji = 'üëã'; }
    else if (isChecking) { emoji = '‚è≥'; }

    // This part creates the toast element
    const toast = document.createElement('div');
    toast.className = `toast-message`;
    toast.innerHTML = `<span class="emoji" role="img" aria-label="icon">${emoji}</span> <span>${msg}</span>`;
    
    // This is the inner function that handles removing the toast
    const removeToast = () => {
        // First, we add the 'exiting' class to trigger the CSS transition
        toast.classList.add('exiting');
        
        // ===================================================================
        // THE ONLY CHANGE IS ON THIS LINE:
        // We now listen for 'transitionend' instead of 'animationend'.
        // This tells the code to wait for our new collapse transition to finish.
        toast.addEventListener('transitionend', () => {
            toast.remove();
        }, { once: true });
        // ===================================================================
    };

    // This sets the timer to automatically dismiss the toast
    const timeoutId = setTimeout(removeToast, duration);

    // This lets the user click the toast to dismiss it early
    toast.addEventListener('click', () => {
        clearTimeout(timeoutId);
        removeToast();
    }, { once: true });

    // This adds the toast to the page
    container.appendChild(toast);

    // This triggers the entry animation
    requestAnimationFrame(() => {
        toast.classList.add('show');
    });
}

function checkTabletMode() {
    // This media query should match the one in your CSS
    const tabletQuery = window.matchMedia('(min-width: 769px) and (max-width: 1200px) and (pointer: coarse)');
    const landscapeQuery = window.matchMedia('(min-width: 769px) and (max-width: 1200px) and (min-height: 500px)');

    isTabletMode = tabletQuery.matches || landscapeQuery.matches;
    console.log("Tablet Mode:", isTabletMode);
}
	function updateUserPointsInFirestore(pointsToAdd) {
        const user = auth.currentUser;
        if (!user) {
            console.warn("Attempted to update points for a non-logged-in user.");
            return;
        }

        const userDocRef = db.collection('thelo-students').doc(user.uid);

        // Use FieldValue.increment for atomic updates to prevent race conditions
        return userDocRef.update({
            points: firebase.firestore.FieldValue.increment(pointsToAdd)
        }).catch(error => {
            console.error("Error updating points in Firestore: ", error);
        });
    }
	/* ===== ADD THIS FUNCTION: The Main Streak Logic ======================== */
async function updateWeeklyStreak() {
    const user = auth.currentUser;
    if (!user) return; // Only run for logged-in users

    const userDocRef = db.collection('thelo-students').doc(user.uid);
    
    try {
        const doc = await userDocRef.get();
        const streakData = doc.exists && doc.data().streakData ? doc.data().streakData : {
            currentStreak: 0,
            longestStreak: 0,
            lastActivityWeek: null
        };

        const thisWeekId = getISOWeekIdentifier(new Date());

        // Scenario A: Already completed a lesson this week
        if (thisWeekId === streakData.lastActivityWeek) {
            console.log("Weekly streak already secured for:", thisWeekId);
            return;
        }

        const prevWeekId = getPreviousWeekIdentifier(thisWeekId);
        let newStreakData = { ...streakData };
        let showCelebration = false;

        // Scenario B: Streak Extended!
        if (prevWeekId === streakData.lastActivityWeek) {
            newStreakData.currentStreak += 1;
            console.log(`Weekly streak extended to ${newStreakData.currentStreak} weeks!`);
            showCelebration = true;
        } 
        // Scenario C: Streak Broken, new one starts
        else {
            newStreakData.currentStreak = 1;
            console.log("New weekly streak started!");
            showCelebration = true;
        }

        // Always update the last activity and check for a new record
        newStreakData.lastActivityWeek = thisWeekId;
        if (newStreakData.currentStreak > newStreakData.longestStreak) {
            newStreakData.longestStreak = newStreakData.currentStreak;
        }

        // Save to Firestore and show the modal
        await userDocRef.set({ streakData: newStreakData }, { merge: true });
        
        if (showCelebration) {
            showStreakCelebrationModal(newStreakData.currentStreak, newStreakData.currentStreak === newStreakData.longestStreak && newStreakData.currentStreak > 1);
        }

    } catch (error) {
        console.error("Error updating weekly streak:", error);
    }
}

function showStreakCelebrationModal(streakCount, isNewRecord) {
    const modal = document.getElementById('streakModal');
    const title = document.getElementById('streakModalTitle');
    const body = document.getElementById('streakModalBody');
    const closeBtn = document.getElementById('streakModalCloseBtn');
    const confirmBtn = document.getElementById('streakModalConfirmBtn');

    title.textContent = isNewRecord ? "New Record!" : "Weekly Streak Extended!";
    body.textContent = `That's ${streakCount} week${streakCount > 1 ? 's' : ''} in a row. Amazing work!`;
    
    const hideModal = () => modal.classList.add('modal-hidden');
    
    closeBtn.onclick = hideModal;
    confirmBtn.onclick = hideModal;

    modal.classList.remove('modal-hidden');
}	
// ANALYTICS: Helper function to log handwriting check attempts
function logHandwritingAttempt(result) {
    const user = auth.currentUser;
    const urlParams = new URLSearchParams(window.location.search);
    const lessonFileName = urlParams.get('lessonFile');

    if (user && lessonFileName && currentStageData) {
        db.collection("analytics_events").add({
            type: "handwriting_check_attempt",
            userId: user.uid,
            lessonId: lessonFileName.replace('.json', ''),
            stageIndex: currentStageIndex,
            result: result, // "correct" or "incorrect"
            timestamp: firebase.firestore.FieldValue.serverTimestamp()
        });
    }
}
	// REPLACE your entire old function with this new one
async function checkHandwritingAnswer() {
    console.log("Auth state at time of call:", isAuthReady);
    if (!isAuthReady) {
        console.warn("Auth is not ready yet. Aborting check.");
        return;
    }

    if (!auth.currentUser) {
        const TXT = getCurrentUIText();
        addChatMessage('AI', formatAIMessage('authErrorVision'));
        console.error("User is not authenticated. Cannot call analyzeHandwriting.");
        
        if (nextCheckBtn) {
            nextCheckBtn.disabled = false;
            nextCheckBtn.textContent = TXT.check;
        }
        return;
    }

    // =================================================================
    //  FIX: Force a refresh of the user's ID token.
    // =================================================================
    try {
        await auth.currentUser.getIdToken(true);
        console.log("Successfully refreshed auth token.");
    } catch (error) {
        console.error("Token refresh failed:", error);
        addChatMessage('AI', "Authentication error. Please try again.");
        // Re-enable the button so the user can try again
        if(nextCheckBtn) {
             const TXT = getCurrentUIText();
             nextCheckBtn.disabled = false;
             nextCheckBtn.textContent = TXT.check;
        }
        return;
    }
    // =================================================================

    if (isThelobookActive || isPageGridVisible) return;
    stopCurrentStageAudio();
    if (!currentStageData || currentStageData.type !== 'question_handwriting') return;
    if (nextCheckBtn.disabled || isTransitioning) return;

    const TXT = getCurrentUIText();
    nextCheckBtn.disabled = true;
    nextCheckBtn.textContent = TXT.checking;
    nextCheckBtn.classList.remove('correct', 'incorrect');

    if (isImageModeActive) {
        imageTerminalFeedback.innerHTML = `<span>${TXT.checking}</span>`;
        imageTerminalFeedback.style.opacity = 1;
    } else {
        addChatMessage('AI', formatAIMessage('checkingAI'));
    }

    let base64ImageData;
    try {
        const blankCanvas = document.createElement('canvas');
        blankCanvas.width = finalAnswerCanvas.width;
        blankCanvas.height = finalAnswerCanvas.height;
        const finalAnswerDataUrl = finalAnswerCanvas.toDataURL('image/png');
        if (finalAnswerDataUrl === blankCanvas.toDataURL()) {
            throw new Error("BLANK_ANSWER");
        }
        base64ImageData = finalAnswerDataUrl.split(',')[1];
    } catch (error) {
        const msg = error.message === "BLANK_ANSWER" ? formatAIMessage('blankBlueWarning') : formatAIMessage('imageDataError', { errorMessage: error.message });
        const shortMsg = "Please write your answer in blue ink.";
        isImageModeActive ? (imageTerminalFeedback.innerHTML = `<span>‚ö†Ô∏è ${shortMsg}</span>`, imageTerminalFeedback.style.opacity = 1) : addChatMessage('AI', msg);
        playRandomFeedback('disapprove');
        nextCheckBtn.disabled = false;
        nextCheckBtn.textContent = TXT.check;
        if (isImageModeActive) setTimeout(() => imageTerminalFeedback.style.opacity = 0, 2500);
        return;
    }

    try {
        const analyzeHandwriting = firebase.functions().httpsCallable('analyzeHandwriting');
        const result = await analyzeHandwriting({ imageBase64: base64ImageData });
        const detectedText = result.data.text || '';

        if (!detectedText.trim()) {
            throw new Error("NO_TEXT_FOUND");
        }

        let cleanedText = detectedText.replace(/\s+/g, '').replace(/[oO]/g, '0').replace(/,/g, '.'); // Also replace commas with dots
const numberPattern = /-?\d+(\.\d+)?/; // This is the new regex
const detectedAnswerMatch = cleanedText.match(numberPattern);
const detectedAnswer = detectedAnswerMatch ? detectedAnswerMatch[0] : ''; // Extract the full number

const correctAnswer = String(currentStageData.correctAnswerOcr);

if (detectedAnswer && parseFloat(detectedAnswer) === parseFloat(correctAnswer)) {
            logHandwritingAttempt('correct');
            const pointsGained = 10;
            const feedbackForTerminal = "üéâ Correct!";
            playRandomFeedback('approve');
            userPoints += pointsGained;
            sessionPoints += pointsGained;
            updatePointsDisplay();
            updateUserPointsInFirestore(pointsGained);
            nextCheckBtn.classList.add('correct');
            const chatMessageWithPoints = `${formatAIMessage('correctAI', { detectedAnswer })} ${formatAIMessage('pointsGained', { points: pointsGained })}`;

            // --- ADD THIS LINE FOR LOGGING ON CORRECT ANSWER ---
            logDigitForTraining(detectedAnswer, 'correct'); // Log the correctly recognized digit

            if (isImageModeActive) {
                imageTerminalFeedback.innerHTML = `<span>${feedbackForTerminal}</span>`;
                imageTerminalFeedback.style.opacity = 1;
                lessonStages[currentStageIndex].headline = chatMessageWithPoints;
                setTimeout(nextStage, 2000);
            } else {
    addChatMessage('AI', chatMessageWithPoints);
    // Wrap the nextStage call in its own timeout to let the chat animation finish first.
    setTimeout(() => {
        nextStage();
    }, 2000); // 2 seconds gives plenty of time for the user to read the feedback.
}
        } else {
            logHandwritingAttempt('incorrect');
            const feedbackForTerminal = "Not quite, try again!";
            playRandomFeedback('disapprove');
            nextCheckBtn.classList.add('incorrect');

            // --- ADD THIS LINE FOR LOGGING ON INCORRECT ANSWER (if you want to capture these too) ---
            // You might log 'detectedAnswer' as the guessed value and 'correctAnswer' as the true value
            logDigitForTraining(detectedAnswer, 'incorrect');

            if (isImageModeActive) {
                imageTerminalFeedback.innerHTML = `<span>‚ö†Ô∏è ${feedbackForTerminal}</span>`;
                imageTerminalFeedback.style.opacity = 1;
                setTimeout(() => {
                    imageTerminalFeedback.style.opacity = 0;
                    nextCheckBtn.disabled = false;
                    nextCheckBtn.textContent = TXT.check;
                    nextCheckBtn.classList.remove('incorrect');
                }, 2500);
            } else {
                addChatMessage('AI', formatAIMessage('incorrectAI', { detectedAnswer: detectedAnswer || 'none', correctAnswer }));
                nextCheckBtn.disabled = false;
                nextCheckBtn.textContent = TXT.check;
                setTimeout(() => nextCheckBtn.classList.remove('incorrect'), 600);
            }
        }
    } catch (error) {
        console.error("Function call failed:", error);
        let userErrorMessage;
        const isKnownUITextError = Object.values(TXT).includes(error.message);

        if (error.code === 'functions/resource-exhausted') {
            userErrorMessage = TXT.limitReached;
        } else if (error.code === 'unauthenticated' || error.message.includes('logged in')) {
            userErrorMessage = TXT.authErrorVision;
        } else if (error.message === "NO_TEXT_FOUND") {
            userErrorMessage = formatAIMessage('noTextFound');
        } else if (isKnownUITextError) {
            userErrorMessage = error.message;
        } else {
            userErrorMessage = formatAIMessage('apiErrorGeneral', { errorMessage: error.message });
        }

        const shortMsg = error.code === 'functions/resource-exhausted' ? "Monthly limit reached." : "An error occurred.";
        isImageModeActive ? (imageTerminalFeedback.innerHTML = `<span>‚ö†Ô∏è ${shortMsg}</span>`, imageTerminalFeedback.style.opacity = 1) : addChatMessage('AI', userErrorMessage);

        playRandomFeedback('disapprove');
        nextCheckBtn.disabled = false;
        nextCheckBtn.textContent = TXT.check;
        if (isImageModeActive) setTimeout(() => imageTerminalFeedback.style.opacity = 0, 2500);
    }
}	    function eraseBlueInk() { if (isThelobookActive || isPageGridVisible) return; const TXT = getCurrentUIText(); if(finalCtx) { finalCtx.fillStyle = '#FFFFFF'; finalCtx.fillRect(0, 0, finalAnswerCanvas.width / devicePixelRatio, finalAnswerCanvas.height / devicePixelRatio); } addChatMessage('AI', formatAIMessage('blueInkErased')); }

    /* ========== THELOBOOK FUNCTIONALITY ========== */
        function updateThelobookPageControls() {
        const TXT = getCurrentUIText();
        const totalPages = Math.max(1, thelobookPages.length); // Ensure at least 1 for display

        if (thelobookPageIndicatorEl && TXT && TXT.thelobookPageIndicator) {
            thelobookPageIndicatorEl.textContent = TXT.thelobookPageIndicator
                .replace('{currentPage}', currentThelobookPageIndex + 1)
                .replace('{totalPages}', totalPages);
        }

        // Disable previous/next page buttons if at bounds or animating
        if (thelobookPrevPageBtn) thelobookPrevPageBtn.disabled = (currentThelobookPageIndex === 0 || isPageSwitchingAnimation);
        if (thelobookNextPageBtn) thelobookNextPageBtn.disabled = (currentThelobookPageIndex >= totalPages - 1 || isPageSwitchingAnimation);

        // Disable Add Page button if limit is reached (32 pages) or animating
        if (thelobookAddPageBtn) {
            thelobookAddPageBtn.disabled = (thelobookPages.length >= PAGES_PER_GRID_BATCH || isPageSwitchingAnimation);
        }

        // Disable eraser/pages button if animating
        if (thelobookEraserBtn) thelobookEraserBtn.disabled = isPageSwitchingAnimation;
        if (thelobookPagesBtn) thelobookPagesBtn.disabled = isPageSwitchingAnimation;
    }
    function saveCurrentThelobookPageDrawing() {
        if (!isThelobookActive || isPageSwitchingAnimation || !thelobookCtx || !thelobookCanvas || thelobookCanvas.width === 0 || thelobookCanvas.height === 0) {
            // Optional: Log why saving was skipped
            // console.warn("Save Thelobook: Conditions not met or canvas zero size", {isThelobookActive, isPageSwitchingAnimation, hasCtx: !!thelobookCtx, hasCanvas: !!thelobookCanvas, cW: thelobookCanvas?.width, cH: thelobookCanvas?.height });
            return;
        }
        try {
            if (currentThelobookPageIndex < 0) currentThelobookPageIndex = 0;
            while (thelobookPages.length <= currentThelobookPageIndex) {
                thelobookPages.push(null);
            }
            // THE FIX IS HERE: Remove division by devicePixelRatio
            thelobookPages[currentThelobookPageIndex] = thelobookCtx.getImageData(0, 0, thelobookCanvas.width, thelobookCanvas.height);
            // console.log("Saved Thelobook page", currentThelobookPageIndex, "with bitmap dimensions:", thelobookCanvas.width, "x", thelobookCanvas.height);
        } catch (e) {
            console.error("Error saving Thelobook page:", e);
            // Add more details if error occurs
            // console.error("Canvas details at error: attr W/H", thelobookCanvas?.width, thelobookCanvas?.height, "style W/H", thelobookCanvas?.style.width, thelobookCanvas?.style.height, "DPR", devicePixelRatio);
        }
    }

    function loadThelobookPageDrawing(pageIndex) {
        if (thelobookCtx) {
            thelobookCtx.clearRect(0, 0, thelobookCanvas.width / devicePixelRatio, thelobookCanvas.height / devicePixelRatio);
            if (pageIndex >= 0 && pageIndex < thelobookPages.length && thelobookPages[pageIndex]) {
                try { thelobookCtx.putImageData(thelobookPages[pageIndex], 0, 0); }
                catch (e) { console.error("Error loading Thelobook page data:", e); }
            }
        }
        currentThelobookPageIndex = pageIndex;
        updateThelobookPageControls();
    }

    function addThelobookNewPage() {
        // Check if page creation limit is reached (PAGES_PER_GRID_BATCH is 32)
        if (thelobookPages.length >= PAGES_PER_GRID_BATCH) {
            const TXT = getCurrentUIText();
            addChatMessage('AI', `‚ö†Ô∏è ${TXT.error}: Maximum of ${PAGES_PER_GRID_BATCH} pages allowed.`); // Provide user feedback
            return; // Stop function execution
        }

        if (isPageSwitchingAnimation) return; // Check if already switching
        saveCurrentThelobookPageDrawing(); // Save current page first
        thelobookPages.push(null); // Add a new blank page placeholder
        currentThelobookPageIndex = thelobookPages.length - 1; // Move to the new page
        loadThelobookPageDrawing(currentThelobookPageIndex); // Load the (blank) new page
        updateThelobookPageControls(); // Ensure controls are updated after adding a page
    }

    function changeThelobookPageSimple(direction) {
        if (isPageSwitchingAnimation) return; // Prevent re-entrant calls

        const oldPageIndex = currentThelobookPageIndex;
        let newPageIndex = currentThelobookPageIndex + direction;
        const totalPages = Math.max(1, thelobookPages.length);

        // Bounds checking for newPageIndex
        if (newPageIndex < 0) newPageIndex = 0;
        if (newPageIndex >= totalPages) newPageIndex = totalPages - 1;

        if (oldPageIndex !== newPageIndex) {
            saveCurrentThelobookPageDrawing(); // **** MOVED: Save current page BEFORE disabling controls/animating ****

            isPageSwitchingAnimation = true;
            updateThelobookPageControls(); // Update controls to reflect "switching" state (e.g., disable buttons)

            currentThelobookPageIndex = newPageIndex;
            loadThelobookPageDrawing(currentThelobookPageIndex); // Load the new page (this also calls updateThelobookPageControls)

            // Reset animation flag after a short delay/next frame to allow UI to settle
            requestAnimationFrame(() => {
                isPageSwitchingAnimation = false;
                updateThelobookPageControls(); // Ensure controls are updated for the new page state
            });
        }
    }
    function toggleThelobookEraser() {
        if (isPageSwitchingAnimation) return;
        isThelobookEraserActive = !isThelobookEraserActive;
        const TXT = getCurrentUIText();
        if (thelobookEraserBtn) {
            thelobookEraserBtn.textContent = isThelobookEraserActive ? 'üñãÔ∏è' : '‚úèÔ∏è';
            thelobookEraserBtn.title = isThelobookEraserActive ? TXT.thelobookPen : TXT.thelobookEraser;
            thelobookEraserBtn.classList.toggle('active', isThelobookEraserActive);
        }
        if (thelobookCanvas) thelobookCanvas.classList.toggle('eraser-active', isThelobookEraserActive);
        updateColorIndicator();
    }

    /* ---------------- helper: snapshot & pause media ---------------- */
    function captureMediaState() {
        mediaPlaybackTimeBeforeThelobook = internalPlaybackTime;
        audioTimeBeforeThelobook       = currentStageAudio ? currentStageAudio.currentTime : 0;
        wasMediaPlayingBeforeThelobook  = false;

        if (currentStageAudio && !currentStageAudio.paused) {
        currentStageAudio.pause();
        wasMediaPlayingBeforeThelobook = true;
        }

        if (isMediaScrubbingActive) {
        if (currentReplayAnimationId) cancelAnimationFrame(currentReplayAnimationId);
        currentReplayAnimationId = null;
        isMediaScrubbingActive  = false;
        wasMediaPlayingBeforeThelobook = true;
        }
        stageProgressBarContainer?.classList.remove('visible');
    }
    /* ---------------- helper: resume or freeze ---------------------- */
    function resumeMediaState() {
        const atEnd =
        currentStageTotalDuration > 0 &&
        mediaPlaybackTimeBeforeThelobook >= currentStageTotalDuration - 0.05;

        internalPlaybackTime = atEnd
        ? currentStageTotalDuration
        : mediaPlaybackTimeBeforeThelobook;

        if (currentStageAudio) { // currentTime will be used by playStageAudio in resume mode
        currentStageAudio.currentTime = audioTimeBeforeThelobook;
        }

        isMediaScrubbingActive = wasMediaPlayingBeforeThelobook && !atEnd;

        if (atEnd && currentStageDrawingData && replayCtx && currentStageTotalDuration > 0) {
        renderDrawingAtTime(currentStageTotalDuration, currentStageDrawingData, replayCtx);
        updateMediaProgressBar(currentStageTotalDuration, currentStageTotalDuration);
        stageProgressBarContainer?.classList.add('visible');
        }
        renderStageUI(currentStageIndex, true); // isResize = true indicates resume context
    }

    function openThelobook() {
    // ‚Äî early exits ‚Äî
    if (isThelobookActive || isPageGridVisible) return;

    /*  MCQ stages are now allowed ‚Äî guard removed  */

    isThelobookActive      = true;
    isThelobookEraserActive = false;

    const TXT = getCurrentUIText();

    // pause audio / drawing playback and snapshot timing
    captureMediaState();

    // show notebook canvas & controls
    thelobookCanvas.classList.remove('grid-underlay');
    thelobookCanvas.classList.add('active');
    thelobookControlsEl.classList.add('visible');

    // ensure at least one page exists, then load current page
    if (thelobookPages.length === 0) {
        thelobookPages.push(null);
        currentThelobookPageIndex = 0;
    }
    loadThelobookPageDrawing(currentThelobookPageIndex);

    // switch input listeners
    removeBoardDrawListeners();
    addThelobookDrawListeners();
    canvas.style.pointerEvents = 'none';

    // update UI text / states
    thelobookBtn.textContent = TXT.thelobookClose;
    if (thelobookEraserBtn) {
        thelobookEraserBtn.textContent = '‚úèÔ∏è';
        thelobookEraserBtn.title      = TXT.thelobookEraser;
        thelobookEraserBtn.classList.remove('active');
    }
    if (clearBtn)  clearBtn.disabled  = true;
    if (prevBtn)   prevBtn.disabled   = true;
    if (nextCheckBtn) nextCheckBtn.disabled = true;

    updateColorIndicator();
    updateThelobookPageControls();

    /* ‚îÄ‚îÄ blur MCQ block if it‚Äôs visible ‚îÄ‚îÄ */
    if (mcqOptionsContainer &&
        mcqOptionsContainer.style.display !== 'none') {
        mcqOptionsContainer.classList.add('blurred-mcq');
    }
}


function closeThelobook(savePage = true) {
    if (!isThelobookActive) return;

    /* ‚îÄ‚îÄ restore MCQ clarity ‚îÄ‚îÄ */
    if (mcqOptionsContainer) {
        mcqOptionsContainer.classList.remove('blurred-mcq');
    }

        if (savePage) saveCurrentThelobookPageDrawing();
        isThelobookActive = false; const TXT = getCurrentUIText();

        thelobookCanvas.classList.remove('active');
        thelobookCanvas.classList.remove('grid-underlay');
        thelobookControlsEl.classList.remove('visible');
        removeThelobookDrawListeners(); addBoardDrawListeners();
        thelobookBtn.textContent = TXT.thelobookOpen;
        
        resumeMediaState();
        
        // ======================= FIX STARTS HERE =======================
        if (currentStageIndex === -1) {
            // This is the edge case: lesson hasn't started.
            // Manually re-enable the 'Start' button.
            if (nextCheckBtn) nextCheckBtn.disabled = false;
        }
        // ======================== FIX ENDS HERE ========================

        // The original logic can remain or be cleaned up, but the fix above is key.
        if (currentStageData) {
            // renderStageUI is called by resumeMediaState
        } else {
            updateColorIndicator();
            canvas.style.pointerEvents = 'none';
        }
       
        wasMediaPlayingBeforeThelobook = false; 
    }
   // REPLACE your existing open/close calculator functions with these

// REPLACE your functions with these corrected versions

function openCalculator() {
    if (isCalculatorActive || isThelobookActive || isPageGridVisible) return;
    isCalculatorActive = true;

    // The line that hid the terminal has been REMOVED from here.

    // Pause lesson and capture state
    captureMediaState();

    // Set the src only when opening to load it
    if(calculatorFrame.src === 'about:blank') {
       calculatorFrame.src = 'https://thelo.space/thelo-calculator/';
    }
    
    // Show the overlay
    calculatorOverlay.classList.remove('calculator-hidden');
    
    // Blur MCQs if they are visible
    if (mcqOptionsContainer && mcqOptionsContainer.style.display !== 'none') {
        mcqOptionsContainer.classList.add('blurred-mcq');
    }

    // Disable main controls
    if (clearBtn)  clearBtn.disabled  = true;
    if (prevBtn)   prevBtn.disabled   = true;
    if (nextCheckBtn) nextCheckBtn.disabled = true;
}

function closeCalculator() {
    if (!isCalculatorActive) return;
    isCalculatorActive = false;
    
    // The line that showed the terminal has been REMOVED from here.
    
    // Hide the overlay
    calculatorOverlay.classList.add('calculator-hidden');
    
    // Un-blur MCQs
    if (mcqOptionsContainer) {
        mcqOptionsContainer.classList.remove('blurred-mcq');
    }
    
    // Resume lesson state
    resumeMediaState();
}
function handleKeyDown(event){
¬† ¬† ¬† ¬† if (event.ctrlKey || event.altKey || event.metaKey || ['INPUT','TEXTAREA','BUTTON'].includes(event.target.tagName.toUpperCase())) return;

        /* ===== ADDED: Activate 'View Progress' on SPACE key at end of lesson ===== */
        if (event.key === ' ' && dashboardBtn && dashboardBtn.classList.contains('visible')) {
            dashboardBtn.click(); // Trigger the button's click event
            event.preventDefault(); // Prevent default spacebar action (e.g., scrolling)
            return; // Stop further execution
        }
        /* ========================================================================= */

¬† ¬† ¬† ¬† if (isPageGridVisible) {
            switch(event.key.toLowerCase()) {
                case 'c': changePageGridBatch(1); event.preventDefault(); return;
                case 'x': changePageGridBatch(-1); event.preventDefault(); return;
                case 'escape': closePageGridView(); event.preventDefault(); return;
            }
            return;
        }
	if (isCalculatorActive) {
            if (event.key.toLowerCase() === 'f' || event.key === 'Escape') {
                closeCalculator();
                event.preventDefault();
            }
            return;
        }
        if (isThelobookActive) {
            switch(event.key.toLowerCase()) {
                case 'b': closeThelobook(true); event.preventDefault(); return;
                case 'escape': closeThelobook(true); event.preventDefault(); return;
                case 'e': toggleThelobookEraser(); event.preventDefault(); return;
                case 'c': clearUserCanvas(); event.preventDefault(); return;
            }
            return;
        }
        /* ‚îÄ‚îÄ QUICK-START LESSON WITH SPACE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
        if (
        event.key === ' ' &&             // space-bar hit
        currentStageIndex === -1 &&       // lesson not started yet
        !isLessonLoading && !isTransitioning &&
        !isThelobookActive && !isPageGridVisible &&
        nextCheckBtn && !nextCheckBtn.disabled
        ) {
        handleNextCheckClick();           // same action as the ‚ÄúStart‚Äù button
        event.preventDefault();           // stop page scrolling, etc.
        return;                           // nothing else to do for this keypress
        }
        /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

        if (currentStageIndex < 0 || isTransitioning || isLessonLoading || !currentStageData) return;
        const mcqDetails = currentStageData.optionsQuiz;
        const isMcqActive = !!(mcqDetails && Array.isArray(mcqDetails.choices) && mcqDetails.choices.length > 0);

        switch (event.key.toLowerCase()){
            case ' ':
                if (!isMcqActive && nextCheckBtn && !nextCheckBtn.disabled){ handleNextCheckClick(); event.preventDefault(); }
                break;
            case 'a':
                if (isStudentInputAllowed && !isMcqActive) { toggleColor(); event.preventDefault(); }
                break;
            case 'b':
                if (currentStageIndex >=0 && currentStageData) { openThelobook(); event.preventDefault(); }
                break;
	    case 'f':
                openCalculator();
                event.preventDefault();
                break;
            case 'c':
                if (isStudentInputAllowed && !isMcqActive && clearBtn && clearBtn.style.display !== 'none' && !clearBtn.disabled){
                    clearUserCanvas(); event.preventDefault();
                }
                break;
        }
        const canScrub = currentStageTotalDuration > 0 && (isMediaScrubbingActive || (currentStageAudio && currentStageData.audioFile) || (currentStageDrawingData && currentStageData.drawingRecord));
        if ((event.key === 'ArrowLeft' || event.key === 'ArrowRight') && canScrub && !isThelobookActive && !isPageGridVisible) {
            const step = 5; const diff = event.key === 'ArrowLeft' ? -step : step;
            let newTime = internalPlaybackTime + diff; newTime = Math.max(0, Math.min(newTime, currentStageTotalDuration));
            internalPlaybackTime = newTime;

            if (currentStageAudio && currentStageData.audioFile){
                currentStageAudio.currentTime = Math.min(newTime, currentStageAudio.duration > 0.01 ? currentStageAudio.duration - 0.01 : 0);
                if (window.userInteracted && currentStageAudio.paused && newTime < (currentStageAudio.duration - 0.01) && currentStageAudio.src.includes(currentStageData.audioFile)){
                    currentStageAudio.play().catch(()=>{});
                }
            }
            if (!isMediaScrubbingActive && currentStageTotalDuration > 0){
                isMediaScrubbingActive = true;
                if (!currentReplayAnimationId){ currentReplayAnimationId = requestAnimationFrame(mediaPlaybackLoop); }
            }
            if (currentStageDrawingData && replayCtx && currentStageData.drawingRecord){
                    renderDrawingAtTime(newTime, currentStageDrawingData, replayCtx);
            }
            updateMediaProgressBar(newTime, currentStageTotalDuration);
            lastFrameTimestampForManualAdvance = performance.now(); event.preventDefault();
        }
    }
    // Prevent zooming via keyboard and mouse wheel
window.addEventListener('keydown', function(e) {
  if ((e.ctrlKey || e.metaKey) && (e.key === '+' || e.key === '-' || e.key === '=')) {
    e.preventDefault();
  }
});

window.addEventListener('wheel', function(e) {
  if (e.ctrlKey) {
    e.preventDefault();
  }
}, { passive: false });
    function initApp() {
      checkTabletMode();
        const audioIdsToLoad = [
            'audio_approve1_hy', 'audio_approve2_hy', 'audio_dis1_hy', 'audio_dis2_hy',
            'audio_approve1_en', 'audio_approve2_en', 'audio_dis1_en', 'audio_dis2_en', 'gotItSound'
        ];
        audioIdsToLoad.forEach(id => {
            const audio = document.getElementById(id);
            if (audio) {
                audioElements[id] = audio;
                if (id.startsWith('audio_approve') && id.endsWith('_hy')) approveSounds_hy.push(audio);
                if (id.startsWith('audio_dis') && id.endsWith('_hy')) disapproveSounds_hy.push(audio);
                if (id.startsWith('audio_approve') && id.endsWith('_en')) approveSounds_en.push(audio);
                if (id.startsWith('audio_dis') && id.endsWith('_en')) disapproveSounds_en.push(audio);
            }
        });
        resizeCanvases();
        addBoardDrawListeners();
        window.addEventListener('mouseup', handleDrawingEnd);
        window.addEventListener('mouseleave', handleDrawingEnd);
        window.addEventListener('touchend', handleDrawingEnd);
        window.addEventListener('touchcancel', handleDrawingEnd);

        const urlParams = new URLSearchParams(window.location.search);
        const lessonFileName = urlParams.get('lessonFile');
        if (lessonFileName) {
            const LESSONS_BASE_PATH = 'https://thelo.space/lessons/';
            const cleanLFN = lessonFileName.startsWith('/') ? lessonFileName.substring(1) : lessonFileName;
            loadLesson(LESSONS_BASE_PATH + cleanLFN.replace(/\.\.+/g, ''));
        } else {
            const TXT = getCurrentUIText();
            addChatMessage('AI', formatAIMessage('lessonFileMissing'));
            if(nextCheckBtn){nextCheckBtn.textContent = TXT.error; nextCheckBtn.disabled = true;}
            if(prevBtn)prevBtn.disabled = true;
            if(bgCtx && backgroundCanvas && backgroundCanvas.width > 0){
                const cw = backgroundCanvas.width/(window.devicePixelRatio||1); const ch = backgroundCanvas.height/(window.devicePixelRatio||1);
                bgCtx.clearRect(0,0,cw,ch); bgCtx.font = `20px 'Mardoto-Light', system-ui, sans-serif`;
                bgCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--thelo-text').trim();
                bgCtx.textAlign='center';bgCtx.textBaseline='middle';
                wrapText(bgCtx, TXT.lessonLoadErrorGeneric, cw/2, ch/2, cw*0.8, 30);
            }
        }
        const interactionListener = () => { if (window.userInteracted) return; window.userInteracted = true; Object.values(audioElements).forEach(a => { if(a.readyState < 1) a.load(); }); if(stageAudioPlayer && stageAudioPlayer.readyState < 1) stageAudioPlayer.load(); try { const tempAC = new (window.AudioContext || window.webkitAudioContext)(); if (tempAC.state === 'suspended') tempAC.resume().then(()=>tempAC.close()); else tempAC.close(); } catch(e){} document.body.removeEventListener('click', interactionListener); document.body.removeEventListener('keydown', interactionListener); document.body.removeEventListener('touchstart', interactionListener); };
        document.body.addEventListener('click', interactionListener, { once: true });
        document.body.addEventListener('keydown', interactionListener, { once: true });
        document.body.addEventListener('touchstart', interactionListener, { once: true });
        window.addEventListener('resize', resizeCanvases);
        if (prevBtn) prevBtn.onclick = previousStage;
        if (nextCheckBtn) nextCheckBtn.onclick = handleNextCheckClick;
        if (clearBtn) clearBtn.onclick = clearUserCanvas;
        if (thelobookBtn) thelobookBtn.onclick = () => { isThelobookActive ? closeThelobook(true) : openThelobook(); };

        if (thelobookPrevPageBtn) thelobookPrevPageBtn.onclick = () => changeThelobookPageSimple(-1);
        if (thelobookNextPageBtn) thelobookNextPageBtn.onclick = () => changeThelobookPageSimple(1);
        if (thelobookEraserBtn) thelobookEraserBtn.onclick = toggleThelobookEraser;
        if (thelobookAddPageBtn) thelobookAddPageBtn.onclick = addThelobookNewPage;
	 if (calculatorCloseBtn) calculatorCloseBtn.onclick = closeCalculator;
	if (dashboardBtn) {
	    dashboardBtn.onclick = () => {
	        window.location.href = 'https://thelo.space/sdashboard';
	    };
	}
        // ... inside the initApp() function

        document.querySelectorAll('button').forEach(button => {
            button.addEventListener('click', () => {
                button.blur();
            });
        });


        document.addEventListener('keydown', handleKeyDown);

        // ANALYTICS: Add event listener to handle users leaving the page
        window.addEventListener('beforeunload', () => {
            const user = auth.currentUser;
            // Check if a lesson is currently in progress
            if (user && lessonStartTime && currentStageIndex < lessonStages.length -1) {
                const urlParams = new URLSearchParams(window.location.search);
                const lessonFileName = urlParams.get('lessonFile');
                
                // This is a synchronous call. It's not guaranteed to complete,
                // but it's the best we can do in a 'beforeunload' event.
                navigator.sendBeacon('https://firestore.googleapis.com/v1/projects/physmathacademy-722b3/databases/(default)/documents/analytics_events', JSON.stringify({
                    fields: {
                        type: { stringValue: 'lesson_abandoned' },
                        userId: { stringValue: user.uid },
                        lessonId: { stringValue: lessonFileName.replace('.json', '') },
                        lastCompletedStageIndex: { integerValue: currentStageIndex },
                        totalStagesInLesson: { integerValue: lessonStages.length },
                        timestamp: { timestampValue: new Date().toISOString() }
                    }
                }));
            }
        });
    }

    if (typeof window.appInitialized === 'undefined') {
        window.appInitialized = false;
    }

    // REPLACE your entire auth.onAuthStateChanged function with this one.

auth.onAuthStateChanged(user => {
    // This inner function will run only after all async tasks are done.
    const finishInitialization = () => {
        if (!window.appInitialized) {
            window.appInitialized = true;
            initApp();
        } else {
            updateAllUITexts();
        }
        // Set the flag to true as the very last step.
        isAuthReady = true;
        console.log("Authentication is now ready.");
    };

    if (user) {
        console.log("User authenticated with UID:", user.uid);
        const userDocRef = db.collection('thelo-students').doc(user.uid);
        
        // This is an async call. We must wait for it to finish.
        userDocRef.get().then(doc => {
            if (doc.exists) {
                userPoints = doc.data().points || 0;
            } else {
                userPoints = 0;
                console.log("No points document found for user, starting at 0.");
            }
            updatePointsDisplay();
            finishInitialization(); // Finish init AFTER getting points.
        }).catch(error => {
            console.error("Error fetching user points:", error);
            userPoints = 0;
            updatePointsDisplay();
            finishInitialization(); // Also finish init if there's an error.
        });
    } else {
        // If there is no user, there's no async task, so we can proceed.
        userPoints = 0;
        updatePointsDisplay();
        console.log("User not authenticated.");
        finishInitialization();
    }
});

// Add this function somewhere logical, e.g., near updateUserPointsInFirestore
async function logDigitForTraining(recognizedValue, feedbackType) {
    const user = auth.currentUser;
    if (!user) {
        console.warn("No user for digit logging. Skipping.");
        return;
    }

    // Ensure finalAnswerCanvas has content (blue ink drawing)
    if (!finalAnswerCanvas || finalAnswerCanvas.width === 0 || finalAnswerCanvas.height === 0) {
        console.warn("finalAnswerCanvas is not ready or empty. Cannot log digit for training.");
        return;
    }

    let base64ImageData;
    try {
        // Capture the content of the finalAnswerCanvas (which contains the blue ink)
        // You might want to consider cropping this canvas to just the bounding box of the digit
        // for optimal training data, but for a demo, the whole canvas is fine.
        base64ImageData = finalAnswerCanvas.toDataURL('image/png'); // PNG is generally better for line art/digits
    } catch (e) {
        console.error("Failed to get image data from canvas for logging:", e);
        return;
    }

    const metadata = {
        digit: String(recognizedValue), // The correct digit from the lesson data
        recognizedByVision: currentStageData.correctAnswerOcr, // What Google Vision identified
        feedbackType: feedbackType, // 'correct' or 'incorrect' for feedback
        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
        userId: user.uid, // Anonymous user ID
        lessonId: new URLSearchParams(window.location.search).get('lessonFile')?.replace('.json', '') || 'unknown',
        stageIndex: currentStageIndex,
        deviceType: isTabletMode ? 'tablet' : 'desktop', // Simple detection
        userAgent: navigator.userAgent, // Detailed user agent
        screenWidth: window.screen.width,
        screenHeight: window.screen.height,
        canvasWidth: finalAnswerCanvas.width,
        canvasHeight: finalAnswerCanvas.height,
        devicePixelRatio: window.devicePixelRatio || 1,
        // You could add inputMethod: e.pointerType (from drawing start event, but harder to pass here)
    };

    try {
        // Send to a new collection specifically for training data
        await db.collection('thelo-training-digits-demo').add({
            imageData: base64ImageData, // Base64 encoded image
            metadata: metadata
        });
        console.log("Handwritten digit logged for training demo:", recognizedValue);
    } catch (error) {
        console.error("Error logging digit for training demo:", error);
    }
}
</script>
	<div id="streakModal" class="modal-hidden">
    <div class="streak-modal-content">
        <span id="streakModalCloseBtn" class="streak-modal-close">&times;</span>
        <div class="streak-modal-icon">üî•</div>
        <h2 id="streakModalTitle"></h2>
        <p id="streakModalBody"></p>
        <button id="streakModalConfirmBtn" class="control-btn">Awesome!</button>
    </div>
</div>
</body>
</html>
