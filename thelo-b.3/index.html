<!DOCTYPE html>
<html lang="hy">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link rel="icon" href="https://thelo.space/img/thelofavicon.png" type="image/png">
    <link rel="apple-touch-icon" href="https://thelo.space/img/yarnicon.png">
    <title>thelo</title>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
	<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-functions-compat.js"></script>
	<link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@300;400;500;700&display=swap" rel="stylesheet">
	<link rel="manifest" href="/manifest.json" />
  
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd" crossorigin="anonymous"></script>
<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">


<style>
 /* ===== NEW: Updated Design System ===== */
 :root {
    /* Core Palette */
    --thelo-blue: #2563eb;
    --thelo-blue-dark: #1d4ed8;
    --thelo-bg: #ffffff;
    --thelo-text: #111827;
    --thelo-text-light: #6b7280;
    --thelo-border: #e5e7eb;

    /* Status Colors */
    --success-green: #22c55e;
    --error-red: #ef4444;
    --accent-yellow: #f59e0b;

    /* UI Element Colors */
    --bg-white: #ffffff;
    --chat-ai-bg: #ffffff;

    /* Ink Colors */
    --ink-black: #000000;
    --ink-blue: var(--thelo-blue);

    /* Effects */
    --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
    --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);

    /* Transitions */
    --fade-duration: 0.3s;
    --animation-duration: 0.3s;
    --thelobook-page-transition-duration: 0.05s;
 }
 #loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: var(--thelo-bg); /* Use your existing background color */
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999; /* Ensure it's on top of all other content */
    opacity: 1;
    /* Add a transition for the fade-out effect */
    transition: opacity 0.5s ease-out;
}

#loading-overlay.hidden {
    opacity: 0;
    pointer-events: none; /* Prevents interaction while fading out */
}

#loading-svg {
    width: 150px; /* A larger logo as requested */
    height: auto;
    animation: pulse-loader 1.5s infinite ease-in-out;
}
/* Add this to your CSS */
 #fullscreenBtn {
    background-color: #6b7280; /* A neutral gray */
 }
/* This is the animation for the logo */
@keyframes pulse-loader {
    0% {
        transform: scale(1);
        opacity: 0.8;
    }
    50% {
        transform: scale(1.1);
        opacity: 1;
    }
    100% {
        transform: scale(1);
        opacity: 0.8;
    }
}

 /* ===== Font Definition (Unchanged as requested) ===== */
@font-face {
  font-family: 'Mardoto-Light';
  src: url('../../fonts/Mardoto-Light.ttf') format('truetype');
  font-weight: 300;
  font-style: normal;
  font-display: swap;
}
	@font-face {
Â  Â  Â  font-family: 'Montserrat Arm';
Â  Â  Â  src: url('https://thelo.space/fonts/Montserratarm-Regular.otf') format('opentype');
Â  Â  Â  font-weight: 400; /* Regular */
Â  Â  Â  font-style: normal;
Â  Â  Â  font-display: swap;
Â  Â  }
Â  Â  @font-face {
Â  Â  Â  font-family: 'Montserrat Arm';
Â  Â  Â  src: url('https://thelo.space/fonts/Montserratarm-SemiBold.otf') format('opentype');
Â  Â  Â  font-weight: 600; /* SemiBold */
Â  Â  Â  font-style: normal;
Â  Â  Â  font-display: swap;
Â  Â  }
Â  Â  @font-face {
Â  Â  Â  font-family: 'Montserrat Arm';
Â  Â  Â  src: url('https://thelo.space/fonts/Montserratarm-ExtraBold.otf') format('opentype');
Â  Â  Â  font-weight: 800; /* ExtraBold */
Â  Â  Â  font-style: normal;
Â  Â  Â  font-display: swap;
Â  Â  }

/* ===== Base Styles ===== */
html {
  font-size: 16px;
  background: var(--thelo-bg);
}
body {
Â  margin: 0;
Â  min-height: 100vh;
Â  height: 100vh;
Â  font-family: 'Montserrat Arm', system-ui, -apple-system, sans-serif;
  font-weight: 400;
Â  display: flex;
Â  flex-direction: column;
Â  overflow: hidden;
Â  background-color: var(--thelo-bg);
Â  color: var(--thelo-text);
Â  Â -webkit-user-select: none; /* Safari */
Â  -moz-user-select: none;Â  Â  /* Firefox */
Â  -ms-user-select: none;Â  Â  Â /* IE10+/Edge */
Â  user-select: none;Â  Â  Â  Â  Â /* Standard */
Â  -webkit-touch-callout: none; /* iOS Safari */
}	/* ADD THIS RULE: Use Manrope font when the body has the 'lang-en' class */
body.lang-en {
  font-family: 'Manrope', system-ui, -apple-system, sans-serif;
}
	/* MCQ buttons blur when thelobook is active */
.blurred-mcq {
    filter: blur(4px);
    opacity: 0.55;
    pointer-events: none;      /* clicks still ignored */
    z-index: 5 !important;     /* sits below thelobookCanvas (z-15) */
    transition: filter .2s, opacity .2s;
}


 /* ===== Layout & App Structure ===== */

 #lessonArea {
    position: absolute; /* <--- NEW */
    top: 0;             /* <--- NEW */
    left: 0;            /* <--- NEW */
    right: 0;           /* <--- NEW */
    bottom: 0;          /* <--- NEW */
    display: flex;
    flex-direction: column;
    overflow: hidden;
    /* position: relative; can be removed or left, it doesn't matter now */
}
 #boardWrap {
    position: relative;
    flex-grow: 1;
    overflow: visible; /* Changed from hidden to visible */
    background-color: var(--thelo-bg);
    /* Grid background */
    background-image: linear-gradient(to right, var(--thelo-border) 1px, transparent 1px),
      linear-gradient(to bottom, var(--thelo-border) 1px, transparent 1px);
    background-size: 40px 40px;
 }

 /* ===== Canvases & Overlays ===== */
 #stageProgressBarContainer {
    position: absolute;
    top: 30.1px;
    left: 2%;
    width: 96%;
    height: 2px;
    background-color: #cccccc;
    border-radius: 2px;
    z-index: 10;
    opacity: 0;
    visibility: hidden;
    transition: opacity var(--fade-duration) ease-in-out, visibility 0s linear var(--fade-duration);
 }
 #stageProgressBarContainer.visible {
    opacity: 1;
    visibility: visible;
    transition: opacity var(--fade-duration) ease-in-out, visibility 0s linear 0s;
 }
 #stageProgressFill {
    height: 100%;
    background-color: #000000;
    width: 0%;
    border-radius: 2px;
    transition: width 0.05s linear;
 }

 #backgroundCanvas,
 #replayCanvas,
 #board,
 #finalAnswerCanvas,
 #thelobookCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: block;
    background-color: transparent;
 }
 #backgroundCanvas {
    z-index: 1;
    pointer-events: none;
    opacity: 1;
    transition: opacity var(--fade-duration) ease-in-out;
 }
 #backgroundCanvas.fade-out {
    opacity: 0;
 }
 #replayCanvas {
    z-index: 2;
    pointer-events: none;
    opacity: 1;
    transition: opacity var(--fade-duration) ease-in-out;
 }
 #replayCanvas.fade-out {
    opacity: 0;
 }
 #board {
	 opacity: 0 !important;          /* invisible */
    pointer-events: auto;           /* keep drawing events working */
    z-index: 3;
    cursor: crosshair;
    touch-action: none;
 }
 #finalAnswerCanvas {
    z-index: 4;
    opacity: 0;
    pointer-events: none;
 }

 #thelobookCanvas {
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    z-index: 15;
    cursor: crosshair;
    touch-action: none;
    opacity: 0;
    visibility: hidden;
    transform: scale(0.95);
    transition: opacity var(--animation-duration) ease, visibility 0s linear var(--animation-duration),
      transform var(--animation-duration) ease;
 }
 #thelobookCanvas.active {
    opacity: 1;
    visibility: visible;
    transform: scale(1);
    transition-delay: 0s, 0s, 0s;
 }
 #thelobookCanvas.grid-underlay {
    opacity: 0.9 !important;
    transform: scale(1) !important;
 }
 #thelobookCanvas.eraser-active {
    cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="rgba(0,0,0,0.5)" d="M19.78,2.22a1,1,0,0,0-1.42,0L9.12,11.46a1,1,0,0,0,0,1.41L11.24,15A1,1,0,0,0,12.66,15L22.22,5.39A1,1,0,0,0,22.22,4L19.78,2.22ZM8.41,12.88,2,19.29V21a1,1,0,0,0,1,1H4.71l6.47-6.46-1.42-1.42A1,1,0,0,0,8.41,12.88Z"/></svg>')
      12 12, auto;
 }

 /* ===== UI Controls ===== */
 /* ===== MODIFIED for Fullscreen Grid ===== */
#bottomBar {
  position: absolute;          /* Take the bar out of the normal layout flow */
  bottom: 0;                   /* Pin it to the bottom of the viewport */
  left: 0;                     /* Pin it to the left */
  width: 100%;                 /* Make it stretch full-width */
  background-color: transparent; /* Let the grid background show through */
  box-sizing: border-box;      /* Ensures padding is included in the width */

  /* These existing rules remain to style the buttons inside */
  padding: 0.5rem 1rem 1rem 1rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
  z-index: 20;
  gap: 0.75rem;
  transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1);
}
 .control-btn {
    font-family: inherit;
    padding: 0.5rem 1rem;
    font-size: 0.9rem;
    font-weight: 500;
    border: none;
    border-radius: 0.5rem;
    color: var(--bg-white);
    cursor: pointer;
    transition: background-color 0.2s, transform 0.15s, box-shadow 0.2s;
    box-shadow: var(--shadow-md);
 }
 .control-btn:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: var(--shadow-lg);
 }
 .control-btn:disabled {
    background-color: #9ca3af !important;
    cursor: not-allowed;
    opacity: 0.7;
 }

 /* Button Colors */
 #prevBtn {
    background-color: var(--accent-yellow);
 }
 #thelobookBtn {
    background-color: var(--success-green);
 }
 #clearBtn {
    background-color: var(--error-red);
 }
 #nextCheckBtn {
    background-color: var(--thelo-blue);
 }
 #nextCheckBtn:hover:not(:disabled) {
    background-color: var(--thelo-blue-dark);
 }
 #nextCheckBtn.correct {
    background-color: var(--success-green);
 }
 #nextCheckBtn.incorrect {
    background-color: var(--error-red);
    animation: shake 0.5s ease-in-out;
 }
 @keyframes shake {
    0%,
    100% {
      transform: translateX(0);
    }
    25%,
    75% {
      transform: translateX(-5px);
    }
    50% {
      transform: translateX(5px);
    }
 }

 /* ===== MODIFIED for Floating Text ===== */
#colorIndicator,
#pointsDisplay {
  background-color: transparent; /* Remove the white box */
  border: none;                  /* Remove the border */
  box-shadow: none;              /* Remove the shadow */
  color: var(--thelo-text);      /* Use the main text color */
  font-size: 1rem;               /* Make text slightly larger for readability */
  font-weight: 500;
  padding: 0.5rem 1rem;          /* Keep padding to maintain spacing */
  white-space: nowrap;
}

 /* MCQ Buttons */
#mcqOptionsContainer {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 30;
    display: none;
    flex-direction: row;
    flex-wrap: wrap;
    justify-content: center;
    gap: 1rem;
    width: 90%;
    max-width: 1200px;
}

@media (max-width: 1024px) {
    .mcq-option-btn {
        font-size: 0.7rem;
    }
}
.mcq-option-btn {
    font-family: inherit;
    padding: 0.8rem 1.5rem;
    font-size: 1.1rem;
    font-weight: 600;
    border: 1px solid var(--thelo-border);
    background-color: #f9fafb;
    color: var(--thelo-text);
    border-radius: 0.75rem;
    cursor: pointer;
    transition: all 0.2s ease-in-out;
    box-shadow: var(--shadow-sm);
    /* CHANGE: Let the button's width be determined by its content. */
    width: fit-content;
    /* CHANGE: Don't force the button to grow or have a specific basis. */
    flex: 0 1 auto;
    white-space: nowrap;
    transform: translateY(0);
}

.mcq-option-btn:hover:not(:disabled) {
    transform: translateY(-3px);
    box-shadow: var(--shadow-lg);
    color: var(--thelo-blue);
    border-color: #dbeafe;
}
.mcq-option-btn.correct {
    background-color: var(--success-green);
    color: white;
    border-color: var(--success-green);
 }
 .mcq-option-btn.incorrect {
    background-color: var(--error-red);
    color: white;
    border-color: var(--error-red);
 }
 .mcq-option-btn.correct-answer-shown {
    border-color: var(--success-green);
    border-width: 2px;
 }

 /* ===== Chat Column ===== */
 #chatCol {
    width: 320px;
    display: flex;
    flex-direction: column;
    background: var(--bg-white);
    border-left: 1px solid var(--thelo-border);
    padding: 1rem;
    height: 100%;
    box-sizing: border-box;
 }
 #terminalLogo {
    height: 60px;
    width: auto;
    display: block;
    align-self: center;
    margin: 0.5rem 0 1.5rem 0;
 }
 #chat {
    flex: 1;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: var(--thelo-border) transparent;
 }
 #chat::-webkit-scrollbar {
    width: 5px;
 }
 #chat::-webkit-scrollbar-thumb {
    background-color: var(--thelo-border);
    border-radius: 10px;
 }
.ai-message {
  background-color: var(--bg-white);
  border: 1px solid #f0f0f0;
  color: var(--thelo-text);
  padding: 0.75rem 1rem;
  border-radius: 0.75rem;
  margin-bottom: 0.75rem;
  max-width: 95%;
  align-self: flex-start;
  word-wrap: break-word;
  box-shadow: var(--shadow-sm);
  font-size: 0.9rem;
  line-height: 1.6;
  opacity: 0;
  transform: translateY(10px);
  transition: opacity 0.3s ease-out, transform 0.3s ease-out;
}

.ai-message.show {
  opacity: 1;
  transform: translateY(0);
}
.ai-message strong {
    color: var(--thelo-blue);
    font-weight: inherit;
 }
 .ai-message .emoji {
    margin-right: 0.5rem;
 }

#dashboardBtn {
    background-color: var(--thelo-blue);
}

#dashboardBtn:hover:not(:disabled) {
    background-color: var(--thelo-blue-dark);
}

#dashboardBtn.visible {
    display: inline-flex !important;
    animation: pulse-glow 2s infinite ease-in-out;
}

#bottomBar.bar-hidden-by-stylus {
    transform: translateY(150%);
    pointer-events: none;
}
	/* ADD THIS CSS: For the Streak Modal */
#streakModal {
    position: fixed;
    z-index: 100;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.6);
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0.3s;
}
#streakModal:not(.modal-hidden) {
    opacity: 1;
    visibility: visible;
}
.streak-modal-content {
    background-color: var(--thelo-bg);
    color: var(--thelo-text);
    padding: 2rem 3rem;
    border-radius: 1rem;
    text-align: center;
    box-shadow: var(--shadow-lg);
    position: relative;
    transform: scale(0.9);
    transition: transform 0.3s ease;
}
#streakModal:not(.modal-hidden) .streak-modal-content {
    transform: scale(1);
}
.streak-modal-icon {
    font-size: 4rem;
    line-height: 1;
    margin-bottom: 1rem;
}
.streak-modal-close {
    position: absolute;
    top: 0.5rem;
    right: 1rem;
    font-size: 1.75rem;
    font-weight: bold;
    color: var(--thelo-text-light);
    cursor: pointer;
}
#streakModalConfirmBtn {
    margin-top: 1.5rem;
    background-color: var(--accent-yellow);
}

@keyframes pulse-glow {
    0% {
        box-shadow: 0 0 5px rgba(37, 99, 235, 0.2), 0 0 7px rgba(37, 99, 235, 0.1);
    }
    50% {
        box-shadow: 0 0 15px rgba(37, 99, 235, 0.4), 0 0 25px rgba(37, 99, 235, 0.3);
    }
    100% {
        box-shadow: 0 0 5px rgba(37, 99, 235, 0.2), 0 0 7px rgba(37, 99, 235, 0.1);
    }
}

 /* ===== ADD THESE STYLES: For Image Terminal & Terminals ===== */
 #chat,
 #image-terminal {
    flex: 1;
    transition: opacity 0.3s ease-in-out;
    overflow: hidden;
    overflow-y: auto; /* Allow scrolling for chat */
 }
 #image-terminal {
    display: none; /* Start hidden */
    flex-direction: column;
    justify-content: flex-start;
    padding-top: 1rem;
    overflow: hidden; /* No scrollbar needed for image view */
 }
 #image-terminal-img-container img {
    max-width: 100%;
    border-radius: 0.75rem;
    box-shadow: var(--shadow-md);
 }
 #image-terminal-feedback {
    text-align: center;
    padding: 1.5rem 1rem;
    font-size: 1rem;
    font-weight: 500;
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
 }
 .terminal-hidden {
    opacity: 0 !important;
    display: none !important;
 }

 /* ===== ADD THESE STYLES: For Smarter MCQ Layouts ===== */
#mcqOptionsContainer.long-options {
    flex-direction: column;
    /* CHANGE: Center the shrink-to-fit buttons instead of stretching them. */
    align-items: center;
    width: fit-content;
    max-width: 92%;
    left: 50%;
    transform: translate(-50%, -50%);
}
 #mcqOptionsContainer.short-options {
    flex-direction: row;
    flex-wrap: wrap;
    align-items: center;
    width: fit-content;
    max-width: 92%;
    left: 50%;
    transform: translate(-50%, -50%);
}


 #mcqOptionsContainer.short-options .mcq-option-btn {
    padding: 1.2rem;
    font-size: 1rem;
    /* REMOVE (optional): This line prevents buttons from being very small. */
    /* min-width: 80px; */
    text-align: center;
}
 /* ===== Thelobook & Grid View ===== */
 #thelobookControls,
 #thelobookPageGridHeader,
 #closePageGridBtn {
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    background-color: rgba(255, 255, 255, 0.7);
    border-radius: 9999px; /* pill shape */
    box-shadow: var(--shadow-md);
    border: 1px solid var(--thelo-border);
 }
 #thelobookControls {
    position: absolute;
    bottom: 2rem;
    left: 50%;
    transform: translateX(-50%);
    z-index: 25;
    padding: 0.5rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s, visibility 0.2s;
 }
 #thelobookControls.visible {
    opacity: 1;
    visibility: visible;
 }
 #thelobookControls button {
    background: transparent;
    border: none;
    font-size: 1.25rem;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: background-color 0.2s;
 }
 #thelobookControls button:hover:not(:disabled) {
    background-color: rgba(0, 0, 0, 0.05);
 }
 #thelobookControls button.active {
    background-color: var(--thelo-blue);
    color: white;
 }

 #thelobookPageGridView {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 40;
    display: flex;
    flex-direction: column;
    padding: 2rem 1rem 1rem;
    box-sizing: border-box;
    opacity: 0;
    visibility: hidden;
    transform: scale(0.95);
    transition: opacity var(--animation-duration) ease, visibility 0s linear var(--animation-duration),
      transform var(--animation-duration) ease;
 }
 #thelobookPageGridView.visible {
    opacity: 1;
    visibility: visible;
    transform: scale(1);
    transition-delay: 0s;
 }

 #thelobookPageGridHeader {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    padding: 0.5rem 1.5rem;
    max-width: fit-content;
    align-self: center;
    gap: 1rem;
 }

 #pageGridBatchIndicator {
    white-space: nowrap;
 }

 #thelobookPageGridContentContainer {
    flex-grow: 1;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-content: flex-start;
    gap: 1rem;
    padding: 0.5rem;
    overflow-y: auto;
    max-height: calc(100vh - 150px);
 }

 .chat-image-container {
    padding: 0.5rem;
    background-color: transparent;
    border: none;
    box-shadow: none;
 }

 .chat-image {
    max-width: 100%;
    border-radius: 0.75rem;
    display: block;
    box-shadow: var(--shadow-md);
 }
 .page-thumbnail {
    border: 1px solid var(--thelo-border);
    box-shadow: var(--shadow-sm);
    border-radius: 0.5rem;
 }
 .page-thumbnail:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-md);
 }
 #closePageGridBtn {
    border-radius: 50%;
    width: 36px;
    height: 36px;
    font-size: 1.1rem;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
 }

 .page-grid-batch {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 1rem;
    width: 100%;
    transition: none;
 }

 @keyframes pageGridFadeIn {
    from {
      opacity: 0;
      transform: scale(0.95);
    }
    to {
      opacity: 1;
      transform: scale(1);
    }
 }

 #thelobookPageGridView.visible {
    animation: pageGridFadeIn var(--animation-duration) ease forwards;
 }

 #thelobookPageGridContentContainer:empty::before {
    content: 'No pages to display. Click "+" to add a new page.';
    color: var(--thelo-text-light);
    font-size: 1rem;
    text-align: center;
    margin-top: 2rem;
 }

 /* Responsive adjustments */
 @media (max-width: 768px) {
    #app {
      flex-direction: column-reverse;
    }
	 /* Inside your @media (max-width: 768px) rule... */

    #chatCol {
      width: 100%;
      height: 30vh;
      border-left: none;
      border-top: 1px solid var(--thelo-border);
    }
    #bottomBar {
      flex-wrap: wrap;
      justify-content: center;
    }
    #actionButtons {
      width: 100%;
      justify-content: center;
      order: 3;
    }
    #pointsDisplay,
    #colorIndicator {
      order: 1;
      margin-bottom: 0.5rem;
    }
    .control-btn {
      padding: 0.6rem 0.8rem;
      font-size: 0.8rem;
    }
    #stageProgressBarContainer {
      top: 0;
      height: 2px;
    }
 }

 /* By default, hide the calculator button in the bottom bar */
 #openCalculatorBtn {
     display: none;
     background-color: var(--thelo-blue); /* Give it the standard blue color */
 }
 
 #openCalculatorBtn:hover:not(:disabled) {
     background-color: var(--thelo-blue-dark); /* Add the standard hover effect */
 }

 /* ===== NEW: Tablet Immersive Mode ===== */
 @media (min-width: 769px) and (max-width: 1200px) and (pointer: coarse) {
    #openCalculatorBtn {
        display: inline-flex;
    }
    /* (pointer: coarse) is key for detecting touch-first devices like tablets */
	/* ===== ENHANCEMENT: Prevent Palm Selection on Canvas ===== */
    #boardWrap {
        /* Prevents the user from being able to select the canvas */
        -webkit-user-select: none; /* Safari */
        -moz-user-select: none;    /* Firefox */
        -ms-user-select: none;     /* IE */
        user-select: none;

        /* Disables the menu (copy/paste) that appears on long-press in Safari */
        -webkit-touch-callout: none;
    }

    #app {
        /* Keep the flex layout but hide the chat column */
        flex-direction: row;
    }

    #chatCol {
        /* Completely hide the terminal */
        display: none !important;
    }

    #lessonArea {
        /* Make the whiteboard take up the full screen width */
        width: 100%;
        flex-basis: 100%;
        border-left: none; /* Remove border that separated it from the chat */
    }
}
 /* ===== NEW: Toast Notification System for Tablets ===== */
#toast-container {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 1000;
    display: flex;
    flex-direction: column-reverse;
    align-items: center;
    gap: 10px;
    width: clamp(300px, 80%, 600px);
    pointer-events: none;
}

.toast-message {
    font-family: 'Manrope', system-ui, -apple-system, sans-serif;
    font-size: 1rem;
    font-weight: 500;
    color: var(--thelo-text);
    background-color: rgba(255, 255, 255, 0.85);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 12px 20px;
    border-radius: 12px;
    box-shadow: var(--shadow-lg);
    border: 1px solid rgba(0,0,0,0.05);
    display: flex;
    align-items: center;
    gap: 12px;
    pointer-events: all;
    cursor: pointer;
    overflow: hidden;
    max-height: 100px;
    margin-top: 10px;
    opacity: 0;
    transition: max-height 0.3s ease-in-out, opacity 0.3s ease-in-out, margin-top 0.3s ease-in-out, padding 0.3s ease-in-out;
}

.toast-message.show {
    animation: toast-in 0.5s cubic-bezier(0.21, 1.02, 0.73, 1) forwards;
}

.toast-message.exiting {
    max-height: 0;
    opacity: 0;
    padding-top: 0;
    padding-bottom: 0;
    margin-top: 0;
}

@keyframes toast-in {
    from {
        opacity: 0;
        transform: translateY(25px) scale(0.9);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

.toast-message .emoji {
    font-size: 1.5rem;
}

.toast-message.toast-success,
.toast-message.toast-error,
.toast-message.toast-warning {
    background-color: rgba(255, 255, 255, 0.6);
    color: var(--thelo-text);
}

/* You might also want a rule for landscape tablets without the pointer check */
@media (min-width: 769px) and (max-width: 1200px) and (min-height: 500px) {
    #openCalculatorBtn {
        display: inline-flex;
    }
   #chatCol {
        display: none !important;
    }

    #lessonArea {
        width: 100%;
        flex-basis: 100%;
        border-left: none;
    }
}
/* >>> add once, after the existing #mcqOptionsContainer rules <<< */
#mcqOptionsContainer.side-by-side {
    position: absolute;
    top: 50%;
    right: 4%;
    left: auto !important;
    transform: translateY(-50%);
    display: flex;
    flex-direction: column;
    gap: 1rem;
    width: 38vw;
    max-width: 420px;
}

/* make the buttons grow full width of the column */
#mcqOptionsContainer.side-by-side .mcq-option-btn{ /* CORRECTED HYPHEN */
    flex:0 0 auto;
    width:100%;
}
/* REPLACE the old #calculatorOverlay and #calculatorFrame rules with these */

#calculatorOverlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 50;
    display: flex;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    background-color: rgba(255, 255, 255, 0.5); /* Soft white background */
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0s linear 0.3s;
}

#calculatorFrame {
    width: 98%;
    height: 98%;
    border: none;
    border-radius: 1rem;
    box-shadow: var(--shadow-lg);
}
/* ADD THIS NEW RULE */
.terminal-hidden-by-calculator {
    display: none !important;
}

#calculatorOverlay:not(.calculator-hidden) {
    opacity: 1;
    visibility: visible;
    transition-delay: 0s;
}


#calculatorCloseBtn {
    position: absolute;
    top: 2rem;
    right: 2rem;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: none;
    background-color: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    font-size: 1.2rem;
    cursor: pointer;
    box-shadow: var(--shadow-md);
    display: flex;
    align-items: center;
    justify-content: center;
}
	/* ===== NEW: Embedded Replay Player Styles ===== */

#replayPlayerContainer {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 5; /* Below UI controls, but above canvases */
    display: flex;
    align-items: center;
    justify-content: center;
    padding-top: 70px;
    box-sizing: border-box;
    opacity: 0;
    visibility: hidden;
    transform: scale(0.95);
    transition: opacity 0.3s ease, visibility 0s linear 0.3s, transform 0.3s ease;
}

#replayPlayerContainer:not(.replay-hidden) {
    opacity: 1;
    visibility: visible;
    transform: scale(1);
    transition-delay: 0s;
}

#replayFrame {
    width: 90%;
    height: 80%;
    max-width: 1200px;
    max-height: 700px;
    border: 1px solid rgba(0, 0, 0, 0.05);
    border-radius: 1rem;
    box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.07);
    background-color: var(--thelo-bg);
}
	/* Add near your other .mcq-option-btn rules */
.mcq-option-btn.selected {
    border-color: var(--thelo-blue);
    background-color: #eff6ff; /* A light blue background */
    color: var(--thelo-blue);
    border-width: 2px;
    transform: translateY(-3px);
    box-shadow: var(--shadow-lg);
}
  .mcq-option-btn .katex { vertical-align: middle; }
/* ===== NEW: Drawing Minimap ===== */
#minimapContainer {
    position: absolute;
    bottom: 1.5rem;
    right: 1.5rem;
    width: 220px;
    height: 165px;
    background-color: rgba(255, 255, 255, 0.95);
    border: 1px solid var(--thelo-border);
    border-radius: 0.75rem;
    box-shadow: var(--shadow-lg);
    z-index: 10;
    overflow: hidden;
    /* Animation styles */
    transition: opacity 0.3s ease, transform 0.3s ease;
    transform: scale(0.95) translateY(10px);
    opacity: 0;
    pointer-events: none; /* Don't let it block clicks */
}

/* This class will be toggled by JS to show the minimap */
#minimapContainer:not(.minimap-hidden) {
    transform: scale(1) translateY(0);
    opacity: 1;
}

#minimapCanvas {
    width: 100%;
    height: 100%;
    display: block;
}
	/* ===== NEW: Animated Feedback System ===== */
#feedbackOverlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 10000;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: none; /* Allows clicks to go through to the canvas below */
    transition: opacity 0.4s ease;
}

#feedbackOverlay.feedback-hidden {
    opacity: 0;
}

#feedbackBox {
    background-color: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    color: var(--thelo-text);
    padding: 2rem 3rem;
    border-radius: 1.5rem;
    text-align: center;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
    border: 1px solid rgba(0, 0, 0, 0.05);
    max-width: 80%;
    transform: scale(0.8);
    opacity: 0;
    transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.3s ease;
}

/* This is the state when the feedback is visible, triggering the animation */
#feedbackOverlay:not(.feedback-hidden) #feedbackBox {
    transform: scale(1);
    opacity: 1;
}

#feedbackEmoji {
    font-size: 4rem;
    line-height: 1;
    display: block;
    margin-bottom: 1rem;
}

#feedbackText {
    font-size: 1.5rem;
    font-weight: 500;
    line-height: 1.5;
    margin: 0;
}

#feedbackText strong {
    color: var(--thelo-blue);
    font-weight: 700;
}
	#feedbackOverlay:not(.feedback-hidden){
    opacity:1; visibility:visible;
}
/* hide cursor when a stylus is down */
.no-cursor {
    cursor: none !important;
}
.control-btn { touch-action: manipulation; }
/* ===== NEW: Fixed Bottom Logo ===== */
#bottom-logo-container {
  position: fixed;
  bottom: 1rem; /* Adjust vertical spacing from the bottom */
  left: 50%;
  transform: translateX(-50%);
  z-index: 10000; /* Ensures it's above the canvas but below modals */
  pointer-events: none; /* Allows clicks to pass through to elements underneath */
}

#bottom-logo-container img {
  display: block;
  height: 35px; /* Adjust the logo size as needed */
  width: auto; /* Makes the logo subtle and less distracting */
}
	html, body {
  cursor: none !important;
}
	/* ===== NEW: On-Canvas Feedback ===== */
#feedbackCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 5; /* Above the drawing board, below UI controls */
    pointer-events: none; /* Allows drawing to pass through */
}
	/* Force Armenian font on buttons when the language is not English */
/* Force Armenian font on all key UI text elements when the language is not English */
body:not(.lang-en) .control-btn,
body:not(.lang-en) .mcq-option-btn,
body:not(.lang-en) #pointsDisplay,
body:not(.lang-en) #colorIndicator {
    font-family: 'Montserrat Arm', sans-serif !important;
    font-weight: 600 !important; /* SemiBold weight for UI elements */
}
  /* ===== NEW: MCQ Keyboard-Only Mode ===== */
body.mcq-active {
    cursor: none; /* Hide the system cursor */
}

body.mcq-active .mcq-option-btn {
    pointer-events: none; /* Disable all mouse/touch interactions on the buttons */
}

/* This makes the selected option more prominent without a cursor */
body.mcq-active .mcq-option-btn.selected {
    border-color: var(--thelo-blue);
    background-color: #dbeafe; /* A darker blue to show focus */
    color: #1e40af;
    transform: scale(1.05); /* Make it pop a bit */
    box-shadow: var(--shadow-lg);
}
</style>
</head>
<body>
    <div id="loading-overlay">
    </div>
    <div id="app">
        <div id="lessonArea">
            <div id="boardWrap">
                <div id="stageProgressBarContainer"><div id="stageProgressFill"></div></div>
                <canvas id="backgroundCanvas"></canvas>
Â  Â  Â  Â  Â  Â  Â  Â  <canvas id="replayCanvas"></canvas>
Â  Â  Â  Â  Â  Â  Â  Â  <canvas id="board"></canvas>
Â  Â  Â  Â  Â  Â  Â  Â  <canvas id="feedbackCanvas"></canvas>
		Â  Â  <canvas id="boardCapture" style="display:none"></canvas>
Â  Â  Â  Â  Â  Â  Â  Â  <canvas id="thelobookCanvas"></canvas>
		<div id="calculatorOverlay" class="calculator-hidden">
                <iframe id="calculatorFrame" src="about:blank" allow="clipboard-write"></iframe>
                <button id="calculatorCloseBtn" title="Close Calculator">âœ•</button>
            </div>
		    <div id="replayPlayerContainer" class="replay-hidden">
			<iframe id="replayFrame" src="about:blank"></iframe>
		</div>
                <div id="thelobookControls">
                    <button id="thelobookPrevPageBtn" title="Previous Page">â€¹</button>
                    <span id="thelobookPageIndicator">Page 1 / 1</span>
                    <button id="thelobookNextPageBtn" title="Next Page">â€º</button>
                    <button id="thelobookEraserBtn" title="Eraser">âœï¸</button>
                    <button id="thelobookAddPageBtn" title="Add New Page">+</button>
                </div>

                <div id="thelobookPageGridView">
                    <div id="thelobookPageGridHeader">
                        <span id="pageGridBatchIndicator">Pages 1-32</span>
                        <button id="closePageGridBtn" title="Close Grid">âœ•</button>
                    </div>
                    <div id="thelobookPageGridContentContainer">
                    </div>
                </div>
		    <div id="minimapContainer" class="minimap-hidden">
    <canvas id="minimapCanvas"></canvas>
</div>

                <div id="mcqOptionsContainer" style="display: none;"></div>
            </div>

            <div id="bottomBar">
                <div id="colorIndicator"></div>
                <div id="pointsDisplay"></div>
                <div id="actionButtons">
    <button id="prevBtn" class="control-btn"></button>
    <button id="openCalculatorBtn" class="control-btn" title="Open Calculator">Graph</button>
    <button id="thelobookBtn" class="control-btn"></button>
    
    <button id="clearBtn" class="control-btn"></button>
    <button id="nextCheckBtn" class="control-btn"></button>
    <button id="dashboardBtn" class="control-btn" style="display: none;"></button>
</div>
            </div>
        </div>
        
    </div>
    <div id="toast-container"></div>
    <div id="audioContainer" style="display: none;">
        <audio id="audio_approve1_hy" src="https://pha.am/audios/approve1.ogg" preload="auto"></audio>
        <audio id="audio_approve2_hy" src="https://pha.am/audios/approve2.ogg" preload="auto"></audio>
        <audio id="audio_dis1_hy" src="https://pha.am/audios/dis1.ogg" preload="auto"></audio>
        <audio id="audio_dis2_hy" src="https://pha.am/audios/dis2.ogg" preload="auto"></audio>
        <audio id="audio_approve1_en" src="https://thelo.space/audio/engcorr1.mp3" preload="auto"></audio>
        <audio id="audio_approve2_en" src="https://thelo.space/audio/engcorr2.mp3" preload="auto"></audio>
        <audio id="audio_dis1_en" src="https://thelo.space/audio/engwrong1.mp3" preload="auto"></audio>
        <audio id="audio_dis2_en" src="https://thelo.space/audio/engwrong2.mp3" preload="auto"></audio>
        <audio id="stageAudioPlayer"></audio>
        <audio id="gotItSound" src="https://pha.am/audios/corr.mp3" preload="auto"></audio>
    </div>
	<div id="streakModal" class="modal-hidden">
    <div class="streak-modal-content">
        <span id="streakModalCloseBtn" class="streak-modal-close">&times;</span>
        <div class="streak-modal-icon">ğŸ”¥</div>
        <h2 id="streakModalTitle"></h2>
        <p id="streakModalBody"></p>
        <button id="streakModalConfirmBtn" class="control-btn">Awesome!</button>
    </div>
		
</div>
	<div id="feedbackOverlay" class="feedback-hidden">
    <div id="feedbackBox">
        <span id="feedbackEmoji"></span>
        <p id="feedbackText"></p>
    </div>
</div>
	<div id="bottom-logo-container">
    <img src="https://thelo.space/img/bluethelo.svg" alt="Thelo Logo">
</div>
</body>
  <script>
    const firebaseConfig = { apiKey: "AIzaSyAbnPpcIt88B0jIAoLUdC71zmQDvR_fdu8", authDomain: "physmathacademy-722b3.firebaseapp.com", databaseURL: "https://physmathacademy-722b3-default-rtdb.firebaseio.com", projectId: "physmathacademy-722b3", storageBucket: "physmathacademy-722b3.appspot.com", messagingSenderId: "1093640992262", appId: "1:1093640992262:web:35b1bf4d2364bcf745f587" };
    firebase.initializeApp(firebaseConfig);


Â  Â  const auth = firebase.auth();
    const db = firebase.firestore();

    // =================================================================
    //  NEW FIX: Set auth persistence to 'session' to work around
    //  potential browser storage restrictions.
    // =================================================================
    auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL)
        .catch((error) => {
            console.error("Auth persistence error:", error.code, error.message);
        });
    getKatexCSSWithEmbeddedFonts().catch(()=>{});
ensureHeadlineFontsLoaded().catch(()=>{});
    const INK_COLORS = { black: '#000000', blue: getComputedStyle(document.documentElement).getPropertyValue('--ink-blue').trim() || '#2563eb' };

    const UI_TEXT = {
        hy: {
            next: "Õ€Õ¡Õ»Õ¸Ö€Õ¤Õ¨", gotIt: "Õ€Õ¡Õ½Õ¯Õ¡ÖÕ¡!", check: "ÕÕ¿Õ¸Ö‚Õ£Õ¥Õ¬", checking: "ÕÕ¿Õ¸Ö‚Õ£Õ¾Õ¸Ö‚Õ´ Õ§...",
            correct: "ÕƒÕ«Õ·Õ¿ Õ§Ö‰", incorrect: "ÕÕ­Õ¡Õ¬ Õ§", apiKeyInvalid: "API Õ¢Õ¡Õ¶Õ¡Õ¬Õ«Õ¶ Õ¡Õ¶Õ¾Õ¡Õ¾Õ¥Ö€ Õ§",
            inkBlack: "Ô³Õ¸Ö‚ÕµÕ¶Õ ÕÖ‡", inkBlue: "Ô³Õ¸Ö‚ÕµÕ¶Õ Ô¿Õ¡ÕºÕ¸Ö‚ÕµÕ¿", loading: "Ô²Õ¥Õ¼Õ¶Õ¾Õ¸Ö‚Õ´ Õ§...",
            clear: "Õ„Õ¡Ö„Ö€Õ¥Õ¬", start: "ÕÕ¯Õ½Õ¥Õ¬", prev: "Õ†Õ¡Õ­Õ¸Ö€Õ¤",
            welcome: "ÕˆÕ²Õ»Õ¸Ö‚Õ›ÕµÕ¶Ö‰ ÕÕ¥Õ²Õ´Õ«Ö€ ÕÕ¯Õ½Õ¥Õ¬ Õ¤Õ¡Õ½Õ¨ Õ½Õ¯Õ½Õ¥Õ¬Õ¸Ö‚ Õ°Õ¡Õ´Õ¡Ö€Ö‰",
            checkingAI: `ÕÕ¿Õ¸Ö‚Õ£Õ¸Ö‚Õ´ Õ¥Õ´ Ö„Õ¸ <strong style="color:${INK_COLORS.blue};">Õ¯Õ¡ÕºÕ¸Ö‚ÕµÕ¿Õ¸Õ¾</strong> Õ£Ö€Õ¾Õ¡Õ® ÕºÕ¡Õ¿Õ¡Õ½Õ­Õ¡Õ¶Õ¨...`,
            blankBlueWarning: `âš ï¸ Ô¿Õ¡Ö€Õ®Õ¥Õ½ Õ©Õ¥ ÕºÕ¡Õ¿Õ¡Õ½Õ­Õ¡Õ¶Õ¨ <strong style="color:${INK_COLORS.blue};">Õ¯Õ¡ÕºÕ¸Ö‚ÕµÕ¿Õ¸Õ¾</strong> Õ¹Õ¥Õ½ Õ¶Õ·Õ¥Õ¬Ö‰ ÕÕ¥Õ²Õ´Õ«Ö€ 'A' Õ½Õ¿Õ¥Õ²Õ¶Õ¨ Õ£Õ¸Ö‚ÕµÕ¶Õ¨ ÖƒÕ¸Õ­Õ¥Õ¬Õ¸Ö‚ Õ°Õ¡Õ´Õ¡Ö€Ö‰`,
            noTextFound: `âš ï¸ <strong style="color:${INK_COLORS.blue};">Ô¿Õ¡ÕºÕ¸Ö‚ÕµÕ¿Õ¸Õ¾</strong> Õ£Ö€Õ¾Õ¡Õ®Õ«Ö Õ¿Õ¥Ö„Õ½Õ¿ Õ¹Õ£Õ¿Õ¶Õ¾Õ¥ÖÖ‰ Õ“Õ¸Ö€Õ±Õ«Ö€ Õ£Ö€Õ¥Õ¬ Õ¡Õ¾Õ¥Õ¬Õ« ÕºÕ¡Ö€Õ¦Ö‰`,
            noDigitsFound: `âš ï¸ Ô¿Õ¡Ö€Õ®Õ¥Õ½ Õ©Õ¥ <strong style="color:${INK_COLORS.blue};">Õ¯Õ¡ÕºÕ¸Ö‚ÕµÕ¿Õ¸Õ¾</strong> Õ©Õ«v Õ¹Õ¥Ö„ Õ£Ö€Õ¥Õ¬Ö‰ (ÕƒÕ¡Õ¶Õ¡Õ¹Õ¾Õ¡Õ® Õ¿Õ¥Ö„Õ½Õ¿Õ {detectedText})`,
            correctAI: `ğŸ‰ ÕƒÕ«Õ·Õ¿ Õ§ Google Vision-Õ« Õ¯Õ¡Ö€Õ®Õ«Ö„Õ¸Õ¾Ö‰ (Ô´Õ¸Ö‚Ö„ Õ£Ö€Õ¥Õ¬ Õ§Õ«Ö„ <strong>{detectedAnswer}</strong>)`,
            incorrectAI: `ğŸ¤” ÕÕ­Õ¡Õ¬ Õ§Ö‰ Google Vision-Õ¨ <strong style="color:${INK_COLORS.blue};">Õ¯Õ¡ÕºÕ¸Ö‚ÕµÕ¿</strong> Õ£Ö€Õ¾Õ¡Õ®Ö„Õ«Ö Õ¯Õ¡Ö€Õ¤Õ¡Ö <strong>{detectedAnswer}</strong>, Õ¢Õ¡ÕµÖ Õ³Õ«Õ·Õ¿ ÕºÕ¡Õ¿Õ¡Õ½Õ­Õ¡Õ¶Õ¶ Õ§ <strong>{correctAnswer}</strong>Ö‰ Õ“Õ¸Ö€Õ±Õ«Ö€ Õ¯Ö€Õ¯Õ«Õ¶Ö‰`,
            parsingError: `âš ï¸ Õ‰Õ¯Õ¡Ö€Õ¸Õ²Õ¡ÖÕ¡ <strong style="color:${INK_COLORS.blue};">Õ¯Õ¡ÕºÕ¸Ö‚ÕµÕ¿</strong> Õ£Ö€Õ¾Õ¡Õ®Ö„Õ«Ö Õ©Õ«Õ¾Õ¨ Õ³Õ¡Õ¶Õ¡Õ¹Õ¥Õ¬Ö‰ (ÕƒÕ¡Õ¶Õ¡Õ¹Õ¾Õ¡Õ® Õ¿Õ¥Ö„Õ½Õ¿Õ {detectedText})`,
            imageDataError: `âŒ ÕÕ­Õ¡Õ¬Õ Õ¹Õ°Õ¡Õ»Õ¸Õ²Õ¾Õ¥Ö Õ½Õ¿Õ¡Õ¶Õ¡Õ¬ Õ¶Õ¯Õ¡Ö€Õ¨ Õ£Ö€Õ¡Õ¿Õ¡Õ­Õ¿Õ¡Õ¯Õ«ÖÖ‰ ({errorMessage})`,
            apiErrorGeneral: `âŒ ÕÕ­Õ¡Õ¬ Õ¿Õ¥Õ²Õ« Õ¸Ö‚Õ¶Õ¥ÖÕ¡Õ¾ Õ½Õ¿Õ¸Ö‚Õ£Õ´Õ¡Õ¶ ÕªÕ¡Õ´Õ¡Õ¶Õ¡Õ¯Ö‰ ({errorMessage})`,
            apiKeyPermissionError: 'âŒ ÕÕ­Õ¡Õ¬Õ API Õ¢Õ¡Õ¶Õ¡Õ¬Õ«Õ¶ Õ¡Õ¶Õ¾Õ¡Õ¾Õ¥Ö€ Õ§ Õ¯Õ¡Õ´ Õ©Õ¸Ö‚ÕµÕ¬Õ¿Õ¾Õ¸Ö‚Õ©ÕµÕ¸Ö‚Õ¶ Õ¹Õ¸Ö‚Õ¶Õ«Ö‰ ÕÕ¿Õ¸Ö‚Õ£Õ¥Ö„ Õ¢Õ¡Õ¶Õ¡Õ¬Õ«Õ¶ Ö‡ Õ°Õ¡Õ´Õ¸Õ¦Õ¾Õ¥Ö„, Õ¸Ö€ Vision API-Õ¶ Õ´Õ«Õ¡ÖÕ¾Õ¡Õ® Õ§Ö‰',
            apiBillingError: 'âŒ ÕÕ­Õ¡Õ¬Õ Õ€Õ¡Õ·Õ¾Õ¡Ö€Õ¯Õ´Õ¡Õ¶ (billing) Õ­Õ¶Õ¤Õ«Ö€Ö‰ ÕÕ¿Õ¸Ö‚Õ£Õ¥Ö„, Õ¸Ö€ Õ¡ÕµÕ¶ Õ´Õ«Õ¡ÖÕ¾Õ¡Õ® Õ§ Õ±Õ¥Ö€ Google Cloud Õ¶Õ¡Õ­Õ¡Õ£Õ®Õ« Õ°Õ¡Õ´Õ¡Ö€Ö‰',
            apiKeyMissingWarning: 'ğŸ›‘ **Ô¿Ô±ÕÔµÕÕˆÕ:** Google Vision API Õ¢Õ¡Õ¶Õ¡Õ¬Õ«Õ¶ Õ½Õ­Õ¡Õ¬ Õ§ Õ¯Õ¡Õ´ Õ¢Õ¡ÖÕ¡Õ¯Õ¡ÕµÕ¸Ö‚Õ´ Õ§Ö‰ Ô½Õ¶Õ¤Ö€Õ¸Ö‚Õ´ Õ¥Õ¶Ö„ ÖƒÕ¸Õ­Õ¡Ö€Õ«Õ¶Õ¥Õ¬ Õ¡ÕµÕ¶Ö‰ Ô±Õ¼Õ¡Õ¶Ö Õ¤Ö€Õ¡, Õ±Õ¥Õ¼Õ¡Õ£Ö€Õ« Õ½Õ¿Õ¸Ö‚Õ£Õ¸Ö‚Õ´Õ¨ Õ¹Õ« Õ¡Õ·Õ­Õ¡Õ¿Õ«Ö‰',
            lessonComplete: "Ô´Õ¡Õ½Õ¶ Õ¡Õ¾Õ¡Ö€Õ¿Õ¾Õ¡Õ® Õ§Ö‰ Õ‡Õ¡Õ¿ Õ¬Õ¡Õ¾ Õ¡Õ·Õ­Õ¡Õ¿Õ¡Õ¶Ö„Ö‰",
            drawActivityWarning: "âš ï¸ Ô½Õ¶Õ¤Ö€Õ¸Ö‚Õ´ Õ¥Õ´, Õ¶Õ¡Õ­ ÖƒÕ¸Ö€Õ±Õ«Ö€ Õ¶Õ¯Õ¡Ö€Õ¥Õ¬Ö‰",
            achievementsPrefix: "ğŸ“š ",
            blueInkErased: "Ô¿Õ¡ÕºÕ¸Ö‚ÕµÕ¿ Õ£Ö€Õ¾Õ¡Õ®Ö„Õ¨ (ÕºÕ¡Õ¿Õ¡Õ½Õ­Õ¡Õ¶Õ¨) Õ´Õ¡Ö„Ö€Õ¾Õ¡Õ® Õ§Ö‰",
            authErrorVision: "Ô±Õ¾Õ¿Õ¸Ö€Õ«Õ¦Õ¡ÖÕ«Õ¡ÕµÕ« Õ½Õ­Õ¡Õ¬Ö‰ Ô½Õ¶Õ¤Ö€Õ¸Ö‚Õ´ Õ¥Õ¶Ö„ Õ´Õ¸Ö‚Õ¿Ö„ Õ£Õ¸Ö€Õ®Õ¥Õ¬Õ Õ¡ÕµÕ½ Õ£Õ¸Ö€Õ®Õ¡Õ¼Õ¸Ö‚ÕµÕ©Õ¶ Ö…Õ£Õ¿Õ¡Õ£Õ¸Ö€Õ®Õ¥Õ¬Õ¸Ö‚ Õ°Õ¡Õ´Õ¡Ö€Ö‰",
            lessonFileMissing: 'ÕÕ­Õ¡Õ¬Ö‰ Ô´Õ¡Õ½Õ« Ö†Õ¡ÕµÕ¬Õ¨ Õ¶Õ·Õ¾Õ¡Õ® Õ¹Õ§ URL-Õ¸Ö‚Õ´Ö‰',
            lessonLoadErrorGeneric: "Ô´Õ¡Õ½Õ¨ Õ¢Õ¥Õ¼Õ¶Õ¥Õ¬Õ¸Ö‚ Õ½Õ­Õ¡Õ¬Ö‰\nÔ½Õ¶Õ¤Ö€Õ¸Ö‚Õ´ Õ¥Õ¶Ö„ Õ¾Õ¥Ö€Õ¡Õ¤Õ¡Õ¼Õ¶Õ¡Õ¬ Ö‡ Õ¶Õ¸Ö€Õ«Ö ÖƒÕ¸Ö€Õ±Õ¥Õ¬Ö‰",
            userNotAuthHandwriting: 'âš ï¸ Õ•Õ£Õ¿Õ¡Õ¿Õ¥Ö€Õ¨ Õ¶Õ¸Ö‚ÕµÕ¶Õ¡Õ¯Õ¡Õ¶Õ¡ÖÕ¾Õ¡Õ® Õ¹Õ§: Ô½Õ¶Õ¤Ö€Õ¸Ö‚Õ´ Õ¥Õ¶Ö„ Õ´Õ¸Ö‚Õ¿Ö„ Õ£Õ¸Ö€Õ®Õ¥Õ¬ Õ±Õ¥Õ¼Õ¡Õ£Ö€Õ« Õ¾Õ¥Ö€Õ¬Õ¸Ö‚Õ®Õ¸Ö‚Õ©ÕµÕ¡Õ¶ Õ£Õ¸Ö€Õ®Õ¡Õ¼Õ¸Ö‚ÕµÕ©Õ¶ Ö…Õ£Õ¿Õ¡Õ£Õ¸Ö€Õ®Õ¥Õ¬Õ¸Ö‚ Õ°Õ¡Õ´Õ¡Ö€:',
            pointsGained: "+{points} Õ´Õ«Õ¡Õ¾Õ¸Ö€ Õ±Õ¥Õ¼Ö„ Õ¢Õ¥Ö€Õ¾Õ¥ÖÖ‰", error: "ÕÕ­Õ¡Õ¬", titleDefaultHy: "Thelo AI Ô³Ö€Õ¡Õ¿Õ¡Õ­Õ¿Õ¡Õ¯",
            thelobookOpen: "Ô¹Õ¥Õ¬Õ¸Õ£Õ«Ö€Ö„", thelobookClose: "Õ“Õ¡Õ¯Õ¥Õ¬", thelobookInk: "Ô³Õ¸Ö‚ÕµÕ¶Õ ÕÖ‡ (Õ†Õ·Õ¸Ö‚Õ´Õ¶Õ¥Ö€)",
            thelobookEraser: "Õ‹Õ¶Õ»Õ«Õ¹", thelobookPen: "Ô³Ö€Õ«Õ¹",
            thelobookDisabledMCQ: "Ô¹Õ¥Õ¬Õ¸Õ£Õ«Ö€Ö„Õ¨ Õ°Õ¡Õ½Õ¡Õ¶Õ¥Õ¬Õ« Õ¹Õ§ Õ°Õ¡Ö€ÖÕ¡Õ·Õ¡Ö€Õ« ÕªÕ¡Õ´Õ¡Õ¶Õ¡Õ¯Ö‰",
            thelobookPagesBtn: "Ô·Õ»Õ¥Ö€",
            thelobookPageIndicator: "Ô·Õ» {currentPage} / {totalPages}",
            pageGridBatchIndicator: "Ô·Õ»Õ¥Ö€ {startPage}-{endPage}",
            pageGridInstructions: "ÕÕ¥Õ²Õ´Õ¥Ö„ 'C' Õ°Õ¡Õ»Õ¸Ö€Õ¤ Õ­Õ´Õ¢Õ« Õ°Õ¡Õ´Õ¡Ö€, 'X' Õ¶Õ¡Õ­Õ¸Ö€Õ¤Õ«Ö‰",
            addPage: "Ô±Õ¾Õ¥Õ¬Õ¡ÖÕ¶Õ¥Õ¬ Õ§Õ»",
	    viewDashboard: "ÕÕ¥Õ½Õ¶Õ¥Õ¬ Õ¡Õ¼Õ¡Õ»Õ¨Õ¶Õ©Õ¡ÖÕ¨", // ADD THIS LINE
	    limitReached: "Ô´Õ¸Ö‚Ö„ Õ£Õ¥Ö€Õ¡Õ¦Õ¡Õ¶ÖÕ¥Õ¬ Õ¥Ö„ Õ±Õ¥Ö€ Õ¡Õ´Õ½Õ¡Õ¯Õ¡Õ¶ Õ¾Õ¥Ö€Õ¬Õ¸Ö‚Õ®Õ¸Ö‚Õ©ÕµÕ¸Ö‚Õ¶Õ¶Õ¥Ö€Õ« Õ½Õ¡Õ°Õ´Õ¡Õ¶Õ¡Õ¹Õ¡ÖƒÕ¨Ö‰ Ô½Õ¶Õ¤Ö€Õ¸Ö‚Õ´ Õ¥Õ¶Ö„ ÖƒÕ¸Ö€Õ±Õ¥Õ¬ Õ¯Ö€Õ¯Õ«Õ¶ Õ°Õ¡Õ»Õ¸Ö€Õ¤ Õ¡Õ´Õ«Õ½Ö‰"
},
		
       en: {
  next: "Next",
  gotIt: "Got it",
  check: "Check",
  checking: "Check",
  correct: "That's right!",
  incorrect: "Not quite.",

  apiKeyInvalid: "Your key doesnâ€™t seem to be working. Please check and try again.",

  inkBlack: "Ink: Black",
  inkBlue: "Ink: Blue",
  loading: "Loading...",
  clear: "Clear",
  start: "Start",
  prev: "Previous",

  welcome: "Welcome! Press Start to begin.",
  checkingAI: `Looking at your answer in <strong style="color:${INK_COLORS.blue};">blue</strong>...`,
  blankBlueWarning: `It looks like there's no answer in <strong style="color:${INK_COLORS.blue};">blue</strong>. Press 'A' to change your ink color.`,
  noTextFound: `I couldnâ€™t find any writing in <strong style="color:${INK_COLORS.blue};">blue</strong>. Try writing a bit more clearly.`,
  noDigitsFound: `I didnâ€™t see a number written in <strong style="color:${INK_COLORS.blue};">blue</strong>. (Detected text: {detectedText})`,

  correctAI: `Looks good to me! You wrote: <strong>{detectedAnswer}</strong>`,
  incorrectAI: `I saw <strong>{detectedAnswer}</strong>, but the correct answer is <strong>{correctAnswer}</strong>. Try again.`,
  parsingError: `I had trouble reading a number from your answer. (Detected: {detectedText})`,

  imageDataError: `Couldn't get the image from the board. ({errorMessage})`,
  apiErrorGeneral: `Something went wrong while checking your answer. ({errorMessage})`,
  apiKeyPermissionError: "Your key may be missing permissions. Make sure everythingâ€™s set up properly.",
  apiBillingError: "There seems to be a billing issue. Check your payment settings.",
  apiKeyMissingWarning: "Important: A valid key is missing. Handwriting checking won't work until itâ€™s added.",

  lessonComplete: "Lesson complete! Nice work.",
  drawActivityWarning: "Please try drawing something first.",
  achievementsPrefix: "ğŸ† ",

  blueInkErased: "Your blue ink answer has been erased.",
  authErrorVision: "Please log in to use this feature.",
  lessonFileMissing: "Lesson file not found. Check the link and try again.",
  lessonLoadErrorGeneric: "There was a problem loading the lesson. Please try again.",
  userNotAuthHandwriting: "You're not logged in. Please log in to use handwriting analysis.",

  pointsGained: "+{points} points earned!",
  error: "Error",
  titleDefaultEn: "Thelo AI Whiteboard",

  thelobookOpen: "thelobook",
  thelobookClose: "Close",
  thelobookInk: "Ink: Black (Notes)",
  thelobookEraser: "Eraser",
  thelobookPen: "Pen",
  thelobookDisabledMCQ: "thelobook is disabled during multiple choice questions.",
  thelobookPagesBtn: "Pages",
  thelobookPageIndicator: "Page {currentPage} of {totalPages}",
  pageGridBatchIndicator: "Pages {startPage}â€“{endPage}",
  pageGridInstructions: "Press 'C' for next batch, 'X' for previous batch.",
  addPage: "Add Page",

  viewDashboard: "View Your Progress",
  limitReached: "You've reached your monthly handwriting check limit. Try again next month.",
}

    };

    let currentLang = 'en';
    /* ========================================================================= */
/* ===== ADD THIS BLOCK: For Weekly Streak Calculation ===================== */
/* ========================================================================= */

/**
 * Calculates the ISO 8601 week number for a given date.
 * A week starts on Monday. This is robust against timezone issues.
 * @param {Date} date The date to calculate the week for.
 * @returns {string} The week identifier in "YYYY-Www" format (e.g., "2025-W26").
 */
function getISOWeekIdentifier(date) {
    // Create a new date object to avoid modifying the original
    const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
    // Set to the nearest Thursday: current date + 4 - current day number
    // Make Sunday's day number 7
    d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
    // Get first day of year
    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    // Calculate full weeks to nearest Thursday
    const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
    // Pad week number with a leading zero if needed
    const weekString = String(weekNo).padStart(2, '0');
    
    return `${d.getUTCFullYear()}-W${weekString}`;
}

/**
 * Gets the week identifier for the week immediately preceding the given one.
 * @param {string} weekId A week identifier like "2025-W26".
 * @returns {string} The previous week's identifier, e.g., "2025-W25".
 */
function getPreviousWeekIdentifier(weekId) {
    const [year, week] = weekId.split('-W').map(Number);
    if (week > 1) {
        const prevWeekString = String(week - 1).padStart(2, '0');
        return `${year}-W${prevWeekString}`;
    } else {
        // This is tricky: the last week of the previous year can be 52 or 53.
        // We'll calculate it based on the last day of the previous year.
        const lastDayOfPrevYear = new Date(year - 1, 11, 31);
        return getISOWeekIdentifier(lastDayOfPrevYear);
    }
}

    /* ========== DOM Elements ========== */
    const backgroundCanvas = document.getElementById('backgroundCanvas');
    const replayCanvas = document.getElementById('replayCanvas');
    const canvas = document.getElementById('board');
    const loadingOverlay = document.getElementById('loading-overlay'); // <-- ADD THIS
    const thelobookCanvas = document.getElementById('thelobookCanvas');
    const boardWrapper = document.getElementById('boardWrap');
    const stageAudioPlayer = document.getElementById('stageAudioPlayer');
    const gotItSoundPlayer = document.getElementById('gotItSound');
    const mcqOptionsContainer = document.getElementById('mcqOptionsContainer');
    const bottomBar = document.getElementById('bottomBar');
    const stageProgressBarContainer = document.getElementById('stageProgressBarContainer');
    const stageProgressFill = document.getElementById('stageProgressFill');
	  const minimapContainer = document.getElementById('minimapContainer');
const minimapCanvas = document.getElementById('minimapCanvas');
let minimapCtx = null;
	  const feedbackCanvas = document.getElementById('feedbackCanvas');
let feedbackCtx = null; // Will be initialized in setupContexts
let feedbackAnimationId = null; // To manage animations
	  let lastFeedbackDetails = null;
	  const feedbackOverlay = document.getElementById('feedbackOverlay');
const feedbackEmoji = document.getElementById('feedbackEmoji');
const feedbackText = document.getElementById('feedbackText');
let feedbackTimer = null; // To manage auto-hiding the message
	const imageTerminal = document.getElementById('image-terminal');
	const imageTerminalImgContainer = document.getElementById('image-terminal-img-container');
	const imageTerminalFeedback = document.getElementById('image-terminal-feedback');

    const bgCtx = backgroundCanvas.getContext('2d');
    let replayCtx = null;
    const ctx = canvas.getContext('2d');
	  const captureCanvas = document.getElementById('boardCapture');   // NEW
const captureCtx    = captureCanvas.getContext('2d');            // NEW
    let thelobookCtx = null;

    const prevBtn = document.getElementById('prevBtn');
    const nextCheckBtn = document.getElementById('nextCheckBtn');
	  /* mobile tap shim */
nextCheckBtn.addEventListener(
  'touchend',
  e => {
    e.preventDefault();      // stop the synthetic click
    nextCheckBtn.click();    // re-use the normal handler
  },
  { passive: false }
);

    const clearBtn = document.getElementById('clearBtn');
    const thelobookBtn = document.getElementById('thelobookBtn');
    const chatArea = document.getElementById('chat');
    const chatCol = document.getElementById('chatCol'); // <-- ADD THIS LINE
    const colorIndicator = document.getElementById('colorIndicator');
    if (colorIndicator){ colorIndicator.addEventListener('click', () => { toggleColor(); }); }
    const pointsDisplayElement = document.getElementById('pointsDisplay');
const dashboardBtn = document.getElementById('dashboardBtn'); // ADD THIS LINE

    const thelobookControlsEl = document.getElementById('thelobookControls');
    const thelobookPagesBtn = document.getElementById('thelobookPagesBtn');
    const thelobookPrevPageBtn = document.getElementById('thelobookPrevPageBtn');
    const thelobookNextPageBtn = document.getElementById('thelobookNextPageBtn');
    const thelobookPageIndicatorEl = document.getElementById('thelobookPageIndicator');
    const thelobookEraserBtn = document.getElementById('thelobookEraserBtn');
    const thelobookAddPageBtn = document.getElementById('thelobookAddPageBtn');
    const calculatorOverlay = document.getElementById('calculatorOverlay');
    const calculatorFrame = document.getElementById('calculatorFrame');
    const calculatorCloseBtn = document.getElementById('calculatorCloseBtn');
	const replayPlayerContainer = document.getElementById('replayPlayerContainer');
	const replayFrame = document.getElementById('replayFrame');
    const audioElements = {};
    const approveSounds_hy = []; const disapproveSounds_hy = [];
    const approveSounds_en = []; const disapproveSounds_en = [];

    /* ========== State Variables ========== */
    let isAuthReady = false;
	  let isInitialStageRendered = false;
	  let selectedMcqIndex = null; // To store the selected MCQ option index
          let isTabletMode = false;
	let isCalculatorActive = false;
	let isReplayActive = false;
		let mousePoints = []; // <<< ADD THIS LINE
const IFRAME_UPDATE_INTERVAL = 40; // ms, throttles updates to 25 FPS (1000 / 40 = 25)
let lastIframeUpdateTime = 0;
	let isPageGridVisible = false; 
        let lessonStartTime = null;
    let lessonStagesRoot = null; let lessonStages = []; let isLessonLoading = false;
    let isImageModeActive = false;
    let currentStageIndex = -1; let currentStageData = null; let isStudentInputAllowed = false;
    let drawing = false; let lastPos = { x: 0, y: 0 };
    let userDrawingOccurred = false; let isTransitioning = false;
    let devicePixelRatio = window.devicePixelRatio || 1; window.userInteracted = false;
    let currentReplayAnimationId = null; let currentStageAudio = null; 
    let userPoints = 0;
    let sessionPoints = 0; // ADDED LINE: To track points for the current lesson session.
    let currentStageDrawingData = null; let currentStageTotalDuration = 0;
    let isMediaScrubbingActive = false; let internalPlaybackTime = 0; let lastFrameTimestampForManualAdvance = 0;
    let isThelobookActive = false; let wasMediaPlayingBeforeThelobook = false;
    let mediaPlaybackTimeBeforeThelobook = 0; let audioTimeBeforeThelobook = 0;
    let thelobookPages = []; let currentThelobookPageIndex = 0;
    let thelobookDrawListenersAttached = false;
    let isThelobookEraserActive = false;
    const THELOBOOK_ERASER_LINEWIDTH = 20;
    const THELOBOOK_PEN_LINEWIDTH = 3;
    let isPageSwitchingAnimation = false;
    const PAGES_PER_GRID_BATCH = 32;
    let tempFullPageCanvasForThumbnails = null;
    let buttonVanishTimer = null;
    let stagesWithPointsAwarded = new Set();
    /* ========== Language Functions ========== */
    function getCurrentUIText() { return UI_TEXT[currentLang] || UI_TEXT['hy']; }
    function updateAllUITexts() {
        const TXT = getCurrentUIText();
        document.documentElement.lang = currentLang;

        if (prevBtn) prevBtn.textContent = TXT.prev;
        if (clearBtn) clearBtn.textContent = TXT.clear;
        if (thelobookBtn) thelobookBtn.textContent = isThelobookActive ? TXT.thelobookClose : TXT.thelobookOpen;

        if (thelobookAddPageBtn) thelobookAddPageBtn.title = TXT.addPage;
        if (thelobookEraserBtn) thelobookEraserBtn.title = isThelobookEraserActive ? TXT.thelobookPen : TXT.thelobookEraser;
        if (thelobookPagesBtn) thelobookPagesBtn.title = TXT.thelobookPagesBtn;
        if (thelobookPrevPageBtn) thelobookPrevPageBtn.title = TXT.prevPage;
        if (thelobookNextPageBtn) thelobookNextPageBtn.title = TXT.nextPage;

        updateColorIndicator();
        updatePointsDisplay();
        if(isThelobookActive && !isPageGridVisible) updateThelobookPageControls();


        if (lessonStagesRoot && lessonStagesRoot.lessonTitle) {
            document.title = lessonStagesRoot.lessonTitle || TXT[`titleDefault${currentLang.charAt(0).toUpperCase() + currentLang.slice(1)}`];
        } else {
            document.title = TXT[`titleDefault${currentLang.charAt(0).toUpperCase() + currentLang.slice(1)}`];
        }
        
        if (currentStageIndex === -1 && lessonStages.length > 0 && nextCheckBtn) { nextCheckBtn.textContent = TXT.start; }
        else if (isLessonLoading && nextCheckBtn) { nextCheckBtn.textContent = TXT.loading; }
        else if (currentStageData && nextCheckBtn) {
                if (currentStageData.type === 'question_handwriting') {
                    if (nextCheckBtn.classList.contains('correct')) { nextCheckBtn.textContent = TXT.correct; }
                    else if (nextCheckBtn.classList.contains('incorrect')) { nextCheckBtn.textContent = TXT.check; }
                    else if (nextCheckBtn.textContent === UI_TEXT.hy.checking || nextCheckBtn.textContent === UI_TEXT.en.checking ) { /* Keep "Checking..." */ }
                    else { nextCheckBtn.textContent = TXT.check; }
                } else {
                    const mcqDetails = currentStageData.optionsQuiz;
                    const isMCQDisplayStage = currentStageData.type === "explanation_with_mcq" && mcqDetails && Array.isArray(mcqDetails.choices) && mcqDetails.choices.length > 0;
                    if (!isMCQDisplayStage) {
                        if (nextCheckBtn.classList.contains('correct')) { nextCheckBtn.textContent = TXT.correct; }
                        else { nextCheckBtn.textContent = TXT.gotIt; }
                    }
                }
        }

        if (currentStageData) {
            if (!isTransitioning && !isLessonLoading) renderStageUI(currentStageIndex, true);
        }
    }
    function setLanguage(lang) {
Â  Â  Â  Â  if (UI_TEXT[lang]) {
Â  Â  Â  Â  Â  Â  if (currentLang !== lang) { currentLang = lang; console.log(`Language set to: ${currentLang} by lesson file.`); }
Â  Â  Â  Â  Â  Â  else { console.log(`Language already set to: ${currentLang}. Forcing UI text update.`); }
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  console.warn(`Language ${lang} from lesson file not supported. Defaulting to 'hy'.`);
Â  Â  Â  Â  Â  Â  currentLang = 'hy';
Â  Â  Â  Â  }
		// Add or remove the language-specific class on the body
		if (currentLang === 'en') {
			document.body.classList.add('lang-en');
		} else {
			document.body.classList.remove('lang-en');
		}
		updateAllUITexts();
Â  Â  }

    /* ========== Core App Functions ========== */
    function updatePointsDisplay() {
Â  Â  Â  Â  const TXT = getCurrentUIText();
Â  Â  Â  Â  // MODIFIED: This now uses sessionPoints for the on-screen display.
Â  Â  Â  Â  if (pointsDisplayElement) pointsDisplayElement.textContent = `${TXT.achievementsPrefix}${sessionPoints}`;
Â  Â  }
  async function loadLesson(lessonJsonPath) {
Â  Â  if (isLessonLoading) return;
Â  Â  isLessonLoading = true;
Â  Â  if (prevBtn) prevBtn.disabled = true;
Â  Â  if (dashboardBtn) dashboardBtn.style.display = 'none';
Â  Â  if (isThelobookActive) closeThelobook(false);
Â  Â  if (isPageGridVisible) closePageGridView();

Â  Â  try {
Â  Â  Â  Â  const response = await fetch(lessonJsonPath);
Â  Â  Â  Â  if (!response.ok) throw new Error(`HTTP error! status: ${response.status} fetching ${lessonJsonPath}`);
Â  Â  Â  Â  lessonStagesRoot = await response.json();
Â  Â  Â  Â  if (!lessonStagesRoot || !Array.isArray(lessonStagesRoot.stages)) throw new Error("Invalid lesson format.");
Â  Â  Â  Â  const lessonLang = lessonStagesRoot.lessonLanguage || 'hy';
Â  Â  Â  Â  setLanguage(lessonLang);
Â  Â  Â  Â  let TXT = getCurrentUIText();
Â  Â  Â  Â  lessonStages = lessonStagesRoot.stages;

        // FIX: Show the welcome message after a brief delay to prevent a font race condition.
        // The 'await ensureHeadlineFontsLoaded()' call has been removed.
        setTimeout(() => {
            showOnCanvasFeedback(TXT.welcome);
        }, 100); // 100ms delay is enough for the browser to settle.

Â  Â  Â  Â  sessionPoints = 0;
Â  Â  Â  Â  updatePointsDisplay();
Â  Â  Â  Â Â 
Â  Â  Â  Â  stagesWithPointsAwarded = new Set();

Â  Â  Â  Â  document.title = lessonStagesRoot.lessonTitle || TXT[`titleDefault${currentLang.charAt(0).toUpperCase() + currentLang.slice(1)}`];
Â  Â  Â  Â  console.log(`Lesson loaded: ${lessonStages.length} stages. Language: ${currentLang}`);

Â  Â  Â  Â  currentStageIndex = -1;
Â  Â  Â  Â  currentStageData = null;
Â  Â  Â  Â  isStudentInputAllowed = false;
Â  Â  Â  Â  if (currentReplayAnimationId) cancelAnimationFrame(currentReplayAnimationId);
Â  Â  Â  Â  currentReplayAnimationId = null;
Â  Â  Â  Â  if (currentStageAudio && !currentStageAudio.paused) {
Â  Â  Â  Â  Â  Â  currentStageAudio.pause();
Â  Â  Â  Â  Â  Â  currentStageAudio.onloadedmetadata = null;
Â  Â  Â  Â  Â  Â  currentStageAudio.onended = null;
Â  Â  Â  Â  }
Â  Â  Â  Â  currentStageAudio = null;
Â  Â  Â  Â  isMediaScrubbingActive = false;
Â  Â  Â  Â  if (stageProgressBarContainer) stageProgressBarContainer.classList.remove('visible');
Â  Â  Â  Â  if (bgCtx) bgCtx.clearRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
Â  Â  Â  Â  if (replayCtx) replayCtx.clearRect(0, 0, replayCanvas.width, replayCanvas.height);
Â  Â  Â  Â  if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
Â  Â  Â  Â Â 
Â  Â  Â  Â  thelobookPages = [];
Â  Â  Â  Â  currentThelobookPageIndex = 0;
Â  Â  Â  Â  updateThelobookPageControls();

Â  Â  } catch (error) {
Â  Â  Â  Â  console.error("Error loading lesson:", error);
Â  Â  Â  Â  let TXT = getCurrentUIText();
Â  Â  Â  Â  addChatMessage('AI', `${formatAIMessage('error')}: ${error.message}`);
Â  Â  } finally {
Â  Â  Â  Â  isLessonLoading = false;

Â  Â  Â  Â  if (lessonStages && lessonStages.length > 0) {
Â  Â  Â  Â  Â  Â  if (nextCheckBtn) {
Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.disabled = false;
Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.textContent = getCurrentUIText().start;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  if (nextCheckBtn) {
Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.textContent = getCurrentUIText().error;
Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.disabled = true;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  if (!UI_TEXT[currentLang]) currentLang = 'hy';
Â  Â  Â  Â  updateAllUITexts();

Â  Â  Â  Â  if (loadingOverlay) {
Â  Â  Â  Â  Â  Â  loadingOverlay.classList.add('hidden');
Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  if(loadingOverlay) loadingOverlay.style.display = 'none';
Â  Â  Â  Â  Â  Â  }, 500);
Â  Â  Â  Â  }
Â  Â  }
}
function resizeCanvases() {
Â  Â  clearTimeout(window.resizeTimeout);
Â  Â  window.resizeTimeout = setTimeout(() => {
Â  Â  Â  Â  checkTabletMode();
Â  Â  Â  Â  if (!boardWrapper) return;

Â  Â  Â  Â  // Save the current drawing before it gets erased by the resize.
Â  Â  Â  Â  let userDrawingData = null;
Â  Â  Â  Â  if (userDrawingOccurred && canvas.width > 0 && canvas.height > 0) {
Â  Â  Â  Â  Â  Â  userDrawingData = ctx.getImageData(0, 0, canvas.width, canvas.height);
Â  Â  Â  Â  }

Â  Â  Â  Â  const rect = boardWrapper.getBoundingClientRect();
Â  Â  Â  Â  const cssWidth = Math.max(1, Math.floor(rect.width));
Â  Â  Â  Â  const cssHeight = Math.max(1, Math.floor(rect.height));
Â  Â  Â  Â  devicePixelRatio = window.devicePixelRatio || 1;
Â  Â  Â  Â  const internalWidth = Math.floor(cssWidth * devicePixelRatio);
Â  Â  Â  Â  const internalHeight = Math.floor(cssHeight * devicePixelRatio);

Â  Â  Â  Â  // This loop erases the canvases when it sets the new width/height.
Â  Â  Â  Â  [backgroundCanvas, replayCanvas, canvas, thelobookCanvas, feedbackCanvas].forEach(c => {
Â  Â  Â  Â  Â  Â  if (c) {
Â  Â  Â  Â  Â  Â  Â  Â  c.width = internalWidth;
Â  Â  Â  Â  Â  Â  Â  Â  c.height = internalHeight;
Â  Â  Â  Â  Â  Â  Â  Â  c.style.width = `${cssWidth}px`;
Â  Â  Â  Â  Â  Â  Â  Â  c.style.height = `${cssHeight}px`;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });
Â  Â  Â  Â Â 
Â  Â  Â  Â  setupContexts();

Â  Â  Â  Â  // Restore the saved drawing onto the newly resized canvas.
Â  Â  Â  Â  if (userDrawingData) {
Â  Â  Â  Â  Â  Â  ctx.putImageData(userDrawingData, 0, 0);
Â  Â  Â  Â  }

Â  Â  Â  Â  // Redraw the rest of the UI.
Â  Â  Â  Â  if (currentStageIndex >= 0 && lessonStages.length > 0) renderStageUI(currentStageIndex, true);
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (isThelobookActive) {
Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  if (isThelobookActive) loadThelobookPageDrawing(currentThelobookPageIndex);
Â  Â  Â  Â  Â  Â  }, 50);
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  if(isPageGridVisible) renderPageGridBatch(currentPageGridBatch, false);

    // At the end of the resizeCanvases function
    if (minimapCanvas) {
    Â  Â  const minimapRect = minimapCanvas.getBoundingClientRect();
    Â  Â  minimapCanvas.width = minimapRect.width * devicePixelRatio;
    Â  Â  minimapCanvas.height = minimapRect.height * devicePixelRatio;
    }

    // The call to setupContexts() should be after this new block
    setupContexts();
Â  Â  }, 150);
}
	function setupContexts() {
Â  Â  if (!backgroundCanvas || !replayCanvas || !canvas || !thelobookCanvas) return;
Â  Â Â 
Â  Â  replayCtx = replayCanvas.getContext('2d');Â 
Â  Â  thelobookCtx = thelobookCanvas.getContext('2d');
Â  Â Â 
Â  Â  [bgCtx, replayCtx, ctx, thelobookCtx].forEach(context => {
Â  Â  Â  Â  if (context) {Â 
Â  Â  Â  Â  Â  Â  context.resetTransform();Â 
Â  Â  Â  Â  Â  Â  context.scale(devicePixelRatio, devicePixelRatio);Â 
Â  Â  Â  Â  }
Â  Â  });
Â  Â Â 
Â  Â  bgCtx.lineWidth = 2;Â 
Â  Â  bgCtx.strokeStyle = '#333';Â 
Â  Â  bgCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--thelo-text').trim();
Â  Â Â 
    const fontFamily = currentLang === 'en' ? "'Manrope', system-ui, sans-serif" : "'Montserrat Arm', system-ui, sans-serif";
Â  Â  bgCtx.font = `20px ${fontFamily}`;Â 
Â  Â  bgCtx.textAlign = 'center';Â 
Â  Â  bgCtx.textBaseline = 'top';
Â  Â Â 
Â  Â  if (replayCtx) {Â 
Â  Â  Â  Â  replayCtx.lineCap = 'round';Â 
Â  Â  Â  Â  replayCtx.lineJoin = 'round';Â 
Â  Â  }
Â  Â Â 
Â  Â  ctx.lineWidth = THELOBOOK_PEN_LINEWIDTH;Â 
Â  Â  ctx.lineCap = 'round';Â 
Â  Â  ctx.lineJoin = 'round';Â 
Â  Â  ctx.strokeStyle = INK_COLORS.blue; // Hardcoded to blue
Â  Â Â 
Â  Â  if (thelobookCtx) {
Â  Â  Â  Â  thelobookCtx.lineCap = 'round';Â 
Â  Â  Â  Â  thelobookCtx.lineJoin = 'round';
Â  Â  }
    if (minimapCanvas) {
Â  Â  Â  Â  minimapCtx = minimapCanvas.getContext('2d');
Â  Â  Â  Â  if (minimapCtx) {
Â  Â  Â  Â  Â  Â  minimapCtx.scale(devicePixelRatio, devicePixelRatio);
Â  Â  Â  Â  Â  Â  minimapCtx.lineWidth = 2;
Â  Â  Â  Â  Â  Â  minimapCtx.lineCap = 'round';
Â  Â  Â  Â  Â  Â  minimapCtx.lineJoin = 'round';
Â  Â  Â  Â  Â  Â  minimapCtx.strokeStyle = INK_COLORS.blue;
Â  Â  Â  Â  }
Â  Â  }
    if (feedbackCanvas) {
        feedbackCtx = feedbackCanvas.getContext('2d');
        if (feedbackCtx) {
            feedbackCtx.resetTransform();
            feedbackCtx.scale(devicePixelRatio, devicePixelRatio);
        }
    }
Â  Â Â 
Â  Â  updateColorIndicator();
}
    function calculateDrawingDuration(drawingData){
        if (!drawingData || !drawingData.strokes || drawingData.strokes.length === 0) return 0;
        let maxTime = 0;
        drawingData.strokes.forEach(stroke => {
            let strokeEndTimeVal = 0;
            if (stroke.endTime !== undefined) { strokeEndTimeVal = stroke.endTime; }
            else if (stroke.points && stroke.points.length > 0) {
                const lastPoint = stroke.points[stroke.points.length - 1];
                strokeEndTimeVal = (stroke.startTime || 0) + (lastPoint.timeOffset || 0);
            } else { strokeEndTimeVal = (stroke.startTime || 0); }
            if (strokeEndTimeVal > maxTime) maxTime = strokeEndTimeVal;
        });
        return maxTime / 1000;
    }
    function renderDrawingAtTime(targetTimeInSeconds, drawingData, targetCtx){
        if (!targetCtx) return;
        const canvasWidth = targetCtx.canvas.width / devicePixelRatio;
        const canvasHeight = targetCtx.canvas.height / devicePixelRatio;
        targetCtx.clearRect(0, 0, canvasWidth, canvasHeight);

        if (!drawingData || !drawingData.strokes) return;

        drawingData.strokes.forEach(stroke => {
            const strokeStartTime = (stroke.startTime || 0) / 1000;
            if (targetTimeInSeconds < strokeStartTime) return;

            targetCtx.lineWidth = stroke.lineWidth || 2;
            targetCtx.strokeStyle = stroke.color || 'black';
            targetCtx.fillStyle = stroke.color || 'black';
            targetCtx.lineCap = 'round'; targetCtx.lineJoin = 'round';

            const points = stroke.points || [];
            if (points.length === 0) return;
            targetCtx.beginPath();
            let movedToFirstPoint = false;

            for (let i = 0; i < points.length; i++) {
                const point = points[i];
                const pointTimeAbsolute = strokeStartTime + ((point.timeOffset || 0) / 1000);
                if (pointTimeAbsolute > targetTimeInSeconds) break;

                if (!movedToFirstPoint) {
                    targetCtx.moveTo(point.normX * canvasWidth, point.normY * canvasHeight);
                    movedToFirstPoint = true;
                } else {
                    targetCtx.lineTo(point.normX * canvasWidth, point.normY * canvasHeight);
                }
                if (points.length === 1) {
                    targetCtx.closePath(); targetCtx.beginPath();
                    targetCtx.arc(point.normX * canvasWidth, point.normY * canvasHeight, (stroke.lineWidth || 2) / 2, 0, Math.PI * 2);
                    targetCtx.fill();
                    break;
                }
            }
            if (movedToFirstPoint && points.length > 1) targetCtx.stroke();
        });
    }
    function updateMediaProgressBar(effectiveTime, totalDuration){
        if (!stageProgressBarContainer) return;
        if (isMediaScrubbingActive && totalDuration > 0) {
            if (!stageProgressBarContainer.classList.contains('visible')) {
                stageProgressBarContainer.classList.add('visible');
            }
            const progress = (effectiveTime / totalDuration) * 100;
            stageProgressFill.style.width = `${Math.min(100, Math.max(0, progress))}%`;
        } else {
            // Keep progress bar visible if not scrubbing but playback is at the end (handled by new snippet in renderStageUI)
        if (!(internalPlaybackTime >= currentStageTotalDuration - 0.05 && currentStageTotalDuration > 0)) {
            stageProgressBarContainer.classList.remove('visible');
            stageProgressFill.style.width = '0%';
        }
        }
    }
   // In your MAIN app's <script> tag
// In your MAIN app's <script> tag - REPLACE this function

// In your MAIN app's <script> tag - REPLACE this function

// In your MAIN app's <script> tag - REPLACE this function
function mediaPlaybackLoop(timestamp) {
    // Exit if playback is no longer supposed to be active
    if (!isMediaScrubbingActive) {
        if (currentReplayAnimationId) cancelAnimationFrame(currentReplayAnimationId);
        currentReplayAnimationId = null;
        return;
    }

    // --- HYBRID TIME CALCULATION (Unchanged) ---
    const audioIsPlaying = currentStageAudio && !currentStageAudio.paused && !currentStageAudio.ended;
    if (audioIsPlaying) {
        internalPlaybackTime = currentStageAudio.currentTime;
        lastFrameTimestampForManualAdvance = timestamp; 
    } else {
        if (lastFrameTimestampForManualAdvance === 0) {
            lastFrameTimestampForManualAdvance = timestamp;
        }
        const deltaTime = (timestamp - lastFrameTimestampForManualAdvance) / 1000.0;
        internalPlaybackTime += deltaTime;
        lastFrameTimestampForManualAdvance = timestamp;
    }
    
    // Ensure playback stops precisely at the end (Unchanged)
    if (internalPlaybackTime >= currentStageTotalDuration) {
        internalPlaybackTime = currentStageTotalDuration;
        isMediaScrubbingActive = false; 
    }

    // --- UNIVERSAL UPDATES (Now with throttling) ---

    // Update the drawing replay on the main canvas (cheap, runs every frame)
    if (currentStageDrawingData && replayCtx) {
        renderDrawingAtTime(internalPlaybackTime, currentStageDrawingData, replayCtx);
    }

    // ======================== THE FIX ========================
    // Only update the expensive iframe if enough time has passed.
    if (isReplayActive && replayFrame.contentWindow && (timestamp - lastIframeUpdateTime > IFRAME_UPDATE_INTERVAL)) {
        replayFrame.contentWindow.postMessage({
            command: 'renderAtTime',
            timeMs: internalPlaybackTime * 1000
        }, '*');
        // Update the timestamp of the last update
        lastIframeUpdateTime = timestamp;
    }
    // =========================================================
    
    // Update the progress bar (cheap, runs every frame for smoothness)
    updateMediaProgressBar(internalPlaybackTime, currentStageTotalDuration);

    // Continue the loop
    currentReplayAnimationId = requestAnimationFrame(mediaPlaybackLoop);
}
function playStrokesAbsoluteTiming(strokeData, targetCtx, onFinished){
        if (isMediaScrubbingActive) { if (typeof onFinished === 'function') onFinished(); return; }
        if (currentReplayAnimationId) { cancelAnimationFrame(currentReplayAnimationId); currentReplayAnimationId = null; }
        if (!targetCtx || !strokeData || !strokeData.strokes || strokeData.strokes.length === 0) { if (typeof onFinished === 'function') onFinished(); return; }
        const targetWidth = targetCtx.canvas.width / devicePixelRatio;
        const targetHeight = targetCtx.canvas.height / devicePixelRatio;
        targetCtx.clearRect(0, 0, targetWidth, targetHeight);
        let currentStrokeIndex = 0, currentPointIndex = 0, animationStartTime = null, strokeSetupDone = false;
        function animateStrokes(timestamp) {
            if (!animationStartTime) animationStartTime = timestamp;
            const elapsedOverallTime = timestamp - animationStartTime;
            if (currentStrokeIndex >= strokeData.strokes.length) { if (typeof onFinished === 'function') onFinished(); currentReplayAnimationId = null; return; }
            const stroke = strokeData.strokes[currentStrokeIndex]; const points = stroke.points || [];
            const scheduledStrokeStartTime = stroke.startTime || 0; const scheduledStrokeEndTime = stroke.endTime === undefined ? Infinity : stroke.endTime;
            if (elapsedOverallTime < scheduledStrokeStartTime) { currentReplayAnimationId = requestAnimationFrame(animateStrokes); return; }
            if (elapsedOverallTime >= scheduledStrokeEndTime && currentPointIndex >= points.length) { currentStrokeIndex++; currentPointIndex = 0; strokeSetupDone = false; currentReplayAnimationId = requestAnimationFrame(animateStrokes); return; }
            if (!strokeSetupDone) { targetCtx.lineWidth = stroke.lineWidth || 2; targetCtx.strokeStyle = stroke.color || 'black'; targetCtx.fillStyle = stroke.color || 'black'; targetCtx.lineCap = 'round'; targetCtx.lineJoin = 'round'; targetCtx.beginPath(); if (points.length > 0) { targetCtx.moveTo(points[0].normX * targetWidth, points[0].normY * targetHeight); } strokeSetupDone = true; }
            const timeElapsedInStroke = elapsedOverallTime - scheduledStrokeStartTime; let processedPointInFrame = false;
            while (currentPointIndex < points.length && timeElapsedInStroke >= points[currentPointIndex].timeOffset) {
                const pt = points[currentPointIndex];
                if (points.length === 1 && currentPointIndex === 0) { targetCtx.arc(pt.normX * targetWidth, pt.normY * targetHeight, (stroke.lineWidth || 2) / 2, 0, Math.PI * 2); targetCtx.fill(); }
                else if (currentPointIndex > 0) { targetCtx.lineTo(pt.normX * targetWidth, pt.normY * targetHeight); processedPointInFrame = true; }
                else if (currentPointIndex === 0 && points.length > 1) { targetCtx.moveTo(pt.normX * targetWidth, pt.normY * targetHeight); }
                currentPointIndex++;
            }
            if (processedPointInFrame) { targetCtx.stroke(); }
            currentReplayAnimationId = requestAnimationFrame(animateStrokes);
        }
        currentReplayAnimationId = requestAnimationFrame(animateStrokes);
    }

   
   function updateColorIndicator() {
Â  Â  const TXT = getCurrentUIText();
Â  Â  if (colorIndicator) {
Â  Â  Â  Â  let showIndicator = false;
Â  Â  Â  Â  if (isThelobookActive && !isPageGridVisible) {
Â  Â  Â  Â  Â  Â  colorIndicator.textContent = isThelobookEraserActive ? TXT.thelobookEraser : TXT.thelobookInk;
Â  Â  Â  Â  Â  Â  showIndicator = true;
Â  Â  Â  Â  }
Â  Â  Â  Â  colorIndicator.style.display = showIndicator ? 'inline-flex' : 'none';
Â  Â  }
}
    function getPos(e, targetCanvas) {
        if (!targetCanvas) return null;
        const rect = targetCanvas.getBoundingClientRect(); let clientX, clientY;
        if (e.touches && e.touches.length > 0) { clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; }
        else if (e.changedTouches && e.changedTouches.length > 0) { clientX = e.changedTouches[0].clientX; clientY = e.changedTouches[0].clientY; }
        else { clientX = e.clientX; clientY = e.clientY; }
        if (typeof clientX !== 'number' || typeof clientY !== 'number') return null;
        return { x: clientX - rect.left, y: clientY - rect.top };
    }
// THIS IS THE NEW, UPDATED FUNCTION
function handleDrawingStart(e) {
	
    if (isTabletMode && e.type.startsWith('touch')) {
        const isStylusPresent = Array.from(e.touches).some(t => t.touchType === 'stylus');
        if (!isStylusPresent) {
            e.preventDefault();
            return;
        }
        // The UI-hiding logic has been REMOVED from here.
    }

    const currentTargetCanvas = e.currentTarget;
    const activeCtx = isThelobookActive ? thelobookCtx : ctx;
    if (!activeCtx) return;
    if (isThelobookActive && currentTargetCanvas !== thelobookCanvas) return;
    if (!isThelobookActive && currentTargetCanvas !== canvas) return;
    if (!isStudentInputAllowed && !isThelobookActive) return;

    const pos = getPos(e, currentTargetCanvas);
    if (!pos) return;
    if (e.touches) e.preventDefault();

    drawing = true;
	if (e.pointerType === 'pen') canvas.classList.add('no-cursor');
    if (!isThelobookActive) userDrawingOccurred = true;

    if (isThelobookActive) {
        activeCtx.lineWidth = isThelobookEraserActive ? THELOBOOK_ERASER_LINEWIDTH : THELOBOOK_PEN_LINEWIDTH;
        activeCtx.globalCompositeOperation = isThelobookEraserActive ? 'destination-out' : 'source-over';
    } else {
        activeCtx.lineWidth = THELOBOOK_PEN_LINEWIDTH;
        activeCtx.globalCompositeOperation = 'source-over';
    }

    lastPos = pos;
    activeCtx.beginPath();
    activeCtx.moveTo(pos.x, pos.y);
}
// THIS IS THE NEW, UPDATED FUNCTION
// REPLACE the old handleDrawingMove function with this one
function handleDrawingMove(e) {
    if (!drawing) return;

    if (isTabletMode) {
        if (buttonVanishTimer) clearTimeout(buttonVanishTimer);
        if (bottomBar && !bottomBar.classList.contains('bar-hidden-by-stylus')) {
            bottomBar.classList.add('bar-hidden-by-stylus');
        }
    }

    const currentTargetCanvas = e.currentTarget;
    const activeCtx = isThelobookActive ? thelobookCtx : ctx;
    if (!activeCtx) return;

    const pos = getPos(e, currentTargetCanvas);
    if (!pos) return;
    if (e.touches) e.preventDefault();

    const midPoint = { x: (lastPos.x + pos.x) / 2, y: (lastPos.y + pos.y) / 2 };

    activeCtx.quadraticCurveTo(lastPos.x, lastPos.y, midPoint.x, midPoint.y);
    activeCtx.stroke();
    activeCtx.moveTo(midPoint.x, midPoint.y);
	captureCtx.quadraticCurveTo(lastPos.x, lastPos.y, midPoint.x, midPoint.y);
captureCtx.stroke();

    lastPos = pos;

    // --- NEW MINIMAP DRAWING LOGIC ---
    // If the minimap context exists and we are NOT in thelobook mode...
    if (minimapCtx && !isThelobookActive) {
        // Clear the previous frame on the minimap
        minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
        // Draw the entire main canvas (where the ink is) onto the minimap, scaled to fit.
        minimapCtx.drawImage(canvas, 0, 0, minimapCanvas.width / devicePixelRatio, minimapCanvas.height / devicePixelRatio);
    }
}
function handleDrawingEnd(e) {
	canvas.classList.remove('no-cursor');
    if (isTabletMode) {
        if (buttonVanishTimer) clearTimeout(buttonVanishTimer);
        buttonVanishTimer = setTimeout(() => {
            if (bottomBar) bottomBar.classList.remove('bar-hidden-by-stylus');
        }, 500);
    }

    if (!drawing) return;
    drawing = false;

    const activeCtx = isThelobookActive ? thelobookCtx : ctx;
    if (!activeCtx) return;

    activeCtx.lineTo(lastPos.x, lastPos.y);
    activeCtx.stroke();
    activeCtx.closePath();
}
    // REPLACE your old drawing functions with these three new versions
function addBoardDrawListeners() {
        canvas.addEventListener('mousedown', handleDrawingStart);
        canvas.addEventListener('mousemove', handleDrawingMove);
        canvas.addEventListener('touchstart', handleDrawingStart, { passive: false });
        canvas.addEventListener('touchmove', handleDrawingMove, { passive: false });
        canvas.addEventListener('touchend', handleDrawingEnd);
        canvas.addEventListener('touchcancel', handleDrawingEnd);
    }
    function removeBoardDrawListeners() {
        canvas.removeEventListener('mousedown', handleDrawingStart);
        canvas.removeEventListener('mousemove', handleDrawingMove);
        canvas.removeEventListener('touchstart', handleDrawingStart);
        canvas.removeEventListener('touchmove', handleDrawingMove);
        canvas.removeEventListener('touchend', handleDrawingEnd);
        canvas.removeEventListener('touchcancel', handleDrawingEnd);
    }
    function addThelobookDrawListeners() {
        if (thelobookDrawListenersAttached) return;
        thelobookCanvas.addEventListener('mousedown', handleDrawingStart);
        thelobookCanvas.addEventListener('mousemove', handleDrawingMove);
        thelobookCanvas.addEventListener('touchstart', handleDrawingStart, { passive: false });
        thelobookCanvas.addEventListener('touchmove', handleDrawingMove, { passive: false });
        thelobookCanvas.addEventListener('touchend', handleDrawingEnd);
        thelobookCanvas.addEventListener('touchcancel', handleDrawingEnd);
        thelobookDrawListenersAttached = true;
    }
    function removeThelobookDrawListeners() {
        if (!thelobookDrawListenersAttached) return;
        thelobookCanvas.removeEventListener('mousedown', handleDrawingStart);
        thelobookCanvas.removeEventListener('mousemove', handleDrawingMove);
        thelobookCanvas.removeEventListener('touchstart', handleDrawingStart);
        thelobookCanvas.removeEventListener('touchmove', handleDrawingMove);
        thelobookCanvas.removeEventListener('touchend', handleDrawingEnd);
        thelobookCanvas.removeEventListener('touchcancel', handleDrawingEnd);
        thelobookDrawListenersAttached = false;
    }

    function wrapText(context, text, x, y, maxWidth, lineHeight){
        const words = text.split(' '); let line = ''; let currentY = y; let lines = [];
        for(let n = 0; n < words.length; n++) {
            const testLine = line + words[n] + ' '; const metrics = context.measureText(testLine);
            const testWidth = metrics.width; const wordWidth = context.measureText(words[n]).width;
            if (wordWidth > maxWidth && line.trim() !== '') { context.fillText(line.trim(), x, currentY); lines.push(line.trim()); line = ''; currentY += lineHeight; }
            if (wordWidth > maxWidth) { context.fillText(words[n], x, currentY); lines.push(words[n]); line = ' '; currentY += lineHeight; }
            else if (testWidth > maxWidth && line.trim() !== '') { context.fillText(line.trim(), x, currentY); lines.push(line.trim()); line = words[n] + ' '; currentY += lineHeight; }
            else { line = testLine; }
        }
        if (line.trim() !== '') { context.fillText(line.trim(), x, currentY); lines.push(line.trim());} return lines.length * lineHeight;
    }
    /**
 * A cache for the fetched KaTeX stylesheet to avoid re-fetching.
 */
/**
 * A cache for the fetched KaTeX stylesheet to avoid re-fetching.
 */
/**
 * A cache for the fetched KaTeX stylesheet to avoid re-fetching.
 */
/**
 * A cache for the fetched KaTeX stylesheet to avoid re-fetching.
 */
let katexCSSInlined = null;

function abToBase64(ab) {
  const CHUNK = 0x8000;
  const bytes = new Uint8Array(ab);
  let binary = '';
  for (let i = 0; i < bytes.length; i += CHUNK) {
    binary += String.fromCharCode(...bytes.subarray(i, i + CHUNK));
  }
  return btoa(binary);
}

async function getKatexCSSWithEmbeddedFonts() {
  if (katexCSSInlined) return katexCSSInlined;

  const base = 'https://cdn.jsdelivr.net/npm/katex@0.16.10/dist';
  let css = await (await fetch(`${base}/katex.min.css`)).text();

  // Minimal set that covers typical inline math + delimiters
  const fonts = [
    'KaTeX_Main-Regular.woff2',
    'KaTeX_Main-Italic.woff2',
    'KaTeX_Main-Bold.woff2',
    'KaTeX_Math-Italic.woff2',
    'KaTeX_AMS-Regular.woff2',
    'KaTeX_Size1-Regular.woff2',
    'KaTeX_Size2-Regular.woff2'
  ];

  for (const name of fonts) {
    const url = `${base}/fonts/${name}`;
    const res = await fetch(url);
    const b64 = abToBase64(await res.arrayBuffer());
    const dataURL = `url(data:font/woff2;base64,${b64}) format("woff2")`;
    css = css.replace(
      new RegExp(`url\\([^)]*${name}[^)]*\\)\\s*format\\("woff2"\\)`, 'g'),
      dataURL
    );
  }

  katexCSSInlined = css;
  return katexCSSInlined;
}
// Wait until the UI font used for headline text is available
async function ensureHeadlineFontsLoaded() {
Â  try {
    const family = (currentLang === 'en') ? 'Manrope' : 'Montserrat Arm';
Â  Â  // Load a specific face/size so measureText uses the right metrics
Â  Â  if (document.fonts && document.fonts.load) {
Â  Â  Â  // Try to load; don't hang forever if the browser doesn't support it
Â  Â  Â  await Promise.race([
Â  Â  Â  Â  (async () => {
Â  Â  Â  Â  Â  await document.fonts.load(`20px "${family}"`);
Â  Â  Â  Â  Â  await document.fonts.ready; // resolves when all pending fonts are ready
Â  Â  Â  Â  })(),
Â  Â  Â  Â  new Promise(res => setTimeout(res, 800)) // safety timeout
Â  Â  Â  ]);
Â  Â  }
Â  } catch (_) { /* ignore */ }
}

// Mixed text + KaTeX headline renderer (SVG with embedded KaTeX fonts)
// - Segments delimited by /K ... K/ are rendered with KaTeX
// - Lines are wrapped to widthFraction of the canvas and centered per line
// - Adds 2px pad in SVG to prevent right-edge clipping of last glyphs
async function renderComplexHeadline(bgCtx, headline, y, opts = {}) {
  if (!headline || !bgCtx) return;

  // ---- config ----
  const widthFraction = Math.min(Math.max(opts.widthFraction ?? 0.88, 0.5), 0.98);
  const yNudge = opts.yNudge ?? -14;
  const fontSize = 20;
  const mathFontSize = 22;

  const fontColor =
    getComputedStyle(document.documentElement)
      .getPropertyValue('--thelo-text')
      .trim() || '#111827';

  // KaTeX CSS with embedded fonts (so data-URL SVG can render the same as DOM)
  const katexCSS = await getKatexCSSWithEmbeddedFonts();

  // Extra font-family overrides to keep headline matching MCQs
  const extraRules = `
.katex, .katex .mathnormal { font-family: "KaTeX_Main", serif !important; }
.katex .mathit, .katex .textit { font-family: "KaTeX_MathItalic", serif !important; }
.katex .mathsf, .katex .textsf { font-family: "KaTeX_SansSerif", sans-serif !important; }
.katex .mathtt, .katex .texttt { font-family: "KaTeX_Typewriter", monospace !important; }
`;

  // ---- parse headline into segments: /K ... K/ => math
  const segments = (headline.split(/(\/K[\s\S]*?K\/)/g) || [])
    .filter(Boolean)
    .map(p =>
      p.startsWith('/K') && p.endsWith('K/')
        ? { type: 'math', content: p.replace(/^\/K\s*/, '').replace(/\s*K\/$/, '') }
        : { type: 'text', content: p }
    );

  // A hidden host for measuring KaTeX DOM sizes (one per call)
  const measureHost = document.createElement('div');
  measureHost.style.position = 'absolute';
  measureHost.style.visibility = 'hidden';
  measureHost.style.left = '-9999px';
  measureHost.style.top = '-9999px';
  document.body.appendChild(measureHost);

  // ---- tokenize with measurements ----
  const tokens = [];
  for (const seg of segments) {
    if (seg.type === 'text') {
      const parts = seg.content.match(/(\s+|[^\s]+)/g) || [];
      for (const p of parts) {
        tokens.push({
          type: 'text',
          content: p,
          width: bgCtx.measureText(p).width,
          height: fontSize,
          isSpace: /^\s+$/.test(p)
        });
      }
      continue;
    }

    // math segment
    try {
      const html = katex.renderToString(seg.content, { throwOnError: false, output: 'html' });

       const style = document.createElement('style');
 style.textContent = katexCSS;          // the CSS you built with embedded fonts
 measureHost.appendChild(style);

 const tmp = document.createElement('div');
 tmp.style.color = fontColor;
 tmp.style.fontSize = `${mathFontSize}px`;
 tmp.innerHTML = html;
 measureHost.appendChild(tmp);

      const katexEl = tmp.querySelector('.katex') || tmp;
      const rect = katexEl.getBoundingClientRect();

      // remove measured node (keep host)
      tmp.remove();

      // Pad & round to avoid clipping last glyphs
      const PAD = 2;
      const w = Math.ceil(rect.width) + PAD;
      const h = Math.ceil(rect.height) + PAD;

      const svg = `
        <svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}">
          <style>${katexCSS}\n${extraRules}</style>
          <foreignObject width="100%" height="100%">
            <div xmlns="http://www.w3.org/1999/xhtml"
                 style="color:${fontColor};font-size:${mathFontSize}px;line-height:initial;display:inline-block;padding-right:${PAD/2}px;">
              ${html}
            </div>
          </foreignObject>
        </svg>`;

      const dataUrl = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svg)));
      const image = new Image();
      image.src = dataUrl;
      await image.decode();

      tokens.push({ type: 'math', image, width: w, height: h, drawW: w, drawH: h });
    } catch (e) {
      // graceful fallback to text measurement
      const w = bgCtx.measureText(seg.content).width;
      tokens.push({ type: 'text', content: seg.content, width: w, height: fontSize, isSpace: false });
    }
  }

  // cleanup measure host
  measureHost.remove();

  // ---- build lines to fit available width ----
  const canvasW = bgCtx.canvas.width / (window.devicePixelRatio || 1);
  const maxWidth = canvasW * widthFraction;
  const lineGap = 8;

  const lines = [];
  let line = { tokens: [], width: 0, height: fontSize };

  for (const t of tokens) {
    // allow scaling down oversized math to fit
    let width = t.width, height = t.height, drawW = t.drawW ?? t.width, drawH = t.drawH ?? t.height;

    if (t.type === 'math' && width > maxWidth) {
      const s = maxWidth / width;
      width = Math.floor(width * s);
      height = Math.floor(height * s);
      drawW = t.drawW * s;
      drawH = t.drawH * s;
    }
    const tok = { ...t, width, height, drawW, drawH };

    if (line.tokens.length && line.width + width > maxWidth) {
      lines.push(line);
      line = { tokens: [], width: 0, height: fontSize };
    }
    if (!(line.tokens.length === 0 && tok.isSpace)) {
      line.tokens.push(tok);
      line.width += width;
      if (height > line.height) line.height = height;
    }
  }
  if (line.tokens.length) lines.push(line);

  // ---- render lines, centered horizontally ----
  const prevAlign = bgCtx.textAlign;
  const prevBase = bgCtx.textBaseline;
  const prevFill = bgCtx.fillStyle;

  bgCtx.fillStyle = fontColor;
  bgCtx.textAlign = 'left';
  bgCtx.textBaseline = 'top';

  let curY = y + yNudge;
  for (const L of lines) {
    let x = (canvasW - L.width) / 2;
    for (const t of L.tokens) {
      const topY = curY + (L.height - t.height) / 2;
      if (t.type === 'text') {
        bgCtx.fillText(t.content, x, topY);
      } else {
        bgCtx.drawImage(t.image, x, topY, t.drawW, t.drawH);
      }
      x += t.width;
    }
    curY += L.height + lineGap;
  }

  // restore ctx
  bgCtx.textAlign = prevAlign || 'center';
  bgCtx.textBaseline = prevBase || 'top';
  bgCtx.fillStyle = prevFill || fontColor;
}



	  function stopCurrentStageAudio(){ if (currentStageAudio && !currentStageAudio.paused) { currentStageAudio.pause(); console.log("Current stage audio paused.");} }

    function playStageAudio(
    audioSrc,
    onLoadedMetadataCallback,
    onEndedCallback,
    isResuming = false
    ) {
    /* â”€â”€â”€â”€â”€ early-out if a modal overlay is open â”€â”€â”€â”€â”€ */
    if (isThelobookActive || isPageGridVisible || isCalculatorActive) {
    if (onLoadedMetadataCallback) onLoadedMetadataCallback(0);
    if (onEndedCallback) onEndedCallback();
    return;
    }

    currentStageAudio = stageAudioPlayer; // make sure weâ€™re pointing at the right element

    /* â”€â”€â”€â”€â”€ RESUME PATH â”€â”€â”€â”€â”€
        Only run this branch if weâ€™re *resuming* and the element
        already has the same source.  We now compare the canonical
        absolute URLs instead of using `.includes()`. */
    if (
    isResuming &&
    currentStageAudio &&
    currentStageAudio.src &&
    new URL(currentStageAudio.src, document.baseURI).href ===
        new URL(audioSrc, document.baseURI).href
    ) {
    const audioEffectivelyAtEnd =
        currentStageAudio.duration > 0 &&
        audioTimeBeforeThelobook >= currentStageAudio.duration - 0.05;

    if (wasMediaPlayingBeforeThelobook && !audioEffectivelyAtEnd) {
        if (window.userInteracted && currentStageAudio.paused) {
        currentStageAudio
            .play()
            .catch((e) => console.warn("Resume audio play failed:", e));
        }
    }

    // wire callbacks (or call immediately if metadata already available)
    if (onLoadedMetadataCallback) {
        if (
        currentStageAudio.readyState >= HTMLMediaElement.HAVE_METADATA
        ) {
        onLoadedMetadataCallback(currentStageAudio.duration);
        } else {
        const tempMetaListener = () => {
            onLoadedMetadataCallback(currentStageAudio.duration);
            currentStageAudio.removeEventListener(
            "loadedmetadata",
            tempMetaListener
            );
        };
        currentStageAudio.addEventListener(
            "loadedmetadata",
            tempMetaListener
        );
        }
    }
    if (onEndedCallback) currentStageAudio.onended = onEndedCallback;
    return; // â† nothing else to do
    }

    /* â”€â”€â”€â”€â”€ FULL (re-)INITIALISATION PATH â”€â”€â”€â”€â”€ */
    if (currentStageAudio && !currentStageAudio.paused) {
    currentStageAudio.pause();
    }
    if (currentStageAudio) {
    currentStageAudio.onloadedmetadata = null;
    currentStageAudio.onended = null;
    }

    if (!audioSrc) {
    if (onLoadedMetadataCallback) onLoadedMetadataCallback(0);
    if (onEndedCallback) onEndedCallback();
    return;
    }

    currentStageAudio.src = audioSrc;
    currentStageAudio.preload = "auto";

    let loadedMetaCalled = false;
    currentStageAudio.onloadedmetadata = () => {
    if (!loadedMetaCalled && onLoadedMetadataCallback) {
        loadedMetaCalled = true;
        onLoadedMetadataCallback(currentStageAudio.duration);
    }
    };
    if (onEndedCallback) currentStageAudio.onended = onEndedCallback;

    currentStageAudio.load();
    if (window.userInteracted) {
    const playPromise = currentStageAudio.play();
    if (playPromise) {
        playPromise.catch((error) => {
        console.warn("Audio play failed (full init):", error);
        if (onEndedCallback) onEndedCallback();
        });
    }
    } else {
    console.warn("Audio interaction needed for autoplay.");
    }
    }
// Render mixed text + /K ... K/ math into a target element (e.g., a button)
function renderMixedKaTeXInto(targetEl, src) {
  // Clear current content
  while (targetEl.firstChild) targetEl.removeChild(targetEl.firstChild);

  if (!src) return;

  const parts = src.split(/(\/K[\s\S]*?K\/)/g).filter(Boolean);

  for (const part of parts) {
    const isMath = part.startsWith('/K') && part.endsWith('K/');
    if (!isMath) {
      targetEl.appendChild(document.createTextNode(part));
      continue;
    }

    const expr = part.replace(/^\/K\s*/, '').replace(/\s*K\/$/, '');
    const span = document.createElement('span');

    try {
      // Render KaTeX directly into the span (no innerHTML injection)
      katex.render(expr, span, { throwOnError: false });

    } catch (e) {
      // Graceful fallback
      span.textContent = expr;
    }
    targetEl.appendChild(span);
  }
}

function displayMcq(mcqDetails){
    const choices = mcqDetails.choices;
    if (!mcqOptionsContainer || !mcqDetails || !Array.isArray(choices) || choices.length === 0) return;
    if (isPageGridVisible) closePageGridView();

    mcqOptionsContainer.innerHTML = '';
    document.body.classList.add('mcq-active'); // Activate keyboard-only CSS

    /* ===== Smartâ€‘layout Logic (Unchanged) ===== */
    const isShort = choices.every(choice => choice.length < 10);
    mcqOptionsContainer.className = isShort ? 'short-options' : 'long-options';
    const isSideBySide = !!(currentStageData && currentStageData.image);
    mcqOptionsContainer.classList.toggle('side-by-side', isSideBySide);
    
    choices.forEach((optionText, index) => {
        const optionButton = document.createElement('button');
        optionButton.classList.add('mcq-option-btn');
        renderMixedKaTeXInto(optionButton, optionText);
        optionButton.dataset.index = index;
        // NO click listener
        mcqOptionsContainer.appendChild(optionButton);
    });

    mcqOptionsContainer.style.display = 'flex';
    mcqOptionsContainer.style.opacity = '1';

    // Set the initial selection to the first option
    updateMcqSelectionVisuals(0); 
}
/**
 * Updates the visual state of MCQ buttons based on the selected index.
 * @param {number} newIndex - The index of the MCQ option to select.
 */
function updateMcqSelectionVisuals(newIndex) {
    if (!mcqOptionsContainer) return;
    selectedMcqIndex = newIndex; // Update the global state

    const optionButtons = mcqOptionsContainer.querySelectorAll('.mcq-option-btn');
    optionButtons.forEach((btn, index) => {
        btn.classList.toggle('selected', index === newIndex);
    });
}  // Replace your old function with this simplified version
function handleMcqOptionClick(selectedIndex, mcqDetails){
    return; // Clicks are disabled
}/**
 * Toggles a distraction-free fullscreen mode that hides the browser's
 * default 'X' button on interaction.
 */
function toggleFocusFullscreen() {
    // Check if we are currently in any fullscreen mode
    if (!document.fullscreenElement) {
        // If not, request fullscreen for the whole page
        document.documentElement.requestFullscreen({
            navigationUI: 'hide' // This is the magic property!
        }).catch(err => {
            // Log any errors if the request fails
            console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
        });
    } else {
        // If we are in fullscreen, exit it
        if (document.exitFullscreen) {
            document.exitFullscreen();
        }
    }
}
	// REPLACE your entire renderStageUI function with this one
/**
 * Draws the stage image onto the background canvas with the correct layout,
 * positioning it to the side if MCQs are present, otherwise centering it.
 * @param {CanvasRenderingContext2D} bgCtx - The context of the background canvas.
 * @param {HTMLImageElement} img - The image to draw.
 * @param {object} currentStageData - The data for the current stage.
 */
function drawImageWithCorrectLayout(bgCtx, img, currentStageData) {
    const canvasWidth = bgCtx.canvas.width / devicePixelRatio;
    const canvasHeight = bgCtx.canvas.height / devicePixelRatio;
    
    // Determine if the stage also has an MCQ to display.
    const hasMcq = currentStageData.optionsQuiz && Array.isArray(currentStageData.optionsQuiz.choices);

    if (hasMcq) {
        // --- Side-by-Side Layout Logic ---
        const sidePad = canvasWidth * 0.04;      // 4% gutter
        const maxImgWidth = canvasWidth * 0.48;   // ~50% of board
        const maxImgHeight = canvasHeight * 0.85; // Leave vertical room
        const scale = Math.min(maxImgWidth / img.width, maxImgHeight / img.height);
        
        const scaledWidth = img.width * scale;
        const scaledHeight = img.height * scale;
        const x = sidePad; // Position on the left
        const y = (canvasHeight - scaledHeight) / 2; // Vertically centered
        bgCtx.drawImage(img, x, y, scaledWidth, scaledHeight);

    } else {
        // --- Default Centered Layout Logic ---
        const maxSizePercentage = 0.50;
        const maxContainerWidth = canvasWidth * maxSizePercentage;
        const maxContainerHeight = canvasHeight * maxSizePercentage;
        const scale = Math.min(maxContainerWidth / img.width, maxContainerHeight / img.height);
        
        const scaledWidth = img.width * scale;
        const scaledHeight = img.height * scale;
        const x = (canvasWidth - scaledWidth) / 2; // Horizontally centered
        const y = (canvasHeight - scaledHeight) / 2; // Vertically centered
        bgCtx.drawImage(img, x, y, scaledWidth, scaledHeight);
    }
}
/**
 * Opens the replay player, fetches the replay data, and sends it to the iframe.
 */
// In your MAIN app's <script> tag

// In your MAIN app's <script> tag
async function openReplayPlayer() {
    if (isReplayActive || !currentStageData || !currentStageData.replayDataUrl) {
        return;
    }
    isReplayActive = true;

    try {
        const response = await fetch(currentStageData.replayDataUrl);
        const replayJson = await response.json();
        const replayActions = replayJson.actions;

        const onIframeReady = (event) => {
            if (event.source === replayFrame.contentWindow && event.data.command === 'ready') {
                replayFrame.contentWindow.postMessage({
                    command: 'loadTimeline',
                    actions: replayActions
                }, '*');

                window.removeEventListener('message', onIframeReady);

                // Start the main app's playback loop
                isMediaScrubbingActive = true;
                lastFrameTimestampForManualAdvance = 0;
                internalPlaybackTime = 0;
                currentReplayAnimationId = requestAnimationFrame(mediaPlaybackLoop);
            }
        };

        window.addEventListener('message', onIframeReady);
        replayFrame.src = 'https://thelo.space/replay'; // Or your replay URL
        replayPlayerContainer.classList.remove('replay-hidden');

    } catch (error) {
        console.error("Failed to load or send replay data:", error);
        isReplayActive = false;
    }
}
		// In your MAIN app's <script> tag
function closeReplayPlayer() {
    if (!isReplayActive) return;
    isReplayActive = false;

    // CRITICAL: Stop the main app's animation loop
    if (currentReplayAnimationId) {
        cancelAnimationFrame(currentReplayAnimationId);
        currentReplayAnimationId = null;
    }
    isMediaScrubbingActive = false;

    replayPlayerContainer.classList.add('replay-hidden');
    replayFrame.src = 'about:blank';
}
// In your main HTML file, REPLACE your entire renderStageUI function with this one.

function renderStageUI(index, isResize = false) {
Â  Â  return new Promise(async (resolve, reject) => {
Â  Â  Â  Â  if (isLessonLoading || index < 0 || index >= lessonStages.length) {
Â  Â  Â  Â  Â  Â  if (index < 0) {
Â  Â  Â  Â  Â  Â  Â  Â  if (nextCheckBtn) { nextCheckBtn.disabled = true; nextCheckBtn.textContent = getCurrentUIText().start; }
Â  Â  Â  Â  Â  Â  Â  Â  if (prevBtn) prevBtn.disabled = true;
Â  Â  Â  Â  Â  Â  Â  Â  if (clearBtn && clearBtn.style) clearBtn.style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  if (colorIndicator && colorIndicator.style) colorIndicator.style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  if (mcqOptionsContainer && mcqOptionsContainer.style) mcqOptionsContainer.style.display = 'none';
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  return resolve();
Â  Â  Â  Â  }

Â  Â  Â  Â  const TXT = getCurrentUIText();
Â  Â  Â  Â  if (!isResize && isThelobookActive) closeThelobook(true);
Â  Â  Â  Â  if (!isResize && isPageGridVisible) closePageGridView();
Â  Â  Â  Â  if (!isResize) closeReplayPlayer();

Â  Â  Â  Â  if (!isResize) {
Â  Â  Â  Â  Â  Â  if (currentReplayAnimationId) { cancelAnimationFrame(currentReplayAnimationId); currentReplayAnimationId = null; }
Â  Â  Â  Â  Â  Â  if (currentStageAudio && !currentStageAudio.paused) { currentStageAudio.pause(); currentStageAudio.currentTime = 0; currentStageAudio.onloadedmetadata = null; currentStageAudio.onended = null; }
Â  Â  Â  Â  Â  Â  isMediaScrubbingActive = false; currentStageDrawingData = null; currentStageTotalDuration = 0; internalPlaybackTime = 0; lastFrameTimestampForManualAdvance = 0;
Â  Â  Â  Â  Â  Â  if (stageProgressBarContainer) stageProgressBarContainer.classList.remove('visible');
Â  Â  Â  Â  Â  Â  if (stageProgressFill) stageProgressFill.style.width = '0%';
Â  Â  Â  Â  }

Â  Â  Â  Â  currentStageData = lessonStages[index];
Â  Â  Â  Â  currentStageIndex = index;
Â  Â  Â  Â  isStudentInputAllowed = currentStageData.studentInput === true;

Â  Â  Â  Â  if (mcqOptionsContainer) { mcqOptionsContainer.innerHTML = ''; mcqOptionsContainer.style.display = 'none'; }

Â  Â  Â  Â  if (bgCtx) bgCtx.clearRect(0, 0, backgroundCanvas.width / devicePixelRatio, backgroundCanvas.height / devicePixelRatio);
Â  Â  Â  Â  if (!isResize) {
Â  Â  Â  Â  Â  Â  clearUserCanvas();
Â  Â  Â  Â  Â  Â  if (replayCtx) replayCtx.clearRect(0, 0, replayCanvas.width / devicePixelRatio, replayCanvas.height / devicePixelRatio);
Â  Â  Â  Â  }

Â  Â  Â  Â  function drawImageWithCorrectLayout(bgCtx, img, currentStageData) {
Â  Â  Â  Â  Â  Â  const canvasWidth = bgCtx.canvas.width / devicePixelRatio;
Â  Â  Â  Â  Â  Â  const canvasHeight = bgCtx.canvas.height / devicePixelRatio;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  const hasMcq = currentStageData.optionsQuiz && Array.isArray(currentStageData.optionsQuiz.choices);

Â  Â  Â  Â  Â  Â  if (hasMcq) {
Â  Â  Â  Â  Â  Â  Â  Â  const sidePad = canvasWidth * 0.04;
Â  Â  Â  Â  Â  Â  Â  Â  const maxImgWidth = canvasWidth * 0.48;
Â  Â  Â  Â  Â  Â  Â  Â  const maxImgHeight = canvasHeight * 0.85;
Â  Â  Â  Â  Â  Â  Â  Â  const scale = Math.min(maxImgWidth / img.width, maxImgHeight / img.height);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  const scaledWidth = img.width * scale;
Â  Â  Â  Â  Â  Â  Â  Â  const scaledHeight = img.height * scale;
Â  Â  Â  Â  Â  Â  Â  Â  const x = sidePad;
Â  Â  Â  Â  Â  Â  Â  Â  const y = (canvasHeight - scaledHeight) / 2;
Â  Â  Â  Â  Â  Â  Â  Â  bgCtx.drawImage(img, x, y, scaledWidth, scaledHeight);
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  const maxSizePercentage = 0.50;
Â  Â  Â  Â  Â  Â  Â  Â  const maxContainerWidth = canvasWidth * maxSizePercentage;
Â  Â  Â  Â  Â  Â  Â  Â  const maxContainerHeight = canvasHeight * maxSizePercentage;
Â  Â  Â  Â  Â  Â  Â  Â  const scale = Math.min(maxContainerWidth / img.width, maxContainerHeight / img.height);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  const scaledWidth = img.width * scale;
Â  Â  Â  Â  Â  Â  Â  Â  const scaledHeight = img.height * scale;
Â  Â  Â  Â  Â  Â  Â  Â  const x = (canvasWidth - scaledWidth) / 2;
Â  Â  Â  Â  Â  Â  Â  Â  const y = (canvasHeight - scaledHeight) / 2;
Â  Â  Â  Â  Â  Â  Â  Â  bgCtx.drawImage(img, x, y, scaledWidth, scaledHeight);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  async function drawHeadlineText() {
Â  Â  Â  Â  Â  Â  const padding = 27;
Â  Â  Â  Â  Â  Â  let headlineCurrentY = padding * 2;
Â  Â  Â  Â  Â  Â  const headlineText = currentStageData.headline || '';

Â  Â  Â  Â  Â  Â  if (headlineText && bgCtx && bgCtx.canvas.width > 0) {
              // FIX: This line is updated to use 'Montserrat Arm'
Â  Â  Â  Â  Â  Â  Â  Â  const fontFamily = currentLang === 'en' ? "'Manrope', system-ui, sans-serif" : "'Montserrat Arm', system-ui, sans-serif";
Â  Â  Â  Â  Â  Â  Â  Â  bgCtx.font = `20px ${fontFamily}`;
Â  Â  Â  Â  Â  Â  Â  Â  await ensureHeadlineFontsLoaded();
Â  Â  Â  Â  Â  Â  Â  Â  await renderComplexHeadline(bgCtx, headlineText, headlineCurrentY + 10);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  function setupStageContent() {
Â  Â  Â  Â  Â  Â  const mcqDetails = currentStageData.optionsQuiz;
Â  Â  Â  Â  Â  Â  const isMCQDisplayStage = currentStageData.type === "explanation_with_mcq" && mcqDetails && Array.isArray(mcqDetails.choices) && mcqDetails.choices.length > 0;
Â  Â  Â  Â  Â  Â  const isQuestionStage = currentStageData.type === 'question_handwriting' || currentStageData.type === 'question_math_solution' || isMCQDisplayStage;

Â  Â  Â  Â  Â  Â  if (!isMCQDisplayStage && nextCheckBtn) {
Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.style.display = 'inline-flex';
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  if (currentStageData.type === 'calculator_replay') {
Â  Â  Â  Â  Â  Â  Â  Â  openReplayPlayer();
Â  Â  Â  Â  Â  Â  Â  Â  if (!isResize) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  internalPlaybackTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lastFrameTimestampForManualAdvance = 0;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  const audioMetaPromise = new Promise((resolveAudio) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (currentStageData.audioFile) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  playStageAudio(currentStageData.audioFile, (duration) => resolveAudio(duration || 0), () => { }, isResize);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  resolveAudio(0);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  const replayDataDurationPromise = fetch(currentStageData.replayDataUrl)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  .then(r => r.ok ? r.json() : Promise.reject(`HTTP ${r.status}`))
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  .then(json => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let totalReplayTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  json.actions.forEach(action => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (action.action === 'delay') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  totalReplayTime += action.ms;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (action.action === 'animateView') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  totalReplayTime += action.payload.duration;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return totalReplayTime / 1000;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  })
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  .catch(e => { console.error("Failed to load replay data for duration calculation:", e); return 0; });
Â  Â  Â  Â  Â  Â  Â  Â  Promise.all([audioMetaPromise, replayDataDurationPromise]).then(([audioDuration, replayDuration]) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentStageTotalDuration = Math.max(audioDuration, replayDuration);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isMediaScrubbingActive = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  updateMediaProgressBar(internalPlaybackTime, currentStageTotalDuration);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (stageProgressBarContainer) stageProgressBarContainer.classList.add('visible');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!currentReplayAnimationId) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentReplayAnimationId = requestAnimationFrame(mediaPlaybackLoop);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }).catch(e => console.error("Error setting up replay stage durations:", e));
Â  Â  Â  Â  Â  Â  Â  Â  if (nextCheckBtn) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.textContent = TXT.gotIt;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.disabled = false;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if (clearBtn) clearBtn.style.display = 'none';
Â  Â  Â  Â  Â  Â  } else if (isQuestionStage) {
Â  Â  Â  Â  Â  Â  Â  Â  if (!isResize) isMediaScrubbingActive = false;
Â  Â  Â  Â  Â  Â  Â  Â  if (stageProgressBarContainer) stageProgressBarContainer.classList.remove('visible');
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (isMCQDisplayStage && mcqDetails) {
            if (bottomBar) bottomBar.style.display = 'flex';
            displayMcq(mcqDetails);
            if (clearBtn) clearBtn.style.display = 'none';

            if (nextCheckBtn) {
                nextCheckBtn.style.display = 'inline-flex';
                nextCheckBtn.disabled = false; // Button starts ENABLED for keyboard
                nextCheckBtn.textContent = TXT.check;
            }
        } else if (currentStageData.type === 'question_handwriting' || currentStageData.type === 'question_math_solution') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (bottomBar) bottomBar.style.display = 'flex';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (nextCheckBtn) { nextCheckBtn.textContent = TXT.check; nextCheckBtn.disabled = false; }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (clearBtn) clearBtn.style.display = 'inline-flex';
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if (currentStageData.audioFile) { playStageAudio(currentStageData.audioFile, (d) => { }, () => { }, isResize); }
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  if (bottomBar) bottomBar.style.display = 'flex';
Â  Â  Â  Â  Â  Â  Â  Â  if (mcqOptionsContainer) mcqOptionsContainer.style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  const isDrawingInputStage = currentStageData.studentInput === true;
Â  Â  Â  Â  Â  Â  Â  Â  if (clearBtn) clearBtn.style.display = isDrawingInputStage ? 'inline-flex' : 'none';
Â  Â  Â  Â  Â  Â  Â  Â  if (currentStageData.audioFile || currentStageData.drawingRecord) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!isResize) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isMediaScrubbingActive = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lastFrameTimestampForManualAdvance = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  internalPlaybackTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  updateMediaProgressBar(internalPlaybackTime, currentStageTotalDuration > 0 ? currentStageTotalDuration : 1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const audioMetaPromise = new Promise((resolveAudio) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (currentStageData.audioFile) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  playStageAudio(currentStageData.audioFile, (duration) => resolveAudio(duration || 0), () => { }, isResize);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  resolveAudio(0);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let drawingDataPromise;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (currentStageData.drawingRecord) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!isResize || !currentStageDrawingData) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  drawingDataPromise = fetch(currentStageData.drawingRecord).then(r => r.ok ? r.json() : Promise.reject(`HTTP ${r.status}`)).then(json => { if (!json || !json.strokes) throw "Bad drawing JSON"; currentStageDrawingData = json; return json; }).catch(e => { console.error("Failed to load drawing data:", e); currentStageDrawingData = null; return null; });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  drawingDataPromise = Promise.resolve(currentStageDrawingData);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentStageDrawingData = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  drawingDataPromise = Promise.resolve(null);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Promise.all([audioMetaPromise, drawingDataPromise]).then(([audioDuration, loadedDrawingData]) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (loadedDrawingData) currentStageDrawingData = loadedDrawingData;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const drawingAnimDuration = currentStageDrawingData ? calculateDrawingDuration(currentStageDrawingData) : 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentStageTotalDuration = Math.max(audioDuration, drawingAnimDuration);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (isMediaScrubbingActive && currentStageTotalDuration > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  updateMediaProgressBar(internalPlaybackTime, currentStageTotalDuration);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (stageProgressBarContainer) stageProgressBarContainer.classList.add('visible');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (currentReplayAnimationId) cancelAnimationFrame(currentReplayAnimationId);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentReplayAnimationId = requestAnimationFrame(mediaPlaybackLoop);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isMediaScrubbingActive = false; if (stageProgressBarContainer) stageProgressBarContainer.classList.remove('visible');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentStageAudio = null; currentStageDrawingData = null; currentStageTotalDuration = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (replayCtx) replayCtx.clearRect(0, 0, replayCanvas.width / devicePixelRatio, replayCanvas.height / devicePixelRatio);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if (nextCheckBtn) { nextCheckBtn.textContent = TXT.gotIt; nextCheckBtn.disabled = false; }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  updateColorIndicator();
Â  Â  Â  Â  Â  Â  canvas.style.pointerEvents = (isStudentInputAllowed && !isThelobookActive && !isPageGridVisible && !isReplayActive) ? 'auto' : 'none';
Â  Â  Â  Â  Â  Â  if (nextCheckBtn) { nextCheckBtn.classList.remove('correct', 'incorrect'); nextCheckBtn.style.backgroundColor = ''; }
Â  Â  Â  Â  Â  Â  if (!isResize) userDrawingOccurred = false;
Â  Â  Â  Â  Â  Â  if (prevBtn) prevBtn.disabled = (index === 0 || isThelobookActive || isPageGridVisible || isReplayActive);
Â  Â  Â  Â  Â  Â  if (nextCheckBtn) {
Â  Â  Â  Â  Â  Â  Â  Â  const isCorrectlyAnsweredHW = currentStageData.type === 'question_handwriting' && nextCheckBtn.classList.contains('correct');
Â  Â  Â  Â  Â  Â  Â  Â  if (!isMCQDisplayStage) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.disabled = (isThelobookActive || isPageGridVisible || isCorrectlyAnsweredHW || isReplayActive && !currentStageData.audioFile);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  if (clearBtn) clearBtn.disabled = (isThelobookActive || isPageGridVisible || isReplayActive);
Â  Â  Â  Â  }

Â  Â  Â  Â  if (currentStageData.image && bgCtx) {
Â  Â  Â  Â  Â  Â  const img = new Image();
Â  Â  Â  Â  Â  Â  img.crossOrigin = "Anonymous";
Â  Â  Â  Â  Â  Â  img.src = currentStageData.image;
Â  Â  Â  Â  Â  Â  img.onload = async () => {
Â  Â  Â  Â  Â  Â  Â  Â  drawImageWithCorrectLayout(bgCtx, img, currentStageData);
Â  Â  Â  Â  Â  Â  Â  Â  await drawHeadlineText();
		Â  Â  const isStudentDrawingStage = currentStageData.studentInput === true && currentStageData.type !== 'explanation_with_mcq';

Â  Â  Â  Â  // Show or hide the minimap container based on the stage type
Â  Â  Â  Â  if (minimapContainer) {
Â  Â  Â  Â  Â  Â  if (isStudentDrawingStage) {
Â  Â  Â  Â  Â  Â  Â  Â  minimapContainer.classList.remove('minimap-hidden');
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  minimapContainer.classList.add('minimap-hidden');
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  setupStageContent();
Â  Â  Â  Â  Â  Â  Â  Â  resolve();
Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  img.onerror = async () => {
Â  Â  Â  Â  Â  Â  Â  Â  console.error("Failed to load stage image:", currentStageData.image);
Â  Â  Â  Â  Â  Â  Â  Â  await drawHeadlineText();
Â  Â  Â  Â  Â  Â  Â  Â  setupStageContent();
Â  Â  Â  Â  Â  Â  Â  Â  resolve();
Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  await drawHeadlineText();
Â  Â  Â  Â  Â  Â  setupStageContent();
Â  Â  Â  Â  Â  Â  resolve();
Â  Â  Â  Â  }
Â  Â  });
}     
	  function transitionToStage(newIndex) {
Â  Â  if (isTransitioning || isLessonLoading || !lessonStages.length) return;
    
    // All feedback is now hidden either by the 'A' key or by advancing a stage.
    hideOnCanvasFeedback();

    selectedMcqIndex = null;
    if (isReplayActive) closeReplayPlayer();
Â  Â  if (isThelobookActive) closeThelobook(true);
Â  Â  if (isPageGridVisible) closePageGridView();

Â  Â  if (currentReplayAnimationId) { cancelAnimationFrame(currentReplayAnimationId); currentReplayAnimationId = null; }
Â  Â  if (currentStageAudio && !currentStageAudio.paused) { currentStageAudio.pause(); currentStageAudio.onloadedmetadata = null; currentStageAudio.onended = null; }
Â  Â  isMediaScrubbingActive = false; currentStageDrawingData = null; currentStageTotalDuration = 0; internalPlaybackTime = 0; lastFrameTimestampForManualAdvance = 0;
Â  Â  if (stageProgressBarContainer) stageProgressBarContainer.classList.remove('visible');
Â  Â  if (stageProgressFill) stageProgressFill.style.width = '0%';

Â  Â  if (newIndex < 0 || newIndex >= lessonStages.length) {
Â  Â  Â  Â  if (newIndex >= lessonStages.length) {
Â  Â  Â  Â  Â  Â  displayLessonComplete();
Â  Â  Â  Â  }
Â  Â  Â  Â  return;
Â  Â  }
Â  Â  isTransitioning = true;
Â  Â  backgroundCanvas.classList.add('fade-out');
Â  Â  if (replayCanvas) replayCanvas.classList.add('fade-out');
Â  Â  if (mcqOptionsContainer) mcqOptionsContainer.style.opacity = 0;

Â  Â  const fadeDuration = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--fade-duration') || '0.3') * 1000;
Â  Â Â 
Â  Â  setTimeout(() => {
Â  Â  Â  Â  currentStageIndex = newIndex;
Â  Â  Â  Â  renderStageUI(currentStageIndex, false).then(() => {
Â  Â  Â  Â  Â  Â  backgroundCanvas.classList.remove('fade-out');
Â  Â  Â  Â  Â  Â  if (replayCanvas) replayCanvas.classList.remove('fade-out');
Â  Â  Â  Â  Â  Â  isTransitioning = false;
Â  Â  Â  Â  });
Â  Â  }, fadeDuration);
}
    function nextStage() { transitionToStage(currentStageIndex + 1); }
    function previousStage() { if (currentStageIndex > 0 && !isThelobookActive && !isPageGridVisible) transitionToStage(currentStageIndex - 1); }
    // FULL UPDATED FUNCTION
async function displayLessonComplete() {
Â  Â  isTransitioning = true;
Â  Â  const TXT = getCurrentUIText();

Â  Â  // --- FIX: START THE UI TRANSITION IMMEDIATELY ---
Â  Â  if (isThelobookActive) closeThelobook(false);
Â  Â  if (isPageGridVisible) closePageGridView();
Â  Â  backgroundCanvas.classList.add('fade-out');
Â  Â  if (replayCanvas) replayCanvas.classList.add('fade-out');
Â  Â  if (mcqOptionsContainer) mcqOptionsContainer.style.display = 'none';
Â  Â  if (currentReplayAnimationId) {
Â  Â  Â  Â  cancelAnimationFrame(currentReplayAnimationId);
Â  Â  Â  Â  currentReplayAnimationId = null;
Â  Â  }
Â  Â  if (currentStageAudio && !currentStageAudio.paused) {
Â  Â  Â  Â  currentStageAudio.pause();
Â  Â  Â  Â  currentStageAudio.currentTime = 0;
Â  Â  }
Â  Â  isMediaScrubbingActive = false;
Â  Â  if (stageProgressBarContainer) stageProgressBarContainer.classList.remove('visible');

Â  Â  setTimeout(() => {
Â  Â  Â  Â  const cssWidth = backgroundCanvas.width / devicePixelRatio;
Â  Â  Â  Â  const cssHeight = backgroundCanvas.height / devicePixelRatio;
Â  Â  Â  Â  bgCtx.clearRect(0, 0, cssWidth, cssHeight);
Â  Â  Â  Â  const fontFamily = currentLang === 'en' ? "'Manrope', system-ui, sans-serif" : "'Montserrat Arm', system-ui, sans-serif";
Â  Â  Â  Â  bgCtx.font = `bold 24px ${fontFamily}`;
Â  Â  Â  Â  bgCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--success-green').trim();
Â  Â  Â  Â  bgCtx.textAlign = 'center';
Â  Â  Â  Â  bgCtx.textBaseline = 'middle';
Â  Â  Â  Â  bgCtx.fillText(TXT.lessonComplete, cssWidth / 2, cssHeight / 3);
Â  Â  Â  Â  clearUserCanvas();
Â  Â  Â  Â  if (replayCtx) replayCtx.clearRect(0, 0, replayCanvas.width / devicePixelRatio, replayCanvas.height / devicePixelRatio);

Â  Â  Â  Â  if (nextCheckBtn) nextCheckBtn.style.display = 'none';
Â  Â  Â  Â  if (prevBtn) prevBtn.style.display = 'none';
Â  Â  Â  Â  if (clearBtn) clearBtn.style.display = 'none';
Â  Â  Â  Â  if (thelobookBtn) thelobookBtn.style.display = 'none';
Â  Â  Â  Â  if (dashboardBtn) {
Â  Â  Â  Â  Â  Â  dashboardBtn.innerHTML = TXT.viewDashboard;
Â  Â  Â  Â  Â  Â  dashboardBtn.classList.add('visible');
Â  Â  Â  Â  }

Â  Â  Â  Â  if (colorIndicator) colorIndicator.style.display = 'none';
Â  Â  Â  Â  addChatMessage('AI', `ğŸ‰ ${TXT.lessonComplete}`);
Â  Â  Â  Â Â 
Â  Â  Â  Â  backgroundCanvas.classList.remove('fade-out');
Â  Â  Â  Â  if (replayCanvas) replayCanvas.classList.remove('fade-out');
Â  Â  Â  Â  isTransitioning = false;
Â  Â  }, parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--fade-duration') || '0.3') * 1000);

Â  Â  // --- DATABASE OPERATIONS IN THE BACKGROUND ---
Â  Â  const user = auth.currentUser;
Â  Â  const urlParams = new URLSearchParams(window.location.search);
Â  Â  const lessonFileName = urlParams.get('lessonFile');

Â  Â  if (user && lessonFileName) {
Â  Â  Â  Â  // Log analytics
Â  Â  Â  Â  if (lessonStartTime) {
Â  Â  Â  Â  Â  Â  const timeToCompleteSeconds = Math.round((Date.now() - lessonStartTime) / 1000);
Â  Â  Â  Â  Â  Â  db.collection("analytics_events").add({
Â  Â  Â  Â  Â  Â  Â  Â  type: "lesson_completed",
Â  Â  Â  Â  Â  Â  Â  Â  userId: user.uid,
Â  Â  Â  Â  Â  Â  Â  Â  lessonId: lessonFileName.replace('.json', ''),
Â  Â  Â  Â  Â  Â  Â  Â  courseId: "sat-math-prep",
Â  Â  Â  Â  Â  Â  Â  Â  timeToCompleteSeconds: timeToCompleteSeconds,
Â  Â  Â  Â  Â  Â  Â  Â  sessionScore: sessionPoints,
Â  Â  Â  Â  Â  Â  Â  Â  timestamp: firebase.firestore.FieldValue.serverTimestamp()
Â  Â  Â  Â  Â  Â  }).catch(e => console.error("Analytics event logging error:", e));
Â  Â  Â  Â  Â  Â  lessonStartTime = null;
Â  Â  Â  Â  }

Â  Â  Â  Â  // Update progress and streak
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  const topicId = lessonFileName.replace('.json', '');
Â  Â  Â  Â  Â  Â  const studentDocRef = db.collection('thelo-students').doc(user.uid);
Â  Â  Â  Â  Â  Â  const progressDocRef = studentDocRef.collection('progress').doc(topicId);
Â  Â  Â  Â  Â  Â  const progressDoc = await progressDocRef.get();
Â  Â  Â  Â  Â  Â  const wasAlreadyCompleted = progressDoc.exists;

Â  Â  Â  Â  Â  Â  await updateStudentProgress(user.uid, topicId, {
Â  Â  Â  Â  Â  Â  Â  Â  status: 'completed',
Â  Â  Â  Â  Â  Â  Â  Â  score: sessionPoints
Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  if (!wasAlreadyCompleted) {
Â  Â  Â  Â  Â  Â  Â  Â  await studentDocRef.update({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lessonsCompleted: firebase.firestore.FieldValue.increment(1)
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  await updateWeeklyStreak();

Â  Â  Â  Â  } catch (error) {
Â  Â  Â  Â  Â  Â  console.error("Error finalizing lesson completion in background:", error);
Â  Â  Â  Â  }
Â  Â  }
}		
	 /**
 * Handles clicks on the main "Next" / "Check" / "Got It" button.
 * This function is now the central point for evaluating all interactive stages.
 */
/**
Â * Handles clicks on the main "Next" / "Check" / "Got It" button.
Â * This function is now the central point for evaluating all interactive stages.
Â */
/* ------------------------------------------------------------------
   REPLACE your current handleNextCheckClick() with everything below
   ------------------------------------------------------------------ */
function handleNextCheckClick() {
Â  // Guard clauses Â­â€“ block interaction during transitions or modals
Â  if (
Â  Â  isTransitioning ||
Â  Â  isLessonLoading ||
Â  Â  isThelobookActive ||
Â  Â  isPageGridVisible
Â  ) return;

Â  const TXT = getCurrentUIText();

Â  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 1. â€œStartâ€ button â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
Â  if (currentStageIndex === -1 && lessonStages.length > 0) {
    // FIX: Explicitly hide the welcome message when starting the lesson
    hideOnCanvasFeedback(); 
Â  Â  lessonStartTime = Date.now();

Â  Â  // analytics
Â  Â  const userÂ  Â  Â  Â = auth.currentUser;
Â  Â  const lessonFile = new URLSearchParams(location.search).get('lessonFile');
Â  Â  if (user && lessonFile) {
Â  Â  Â  db.collection('analytics_events').add({
Â  Â  Â  Â  typeÂ  Â  Â  : 'lesson_started',
Â  Â  Â  Â  userIdÂ  Â  : user.uid,
Â  Â  Â  Â  lessonIdÂ  : lessonFile.replace('.json', ''),
Â  Â  Â  Â  courseIdÂ  : 'sat-math-prep',
Â  Â  Â  Â  timestamp : firebase.firestore.FieldValue.serverTimestamp()
Â  Â  Â  });
Â  Â  }
Â  Â  transitionToStage(0);
Â  Â  return;
Â  }

Â  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 2. MCQ stages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
Â  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 2. MCQ stages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 2. MCQ stages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    const mcq = currentStageData.optionsQuiz;
    const isMCQStage =
        currentStageData.type === 'explanation_with_mcq' &&
        mcq &&
        Array.isArray(mcq.choices) &&
        mcq.choices.length > 0;

    if (isMCQStage) {
        document.body.classList.remove('mcq-active'); // Always remove class on check

        if (nextCheckBtn.textContent === TXT.next || nextCheckBtn.textContent === TXT.gotIt) {
            nextStage();
            return;
        }

        if (selectedMcqIndex === null) { return; } // Should not happen in keyboard mode

        const buttons = mcqOptionsContainer.querySelectorAll('.mcq-option-btn');
        nextCheckBtn.disabled = true;

        const correct = selectedMcqIndex === mcq.correctIndex;
        const selectedButton = buttons[selectedMcqIndex];

        if (correct) {
            selectedButton.classList.remove('selected');
            selectedButton.classList.add('correct');
            addChatMessage('AI', `ğŸ‰ ${mcq.feedbackCorrect || TXT.correct}`);
            playRandomFeedback('approve');

            nextCheckBtn.textContent = TXT.next;
            nextCheckBtn.classList.add('correct');
            nextCheckBtn.disabled = false;

        } else { // Incorrect answer
            selectedButton.classList.remove('selected');
            selectedButton.classList.add('incorrect');
            if (buttons[mcq.correctIndex]) {
                buttons[mcq.correctIndex].classList.add('correct-answer-shown');
            }
            addChatMessage('AI', `ğŸ¤” ${mcq.feedbackIncorrect || TXT.incorrect}`);
            playRandomFeedback('disapprove');

            setTimeout(() => {
                buttons.forEach(b => {
                    b.classList.remove('incorrect', 'correct-answer-shown');
                });
                document.body.classList.add('mcq-active'); // Re-enable keyboard mode
                updateMcqSelectionVisuals(0); // Reset selection to first option
                nextCheckBtn.disabled = false; // Re-enable check button for another try
            }, 2000);
        }
        return;
    }
Â  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 3. â€œGot Itâ€ / info stages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
Â  if (nextCheckBtn.textContent === TXT.gotIt) {
Â  Â  if (!stagesWithPointsAwarded.has(currentStageIndex)) {
Â  Â  Â  stagesWithPointsAwarded.add(currentStageIndex);
Â  Â  Â  stopCurrentStageAudio();
Â  Â  Â  const pts = Math.floor(Math.random() * 4) + 6;
Â  Â  Â  userPointsÂ  Â  Â += pts;
Â  Â  Â  sessionPointsÂ  += pts;
Â  Â  Â  updateUserPointsInFirestore(pts);
Â  Â  Â  updatePointsDisplay();
Â  Â  Â  addChatMessage('AI', formatAIMessage('pointsGained', { points: pts }));
Â  Â  Â  if (window.userInteracted) {
Â  Â  Â  Â  gotItSoundPlayer.currentTime = 0;
Â  Â  Â  Â  gotItSoundPlayer.play().catch(() => {});
Â  Â  Â  }
Â  Â  }
Â  Â  if (isReplayActive) closeReplayPlayer();
Â  Â  nextStage();
Â  Â  return;
Â  }

Â  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 4. Question stages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
Â  if (currentStageData.type === 'question_handwriting') {
Â  Â  checkHandwritingAnswer();
Â  } else if (currentStageData.type === 'question_math_solution') {
Â  Â  checkMathDrawing();
Â  } else {
Â  Â  nextStage();
Â  }
}
	  /* ------------------------------------------------------------------ */

	  function addChatImage(url) {
    const wrapper = Object.assign(document.createElement('div'), {
        className: 'ai-message chat-image-container'
    });

    const img = Object.assign(document.createElement('img'), {
        className: 'chat-image',
        src: url,
        alt: 'Lesson Content Image',
        style: 'opacity:0'
    });

    wrapper.appendChild(img);
    chatArea.appendChild(wrapper);
    
    // Calculate target scroll position
    const targetScrollTop = wrapper.offsetTop - chatArea.offsetTop;
    
    img.onload = () => {
        // Fade in the image
        img.style.transition = 'opacity .4s';
        img.style.opacity = '1';
        
        // Smooth scroll to position
        chatArea.scrollTo({
        top: targetScrollTop,
        behavior: 'smooth'
        });
    };
    }
    // Find your addChatMessage function (around line 1774 or search for 'function addChatMessage(sender, rawMsg)')
// REPLACE your entire addChatMessage function with this one
/**
 * Finds simple math notations in a string and converts them to KaTeX HTML.
 * Supports:
 * - `sqrt(content)` -> rendered square root
 * - `base^exponent` -> rendered power
 * - `(base)^exponent` -> rendered power with parentheses
 * @param {string} text - The input string, potentially containing math.
 * @returns {string} An HTML string with math portions rendered by KaTeX.
 */
function parseAndRenderMath(text) {
    if (!text || typeof text !== 'string') return '';

    // This regex looks for one of three patterns using the OR | operator:
    // 1. The full "sqrt(content)" expression, capturing the "content".
    // 2. A parenthesized "(base)" followed by "^exponent", capturing "base" and "exponent".
    // 3. A simple "base" word followed by "^exponent", capturing "base" and "exponent".
    const mathRegex = /(\bsqrt\(([^)]+)\))|(\(([^)]+)\)\^(\w+))|(\b(\w+)\^(\w+)\b)/g;

    return text.replace(mathRegex, (match, sqrtFull, sqrtContent, powerParenFull, powerParenBase, powerParenExp, powerWordFull, powerWordBase, powerWordExp) => {
        try {
            // Case 1: Matched sqrt(content)
            if (sqrtFull) {
                return katex.renderToString(`\\sqrt{${sqrtContent}}`, { throwOnError: false, displayMode: false });
            }
            // Case 2: Matched (base)^exponent
            if (powerParenFull) {
                return katex.renderToString(`{(${powerParenBase})}^{${powerParenExp}}`, { throwOnError: false, displayMode: false });
            }
            // Case 3: Matched base^exponent
            if (powerWordFull) {
                return katex.renderToString(`${powerWordBase}^{${powerWordExp}}`, { throwOnError: false, displayMode: false });
            }
        } catch (e) {
            console.warn("KaTeX rendering failed for:", match, e);
            return match; // In case of error, fall back to the original text.
        }
        return match; // Should not be reached, but good practice.
    });
}
// REPLACE your entire addChatMessage function with this one

function addChatMessage(sender, rawMsg) {
Â  Â  if (isTabletMode) {
Â  Â  Â  Â  // Tablet toast logic remains the same
Â  Â  Â  Â  const isImportant = rawMsg.includes('ğŸ‰') || rawMsg.includes('ğŸ¤”') || rawMsg.includes('âš ï¸');
Â  Â  Â  Â  showToast(rawMsg, isImportant ? 5000 : 3500);
	    showFeedback(rawMsg, 3500);
Â  Â  } else {
Â  Â  Â  Â  // Desktop/mobile terminal chat
Â  Â  Â  Â  const chatArea = document.getElementById('chat');
Â  Â  Â  Â  if (!chatArea) return;

Â  Â  Â  Â  const msg = rawMsg.replace(/^[\p{Extended_Pictographic}\uFE0F]+\s*/u, '');
Â  Â  Â  Â  const TXT = getCurrentUIText();
Â  Â  Â  Â  let emoji = 'ğŸ«§';

Â  Â  Â  Â  const isPoints = /points? gained/i.test(msg) || (TXT.pointsGained && msg.includes(TXT.pointsGained.split("{")[0].trim()));
Â  Â  Â  Â  const isWrong = msg.includes('Not quite') || (TXT.incorrect && msg.includes(TXT.incorrect)) || msg.includes('Incorrect') || msg.includes('Wrong');
Â  Â  Â  Â  const isCorrect = !isWrong && ((TXT.correct && msg.includes(TXT.correct)) || /^correct/i.test(msg));
Â  Â  Â  Â  const isWarning = msg.includes('âš ï¸') || (TXT.error && msg.includes(TXT.error));
Â  Â  Â  Â  const isWelcome = TXT.welcome && msg.includes(TXT.welcome);
Â  Â  Â  Â  const isChecking = TXT.checkingAI && msg.includes(TXT.checkingAI.split('<')[0]);

Â  Â  Â  Â  if(isWrong) emoji = 'ğŸ¤”';
Â  Â  Â  Â  else if (isCorrect || isPoints) emoji = 'ğŸ‰';
Â  Â  Â  Â  else if (isWarning || msg.includes('ğŸ›‘')) emoji = 'âš ï¸';
Â  Â  Â  Â  else if (isWelcome) emoji = 'ğŸ‘‹';
Â  Â  Â  Â  else if (isChecking) emoji = 'â³';
        
        // ======================= THE CHANGE IS HERE =======================
        // Use our new function to parse the message for math before displaying it.
        const finalHTML = parseAndRenderMath(msg);
        // ================================================================

Â  Â  Â  Â  const bubble = document.createElement('div');
Â  Â  Â  Â  bubble.className = 'ai-message'; // Starts with opacity: 0
        
        // And now we use the processed HTML instead of the raw message.
Â  Â  Â  Â  bubble.innerHTML = `<span class="emoji" role="img" aria-label="icon">${emoji}</span> <span>${finalHTML}</span>`;
Â  Â  Â  Â  chatArea.appendChild(bubble);

Â  Â  Â  Â  // Force the browser to paint the initial state before animating
Â  Â  Â  Â  requestAnimationFrame(() => {
Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  bubble.classList.add('show');
Â  Â  Â  Â  Â  Â  Â  Â  chatArea.scrollTo({ top: chatArea.scrollHeight, behavior: 'smooth' });
Â  Â  Â  Â  Â  Â  }, 10);
Â  Â  Â  Â  });
Â  Â  }
}
	  /**
 * Creates or updates a student's progress for a specific topic in Firestore.
 * @param {string} userId - The authenticated user's UID.
 * @param {string} topicId - The unique ID for the lesson (e.g., 'sat-linear-equations-one-var').
 * @param {object} progressData - The data to save (e.g., { status: 'in-progress' }).
 */
async function updateStudentProgress(userId, topicId, progressData) {
  if (!userId || !topicId) {
    console.error("User ID or Topic ID is missing. Cannot save progress.");
    return;
  }
  
  // The path to the specific progress document for this user and topic.
  const progressDocRef = db.collection('thelo-students').doc(userId).collection('progress').doc(topicId);
  
  // Add a timestamp to every update.
  const dataWithTimestamp = {
    ...progressData,
    lastAttempted: firebase.firestore.FieldValue.serverTimestamp()
  };

  try {
    // Use setDoc with { merge: true } to create or update the document.
    await progressDocRef.set(dataWithTimestamp, { merge: true });
    console.log(`Progress for topic '${topicId}' updated:`, dataWithTimestamp);
  } catch (error) {
    console.error("Error updating student progress:", error);
  }
}
    function playAudio(audioElement){ return new Promise((resolve, reject) => { if (!audioElement || !(audioElement instanceof HTMLAudioElement)) { return reject(new Error("Invalid audio element")); } if (!window.userInteracted) { return resolve(); } audioElement.currentTime = 0; const playPromise = audioElement.play(); if(playPromise !== undefined) { playPromise.then(resolve).catch(error => { reject(error); }); } else { resolve(); } }); }
    function playRandomFeedback(soundType){
        if (!window.userInteracted || isThelobookActive || isPageGridVisible) return;
        let soundArray;
        if (currentLang === 'en') soundArray = (soundType === 'approve') ? approveSounds_en : disapproveSounds_en;
        else soundArray = (soundType === 'approve') ? approveSounds_hy : disapproveSounds_hy;
        if (soundArray && soundArray.length > 0) {
            const availableSounds = soundArray.filter(sound => sound instanceof HTMLAudioElement);
            if (availableSounds.length > 0) {
                const randomIndex = Math.floor(Math.random() * availableSounds.length);
                playAudio(availableSounds[randomIndex]).catch(e => {});
            }
        }
    }
    function formatAIMessage(key, replacements = {}){
        const TXT = getCurrentUIText(); let message = TXT[key] || `Missing text [${currentLang}]: ${key}`;
        const escapeHTML = (str) => String(str).replace(/[&<>"']/g, match => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[match]));
        for (const placeholder in replacements) {
            const replacementValue = replacements[placeholder] !== undefined && replacements[placeholder] !== null ? String(replacements[placeholder]) : '';
            message = message.replace(new RegExp(`{${placeholder}}`, 'g'), `<strong>${escapeHTML(replacementValue)}</strong>`);
        }
        return message;
    }
          /* ========== NEW: Toast Notification Logic ========== */
function showToast(rawMsg, duration = 4000) {
    const container = document.getElementById('toast-container');
    if (!container) return;

    // This part classifies the message to show the right icon
    const msg = rawMsg.replace(/^[\p{Extended_Pictographic}\uFE0F]+\s*/u, '');
    const TXT = getCurrentUIText();
    let emoji = 'ğŸ«§';
    let type = 'info'; 

    const isPoints  = /points? gained/i.test(msg) || (TXT.pointsGained && msg.includes(TXT.pointsGained.split("{")[0].trim()));
    const isWrong   = msg.includes('Not quite') || (TXT.incorrect && msg.includes(TXT.incorrect)) || msg.includes('Incorrect') || msg.includes('Wrong');
    const isCorrect = !isWrong && ((TXT.correct && msg.includes(TXT.correct)) || /^correct/i.test(msg));
    const isWarning = msg.includes('âš ï¸') || (TXT.error && msg.includes(TXT.error));
    const isWelcome = TXT.welcome && msg.includes(TXT.welcome);
    const isChecking = TXT.checkingAI && msg.includes(TXT.checkingAI.split('<')[0]);

    if (isWrong) { emoji = 'ğŸ¤”'; type = 'error'; }
    else if (isCorrect || isPoints) { emoji = 'ğŸ‰'; type = 'success'; }
    else if (isWarning || msg.includes('ğŸ›‘')) { emoji = 'âš ï¸'; type = 'warning'; }
    else if (isWelcome) { emoji = 'ğŸ‘‹'; }
    else if (isChecking) { emoji = 'â³'; }

    // This part creates the toast element
    const toast = document.createElement('div');
    toast.className = `toast-message`;
    toast.innerHTML = `<span class="emoji" role="img" aria-label="icon">${emoji}</span> <span>${msg}</span>`;
    
    // This is the inner function that handles removing the toast
    const removeToast = () => {
        // First, we add the 'exiting' class to trigger the CSS transition
        toast.classList.add('exiting');
        
        // ===================================================================
        // THE ONLY CHANGE IS ON THIS LINE:
        // We now listen for 'transitionend' instead of 'animationend'.
        // This tells the code to wait for our new collapse transition to finish.
        toast.addEventListener('transitionend', () => {
            toast.remove();
        }, { once: true });
        // ===================================================================
    };

    // This sets the timer to automatically dismiss the toast
    const timeoutId = setTimeout(removeToast, duration);

    // This lets the user click the toast to dismiss it early
    toast.addEventListener('click', () => {
        clearTimeout(timeoutId);
        removeToast();
    }, { once: true });

    // This adds the toast to the page
    container.appendChild(toast);

    // This triggers the entry animation
    requestAnimationFrame(() => {
        toast.classList.add('show');
    });
}
	  // Add this new function somewhere in your script, e.g., after the toast/tablet functions

// REPLACE your existing showFeedback function with this DEBUGGING version.

/**
 * Pops up a transient feedback card in the centre of the screen.
 * @param {string} rawMsg  â€“  HTML-allowed message (e.g. "ğŸ‰ <strong>Correct!</strong>")
 * @param {number} duration â€“ how long to stay visible (ms)
 */

function showOnCanvasFeedback(message, type = 'info') {
    if (!feedbackCtx) return;

    // --- Configuration ---
    const FADE_TIME = 400;
    const MAX_WIDTH_PERCENTAGE = 0.70;
    const TEXT_COLOR = '#111827';
    const FONT_FAMILY = currentLang === 'en' ? "'Manrope', system-ui, sans-serif" : "'Montserrat Arm', system-ui, sans-serif";
    const LINE_HEIGHT_MULTIPLIER = 1.2;

    let maxFontSize = 48;
    let minFontSize = 20;
    let EMOJI = '';

    if (type === 'success') {
        maxFontSize = 72;
        EMOJI = 'ğŸ‰ ';
    }

    const finalMessage = EMOJI + message;
    const canvasWidth = feedbackCanvas.width / devicePixelRatio;
    const canvasHeight = feedbackCanvas.height / devicePixelRatio;
    const maxWidth = canvasWidth * MAX_WIDTH_PERCENTAGE;

    const wrapText = (ctx, text, maxWidth) => {
        const words = text.split(' ');
        let lines = [];
        let currentLine = words[0] || '';
        for (let i = 1; i < words.length; i++) {
            const word = words[i];
            const width = ctx.measureText(currentLine + " " + word).width;
            if (width < maxWidth) {
                currentLine += " " + word;
            } else {
                lines.push(currentLine);
                currentLine = word;
            }
        }
        lines.push(currentLine);
        return lines;
    };
    
    let currentFontSize = maxFontSize;
    let lines = [];
    
    do {
        feedbackCtx.font = `900 ${currentFontSize}px ${FONT_FAMILY}`;
        lines = wrapText(feedbackCtx, finalMessage, maxWidth);
        const longestWord = finalMessage.split(' ').reduce((a, b) => a.length > b.length ? a : b, '');
        if (feedbackCtx.measureText(longestWord).width > maxWidth) {
             currentFontSize--;
        } else {
            break;
        }
    } while (currentFontSize > minFontSize)
    
    feedbackCtx.font = `900 ${currentFontSize}px ${FONT_FAMILY}`;
    lines = wrapText(feedbackCtx, finalMessage, maxWidth);
    
    const lineHeight = currentFontSize * LINE_HEIGHT_MULTIPLIER;
    const totalTextHeight = lines.length * lineHeight;
    let startY = (canvasHeight / 2) - (totalTextHeight / 2);

    // FIX: Store the font family along with other details
    lastFeedbackDetails = { lines, lineHeight, startY, fontSize: currentFontSize, fontFamily: FONT_FAMILY };

    if (feedbackAnimationId) cancelAnimationFrame(feedbackAnimationId);
    let startTime = null;
    
    const animate = (timestamp) => {
        if (!startTime) startTime = timestamp;
        const elapsed = timestamp - startTime;
        feedbackCtx.clearRect(0, 0, canvasWidth, canvasHeight);
        let currentOpacity = (elapsed < FADE_TIME) ? (elapsed / FADE_TIME) : 1.0;
        feedbackCtx.globalAlpha = currentOpacity;
        feedbackCtx.font = `900 ${currentFontSize}px ${FONT_FAMILY}`;
        feedbackCtx.fillStyle = TEXT_COLOR;
        feedbackCtx.textAlign = 'center';
        feedbackCtx.textBaseline = 'top';
        for (let i = 0; i < lines.length; i++) {
            feedbackCtx.fillText(lines[i], canvasWidth / 2, startY + (i * lineHeight));
        }
        feedbackCtx.globalAlpha = 1.0;
        if (elapsed < FADE_TIME) {
            feedbackAnimationId = requestAnimationFrame(animate);
        } else {
            cancelAnimationFrame(feedbackAnimationId);
            feedbackAnimationId = null;
        }
    };
    
    feedbackAnimationId = requestAnimationFrame(animate);
}
function hideOnCanvasFeedback() {
    if (!feedbackCtx || !lastFeedbackDetails) return;

    const FADE_TIME = 400;
    const canvasWidth = feedbackCanvas.width / devicePixelRatio;
    const canvasHeight = feedbackCanvas.height / devicePixelRatio;
    const TEXT_COLOR = '#111827';
    
    // FIX: Retrieve the exact font family that was used to show the message
    const { lines, lineHeight, startY, fontSize, fontFamily } = lastFeedbackDetails;

    if (feedbackAnimationId) cancelAnimationFrame(feedbackAnimationId);
    let startTime = null;

    const animateFadeOut = (timestamp) => {
        if (!startTime) startTime = timestamp;
        const elapsed = timestamp - startTime;
        
        feedbackCtx.clearRect(0, 0, canvasWidth, canvasHeight);
        
        let currentOpacity = 1.0;
        if (elapsed < FADE_TIME) {
            currentOpacity = 1.0 - (elapsed / FADE_TIME);
        } else {
            lastFeedbackDetails = null;
            cancelAnimationFrame(feedbackAnimationId);
            feedbackAnimationId = null;
            return;
        }

        feedbackCtx.globalAlpha = currentOpacity;
        feedbackCtx.font = `900 ${fontSize}px ${fontFamily}`; // Use the stored font family
        feedbackCtx.fillStyle = TEXT_COLOR;
        feedbackCtx.textAlign = 'center';
        feedbackCtx.textBaseline = 'top';
        
        for (let i = 0; i < lines.length; i++) {
            feedbackCtx.fillText(lines[i], canvasWidth / 2, startY + (i * lineHeight));
        }

        feedbackCtx.globalAlpha = 1.0;

        feedbackAnimationId = requestAnimationFrame(animateFadeOut);
    };

    feedbackAnimationId = requestAnimationFrame(animateFadeOut);
}
	  function checkTabletMode() {
    // This media query should match the one in your CSS
    const tabletQuery = window.matchMedia('(min-width: 769px) and (max-width: 1200px) and (pointer: coarse)');
    const landscapeQuery = window.matchMedia('(min-width: 769px) and (max-width: 1200px) and (min-height: 500px)');

    isTabletMode = tabletQuery.matches || landscapeQuery.matches;
    console.log("Tablet Mode:", isTabletMode);
}
	function updateUserPointsInFirestore(pointsToAdd) {
        const user = auth.currentUser;
        if (!user) {
            console.warn("Attempted to update points for a non-logged-in user.");
            return;
        }

        const userDocRef = db.collection('thelo-students').doc(user.uid);

        // Use FieldValue.increment for atomic updates to prevent race conditions
        return userDocRef.update({
            points: firebase.firestore.FieldValue.increment(pointsToAdd)
        }).catch(error => {
            console.error("Error updating points in Firestore: ", error);
        });
    }
	/* ===== ADD THIS FUNCTION: The Main Streak Logic ======================== */
async function updateWeeklyStreak() {
    const user = auth.currentUser;
    if (!user) return; // Only run for logged-in users

    const userDocRef = db.collection('thelo-students').doc(user.uid);
    
    try {
        const doc = await userDocRef.get();
        const streakData = doc.exists && doc.data().streakData ? doc.data().streakData : {
            currentStreak: 0,
            longestStreak: 0,
            lastActivityWeek: null
        };

        const thisWeekId = getISOWeekIdentifier(new Date());

        // Scenario A: Already completed a lesson this week
        if (thisWeekId === streakData.lastActivityWeek) {
            console.log("Weekly streak already secured for:", thisWeekId);
            return;
        }

        const prevWeekId = getPreviousWeekIdentifier(thisWeekId);
        let newStreakData = { ...streakData };
        let showCelebration = false;

        // Scenario B: Streak Extended!
        if (prevWeekId === streakData.lastActivityWeek) {
            newStreakData.currentStreak += 1;
            console.log(`Weekly streak extended to ${newStreakData.currentStreak} weeks!`);
            showCelebration = true;
        } 
        // Scenario C: Streak Broken, new one starts
        else {
            newStreakData.currentStreak = 1;
            console.log("New weekly streak started!");
            showCelebration = true;
        }

        // Always update the last activity and check for a new record
        newStreakData.lastActivityWeek = thisWeekId;
        if (newStreakData.currentStreak > newStreakData.longestStreak) {
            newStreakData.longestStreak = newStreakData.currentStreak;
        }

        // Save to Firestore and show the modal
        await userDocRef.set({ streakData: newStreakData }, { merge: true });
        
        if (showCelebration) {
            showStreakCelebrationModal(newStreakData.currentStreak, newStreakData.currentStreak === newStreakData.longestStreak && newStreakData.currentStreak > 1);
        }

    } catch (error) {
        console.error("Error updating weekly streak:", error);
    }
}

function showStreakCelebrationModal(streakCount, isNewRecord) {
    const modal = document.getElementById('streakModal');
    const title = document.getElementById('streakModalTitle');
    const body = document.getElementById('streakModalBody');
    const closeBtn = document.getElementById('streakModalCloseBtn');
    const confirmBtn = document.getElementById('streakModalConfirmBtn');

    title.textContent = isNewRecord ? "New Record!" : "Weekly Streak Extended!";
    body.textContent = `That's ${streakCount} week${streakCount > 1 ? 's' : ''} in a row. Amazing work!`;
    
    const hideModal = () => modal.classList.add('modal-hidden');
    
    closeBtn.onclick = hideModal;
    confirmBtn.onclick = hideModal;

    modal.classList.remove('modal-hidden');
}	
// ANALYTICS: Helper function to log handwriting check attempts
function logHandwritingAttempt(result) {
    const user = auth.currentUser;
    const urlParams = new URLSearchParams(window.location.search);
    const lessonFileName = urlParams.get('lessonFile');

    if (user && lessonFileName && currentStageData) {
        db.collection("analytics_events").add({
            type: "handwriting_check_attempt",
            userId: user.uid,
            lessonId: lessonFileName.replace('.json', ''),
            stageIndex: currentStageIndex,
            result: result, // "correct" or "incorrect"
            timestamp: firebase.firestore.FieldValue.serverTimestamp()
        });
    }
}
	async function checkHandwritingAnswer() {
Â  Â  console.log("Auth state at time of call:", isAuthReady);
Â  Â  if (!isAuthReady || !auth.currentUser) {
Â  Â  Â  Â  addChatMessage('AI', formatAIMessage('authErrorVision'));
Â  Â  Â  Â  console.error("User is not authenticated. Cannot call AI function.");
Â  Â  Â  Â  return;
Â  Â  }

Â  Â  try {
Â  Â  Â  Â  await auth.currentUser.getIdToken(true); // Refresh token to ensure validity
Â  Â  } catch (error) {
Â  Â  Â  Â  console.error("Token refresh failed:", error);
Â  Â  Â  Â  addChatMessage('AI', "Authentication error. Please try logging in again.");
Â  Â  Â  Â  return;
Â  Â  }
Â  Â Â 
Â  Â  if (isThelobookActive || isPageGridVisible || nextCheckBtn.disabled || isTransitioning) return;

Â  Â  const TXT = getCurrentUIText();
Â  Â  nextCheckBtn.disabled = true;
Â  Â  nextCheckBtn.textContent = TXT.checking;
    showOnCanvasFeedback(TXT.checking);
Â  Â Â 
Â  Â  let base64ImageData;
Â  Â  try {
Â  Â  Â  Â  const blankCanvas = document.createElement('canvas');
Â  Â  Â  Â  blankCanvas.width = canvas.width;
Â  Â  Â  Â  blankCanvas.height = canvas.height;
Â  Â  Â  Â  const imageDataUrl = captureCanvas.toDataURL('image/png');

Â  Â  Â  Â  if (imageDataUrl === blankCanvas.toDataURL()) {
Â  Â  Â  Â  Â  Â  throw new Error("BLANK_ANSWER");
Â  Â  Â  Â  }
Â  Â  Â  Â  base64ImageData = imageDataUrl;
Â  Â  } catch (error) {
Â  Â  Â  Â  addChatMessage('AI', formatAIMessage('drawActivityWarning'));
Â  Â  Â  Â  playRandomFeedback('disapprove');
Â  Â  Â  Â  nextCheckBtn.disabled = false;
Â  Â  Â  Â  nextCheckBtn.textContent = TXT.check;
Â  Â  Â  Â  return;
Â  Â  }
Â  Â Â 
Â  Â  const payload = {
Â  Â  Â  Â  imageBase64: base64ImageData,
Â  Â  Â  Â  problemText: "The user is writing a number to answer a question.",
Â  Â  Â  Â  correctAnswer: String(currentStageData.correctAnswerOcr),
Â  Â  Â  Â  customInstructions: `Analyze the user's handwritten number. The work is 'correct' ONLY IF the number in the image is clearly identifiable and matches the correct answer: ${currentStageData.correctAnswerOcr}. Otherwise, it is 'incorrect'.`,
Â  Â  Â  Â  language: currentLang
Â  Â  };

Â  Â  try {
Â  Â  Â  Â  const analyzeMathDrawing = firebase.functions().httpsCallable('analyzeMathDrawing');
Â  Â  Â  Â  const result = await analyzeMathDrawing(payload);
Â  Â  Â  Â  const { status, feedback } = result.data;
Â  Â  Â  Â Â 
        if (status === 'correct') {
            showOnCanvasFeedback(feedback, undefined, 'success');
        } else {
            showOnCanvasFeedback(feedback);
        }
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (status === 'correct') {
Â  Â  Â  Â  Â  Â  logHandwritingAttempt('correct');
Â  Â  Â  Â  Â  Â  const pointsGained = 10;
Â  Â  Â  Â  Â  Â  playRandomFeedback('approve');
Â  Â  Â  Â  Â  Â  userPoints += pointsGained;
Â  Â  Â  Â  Â  Â  sessionPoints += pointsGained;
Â  Â  Â  Â  Â  Â  updatePointsDisplay();
Â  Â  Â  Â  Â  Â  updateUserPointsInFirestore(pointsGained);
Â  Â  Â  Â  Â  Â  nextCheckBtn.classList.add('correct');
Â  Â  Â  Â  Â  Â  nextCheckBtn.textContent = TXT.correct;
Â  Â  Â  Â  Â  Â  setTimeout(nextStage, 2500);
Â  Â  Â  Â  } else {Â 
Â  Â  Â  Â  Â  Â  logHandwritingAttempt('incorrect');
Â  Â  Â  Â  Â  Â  playRandomFeedback('disapprove');
Â  Â  Â  Â  Â  Â  nextCheckBtn.classList.add('incorrect');
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.disabled = false;
Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.textContent = TXT.check;
Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.classList.remove('incorrect');
Â  Â  Â  Â  Â  Â  }, 1000);
Â  Â  Â  Â  }

Â  Â  } catch (error) {
Â  Â  Â  Â  console.error("Function call to analyzeMathDrawing failed:", error);
Â  Â  Â  Â  addChatMessage('AI', formatAIMessage('apiErrorGeneral', { errorMessage: error.message }));
Â  Â  Â  Â  playRandomFeedback('disapprove');
Â  Â  Â  Â  nextCheckBtn.disabled = false;
Â  Â  Â  Â  nextCheckBtn.textContent = TXT.check;
Â  Â  }
}
async function checkMathDrawing(isMcqContext = false) {
Â  Â  if (!auth.currentUser) {
Â  Â  Â  Â  console.error("User is not authenticated.");
Â  Â  Â  Â  addChatMessage('AI', 'âš ï¸ You must be logged in to use this feature.');
Â  Â  Â  Â  throw new Error("User not authenticated.");
Â  Â  }
Â  Â  try {
Â  Â  Â  Â  await auth.currentUser.getIdToken(true);
Â  Â  } catch (error) {
Â  Â  Â  Â  console.error("Token refresh failed:", error);
Â  Â  Â  Â  addChatMessage('AI', 'âš ï¸ Your session has expired. Please refresh and log in again.');
Â  Â  Â  Â  throw new Error("Token refresh failed.");
Â  Â  }

Â  Â  try {
Â  Â  Â  Â  const blankCanvasCheck = document.createElement('canvas');
Â  Â  Â  Â  blankCanvasCheck.width = canvas.width;
Â  Â  Â  Â  blankCanvasCheck.height = canvas.height;
Â  Â  Â  Â  if (canvas.toDataURL() === blankCanvasCheck.toDataURL()) {
Â  Â  Â  Â  Â  Â  addChatMessage('AI', "I can't check your work because nothing has been drawn yet. Please try solving the problem on the whiteboard first.");
Â  Â  Â  Â  Â  Â  throw new Error("No drawing found on canvas.");
Â  Â  Â  Â  }
Â  Â  } catch (e) {
Â  Â  Â  Â  console.error("Blank canvas check failed:", e.message);
Â  Â  Â  Â  throw e;
Â  Â  }

Â  Â  const TXT = getCurrentUIText();
Â  Â  nextCheckBtn.disabled = true;
Â  Â  nextCheckBtn.textContent = TXT.checking;
Â  Â Â 
Â  Â  await new Promise(resolve => setTimeout(resolve, 100));
Â  Â Â 
Â  Â  try {
Â  Â  Â  Â  let imageBase64;
Â  Â  Â  Â  if (isMcqContext) {
Â  Â  Â  Â  Â  Â  imageBase64 = canvas.toDataURL("image/png");
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  const compositeCanvas = document.createElement('canvas');
Â  Â  Â  Â  Â  Â  compositeCanvas.width = canvas.width;
Â  Â  Â  Â  Â  Â  compositeCanvas.height = canvas.height;
Â  Â  Â  Â  Â  Â  const compositeCtx = compositeCanvas.getContext('2d');
Â  Â  Â  Â  Â  Â  compositeCtx.drawImage(backgroundCanvas, 0, 0);
Â  Â  Â  Â  Â  Â  compositeCtx.drawImage(canvas, 0, 0);
Â  Â  Â  Â  Â  Â  imageBase64 = compositeCanvas.toDataURL("image/png");
Â  Â  Â  Â  }

Â  Â  Â  Â  const payload = {
Â  Â  Â  Â  Â  Â  imageBase64: imageBase64,
Â  Â  Â  Â  Â  Â  problemText: currentStageData.problemText || "No problem text provided.",
Â  Â  Â  Â  Â  Â  correctAnswer: currentStageData.correctAnswer || "No correct answer provided.",
Â  Â  Â  Â  Â  Â  solutionSteps: currentStageData.solutionSteps || "",
Â  Â  Â  Â  Â  Â  customInstructions: currentStageData.customInstructions || "",
Â  Â  Â  Â  Â  Â  language: currentLang
Â  Â  Â  Â  };

Â  Â  Â  Â  const analyzeMathDrawing = firebase.functions().httpsCallable('analyzeMathDrawing');
Â  Â  Â  Â  const result = await analyzeMathDrawing(payload);
Â  Â  Â  Â  const { status, feedback } = result.data;
	
        if (status === 'correct') {
            showOnCanvasFeedback(feedback, undefined, 'success');
        } else {
            showOnCanvasFeedback(feedback);
        }

Â  Â  Â  Â  if (status === 'correct') {
Â  Â  Â  Â  Â  Â  playRandomFeedback('approve');
Â  Â  Â  Â  Â  Â  nextCheckBtn.classList.add('correct');
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  const pointsGained = 15;
Â  Â  Â  Â  Â  Â  userPoints += pointsGained;
Â  Â  Â  Â  Â  Â  sessionPoints += pointsGained;
Â  Â  Â  Â  Â  Â  updatePointsDisplay();
Â  Â  Â  Â  Â  Â  updateUserPointsInFirestore(pointsGained);

Â  Â  Â  Â  Â  Â  if (currentStageData.type === 'question_math_solution') {
Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.textContent = TXT.gotIt;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  nextCheckBtn.disabled = false;

Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  playRandomFeedback('disapprove');
Â  Â  Â  Â  Â  Â  nextCheckBtn.classList.add('incorrect');
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.disabled = false;
Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.textContent = TXT.check;
Â  Â  Â  Â  Â  Â  Â  Â  nextCheckBtn.classList.remove('incorrect');
Â  Â  Â  Â  Â  Â  }, 2000);
Â  Â  Â  Â  }

Â  Â  } catch (error) {
Â  Â  Â  Â  console.error("Math analysis failed:", error);
Â  Â  Â  Â  addChatMessage('AI', `âš ï¸ An error occurred during analysis: ${error.message}`);
Â  Â  Â  Â  playRandomFeedback('disapprove');
Â  Â  Â  Â Â 
Â  Â  Â  Â  nextCheckBtn.disabled = false;
Â  Â  Â  Â  nextCheckBtn.textContent = TXT.check;
Â  Â  Â  Â  nextCheckBtn.classList.remove('incorrect');
Â  Â  }
}
	    /* ========== THELOBOOK FUNCTIONALITY ========== */
        function updateThelobookPageControls() {
        const TXT = getCurrentUIText();
        const totalPages = Math.max(1, thelobookPages.length); // Ensure at least 1 for display

        if (thelobookPageIndicatorEl && TXT && TXT.thelobookPageIndicator) {
            thelobookPageIndicatorEl.textContent = TXT.thelobookPageIndicator
                .replace('{currentPage}', currentThelobookPageIndex + 1)
                .replace('{totalPages}', totalPages);
        }

        // Disable previous/next page buttons if at bounds or animating
        if (thelobookPrevPageBtn) thelobookPrevPageBtn.disabled = (currentThelobookPageIndex === 0 || isPageSwitchingAnimation);
        if (thelobookNextPageBtn) thelobookNextPageBtn.disabled = (currentThelobookPageIndex >= totalPages - 1 || isPageSwitchingAnimation);

        // Disable Add Page button if limit is reached (32 pages) or animating
        if (thelobookAddPageBtn) {
            thelobookAddPageBtn.disabled = (thelobookPages.length >= PAGES_PER_GRID_BATCH || isPageSwitchingAnimation);
        }

        // Disable eraser/pages button if animating
        if (thelobookEraserBtn) thelobookEraserBtn.disabled = isPageSwitchingAnimation;
        if (thelobookPagesBtn) thelobookPagesBtn.disabled = isPageSwitchingAnimation;
    }
    function saveCurrentThelobookPageDrawing() {
        if (!isThelobookActive || isPageSwitchingAnimation || !thelobookCtx || !thelobookCanvas || thelobookCanvas.width === 0 || thelobookCanvas.height === 0) {
            // Optional: Log why saving was skipped
            // console.warn("Save Thelobook: Conditions not met or canvas zero size", {isThelobookActive, isPageSwitchingAnimation, hasCtx: !!thelobookCtx, hasCanvas: !!thelobookCanvas, cW: thelobookCanvas?.width, cH: thelobookCanvas?.height });
            return;
        }
        try {
            if (currentThelobookPageIndex < 0) currentThelobookPageIndex = 0;
            while (thelobookPages.length <= currentThelobookPageIndex) {
                thelobookPages.push(null);
            }
            // THE FIX IS HERE: Remove division by devicePixelRatio
            thelobookPages[currentThelobookPageIndex] = thelobookCtx.getImageData(0, 0, thelobookCanvas.width, thelobookCanvas.height);
            // console.log("Saved Thelobook page", currentThelobookPageIndex, "with bitmap dimensions:", thelobookCanvas.width, "x", thelobookCanvas.height);
        } catch (e) {
            console.error("Error saving Thelobook page:", e);
            // Add more details if error occurs
            // console.error("Canvas details at error: attr W/H", thelobookCanvas?.width, thelobookCanvas?.height, "style W/H", thelobookCanvas?.style.width, thelobookCanvas?.style.height, "DPR", devicePixelRatio);
        }
    }

    function loadThelobookPageDrawing(pageIndex) {
        if (thelobookCtx) {
            thelobookCtx.clearRect(0, 0, thelobookCanvas.width / devicePixelRatio, thelobookCanvas.height / devicePixelRatio);
            if (pageIndex >= 0 && pageIndex < thelobookPages.length && thelobookPages[pageIndex]) {
                try { thelobookCtx.putImageData(thelobookPages[pageIndex], 0, 0); }
                catch (e) { console.error("Error loading Thelobook page data:", e); }
            }
        }
        currentThelobookPageIndex = pageIndex;
        updateThelobookPageControls();
    }

    function addThelobookNewPage() {
        // Check if page creation limit is reached (PAGES_PER_GRID_BATCH is 32)
        if (thelobookPages.length >= PAGES_PER_GRID_BATCH) {
            const TXT = getCurrentUIText();
            addChatMessage('AI', `âš ï¸ ${TXT.error}: Maximum of ${PAGES_PER_GRID_BATCH} pages allowed.`); // Provide user feedback
            return; // Stop function execution
        }

        if (isPageSwitchingAnimation) return; // Check if already switching
        saveCurrentThelobookPageDrawing(); // Save current page first
        thelobookPages.push(null); // Add a new blank page placeholder
        currentThelobookPageIndex = thelobookPages.length - 1; // Move to the new page
        loadThelobookPageDrawing(currentThelobookPageIndex); // Load the (blank) new page
        updateThelobookPageControls(); // Ensure controls are updated after adding a page
    }

    function changeThelobookPageSimple(direction) {
        if (isPageSwitchingAnimation) return; // Prevent re-entrant calls

        const oldPageIndex = currentThelobookPageIndex;
        let newPageIndex = currentThelobookPageIndex + direction;
        const totalPages = Math.max(1, thelobookPages.length);

        // Bounds checking for newPageIndex
        if (newPageIndex < 0) newPageIndex = 0;
        if (newPageIndex >= totalPages) newPageIndex = totalPages - 1;

        if (oldPageIndex !== newPageIndex) {
            saveCurrentThelobookPageDrawing(); // **** MOVED: Save current page BEFORE disabling controls/animating ****

            isPageSwitchingAnimation = true;
            updateThelobookPageControls(); // Update controls to reflect "switching" state (e.g., disable buttons)

            currentThelobookPageIndex = newPageIndex;
            loadThelobookPageDrawing(currentThelobookPageIndex); // Load the new page (this also calls updateThelobookPageControls)

            // Reset animation flag after a short delay/next frame to allow UI to settle
            requestAnimationFrame(() => {
                isPageSwitchingAnimation = false;
                updateThelobookPageControls(); // Ensure controls are updated for the new page state
            });
        }
    }
    function toggleThelobookEraser() {
        if (isPageSwitchingAnimation) return;
        isThelobookEraserActive = !isThelobookEraserActive;
        const TXT = getCurrentUIText();
        if (thelobookEraserBtn) {
            thelobookEraserBtn.textContent = isThelobookEraserActive ? 'ğŸ–‹ï¸' : 'âœï¸';
            thelobookEraserBtn.title = isThelobookEraserActive ? TXT.thelobookPen : TXT.thelobookEraser;
            thelobookEraserBtn.classList.toggle('active', isThelobookEraserActive);
        }
        if (thelobookCanvas) thelobookCanvas.classList.toggle('eraser-active', isThelobookEraserActive);
        updateColorIndicator();
    }

    /* ---------------- helper: snapshot & pause media ---------------- */
    function captureMediaState() {
        mediaPlaybackTimeBeforeThelobook = internalPlaybackTime;
        audioTimeBeforeThelobook       = currentStageAudio ? currentStageAudio.currentTime : 0;
        wasMediaPlayingBeforeThelobook  = false;

        if (currentStageAudio && !currentStageAudio.paused) {
        currentStageAudio.pause();
        wasMediaPlayingBeforeThelobook = true;
        }

        if (isMediaScrubbingActive) {
        if (currentReplayAnimationId) cancelAnimationFrame(currentReplayAnimationId);
        currentReplayAnimationId = null;
        isMediaScrubbingActive  = false;
        wasMediaPlayingBeforeThelobook = true;
        }
        stageProgressBarContainer?.classList.remove('visible');
    }
    /* ---------------- helper: resume or freeze ---------------------- */
    function resumeMediaState() {
        const atEnd =
        currentStageTotalDuration > 0 &&
        mediaPlaybackTimeBeforeThelobook >= currentStageTotalDuration - 0.05;

        internalPlaybackTime = atEnd
        ? currentStageTotalDuration
        : mediaPlaybackTimeBeforeThelobook;

        if (currentStageAudio) { // currentTime will be used by playStageAudio in resume mode
        currentStageAudio.currentTime = audioTimeBeforeThelobook;
        }

        isMediaScrubbingActive = wasMediaPlayingBeforeThelobook && !atEnd;

        if (atEnd && currentStageDrawingData && replayCtx && currentStageTotalDuration > 0) {
        renderDrawingAtTime(currentStageTotalDuration, currentStageDrawingData, replayCtx);
        updateMediaProgressBar(currentStageTotalDuration, currentStageTotalDuration);
        stageProgressBarContainer?.classList.add('visible');
        }
        renderStageUI(currentStageIndex, true); // isResize = true indicates resume context
    }

    function openThelobook() {
    // â€” early exits â€”
    if (isThelobookActive || isPageGridVisible) return;

    /*  MCQ stages are now allowed â€” guard removed  */

    isThelobookActive      = true;
    isThelobookEraserActive = false;

    const TXT = getCurrentUIText();

    // pause audio / drawing playback and snapshot timing
    captureMediaState();

    // show notebook canvas & controls
    thelobookCanvas.classList.remove('grid-underlay');
    thelobookCanvas.classList.add('active');
    thelobookControlsEl.classList.add('visible');

    // ensure at least one page exists, then load current page
    if (thelobookPages.length === 0) {
        thelobookPages.push(null);
        currentThelobookPageIndex = 0;
    }
    loadThelobookPageDrawing(currentThelobookPageIndex);

    // switch input listeners
    removeBoardDrawListeners();
    addThelobookDrawListeners();
    canvas.style.pointerEvents = 'none';

    // update UI text / states
    thelobookBtn.textContent = TXT.thelobookClose;
    if (thelobookEraserBtn) {
        thelobookEraserBtn.textContent = 'âœï¸';
        thelobookEraserBtn.title      = TXT.thelobookEraser;
        thelobookEraserBtn.classList.remove('active');
    }
    if (clearBtn)  clearBtn.disabled  = true;
    if (prevBtn)   prevBtn.disabled   = true;
    if (nextCheckBtn) nextCheckBtn.disabled = true;

    updateColorIndicator();
    updateThelobookPageControls();

    /* â”€â”€ blur MCQ block if itâ€™s visible â”€â”€ */
    if (mcqOptionsContainer &&
        mcqOptionsContainer.style.display !== 'none') {
        mcqOptionsContainer.classList.add('blurred-mcq');
    }
}


function closeThelobook(savePage = true) {
    if (!isThelobookActive) return;

    /* â”€â”€ restore MCQ clarity â”€â”€ */
    if (mcqOptionsContainer) {
        mcqOptionsContainer.classList.remove('blurred-mcq');
    }

        if (savePage) saveCurrentThelobookPageDrawing();
        isThelobookActive = false; const TXT = getCurrentUIText();

        thelobookCanvas.classList.remove('active');
        thelobookCanvas.classList.remove('grid-underlay');
        thelobookControlsEl.classList.remove('visible');
        removeThelobookDrawListeners(); addBoardDrawListeners();
        thelobookBtn.textContent = TXT.thelobookOpen;
        
        resumeMediaState();
        
        // ======================= FIX STARTS HERE =======================
        if (currentStageIndex === -1) {
            // This is the edge case: lesson hasn't started.
            // Manually re-enable the 'Start' button.
            if (nextCheckBtn) nextCheckBtn.disabled = false;
        }
        // ======================== FIX ENDS HERE ========================

        // The original logic can remain or be cleaned up, but the fix above is key.
        if (currentStageData) {
            // renderStageUI is called by resumeMediaState
        } else {
            updateColorIndicator();
            canvas.style.pointerEvents = 'none';
        }
       
        wasMediaPlayingBeforeThelobook = false; 
    }
   // REPLACE your existing open/close calculator functions with these

// REPLACE your functions with these corrected versions

function openCalculator() {
    if (isCalculatorActive || isThelobookActive || isPageGridVisible) return;
    isCalculatorActive = true;

    // The line that hid the terminal has been REMOVED from here.

    // Pause lesson and capture state
    captureMediaState();

    // Set the src only when opening to load it
    if(calculatorFrame.src === 'about:blank') {
       calculatorFrame.src = 'https://thelo.space/thelo-calculator/';
    }
    
    // Show the overlay
    calculatorOverlay.classList.remove('calculator-hidden');
    
    // Blur MCQs if they are visible
    if (mcqOptionsContainer && mcqOptionsContainer.style.display !== 'none') {
        mcqOptionsContainer.classList.add('blurred-mcq');
    }

    // Disable main controls
    if (clearBtn)  clearBtn.disabled  = true;
    if (prevBtn)   prevBtn.disabled   = true;
    if (nextCheckBtn) nextCheckBtn.disabled = true;
}

function closeCalculator() {
    if (!isCalculatorActive) return;
    isCalculatorActive = false;
    
    // The line that showed the terminal has been REMOVED from here.
    
    // Hide the overlay
    calculatorOverlay.classList.add('calculator-hidden');
    
    // Un-blur MCQs
    if (mcqOptionsContainer) {
        mcqOptionsContainer.classList.remove('blurred-mcq');
    }
    
    // Resume lesson state
    resumeMediaState();
}
function handleKeyDown(event) {
    // 1. Universal Replay Seeking (Highest Priority)
    if (currentStageTotalDuration > 0 && (event.key === 'ArrowLeft' || event.key === 'ArrowRight')) {
        const isReplayActiveStage = currentStageData?.type === 'explanation_with_media' || currentStageData?.type === 'calculator_replay';
        if (isReplayActiveStage || isMediaScrubbingActive) {
            event.preventDefault(); isMediaScrubbingActive = true;
            if (currentReplayAnimationId) { cancelAnimationFrame(currentReplayAnimationId); currentReplayAnimationId = null; }
            const step = 5; const diff = event.key === 'ArrowLeft' ? -step : step;
            let newTime = Math.max(0, Math.min(internalPlaybackTime + diff, currentStageTotalDuration));
            internalPlaybackTime = newTime;
            if (currentStageAudio) {
                const audioTargetTime = Math.min(newTime, currentStageAudio.duration > 0.01 ? currentStageAudio.duration - 0.01 : 0);
                currentStageAudio.currentTime = audioTargetTime;
                if (window.userInteracted && currentStageAudio.paused && audioTargetTime < (currentStageAudio.duration - 0.01)) { currentStageAudio.play().catch(() => {}); }
            }
            if (isReplayActive && replayFrame && replayFrame.contentWindow) { replayFrame.contentWindow.postMessage({ command: 'seekToTime', timeMs: newTime * 1000 }, '*'); }
            if (currentStageDrawingData && replayCtx) { renderDrawingAtTime(newTime, currentStageDrawingData, replayCtx); }
            updateMediaProgressBar(newTime, currentStageTotalDuration);
            lastFrameTimestampForManualAdvance = 0; currentReplayAnimationId = requestAnimationFrame(mediaPlaybackLoop);
            return;
        }
    }

    // 2. Ignore inputs with modifiers or in text fields
    if (event.ctrlKey || event.altKey || event.metaKey || ['INPUT', 'TEXTAREA'].includes(event.target.tagName.toUpperCase())) { return; }

    // 3. Handle overlay key presses
    if (isPageGridVisible) {
        if (event.key.toLowerCase() === 'c') changePageGridBatch(1);
        if (event.key.toLowerCase() === 'x') changePageGridBatch(-1);
        if (event.key === 'Escape') closePageGridView();
        return;
    }
    if (isCalculatorActive) {
        if (event.key.toLowerCase() === 'f' || event.key === 'Escape') closeCalculator();
        return;
    }
    if (isThelobookActive) {
        if (event.key.toLowerCase() === 'b' || event.key === 'Escape') closeThelobook(true);
        if (event.key.toLowerCase() === 'e') toggleThelobookEraser();
        if (event.key.toLowerCase() === 'c') clearUserCanvas();
        return;
    }
    
    // 4. Handle MCQ-specific navigation
    const mcqDetails = currentStageData ? currentStageData.optionsQuiz : null;
    const isMcqActive = !!(currentStageData && currentStageData.type === "explanation_with_mcq" && mcqDetails && mcqDetails.choices);

    if (isMcqActive) {
        event.preventDefault();
        const optionCount = mcqDetails.choices.length;
        let newIndex = selectedMcqIndex;

        if (event.key === 'ArrowRight') { newIndex = (selectedMcqIndex + 1) % optionCount; } 
        else if (event.key === 'ArrowLeft') { newIndex = (selectedMcqIndex - 1 + optionCount) % optionCount; }
        
        updateMcqSelectionVisuals(newIndex);
        
        if (event.key !== ' ' && event.key !== 'Enter') { return; }
    }

    // 5. Handle Confirmation Keys (Spacebar & Enter)
    if (event.key === ' ' || event.key === 'Enter') {
        event.preventDefault();
        if (dashboardBtn && dashboardBtn.classList.contains('visible')) { dashboardBtn.click(); return; }
        if (nextCheckBtn && !nextCheckBtn.disabled) { handleNextCheckClick(); }
    }
    
    // 6. Handle General App Shortcuts
    if (currentStageIndex >= 0 && !isTransitioning && !isLessonLoading && currentStageData) {
        switch (event.key.toLowerCase()) {
            case 'b': openThelobook(); event.preventDefault(); break;
            case 'f': openCalculator(); event.preventDefault(); break;
            case 'a': hideOnCanvasFeedback(); event.preventDefault(); break;
            case 'c':
                if (isStudentInputAllowed && !isMcqActive && clearBtn && clearBtn.style.display !== 'none' && !clearBtn.disabled) {
                    clearUserCanvas(); event.preventDefault();
                }
                break;
        }
    }
}	  
	  window.addEventListener('keydown', function(e) {
  if ((e.ctrlKey || e.metaKey) && (e.key === '+' || e.key === '-' || e.key === '=')) {
    e.preventDefault();
  }
});

window.addEventListener('wheel', function(e) {
  if (e.ctrlKey) {
    e.preventDefault();
  }
}, { passive: false });
	 // REPLACE the old clearUserCanvas function with this one
function clearUserCanvas() {
    if (isPageGridVisible) return;

    if (isThelobookActive) {
        if (thelobookCtx) {
            thelobookCtx.clearRect(0, 0, thelobookCanvas.width / devicePixelRatio, thelobookCanvas.height / devicePixelRatio);
            if (currentThelobookPageIndex >= 0 && currentThelobookPageIndex < thelobookPages.length) {
                thelobookPages[currentThelobookPageIndex] = null;
            }
        }
        return;
    }

    if (ctx) {
        ctx.clearRect(0, 0, canvas.width / devicePixelRatio, canvas.height / devicePixelRatio);
    }

    userDrawingOccurred = false;

    // --- ADD THIS ---
    // Also clear the minimap canvas
    if (minimapCtx) {
        minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
    }
}
    // REPLACE your existing initApp function with this entire block

function initApp() {
    // NEW: Add this check at the very top of the function
   
    // --- The rest of your original initApp function continues below ---
    
    console.log("KaTeX is ready. Initializing app.");
    checkTabletMode();
    const audioIdsToLoad = [
        'audio_approve1_hy', 'audio_approve2_hy', 'audio_dis1_hy', 'audio_dis2_hy',
        'audio_approve1_en', 'audio_approve2_en', 'audio_dis1_en', 'audio_dis2_en', 'gotItSound'
    ];
    audioIdsToLoad.forEach(id => {
        const audio = document.getElementById(id);
        if (audio) {
            audioElements[id] = audio;
            if (id.startsWith('audio_approve') && id.endsWith('_hy')) approveSounds_hy.push(audio);
            if (id.startsWith('audio_dis') && id.endsWith('_hy')) disapproveSounds_hy.push(audio);
            if (id.startsWith('audio_approve') && id.endsWith('_en')) approveSounds_en.push(audio);
            if (id.startsWith('audio_dis') && id.endsWith('_en')) disapproveSounds_en.push(audio);
        }
    });
    resizeCanvases();
    addBoardDrawListeners();
    window.addEventListener('mouseup', handleDrawingEnd);
    window.addEventListener('mouseleave', handleDrawingEnd);
    window.addEventListener('touchend', handleDrawingEnd);
    window.addEventListener('touchcancel', handleDrawingEnd);

    const urlParams = new URLSearchParams(window.location.search);
    const lessonFileName = urlParams.get('lessonFile');
    if (lessonFileName) {
        const LESSONS_BASE_PATH = 'https://thelo.space/lessons/';
        const cleanLFN = lessonFileName.startsWith('/') ? lessonFileName.substring(1) : lessonFileName;
        loadLesson(LESSONS_BASE_PATH + cleanLFN.replace(/\.\.+/g, ''));
    } else {
        const TXT = getCurrentUIText();
        addChatMessage('AI', formatAIMessage('lessonFileMissing'));
        if(nextCheckBtn){nextCheckBtn.textContent = TXT.error; nextCheckBtn.disabled = true;}
        if(prevBtn)prevBtn.disabled = true;
        if(bgCtx && backgroundCanvas && backgroundCanvas.width > 0){
            const cw = backgroundCanvas.width/(window.devicePixelRatio||1); const ch = backgroundCanvas.height/(window.devicePixelRatio||1);
            bgCtx.clearRect(0,0,cw,ch); bgCtx.font = `20px 'Mardoto-Light', system-ui, sans-serif`;
            bgCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--thelo-text').trim();
            bgCtx.textAlign='center';bgCtx.textBaseline='middle';
            wrapText(bgCtx, TXT.lessonLoadErrorGeneric, cw/2, ch/2, cw*0.8, 30);
        }
    }
    const interactionListener = () => { if (window.userInteracted) return; window.userInteracted = true; Object.values(audioElements).forEach(a => { if(a.readyState < 1) a.load(); }); if(stageAudioPlayer && stageAudioPlayer.readyState < 1) stageAudioPlayer.load(); try { const tempAC = new (window.AudioContext || window.webkitAudioContext)(); if (tempAC.state === 'suspended') tempAC.resume().then(()=>tempAC.close()); else tempAC.close(); } catch(e){} document.body.removeEventListener('click', interactionListener); document.body.removeEventListener('keydown', interactionListener); document.body.removeEventListener('touchstart', interactionListener); };
    document.body.addEventListener('click', interactionListener, { once: true });
    document.body.addEventListener('keydown', interactionListener, { once: true });
    document.body.addEventListener('touchstart', interactionListener, { once: true });
    window.addEventListener('resize', resizeCanvases);
    if (prevBtn) prevBtn.onclick = previousStage;
    if (nextCheckBtn) nextCheckBtn.onclick = handleNextCheckClick;
    const fullscreenBtn = document.getElementById('fullscreenBtn');
    if (fullscreenBtn) {
        fullscreenBtn.onclick = toggleFocusFullscreen;
    }

    if (clearBtn) clearBtn.onclick = clearUserCanvas;
    if (thelobookBtn) thelobookBtn.onclick = () => { isThelobookActive ? closeThelobook(true) : openThelobook(); };

    if (thelobookPrevPageBtn) thelobookPrevPageBtn.onclick = () => changeThelobookPageSimple(-1);
    if (thelobookNextPageBtn) thelobookNextPageBtn.onclick = () => changeThelobookPageSimple(1);
    if (thelobookEraserBtn) thelobookEraserBtn.onclick = toggleThelobookEraser;
    if (thelobookAddPageBtn) thelobookAddPageBtn.onclick = addThelobookNewPage;
    if (calculatorCloseBtn) calculatorCloseBtn.onclick = closeCalculator;
    if (openCalculatorBtn) openCalculatorBtn.onclick = openCalculator;
    if (dashboardBtn) {
        dashboardBtn.onclick = () => {
            window.location.href = 'https://thelo.space/sdashboard';
        };
    }

    document.querySelectorAll('button').forEach(button => {
        button.addEventListener('click', () => {
            button.blur();
        });
    });

    document.addEventListener('keydown', handleKeyDown);

    window.addEventListener('beforeunload', () => {
        const user = auth.currentUser;
        if (user && lessonStartTime && currentStageIndex < lessonStages.length -1) {
            const urlParams = new URLSearchParams(window.location.search);
            const lessonFileName = urlParams.get('lessonFile');
            
            navigator.sendBeacon('https://firestore.googleapis.com/v1/projects/physmathacademy-722b3/databases/(default)/documents/analytics_events', JSON.stringify({
                fields: {
                    type: { stringValue: 'lesson_abandoned' },
                    userId: { stringValue: user.uid },
                    lessonId: { stringValue: lessonFileName.replace('.json', '') },
                    lastCompletedStageIndex: { integerValue: currentStageIndex },
                    totalStagesInLesson: { integerValue: lessonStages.length },
                    timestamp: { timestampValue: new Date().toISOString() }
                }
            }));
        }
    });
}

    if (typeof window.appInitialized === 'undefined') {
        window.appInitialized = false;
    }

  // This listener ensures the entire page, including all styles and fonts, is ready before the app starts.
document.addEventListener('DOMContentLoaded', async () => {

    // Helper function to programmatically load KaTeX CSS
    let isKatexCssInjected = false;
    async function ensureKatexCssIsLoaded() {
        if (isKatexCssInjected) return;
        // This re-uses your existing function that cleverly embeds the fonts!
        const cssText = await getKatexCSSWithEmbeddedFonts();
        const style = document.createElement('style');
        style.textContent = cssText;
        document.head.appendChild(style);
        isKatexCssInjected = true;
        console.log('KaTeX CSS has been injected into the document head.');
    }

    // --- Start of App Initialization ---

    console.log('DOM is ready. Checking for KaTeX library:', typeof katex);
    if (typeof katex === 'undefined') {
        console.error('CRITICAL: KaTeX library failed to load before app start.');
        return;
    }

    try {
        // 1. Force the CSS to load and be injected first.
        await ensureKatexCssIsLoaded();

        // 2. Now, wait for the browser to acknowledge all fonts are ready.
        await document.fonts.ready;
        console.log('All fonts are confirmed ready.');

        // 3. Proceed with app initialization, confident that everything is loaded.
        auth.onAuthStateChanged(user => {
            const finishInitialization = () => {
                if (!window.appInitialized) {
                    window.appInitialized = true;
                    initApp();
                } else {
                    updateAllUITexts();
                }
                isAuthReady = true;
                console.log("Authentication is now ready.");
            };

            if (user) {
                console.log("User authenticated with UID:", user.uid);
                const userDocRef = db.collection('thelo-students').doc(user.uid);

                userDocRef.get().then(doc => {
                    if (doc.exists) {
                        userPoints = doc.data().points || 0;
                    } else {
                        userPoints = 0;
                        console.log("No points document found for user, starting at 0.");
                    }
                    updatePointsDisplay();
                    finishInitialization();
                }).catch(error => {
                    console.error("Error fetching user points:", error);
                    userPoints = 0;
                    updatePointsDisplay();
                    finishInitialization();
                });
            } else {
                userPoints = 0;
                updatePointsDisplay();
                console.log("User not authenticated.");
                finishInitialization();
            }
        });

    } catch (error) {
        console.error('Styles or fonts failed to load, app initialization aborted:', error);
    }
});
// Add this function somewhere logical, e.g., near updateUserPointsInFirestore
async function logDigitForTraining(recognizedValue, feedbackType) {
Â  Â  const user = auth.currentUser;
Â  Â  if (!user) {
Â  Â  Â  Â  console.warn("No user for digit logging. Skipping.");
Â  Â  Â  Â  return;
Â  Â  }

Â  Â  // Ensure the main canvas has content
Â  Â  if (!canvas || canvas.width === 0 || canvas.height === 0) {
Â  Â  Â  Â  console.warn("Main canvas is not ready or empty. Cannot log digit for training.");
Â  Â  Â  Â  return;
Â  Â  }

Â  Â  let base64ImageData;
Â  Â  try {
Â  Â  Â  Â  // Capture the content of the main canvas (which contains the blue ink)
Â  Â  Â  Â  base64ImageData = canvas.toDataURL('image/png');
Â  Â  } catch (e) {
Â  Â  Â  Â  console.error("Failed to get image data from canvas for logging:", e);
Â  Â  Â  Â  return;
Â  Â  }

Â  Â  const metadata = {
Â  Â  Â  Â  digit: String(recognizedValue),
Â  Â  Â  Â  recognizedByVision: currentStageData.correctAnswerOcr,
Â  Â  Â  Â  feedbackType: feedbackType,
Â  Â  Â  Â  timestamp: firebase.firestore.FieldValue.serverTimestamp(),
Â  Â  Â  Â  userId: user.uid,
Â  Â  Â  Â  lessonId: new URLSearchParams(window.location.search).get('lessonFile')?.replace('.json', '') || 'unknown',
Â  Â  Â  Â  stageIndex: currentStageIndex,
Â  Â  Â  Â  deviceType: isTabletMode ? 'tablet' : 'desktop',
Â  Â  Â  Â  userAgent: navigator.userAgent,
Â  Â  Â  Â  screenWidth: window.screen.width,
Â  Â  Â  Â  screenHeight: window.screen.height,
Â  Â  Â  Â  canvasWidth: canvas.width,
Â  Â  Â  Â  canvasHeight: canvas.height,
Â  Â  Â  Â  devicePixelRatio: window.devicePixelRatio || 1,
Â  Â  };

Â  Â  try {
Â  Â  Â  Â  // Send to a new collection specifically for training data
Â  Â  Â  Â  await db.collection('thelo-training-digits-demo').add({
Â  Â  Â  Â  Â  Â  imageData: base64ImageData,
Â  Â  Â  Â  Â  Â  metadata: metadata
Â  Â  Â  Â  });
Â  Â  Â  Â  console.log("Handwritten digit logged for training demo:", recognizedValue);
Â  Â  } catch (error) {
Â  Â  Â  Â  console.error("Error logging digit for training demo:", error);
Â  Â  }
}

</script>
</html>
