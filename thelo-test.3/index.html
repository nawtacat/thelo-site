<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link rel="icon" href="https://thelo.space/img/thelofavicon.png" type="image/png">
    <link rel="apple-touch-icon" href="https://thelo.space/img/yarnicon.png">
    <title>thelo | Test Mode</title>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-functions-compat.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@300;400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<style>
  /* ===== NEW: Updated Design System ===== */
  :root {
    /* Core Palette */
    --thelo-blue: #2563eb;
    --thelo-blue-dark: #1d4ed8;
    --thelo-bg: #ffffff;
    --thelo-text: #111827;
    --thelo-text-light: #6b7280;
    --thelo-border: #e5e7eb;

    /* Status Colors */
    --success-green: #22c55e;
    --error-red: #ef4444;
    --accent-yellow: #f59e0b;

    /* UI Element Colors */
    --bg-white: #ffffff;
    --chat-ai-bg: #ffffff;
    --bg-light-gray: #f9fafb;

    /* Ink Colors */
    --ink-black: #000000;
    --ink-blue: var(--thelo-blue);

    /* Effects */
    --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
    --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);

    /* Transitions */
    --fade-duration: 0.3s;
    --animation-duration: 0.3s;
  }

  /* ===== NEW: Armenian Font Definitions ===== */
  @font-face {
    font-family: 'Montserrat Arm';
    src: url('https://thelo.space/fonts/Montserratarm-Regular.otf') format('opentype');
    font-weight: 400; /* Regular */
    font-style: normal;
    font-display: swap;
  }
  @font-face {
    font-family: 'Montserrat Arm';
    src: url('https://thelo.space/fonts/Montserratarm-SemiBold.otf') format('opentype');
    font-weight: 600; /* SemiBold */
    font-style: normal;
    font-display: swap;
  }
  @font-face {
    font-family: 'Montserrat Arm';
    src: url('https://thelo.space/fonts/Montserratarm-ExtraBold.otf') format('opentype');
    font-weight: 800; /* ExtraBold */
    font-style: normal;
    font-display: swap;
  }

  /* Rule to apply the Armenian font when needed */
  body.lang-hy {
    font-family: 'Montserrat Arm', 'Manrope', system-ui, -apple-system, sans-serif;
  }

  #loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: var(--thelo-bg);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999;
    opacity: 1;
    transition: opacity 0.5s ease-out;
  }
  #loading-overlay.hidden {
    opacity: 0;
    pointer-events: none;
  }
  #loading-svg {
    width: 150px;
    height: auto;
    animation: pulse-loader 1.5s infinite ease-in-out;
  }
  @keyframes pulse-loader {
    0% { transform: scale(1); opacity: 0.8; }
    50% { transform: scale(1.1); opacity: 1; }
    100% { transform: scale(1); opacity: 0.8; }
  }
  html {
    font-size: 16px;
    background: var(--thelo-bg);
  }
  body {
    margin: 0;
    min-height: 100vh;
    height: 100vh;
    font-family: 'Manrope', system-ui, -apple-system, sans-serif;
    font-weight: 400;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    background-color: var(--thelo-bg);
    color: var(--thelo-text);
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;
  }
  #app { display: flex; flex-grow: 1; height: 100%; }
  #lessonArea {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }
  #boardWrap {
    position: relative;
    flex-grow: 1;
    overflow: hidden;
    background-color: var(--thelo-bg);
    background-image: linear-gradient(to right, var(--thelo-border) 1px, transparent 1px),
      linear-gradient(to bottom, var(--thelo-border) 1px, transparent 1px);
    background-size: 40px 40px;
  }
  #backgroundCanvas,
  #board {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: block;
    background-color: transparent;
  }
  #backgroundCanvas {
    z-index: 1;
    pointer-events: none;
    opacity: 1;
    transition: opacity var(--fade-duration) ease-in-out;
  }
  #backgroundCanvas.fade-out {
    opacity: 0;
  }
  #board {
    z-index: 3;
    cursor: crosshair;
    touch-action: none;
  }
  #bottomBar {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    background-color: transparent;
    box-sizing: border-box;
    padding: 1rem 1.5rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    z-index: 20;
    transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1);
  }
  #button-group {
      display: flex;
      gap: 0.2rem; /* MODIFIED: Buttons are closer */
  }
  .control-btn {
    font-family: inherit;
    padding: 0.5rem 1rem;
    font-size: 0.9rem;
    font-weight: 500;
    border: none;
    border-radius: 0.5rem;
    color: var(--bg-white);
    cursor: pointer;
    transition: background-color 0.2s, transform 0.15s, box-shadow 0.2s;
    box-shadow: var(--shadow-md);
    touch-action: manipulation;
  }
  .control-btn:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: var(--shadow-lg);
  }
  .control-btn:disabled {
    background-color: #9ca3af !important;
    cursor: not-allowed;
    opacity: 0.7;
  }
  #prevBtn, #detailPrevBtn { background-color: var(--accent-yellow); }
  #clearBtn, #detailBackBtn { background-color: var(--error-red); }
  #submitBtn, #detailNextBtn { background-color: var(--thelo-blue); }
  #submitBtn:hover:not(:disabled), #detailNextBtn:hover:not(:disabled) { background-color: var(--thelo-blue-dark); }

  .bar-hidden-by-stylus {
    transform: translateY(150%);
    pointer-events: none;
  }
  html, body {
    cursor: none !important;
  }
  .no-cursor {
    cursor: none !important;
  }
  #bottom-logo-container {
    position: fixed;
    bottom: 1.25rem; /* MODIFIED: Logo is raised slightly */
    left: 50%;
    transform: translateX(-50%);
    z-index: 10000;
    pointer-events: none;
  }
  #bottom-logo-container img {
    display: block;
    height: 35px;
    width: auto;
  }
  #timerDisplay {
    background-color: rgba(255, 255, 255, 0.8);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 0.5rem 1.25rem;
    border-radius: 999px;
    font-size: 1.2rem;
    font-weight: 700;
    color: var(--thelo-text);
    box-shadow: var(--shadow-md);
    border: 1px solid var(--thelo-border);
  }

  /* ===== NEW / REFACTORED: Results Screen Styling ===== */
  .hidden {
      display: none !important;
  }
  .results-view {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 50;
    background-color: var(--thelo-bg);
    display: flex;
    flex-direction: column;
    padding: 2rem;
    box-sizing: border-box;
    overflow: hidden;
  }
  .results-container {
    width: 100%;
    max-width: 800px;
    margin: 0 auto;
    display: flex;
    flex-direction: column;
    height: 100%;
  }
  .results-header {
    border-bottom: 2px solid var(--thelo-border);
    padding-bottom: 1rem;
    margin-bottom: 1.5rem;
    text-align: center;
    flex-shrink: 0;
  }
  #resultsScore {
    font-size: 2.5rem;
    font-weight: 800;
    color: var(--thelo-blue);
  }
  #resultsTime {
    font-size: 1.2rem;
    color: var(--thelo-text-light);
  }

  /* Summary List Styling */
  #resultsFeedbackList {
    flex-grow: 1;
    overflow-y: auto;
    padding-right: 1rem; /* For scrollbar */
  }
  .summary-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem;
    border-bottom: 1px solid var(--thelo-border);
    cursor: pointer;
    transition: background-color 0.2s;
  }
  .summary-item:hover {
    background-color: var(--bg-light-gray);
  }
  .summary-item-text {
    font-weight: 500;
  }
  .summary-item-status {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-weight: 700;
  }
  .summary-item-status.status-correct { color: var(--success-green); }
  .summary-item-status.status-incorrect { color: var(--error-red); }

  /* Detail View Styling */
  #detailViewScreen {
      z-index: 60; /* Above summary screen */
  }
  #detailViewHeader {
      flex-shrink: 0;
      padding-bottom: 1rem;
      border-bottom: 1px solid var(--thelo-border);
      margin-bottom: 1.5rem;
  }
  #detail-question-title {
      font-size: 1.2rem;
      font-weight: 700;
      margin: 0 0 0.5rem 0;
  }
  #detail-status-text {
      font-size: 1rem;
      font-weight: 700;
  }
  #detailViewContent {
      flex-grow: 1;
      display: flex;
      gap: 2rem;
      overflow-y: auto;
  }
  #user-solution-container {
      flex: 1;
      min-width: 300px;
  }
  #ai-feedback-container {
      flex: 1;
      line-height: 1.6;
  }
  .detail-section-title {
      font-weight: 700;
      margin-top: 0;
      margin-bottom: 0.5rem;
      color: var(--thelo-text-light);
      font-size: 0.9rem;
      text-transform: uppercase;
  }
  #user-solution-img {
      width: 100%;
      height: auto;
      border: 1px solid var(--thelo-border);
      border-radius: 0.5rem;
      background-color: var(--bg-white);
  }
  #detailViewNav {
      flex-shrink: 0;
      padding-top: 1.5rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
  }

  @media (max-width: 768px) {
    #bottomBar {
      flex-wrap: wrap;
      justify-content: center;
      gap: 1rem;
    }
    .control-btn {
      padding: 0.6rem 0.8rem;
      font-size: 0.8rem;
    }
    #detailViewContent {
      flex-direction: column;
    }
  }

  @media (min-width: 769px) and (max-width: 1200px) and (pointer: coarse) {
    #boardWrap {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
    }
  }
</style>
</head>
<body>
    <div id="loading-overlay">
        <img id="loading-svg" src="https://thelo.space/img/bluethelo.svg" alt="Loading...">
    </div>
    <div id="app">
        <div id="lessonArea">
            <div id="boardWrap">
                <canvas id="backgroundCanvas"></canvas>
                <canvas id="board"></canvas>
            </div>
            <div id="bottomBar">
                <div id="timerDisplay">00:00</div>
                <div id="button-group">
                    <button id="prevBtn" class="control-btn"></button>
                    <button id="clearBtn" class="control-btn"></button>
                    <button id="submitBtn" class="control-btn"></button>
                </div>
            </div>
        </div>
    </div>

    <div id="resultsScreen" class="results-view hidden">
        <div class="results-container">
            <div class="results-header">
                <h1 id="results-title">Test Complete!</h1>
                <div id="resultsScore">Score: 0 / 0 (0%)</div>
                <div id="resultsTime">Time Taken: 00:00</div>
            </div>
            <div id="resultsFeedbackList">
                </div>
        </div>
    </div>

    <div id="detailViewScreen" class="results-view hidden">
        <div class="results-container">
            <div id="detailViewHeader">
                <h2 id="detail-question-title">Question X</h2>
                <div id="detail-status-text">Status</div>
            </div>
            <div id="detailViewContent">
                <div id="user-solution-container">
                    <h3 class="detail-section-title" id="detail-your-solution-title">Your Solution</h3>
                    <img id="user-solution-img" src="" alt="User's solution drawing">
                </div>
                <div id="ai-feedback-container">
                    <h3 class="detail-section-title" id="detail-ai-feedback-title">AI Feedback</h3>
                    <p id="ai-feedback-text">Loading feedback...</p>
                </div>
            </div>
            <div id="detailViewNav">
                 <button id="detailBackBtn" class="control-btn"></button>
                 <div id="detail-button-group" style="display: flex; gap: 0.5rem;">
                     <button id="detailPrevBtn" class="control-btn"></button>
                     <button id="detailNextBtn" class="control-btn"></button>
                 </div>
            </div>
        </div>
    </div>


    <div id="bottom-logo-container">
        <img src="https://thelo.space/img/bluethelo.svg" alt="Thelo Logo">
    </div>

<script>
    const firebaseConfig = { apiKey: "AIzaSyAbnPpcIt88B0jIAoLUdC71zmQDvR_fdu8", authDomain: "physmathacademy-722b3.firebaseapp.com", projectId: "physmathacademy-722b3", messagingSenderId: "1093640992262", appId: "1:1093640992262:web:35b1bf4d2364bcf745f587" };
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    /* ========== DOM Elements ========== */
    const loadingOverlay = document.getElementById('loading-overlay');
    const backgroundCanvas = document.getElementById('backgroundCanvas');
    const canvas = document.getElementById('board');
    const boardWrapper = document.getElementById('boardWrap');
    const prevBtn = document.getElementById('prevBtn');
    const submitBtn = document.getElementById('submitBtn');
    const clearBtn = document.getElementById('clearBtn');
    const timerDisplay = document.getElementById('timerDisplay');
    const bottomBar = document.getElementById('bottomBar');
    const bgCtx = backgroundCanvas.getContext('2d');
    const ctx = canvas.getContext('2d');

    // NEW: Result Screen DOM Elements
    const resultsScreen = document.getElementById('resultsScreen');
    const detailViewScreen = document.getElementById('detailViewScreen');
    const resultsFeedbackList = document.getElementById('resultsFeedbackList');
    const detailBackBtn = document.getElementById('detailBackBtn');
    const detailPrevBtn = document.getElementById('detailPrevBtn');
    const detailNextBtn = document.getElementById('detailNextBtn');


    /* ========== State Variables ========== */
    let testData = null;
    let currentStageIndex = -1;
    let currentDetailIndex = -1; // NEW: To track which detail view is open
    let currentStageData = null;
    let drawing = false;
    let lastPos = { x: 0, y: 0 };
    let userDrawingOccurred = false;
    let isTransitioning = false;
    let devicePixelRatio = window.devicePixelRatio || 1;
    let timerInterval = null;
    let testStartTime = null;
    let testResults = [];
    let isTabletMode = false;
    let buttonVanishTimer = null;
    let currentLang = 'en';

    /* ========== UI Text ========== */
    const UI_TEXT = {
        en: {
            start: "Start Test",
            submit: "Submit Answer",
            checking: "Checking...",
            prev: "Previous",
            clear: "Clear",
            testComplete: "Test Complete!",
            score: "Score:",
            timeTaken: "Time Taken:",
            provideSolution: "Please provide a solution before submitting.",
            question: "Question",
            aiFeedback: "AI Feedback",
            generatingFeedback: "Generating detailed feedback...",
            analysisError: "Could not submit for analysis.",
            backToSummary: "Back to Summary", // NEW
            yourSolution: "Your Solution" // NEW
        },
        hy: {
            start: "Սկսել թեստը",
            submit: "Ուղարկել",
            checking: "Ստուգվում է...",
            prev: "Նախորդ",
            clear: "Մաքրել",
            testComplete: "Թեստն ավարտված է",
            score: "Միավոր:",
            timeTaken: "Ժամանակ:",
            provideSolution: "Խնդրում ենք լուծումը գրել նոր ուղարկել։",
            question: "Հարց",
            aiFeedback: "Արհեստական բանականության վերլուծություն",
            generatingFeedback: "Ստեղծվում է մանրամասն վերլուծություն...",
            analysisError: "Չհաջողվեց ուղարկել վերլուծության։",
            backToSummary: "Վերադառնալ", // NEW
            yourSolution: "Ձեր լուծումը" // NEW
        }
    };
    // ===================================================================
    //  KaTeX and Headline Rendering Functions (Unchanged)
    // ===================================================================
    let katexCSSInlined = null;

    function abToBase64(ab) {
        const CHUNK = 0x8000;
        const bytes = new Uint8Array(ab);
        let binary = '';
        for (let i = 0; i < bytes.length; i += CHUNK) {
            binary += String.fromCharCode(...bytes.subarray(i, i + CHUNK));
        }
        return btoa(binary);
    }

    async function getKatexCSSWithEmbeddedFonts() {
        if (katexCSSInlined) return katexCSSInlined;
        const base = 'https://cdn.jsdelivr.net/npm/katex@0.16.10/dist';
        let css = await (await fetch(`${base}/katex.min.css`)).text();
        const fonts = ['KaTeX_Main-Regular.woff2', 'KaTeX_Main-Italic.woff2', 'KaTeX_Main-Bold.woff2', 'KaTeX_Math-Italic.woff2', 'KaTeX_AMS-Regular.woff2', 'KaTeX_Size1-Regular.woff2', 'KaTeX_Size2-Regular.woff2'];
        for (const name of fonts) {
            const url = `${base}/fonts/${name}`;
            const res = await fetch(url);
            const b64 = abToBase64(await res.arrayBuffer());
            const dataURL = `url(data:font/woff2;base64,${b64}) format("woff2")`;
            css = css.replace(new RegExp(`url\\([^)]*${name}[^)]*\\)\\s*format\\("woff2"\\)`, 'g'), dataURL);
        }
        katexCSSInlined = css;
        return katexCSSInlined;
    }

    async function ensureHeadlineFontsLoaded() {
        try {
            if (document.fonts && document.fonts.load) {
                await Promise.race([
                    (async () => {
                        await document.fonts.load(`24px "Manrope"`);
                        if (currentLang === 'hy') {
                           await document.fonts.load(`24px "Montserrat Arm"`);
                        }
                        await document.fonts.ready;
                    })(),
                    new Promise(res => setTimeout(res, 800))
                ]);
            }
        } catch (_) {}
    }

    async function renderComplexHeadline(bgCtx, headline, y, opts = {}) {
        if (!headline || !bgCtx) return;
        const widthFraction = 0.88, yNudge = -14, fontSize = 24, mathFontSize = 26;
        const fontColor = getComputedStyle(document.documentElement).getPropertyValue('--thelo-text').trim() || '#111827';
        const katexCSS = await getKatexCSSWithEmbeddedFonts();
        const extraRules = `.katex, .katex .mathnormal { font-family: "KaTeX_Main", serif !important; }`;
        const segments = (headline.split(/(\/K[\s\S]*?K\/)/g) || []).filter(Boolean).map(p => p.startsWith('/K') && p.endsWith('K/') ? { type: 'math', content: p.replace(/^\/K\s*/, '').replace(/\s*K\/$/, '') } : { type: 'text', content: p });
        const measureHost = document.createElement('div');
        measureHost.style.cssText = 'position:absolute;visibility:hidden;left:-9999px;top:-9999px;';
        document.body.appendChild(measureHost);
        const tokens = [];
        for (const seg of segments) {
            if (seg.type === 'text') {
                const parts = seg.content.match(/(\s+|[^\s]+)/g) || [];
                for (const p of parts) {
                    tokens.push({ type: 'text', content: p, width: bgCtx.measureText(p).width, height: fontSize, isSpace: /^\s+$/.test(p) });
                }
                continue;
            }
            try {
                const html = katex.renderToString(seg.content, { throwOnError: false, output: 'html' });
                const style = document.createElement('style'); style.textContent = katexCSS; measureHost.appendChild(style);
                const tmp = document.createElement('div'); tmp.style.color = fontColor; tmp.style.fontSize = `${mathFontSize}px`; tmp.innerHTML = html; measureHost.appendChild(tmp);
                const rect = (tmp.querySelector('.katex') || tmp).getBoundingClientRect();
                tmp.remove();
                const PAD = 2; const w = Math.ceil(rect.width) + PAD; const h = Math.ceil(rect.height) + PAD;
                const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}"><style>${katexCSS}\n${extraRules}</style><foreignObject width="100%" height="100%"><div xmlns="http://www.w3.org/1999/xhtml" style="color:${fontColor};font-size:${mathFontSize}px;line-height:initial;display:inline-block;padding-right:${PAD/2}px;">${html}</div></foreignObject></svg>`;
                const dataUrl = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svg)));
                const image = new Image(); image.src = dataUrl; await image.decode();
                tokens.push({ type: 'math', image, width: w, height: h, drawW: w, drawH: h });
            } catch (e) {
                tokens.push({ type: 'text', content: seg.content, width: bgCtx.measureText(seg.content).width, height: fontSize, isSpace: false });
            }
        }
        measureHost.remove();
        const canvasW = bgCtx.canvas.width / devicePixelRatio;
        const maxWidth = canvasW * widthFraction;
        const lines = []; let line = { tokens: [], width: 0, height: fontSize };
        for (const t of tokens) {
            let width = t.width, height = t.height, drawW = t.drawW ?? t.width, drawH = t.drawH ?? t.height;
            if (t.type === 'math' && width > maxWidth) { const s = maxWidth / width; width = Math.floor(width * s); height = Math.floor(height * s); drawW *= s; drawH *= s; }
            const tok = { ...t, width, height, drawW, drawH };
            if (line.tokens.length && line.width + width > maxWidth) { lines.push(line); line = { tokens: [], width: 0, height: fontSize }; }
            if (!(line.tokens.length === 0 && tok.isSpace)) { line.tokens.push(tok); line.width += width; if (height > line.height) line.height = height; }
        }
        if (line.tokens.length) lines.push(line);
        const prevAlign = bgCtx.textAlign; const prevBase = bgCtx.textBaseline; const prevFill = bgCtx.fillStyle;
        bgCtx.fillStyle = fontColor; bgCtx.textAlign = 'left'; bgCtx.textBaseline = 'top';
        let curY = y + yNudge;
        for (const L of lines) {
            let x = (canvasW - L.width) / 2;
            for (const t of L.tokens) {
                const topY = curY + (L.height - t.height) / 2;
                if (t.type === 'text') bgCtx.fillText(t.content, x, topY); else bgCtx.drawImage(t.image, x, topY, t.drawW, t.drawH);
                x += t.width;
            }
            curY += L.height + 8;
        }
        bgCtx.textAlign = prevAlign; bgCtx.textBaseline = prevBase; bgCtx.fillStyle = prevFill;
    }
    // ===================================================================
    //  Main Application Logic (Mostly Unchanged, except finishTest)
    // ===================================================================
    function getBoundingBox(ctx, padding = 20 * (window.devicePixelRatio || 1)) {
        const canvas = ctx.canvas;
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        let minX = canvas.width, minY = canvas.height, maxX = -1, maxY = -1;
        for (let y = 0; y < canvas.height; y++) {
            for (let x = 0; x < canvas.width; x++) {
                if (data[(y * canvas.width + x) * 4 + 3] > 0) {
                    minX = Math.min(minX, x); minY = Math.min(minY, y);
                    maxX = Math.max(maxX, x); maxY = Math.max(maxY, y);
                }
            }
        }
        if (maxX === -1) return null;
        minX = Math.max(0, minX - padding); minY = Math.max(0, minY - padding);
        maxX = Math.min(canvas.width, maxX + padding); maxY = Math.min(canvas.height, maxY + padding);
        return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
    }

    async function loadTest(testJsonPath) {
        isTransitioning = true;
        try {
            const response = await fetch(testJsonPath);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            testData = await response.json();
            if (!testData || !Array.isArray(testData.stages)) throw new Error("Invalid test format.");
            
            currentLang = testData.lang === 'hy' ? 'hy' : 'en';
            document.body.className = currentLang === 'hy' ? 'lang-hy' : '';

            document.title = testData.testTitle || "thelo | Test Mode";
            currentStageIndex = -1;
            testResults = [];
            updateAllUITexts();
            submitBtn.disabled = false;
            prevBtn.disabled = true;
        } catch (error) {
            console.error("Error loading test:", error);
            alert("Failed to load the test file. Please check the console for details.");
        } finally {
            isTransitioning = false;
            loadingOverlay.classList.add('hidden');
        }
    }

    function startTest() {
        if (currentStageIndex !== -1) return;
        testStartTime = Date.now();
        timerInterval = setInterval(updateTimerDisplay, 1000);
        transitionToStage(0);
    }

    function updateTimerDisplay() {
        if (!testStartTime) return;
        const elapsed = Math.floor((Date.now() - testStartTime) / 1000);
        const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
        const seconds = (elapsed % 60).toString().padStart(2, '0');
        timerDisplay.textContent = `${minutes}:${seconds}`;
    }

    async function renderStageUI(index) {
        if (index < 0 || index >= testData.stages.length) return;
        currentStageData = testData.stages[index];
        currentStageIndex = index;
        bgCtx.clearRect(0, 0, backgroundCanvas.width / devicePixelRatio, backgroundCanvas.height / devicePixelRatio);
        clearUserCanvas();
        const headlineText = `${UI_TEXT[currentLang].question} ${index + 1}: ${currentStageData.headline || ''}`;
        if (headlineText && bgCtx.canvas.width > 0) {
            const baseFont = currentLang === 'hy' ? "Montserrat Arm" : "Manrope";
            bgCtx.font = `24px '${baseFont}', system-ui, sans-serif`;
            await ensureHeadlineFontsLoaded();
            await renderComplexHeadline(bgCtx, headlineText, 65);
        }
        prevBtn.disabled = index === 0;
        submitBtn.disabled = false;
        updateAllUITexts();
        userDrawingOccurred = false;
    }

    function transitionToStage(newIndex) {
        if (isTransitioning) return;
        if (newIndex >= testData.stages.length) {
            finishTest();
            return;
        }
        isTransitioning = true;
        backgroundCanvas.classList.add('fade-out');
        setTimeout(() => {
            renderStageUI(newIndex).then(() => {
                backgroundCanvas.classList.remove('fade-out');
                isTransitioning = false;
            });
        }, parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--fade-duration') || '0.3') * 1000);
    }

    async function handleSubmitClick() {
        if (currentStageIndex === -1) {
            startTest();
            return;
        }
        if (!userDrawingOccurred) {
            alert(UI_TEXT[currentLang].provideSolution);
            return;
        }
        const texts = UI_TEXT[currentLang] || UI_TEXT.en;
        submitBtn.disabled = true;
        submitBtn.textContent = texts.checking;
        const user = auth.currentUser;
        if (!user) {
            alert("You must be signed in to submit a test.");
            submitBtn.disabled = false;
            updateAllUITexts();
            return;
        }
        let base64ImageData;
        try {
            const box = getBoundingBox(ctx);
            if (!box) throw new Error("No drawing found to capture.");
            const cropCanvas = document.createElement('canvas');
            cropCanvas.width = box.width;
            cropCanvas.height = box.height;
            const cropCtx = cropCanvas.getContext('2d');
            cropCtx.fillStyle = '#FFFFFF';
            cropCtx.fillRect(0, 0, cropCanvas.width, cropCanvas.height);
            cropCtx.drawImage(canvas, box.x, box.y, box.width, box.height, 0, 0, box.width, box.height);
            base64ImageData = cropCanvas.toDataURL("image/png");
        } catch (e) {
            console.error("Image capture error:", e);
            alert("Error capturing your solution. Please ensure something is drawn.");
            submitBtn.disabled = false;
            updateAllUITexts();
            return;
        }
        try {
            const analyzeMathDrawing = firebase.functions().httpsCallable('analyzeMathDrawing');
            const payload = {
                imageBase64: base64ImageData,
                problemText: currentStageData.headline || "A math problem.",
                correctAnswer: String(currentStageData.correctAnswer),
                language: currentLang
            };
            const result = await analyzeMathDrawing(payload);
            const { status, feedback } = result.data;
            testResults.push({
                question: currentStageData.headline,
                correctAnswer: currentStageData.correctAnswer,
                solutionImage: base64ImageData,
                status: status,
                feedback: feedback,
            });
            transitionToStage(currentStageIndex + 1);
        } catch (error) {
            console.error("AI analysis failed:", error);
            alert("There was an error checking your answer. Please try again.");
            submitBtn.disabled = false;
            updateAllUITexts();
        }
    }
    
    // ===================================================================
    //  NEW / REFACTORED: Results Screen Logic
    // ===================================================================

    function finishTest() {
        clearInterval(timerInterval);
        const timeTaken = Math.floor((Date.now() - testStartTime) / 1000);
        document.getElementById('lessonArea').style.display = 'none';

        const texts = UI_TEXT[currentLang] || UI_TEXT.en;

        const correctAnswers = testResults.filter(r => r.status === 'correct').length;
        const totalQuestions = testData.stages.length;
        const scorePercentage = totalQuestions > 0 ? Math.round((correctAnswers / totalQuestions) * 100) : 0;

        // Populate Summary Screen Header
        document.getElementById('results-title').textContent = texts.testComplete;
        document.getElementById('resultsScore').textContent = `${texts.score} ${correctAnswers} / ${totalQuestions} (${scorePercentage}%)`;
        const minutes = Math.floor(timeTaken / 60).toString().padStart(2, '0');
        const seconds = (timeTaken % 60).toString().padStart(2, '0');
        document.getElementById('resultsTime').textContent = `${texts.timeTaken} ${minutes}:${seconds}`;

        // Populate Summary List
        resultsFeedbackList.innerHTML = ''; // Clear previous content
        testResults.forEach((result, index) => {
            const item = document.createElement('div');
            item.className = 'summary-item';
            item.setAttribute('data-index', index);

            const statusClass = result.status === 'correct' ? 'status-correct' : 'status-incorrect';
            
            item.innerHTML = `
                <span class="summary-item-text">${texts.question} ${index + 1}</span>
                <span class="summary-item-status ${statusClass}">${result.status.charAt(0).toUpperCase() + result.status.slice(1)}</span>
            `;
            resultsFeedbackList.appendChild(item);
        });

        resultsScreen.classList.remove('hidden');

        // Backend submission logic (unchanged)
        const user = auth.currentUser;
        if (user) {
            try {
                const submitTestResults = firebase.functions().httpsCallable('submitTestResults');
                submitTestResults({
                    testId: new URLSearchParams(window.location.search).get('testFile')?.replace('.json', ''),
                    score: correctAnswers,
                    totalQuestions,
                    timeTakenSeconds: timeTaken,
                    results: testResults,
                    language: currentLang
                }).then(response => {
                    console.log("Test results submitted for deep analysis.", response);
                    const resultId = response.data.resultId;
                    if (resultId) {
                        listenForDetailedFeedback(user.uid, resultId);
                    }
                });
            } catch (err) {
                console.error("Error submitting test results for analysis:", err);
            }
        }
    }

    function showDetailView(index) {
        currentDetailIndex = index;
        const result = testResults[index];
        if (!result) return;
        
        const texts = UI_TEXT[currentLang] || UI_TEXT.en;

        // Populate detail view
        document.getElementById('detail-question-title').textContent = `${texts.question} ${index + 1}`;
        const statusText = result.status.charAt(0).toUpperCase() + result.status.slice(1);
        const statusEl = document.getElementById('detail-status-text');
        statusEl.textContent = statusText;
        statusEl.style.color = result.status === 'correct' ? 'var(--success-green)' : 'var(--error-red)';
        
        document.getElementById('detail-your-solution-title').textContent = texts.yourSolution;
        document.getElementById('detail-ai-feedback-title').textContent = texts.aiFeedback;
        document.getElementById('user-solution-img').src = result.solutionImage;
        document.getElementById('ai-feedback-text').textContent = result.feedback || texts.generatingFeedback;

        // Update navigation buttons
        detailBackBtn.textContent = texts.backToSummary;
        detailPrevBtn.textContent = texts.prev;
        detailNextBtn.textContent = texts.submit; // Or "Next"
        
        detailPrevBtn.disabled = index === 0;
        detailNextBtn.disabled = index === testResults.length - 1;

        // Switch screens
        resultsScreen.classList.add('hidden');
        detailViewScreen.classList.remove('hidden');
    }

    function showSummaryView() {
        detailViewScreen.classList.add('hidden');
        resultsScreen.classList.remove('hidden');
        currentDetailIndex = -1;
    }

    function listenForDetailedFeedback(uid, resultId) {
        const solutionsRef = db.collection('thelo-students').doc(uid).collection('test_results').doc(resultId).collection('solutions');
        solutionsRef.onSnapshot(snapshot => {
            snapshot.docChanges().forEach(change => {
                if (change.type === "modified" || change.type === "added") {
                    const solutionData = change.doc.data();
                    const index = parseInt(change.doc.id, 10);
                    
                    if (solutionData.detailedFeedback && testResults[index]) {
                         // Update the locally stored feedback
                        testResults[index].feedback = solutionData.detailedFeedback;
                        // If user is currently viewing this detail page, update the text
                        if(currentDetailIndex === index) {
                            document.getElementById('ai-feedback-text').textContent = solutionData.detailedFeedback;
                        }
                    }
                }
            });
        });
    }

    // ===================================================================
    //  Canvas and Event Listener Setup
    // ===================================================================
    function resizeCanvases() {
        checkTabletMode();
        if (!boardWrapper) return;
        const rect = boardWrapper.getBoundingClientRect();
        const cssWidth = Math.floor(rect.width); const cssHeight = Math.floor(rect.height);
        devicePixelRatio = window.devicePixelRatio || 1;
        const internalWidth = cssWidth * devicePixelRatio; const internalHeight = cssHeight * devicePixelRatio;
        [backgroundCanvas, canvas].forEach(c => {
            c.width = internalWidth; c.height = internalHeight;
            c.style.width = `${cssWidth}px`; c.style.height = `${cssHeight}px`;
        });
        setupContexts();
        if (currentStageIndex >= 0) renderStageUI(currentStageIndex);
    }

    function setupContexts() {
        [bgCtx, ctx].forEach(context => {
            context.resetTransform();
            context.scale(devicePixelRatio, devicePixelRatio);
        });
        ctx.lineWidth = 3; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.strokeStyle = '#000000';
    }

    function getPos(e, targetCanvas) {
        const rect = targetCanvas.getBoundingClientRect();
        let clientX, clientY;
        if (e.touches && e.touches.length > 0) { clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; }
        else if (e.changedTouches && e.changedTouches.length > 0) { clientX = e.changedTouches[0].clientX; clientY = e.changedTouches[0].clientY; }
        else { clientX = e.clientX; clientY = e.clientY; }
        if (typeof clientX !== 'number' || typeof clientY !== 'number') return null;
        return { x: clientX - rect.left, y: clientY - rect.top };
    }

    function handleDrawingStart(e) {
        if (isTabletMode && e.type.startsWith('touch')) {
            if (!Array.from(e.touches).some(t => t.touchType === 'stylus')) { e.preventDefault(); return; }
        }
        const pos = getPos(e, canvas);
        if (!pos) return;
        if (e.touches) e.preventDefault();
        drawing = true;
        if (e.pointerType === 'pen') canvas.classList.add('no-cursor');
        userDrawingOccurred = true;
        lastPos = pos;
        ctx.beginPath();
        ctx.moveTo(pos.x, pos.y);
    }

    function handleDrawingMove(e) {
        if (!drawing) return;
        if (isTabletMode) {
            if (buttonVanishTimer) clearTimeout(buttonVanishTimer);
            if (bottomBar && !bottomBar.classList.contains('bar-hidden-by-stylus')) {
                bottomBar.classList.add('bar-hidden-by-stylus');
            }
        }
        const pos = getPos(e, canvas);
        if (!pos) return;
        if (e.touches) e.preventDefault();
        const midPoint = { x: (lastPos.x + pos.x) / 2, y: (lastPos.y + pos.y) / 2 };
        ctx.quadraticCurveTo(lastPos.x, lastPos.y, midPoint.x, midPoint.y);
        ctx.stroke();
        ctx.moveTo(midPoint.x, midPoint.y);
        lastPos = pos;
    }

    function handleDrawingEnd(e) {
        canvas.classList.remove('no-cursor');
        if (isTabletMode) {
            if (buttonVanishTimer) clearTimeout(buttonVanishTimer);
            buttonVanishTimer = setTimeout(() => {
                if (bottomBar) bottomBar.classList.remove('bar-hidden-by-stylus');
            }, 500);
        }
        if (!drawing) return;
        drawing = false;
        ctx.lineTo(lastPos.x, lastPos.y);
        ctx.stroke();
        ctx.closePath();
    }
    
    function clearUserCanvas() {
        ctx.clearRect(0, 0, canvas.width / devicePixelRatio, canvas.height / devicePixelRatio);
        userDrawingOccurred = false;
    }

    function updateAllUITexts() {
        const texts = UI_TEXT[currentLang] || UI_TEXT.en;
        submitBtn.textContent = (currentStageIndex === -1) ? texts.start : texts.submit;
        prevBtn.textContent = texts.prev;
        clearBtn.textContent = texts.clear;
        detailNextBtn.textContent = texts.prev;
    }

    function checkTabletMode() {
        const tabletQuery = window.matchMedia('(min-width: 769px) and (max-width: 1200px) and (pointer: coarse)');
        const landscapeQuery = window.matchMedia('(min-width: 769px) and (max-width: 1200px) and (min-height: 500px)');
        isTabletMode = tabletQuery.matches || landscapeQuery.matches;
    }

    function initApp() {
        resizeCanvases();
        // Test-taking listeners
        canvas.addEventListener('mousedown', handleDrawingStart);
        canvas.addEventListener('mousemove', handleDrawingMove);
        canvas.addEventListener('touchstart', handleDrawingStart, { passive: false });
        canvas.addEventListener('touchmove', handleDrawingMove, { passive: false });
        window.addEventListener('mouseup', handleDrawingEnd);
        window.addEventListener('mouseleave', handleDrawingEnd);
        window.addEventListener('touchend', handleDrawingEnd);
        window.addEventListener('touchcancel', handleDrawingEnd);
        prevBtn.onclick = () => transitionToStage(currentStageIndex - 1);
        submitBtn.onclick = handleSubmitClick;
        clearBtn.onclick = clearUserCanvas;

        // NEW: Results screen listeners
        resultsFeedbackList.addEventListener('click', (e) => {
            const item = e.target.closest('.summary-item');
            if (item) {
                const index = parseInt(item.getAttribute('data-index'), 10);
                showDetailView(index);
            }
        });
        detailBackBtn.onclick = showSummaryView;
        detailPrevBtn.onclick = () => showDetailView(currentDetailIndex - 1);
        detailNextBtn.onclick = () => showDetailView(currentDetailIndex + 1);

        window.addEventListener('resize', resizeCanvases);
        const urlParams = new URLSearchParams(window.location.search);
        const testFileName = urlParams.get('testFile');
        if (testFileName) {
            loadTest(`https://thelo.space/tests/${testFileName}`);
        } else {
            alert("No test file specified in the URL. Please add '?testFile=your-test.json'.");
            loadingOverlay.classList.add('hidden');
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        updateAllUITexts(); // Set initial button text
        auth.onAuthStateChanged(user => {
            initApp();
        });
    });
</script>
</body>
</html>
