<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link rel="icon" href="https://thelo.space/img/thelofavicon.png" type="image/png">
    <link rel="apple-touch-icon" href="https://thelo.space/img/yarnicon.png">
    <title>thelo | Test Mode</title>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-functions-compat.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@300;400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<style>
    :root {
        --thelo-blue: #2563eb; --thelo-blue-dark: #1d4ed8; --thelo-bg: #ffffff;
        --thelo-text: #111827; --thelo-text-light: #6b7280; --thelo-border: #e5e7eb;
        --success-green: #22c55e; --error-red: #ef4444; --accent-yellow: #f59e0b;
        --bg-white: #ffffff; --ink-black: #000000;
        --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
        --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        --fade-duration: 0.3s;
    }
    @font-face { font-family: 'Montserrat Arm'; src: url('https://thelo.space/fonts/Montserratarm-Regular.otf') format('opentype'); font-weight: 400; }
    @font-face { font-family: 'Montserrat Arm'; src: url('https://thelo.space/fonts/Montserratarm-SemiBold.otf') format('opentype'); font-weight: 600; }
    @font-face { font-family: 'Montserrat Arm'; src: url('https://thelo.space/fonts/Montserratarm-ExtraBold.otf') format('opentype'); font-weight: 800; }
    body.lang-hy { font-family: 'Montserrat Arm', 'Manrope', system-ui, -apple-system, sans-serif; }
    #loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--thelo-bg); display: flex; justify-content: center; align-items: center; z-index: 9999; opacity: 1; transition: opacity 0.5s ease-out; }
    #loading-overlay.hidden { opacity: 0; pointer-events: none; }
    #loading-svg { width: 150px; height: auto; animation: pulse-loader 1.5s infinite ease-in-out; }
    @keyframes pulse-loader { 0%, 100% { transform: scale(1); opacity: 0.8; } 50% { transform: scale(1.1); opacity: 1; } }
    html { font-size: 16px; background: var(--thelo-bg); }
    body { margin: 0; height: 100vh; font-family: 'Manrope', system-ui, sans-serif; display: flex; flex-direction: column; overflow: hidden; background-color: var(--thelo-bg); color: var(--thelo-text); user-select: none; -webkit-user-select: none; }
    #app { display: flex; flex-grow: 1; height: 100%; }
    #lessonArea { position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; flex-direction: column; overflow: hidden; }
    #boardWrap { position: relative; flex-grow: 1; overflow: hidden; background-color: var(--thelo-bg); background-image: linear-gradient(to right, var(--thelo-border) 1px, transparent 1px), linear-gradient(to bottom, var(--thelo-border) 1px, transparent 1px); background-size: 40px 40px; }
    #backgroundCanvas, #board { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; background-color: transparent; }
    #backgroundCanvas { z-index: 1; pointer-events: none; opacity: 1; transition: opacity var(--fade-duration) ease-in-out; }
    #backgroundCanvas.fade-out { opacity: 0; }
    #board { z-index: 3; cursor: crosshair; touch-action: none; }
    #bottomBar { position: absolute; bottom: 0; left: 0; width: 100%; background-color: transparent; box-sizing: border-box; padding: 1rem 1.5rem; display: flex; justify-content: space-between; align-items: center; z-index: 20; transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1); }
    #button-group { display: flex; gap: 0.5rem; }
    .control-btn { font-family: inherit; padding: 0.5rem 1rem; font-size: 0.9rem; font-weight: 500; border: none; border-radius: 0.5rem; color: var(--bg-white); cursor: pointer; transition: all 0.2s; box-shadow: var(--shadow-md); touch-action: manipulation; }
    .control-btn:hover:not(:disabled) { transform: translateY(-2px); box-shadow: var(--shadow-lg); }
    .control-btn:disabled { background-color: #9ca3af !important; cursor: not-allowed; opacity: 0.7; }
    #prevBtn, #undoBtn { background-color: #6b7280; }
    #unsureBtn { background-color: var(--accent-yellow); }
    #clearBtn, #redoBtn { background-color: var(--error-red); }
    #submitBtn { background-color: var(--thelo-blue); }
    #timerDisplay { background-color: rgba(255, 255, 255, 0.8); backdrop-filter: blur(10px); padding: 0.5rem 1.25rem; border-radius: 999px; font-size: 1.2rem; font-weight: 700; color: var(--thelo-text); box-shadow: var(--shadow-md); border: 1px solid var(--thelo-border); }
    
    /* ✨ NEW: Screen Styles */
    .screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 50; background-color: var(--thelo-bg); display: none; flex-direction: column; align-items: center; padding: 2rem; box-sizing: border-box; }
    .screen-container { width: 100%; max-width: 800px; text-align: center; }
    .screen-header { border-bottom: 2px solid var(--thelo-border); padding-bottom: 1rem; margin-bottom: 1.5rem; }
    #resultsScore { font-size: 2.5rem; font-weight: 800; color: var(--thelo-blue); }
    #resultsTime { font-size: 1.2rem; color: var(--thelo-text-light); }
    .feedback-list { flex-grow: 1; width: 100%; overflow-y: auto; text-align: left; }
    .feedback-item { background-color: #f9fafb; border: 1px solid var(--thelo-border); border-radius: 0.75rem; padding: 1rem 1.5rem; margin-bottom: 1rem; }
    .feedback-item-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; }
    .feedback-item-header h3 { margin: 0; font-size: 1.1rem; }
    .status-correct { color: var(--success-green); font-weight: 700; }
    .status-incorrect { color: var(--error-red); font-weight: 700; }
    
    /* ✨ NEW: Navigation Panel */
    #navToggleBtn { position: fixed; top: 20px; right: 20px; z-index: 1001; background-color: var(--thelo-blue); color: white; border: none; border-radius: 50%; width: 50px; height: 50px; font-size: 24px; box-shadow: var(--shadow-lg); cursor: pointer; }
    #navPanel { position: fixed; top: 0; right: -320px; width: 300px; height: 100%; background: #f9fafb; z-index: 1000; box-shadow: var(--shadow-lg); transition: right 0.3s ease-in-out; display: flex; flex-direction: column; padding: 20px; box-sizing: border-box; border-left: 1px solid var(--thelo-border); }
    #navPanel.open { right: 0; }
    #navGrid { display: grid; grid-template-columns: repeat(auto-fill, minmax(45px, 1fr)); gap: 10px; overflow-y: auto; padding: 10px; }
    .nav-item { width: 45px; height: 45px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 600; cursor: pointer; transition: all 0.2s; border: 2px solid var(--thelo-border); }
    .nav-item.unanswered { background-color: #e5e7eb; color: #6b7280; }
    .nav-item.answered { background-color: var(--success-green); color: white; border-color: var(--success-green); }
    .nav-item.unsure { background-color: var(--accent-yellow); color: white; border-color: var(--accent-yellow); }
    .nav-item.current { transform: scale(1.1); box-shadow: 0 0 10px var(--thelo-blue); border-color: var(--thelo-blue); }

    /* ✨ NEW: Notes Panel */
    #notesPanel { position: fixed; bottom: 90px; right: 20px; width: 300px; height: 40%; background: white; z-index: 1002; box-shadow: var(--shadow-lg); border-radius: 1rem; display: none; flex-direction: column; border: 1px solid var(--thelo-border); }
    #notesPanel.open { display: flex; }
    #notesPanel h4 { margin: 0; padding: 1rem; background-color: #f3f4f6; border-bottom: 1px solid var(--thelo-border); border-radius: 1rem 1rem 0 0;}
    #notesInput { flex-grow: 1; border: none; padding: 1rem; font-family: inherit; font-size: 1rem; resize: none; border-radius: 0 0 1rem 1rem; }
    #notesInput:focus { outline: none; }
    
    /* ✨ NEW: Review Screen Specifics */
    #reviewContainer { display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: auto 1fr; gap: 1rem; width: 100%; max-width: 1200px; height: calc(100vh - 150px); }
    #reviewHeader { grid-column: 1 / -1; }
    #reviewStudentSolution, #reviewCorrectSolution { border: 1px solid var(--thelo-border); border-radius: 0.5rem; padding: 1rem; overflow-y: auto; }
    #reviewStudentSolution h4, #reviewCorrectSolution h4 { margin-top: 0; }
    #reviewStudentDrawing { max-width: 100%; border: 1px solid #ccc; }
    #reviewStudentNotes { background-color: #fefce8; padding: 0.5rem; border-radius: 0.25rem; white-space: pre-wrap; }
    #reviewNav { position: absolute; bottom: 2rem; width: 100%; display: flex; justify-content: center; gap: 1rem; }
    
</style>
</head>
<body>
    <div id="loading-overlay">
        <img id="loading-svg" src="https://thelo.space/img/bluethelo.svg" alt="Loading...">
    </div>

    <div id="app">
        <div id="lessonArea">
            <div id="boardWrap">
                <canvas id="backgroundCanvas"></canvas>
                <canvas id="board"></canvas>
            </div>
            <div id="bottomBar">
                <div id="timerDisplay">00:00</div>
                <div id="button-group">
                    <button id="prevBtn" class="control-btn" title="Previous Question (←)"></button>
                    <button id="undoBtn" class="control-btn" title="Undo (Ctrl+Z)">↶</button>
                    <button id="redoBtn" class="control-btn" title="Redo (Ctrl+Y)">↷</button>
                    <button id="clearBtn" class="control-btn"></button>
                    <button id="unsureBtn" class="control-btn" title="Mark as Unsure (U)"></button>
                    <button id="submitBtn" class="control-btn" title="Next Question (→)"></button>
                </div>
            </div>
        </div>
        
        <button id="navToggleBtn" title="Toggle Problem List">☰</button>
        <div id="navPanel">
            <h3>Problems</h3>
            <div id="navGrid"></div>
        </div>
        
        <div id="notesPanel">
            <h4>My Notes (Toggle with 'A')</h4>
            <textarea id="notesInput" placeholder="Type your notes for this problem here..."></textarea>
        </div>

        <div id="resultsOverviewScreen" class="screen">
            <div class="screen-container">
                <div class="screen-header">
                    <h1 id="resultsHeaderTitle"></h1>
                    <div id="resultsScore"></div>
                    <div id="resultsTime"></div>
                </div>
                <div id="resultsNavGrid" style="margin-bottom: 2rem;"></div>
                <button id="reviewAnswersBtn" class="control-btn" style="background-color: var(--thelo-blue);">Review Answers</button>
            </div>
        </div>

        <div id="reviewScreen" class="screen">
             <div id="reviewContainer">
                <div id="reviewHeader">
                    <h2 id="reviewProblemTitle"></h2>
                </div>
                <div id="reviewStudentSolution">
                    <h4>Your Solution</h4>
                    <img id="reviewStudentDrawing" src="" alt="Your drawing">
                    <h4>Your Notes</h4>
                    <p id="reviewStudentNotes"></p>
                </div>
                <div id="reviewCorrectSolution">
                    <h4>AI Feedback & Correct Answer</h4>
                    <p id="reviewAIFeedback"></p>
                    <p><strong>Correct Answer:</strong> <span id="reviewCorrectAnswer"></span></p>
                </div>
            </div>
            <div id="reviewNav">
                <button id="reviewPrevBtn" class="control-btn">← Previous</button>
                <button id="reviewNextBtn" class="control-btn">Next →</button>
            </div>
        </div>
    </div>

<script>
    const firebaseConfig = { apiKey: "AIzaSyAbnPpcIt88B0jIAoLUdC71zmQDvR_fdu8", authDomain: "physmathacademy-722b3.firebaseapp.com", projectId: "physmathacademy-722b3", messagingSenderId: "1093640992262", appId: "1:1093640992262:web:35b1bf4d2364bcf745f587" };
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    /* ========== DOM Elements ========== */
    const loadingOverlay = document.getElementById('loading-overlay');
    const backgroundCanvas = document.getElementById('backgroundCanvas');
    const canvas = document.getElementById('board');
    const prevBtn = document.getElementById('prevBtn');
    const submitBtn = document.getElementById('submitBtn');
    const clearBtn = document.getElementById('clearBtn');
    const timerDisplay = document.getElementById('timerDisplay');
    const lessonArea = document.getElementById('lessonArea');
    const bgCtx = backgroundCanvas.getContext('2d');
    const ctx = canvas.getContext('2d');
    
    // ✨ NEW DOM Elements
    const unsureBtn = document.getElementById('unsureBtn');
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');
    const navToggleBtn = document.getElementById('navToggleBtn');
    const navPanel = document.getElementById('navPanel');
    const navGrid = document.getElementById('navGrid');
    const notesPanel = document.getElementById('notesPanel');
    const notesInput = document.getElementById('notesInput');
    const resultsOverviewScreen = document.getElementById('resultsOverviewScreen');
    const reviewScreen = document.getElementById('reviewScreen');
    
    /* ========== State Variables ========== */
    let testData = null;
    let currentStageIndex = 0;
    let drawing = false;
    let isTransitioning = false;
    let devicePixelRatio = window.devicePixelRatio || 1;
    let timerInterval = null;
    let testStartTime = null;
    let testId = null;
    let currentLang = 'en';

    // ✨ NEW State Management
    let problemStates = []; // Core state for all problems
    let undoStack = [];
    let redoStack = [];
    const UNDO_LIMIT = 30;

    const UI_TEXT = {
        en: { start: "Start Test", submit: "Next", checking: "Checking...", prev: "Previous", clear: "Clear", testComplete: "Test Complete!", score: "Score:", timeTaken: "Time Taken:", provideSolution: "Please draw a solution before continuing.", question: "Question", aiFeedback: "AI Feedback:", generatingFeedback: "Generating detailed feedback...", analysisError: "Could not submit for analysis.", finishTest: "Finish Test", unsure: "I'm Unsure", reviewAnswers: "Review Answers" },
        hy: { start: "Սկսել թեստը", submit: "Հաջորդը", checking: "Ստուգվում է...", prev: "Նախորդ", clear: "Մաքրել", testComplete: "Թեստն ավարտված է", score: "Միավոր:", timeTaken: "Ժամանակ:", provideSolution: "Խնդրում ենք լուծումը գրել նոր շարունակել։", question: "Հարց", aiFeedback: "Արհեստական բանականության վերլուծություն:", generatingFeedback: "Ստեղծվում է մանրամասն վերլուծություն...", analysisError: "Չհաջողվեց ուղարկել վերլուծության։", finishTest: "Ավարտել թեստը", unsure: "Վստահ չեմ", reviewAnswers: "Դիտել պատասխանները" }
    };

    // KaTeX functions (unchanged)...

    /* ========== Main Application Logic ========== */
    
    function getLocalStorageKey() {
        return `thelo-test-progress-${testId}`;
    }

    function saveStateToLocalStorage() {
        try {
            const stateToSave = {
                currentStageIndex,
                problemStates,
                testStartTime
            };
            localStorage.setItem(getLocalStorageKey(), JSON.stringify(stateToSave));
        } catch (e) {
            console.error("Failed to save state:", e);
        }
    }

    function loadStateFromLocalStorage() {
        try {
            const savedState = localStorage.getItem(getLocalStorageKey());
            if (savedState) {
                const parsedState = JSON.parse(savedState);
                problemStates = parsedState.problemStates || [];
                currentStageIndex = parsedState.currentStageIndex || 0;
                testStartTime = parsedState.testStartTime || null;
                // Ensure problemStates has the correct length if test was updated
                while (problemStates.length < testData.stages.length) {
                    problemStates.push({ status: 'unanswered', drawingDataUrl: null, notes: '' });
                }
                return true;
            }
        } catch (e) {
            console.error("Failed to load state:", e);
            // If loading fails, clear the corrupted state
            localStorage.removeItem(getLocalStorageKey());
        }
        return false;
    }

    async function loadTest(testJsonPath) {
        testId = new URLSearchParams(window.location.search).get('testFile')?.replace('.json', '');
        isTransitioning = true;
        try {
            const response = await fetch(testJsonPath);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            testData = await response.json();
            if (!testData || !Array.isArray(testData.stages)) throw new Error("Invalid test format.");
            
            currentLang = testData.lang === 'hy' ? 'hy' : 'en';
            document.body.className = currentLang === 'hy' ? 'lang-hy' : '';
            document.title = testData.testTitle || "thelo | Test Mode";
            
            if (!loadStateFromLocalStorage()) {
                // Initialize fresh state if nothing is loaded
                problemStates = testData.stages.map(() => ({
                    status: 'unanswered', // can be 'answered', 'unanswered', 'unsure'
                    drawingDataUrl: null,
                    notes: '',
                }));
                currentStageIndex = 0;
            }
            
            updateAllUITexts();
            renderNavPanel();
            if(testStartTime) {
                // We've loaded a session in progress
                timerInterval = setInterval(updateTimerDisplay, 1000);
                transitionToStage(currentStageIndex, true); // Don't save on initial load
            } else {
                // Show start screen
                 renderStageUI(0); // Show first question but don't start timer
            }

        } catch (error) {
            console.error("Error loading test:", error);
            alert("Failed to load the test file.");
        } finally {
            isTransitioning = false;
            loadingOverlay.classList.add('hidden');
        }
    }

    function startTest() {
        if (testStartTime) return; // Test already started
        testStartTime = Date.now();
        timerInterval = setInterval(updateTimerDisplay, 1000);
        saveStateToLocalStorage();
        transitionToStage(0);
    }
    
    function updateTimerDisplay() {
        if (!testStartTime) return;
        const elapsed = Math.floor((Date.now() - testStartTime) / 1000);
        const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
        const seconds = (elapsed % 60).toString().padStart(2, '0');
        timerDisplay.textContent = `${minutes}:${seconds}`;
    }

    async function renderStageUI(index) {
        currentStageIndex = index;
        const currentProblemState = problemStates[index];
        
        // Render headline
        bgCtx.clearRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
        const headlineText = `${UI_TEXT[currentLang].question} ${index + 1}: ${testData.stages[index].headline || ''}`;
        const baseFont = currentLang === 'hy' ? "Montserrat Arm" : "Manrope";
        bgCtx.font = `24px '${baseFont}', system-ui, sans-serif`;
        await renderComplexHeadline(bgCtx, headlineText, 65);
        
        // Restore drawing if it exists
        clearUserCanvas(true); // Clear without affecting undo stack
        if (currentProblemState.drawingDataUrl) {
            const img = new Image();
            img.onload = () => {
                ctx.drawImage(img, 0, 0, canvas.width / devicePixelRatio, canvas.height / devicePixelRatio);
                pushToUndoStack(); // Add restored drawing as initial state
            };
            img.src = currentProblemState.drawingDataUrl;
        } else {
             pushToUndoStack(); // Add blank state as initial
        }
        
        // Restore notes
        notesInput.value = currentProblemState.notes;
        
        // Update UI
        updateAllUITexts();
        renderNavPanel();
    }
    
    function transitionToStage(newIndex, isInitialLoad = false) {
        if (isTransitioning || newIndex < 0 || newIndex >= testData.stages.length) return;
        
        if (!isInitialLoad) {
            saveCurrentProblemState();
        }

        isTransitioning = true;
        backgroundCanvas.classList.add('fade-out');
        
        setTimeout(() => {
            renderStageUI(newIndex).then(() => {
                backgroundCanvas.classList.remove('fade-out');
                isTransitioning = false;
            });
        }, 300);
    }

    function saveCurrentProblemState() {
        const hasDrawing = !isCanvasBlank();
        const state = problemStates[currentStageIndex];
        
        if (hasDrawing) {
            state.drawingDataUrl = canvas.toDataURL();
            if (state.status === 'unanswered') {
                state.status = 'answered';
            }
        }
        state.notes = notesInput.value;
        saveStateToLocalStorage();
    }

    function handleNextClick() {
        if (!testStartTime) {
            startTest();
            return;
        }
        if (currentStageIndex < testData.stages.length - 1) {
            transitionToStage(currentStageIndex + 1);
        } else {
            // This is the "Finish Test" click
            saveCurrentProblemState();
            finishTest();
        }
    }

    async function finishTest() {
        clearInterval(timerInterval);
        loadingOverlay.classList.remove('hidden');
        lessonArea.style.display = 'none';

        const finalResults = [];
        problemStates.forEach((state, index) => {
            if (state.status !== 'unanswered') {
                finalResults.push({
                    index, // Keep track of original index
                    question: testData.stages[index].headline,
                    correctAnswer: testData.stages[index].correctAnswer,
                    solutionImage: state.drawingDataUrl,
                    notes: state.notes,
                    initialStatus: state.status // 'answered' or 'unsure'
                });
            }
        });
        
        // TODO: Call backend with finalResults
        // For now, let's simulate a response with mock AI feedback
        setTimeout(() => {
             finalResults.forEach(r => {
                r.aiStatus = Math.random() > 0.5 ? 'correct' : 'incorrect';
                r.aiFeedback = `This is simulated AI feedback for question ${r.index + 1}. You did a great job!`;
            });
            renderResultsOverview(finalResults);
            loadingOverlay.classList.add('hidden');
            localStorage.removeItem(getLocalStorageKey()); // Clear session on completion
        }, 2000);
    }

    function renderResultsOverview(results) {
        const texts = UI_TEXT[currentLang];
        const correctAnswers = results.filter(r => r.aiStatus === 'correct').length;
        const totalAnswered = results.length;
        const scorePercentage = totalAnswered > 0 ? Math.round((correctAnswers / totalAnswered) * 100) : 0;
        
        document.getElementById('resultsHeaderTitle').textContent = texts.testComplete;
        document.getElementById('resultsScore').textContent = `${texts.score} ${correctAnswers} / ${testData.stages.length} (${scorePercentage}%)`;
        document.getElementById('resultsTime').textContent = `${texts.timeTaken} ${timerDisplay.textContent}`;
        
        // Render nav grid for results overview
        const resultsNavGrid = document.getElementById('resultsNavGrid');
        resultsNavGrid.innerHTML = '';
        resultsNavGrid.className = 'nav-grid-results'; // You might want to style this differently
        
        for (let i = 0; i < testData.stages.length; i++) {
            const item = document.createElement('div');
            item.textContent = i + 1;
            const result = results.find(r => r.index === i);
            let statusClass = 'unanswered';
            if (result) {
                statusClass = result.aiStatus === 'correct' ? 'answered' : 'incorrect-result'; // new class for styling
            }
            item.className = `nav-item ${statusClass}`;
            resultsNavGrid.appendChild(item);
        }
        
        resultsOverviewScreen.style.display = 'flex';
        
        document.getElementById('reviewAnswersBtn').onclick = () => {
            resultsOverviewScreen.style.display = 'none';
            renderReviewScreen(0, results);
        };
    }

    function renderReviewScreen(index, results) {
        const result = results.find(r => r.index === index);
        if (!result) return; // Should not happen if navigated correctly

        document.getElementById('reviewProblemTitle').textContent = `Question ${index + 1}: ${result.question}`;
        document.getElementById('reviewStudentDrawing').src = result.solutionImage;
        document.getElementById('reviewStudentNotes').textContent = result.notes || "No notes taken.";
        document.getElementById('reviewAIFeedback').textContent = result.aiFeedback;
        document.getElementById('reviewCorrectAnswer').textContent = result.correctAnswer;
        
        reviewScreen.style.display = 'flex';
        
        document.getElementById('reviewPrevBtn').disabled = index === 0;
        document.getElementById('reviewNextBtn').disabled = index === results.length - 1;
        
        document.getElementById('reviewPrevBtn').onclick = () => renderReviewScreen(index - 1, results);
        document.getElementById('reviewNextBtn').onclick = () => renderReviewScreen(index + 1, results);
    }

    function renderNavPanel() {
        navGrid.innerHTML = '';
        problemStates.forEach((state, index) => {
            const item = document.createElement('div');
            item.textContent = index + 1;
            item.className = 'nav-item';
            item.classList.add(state.status);
            if (index === currentStageIndex) {
                item.classList.add('current');
            }
            item.onclick = () => transitionToStage(index);
            navGrid.appendChild(item);
        });
    }
    
    function isCanvasBlank() {
        const pixelBuffer = new Uint32Array(ctx.getImageData(0, 0, canvas.width, canvas.height).data.buffer);
        return !pixelBuffer.some(color => color !== 0);
    }

    /* Drawing and Canvas Logic */
    function setupContexts() { /* ... unchanged ... */ }
    function resizeCanvases() { /* ... unchanged ... */ }
    function getPos(e, targetCanvas) { /* ... unchanged ... */ }
    
    function pushToUndoStack() {
        if(undoStack.length >= UNDO_LIMIT) {
            undoStack.shift(); // Remove oldest state
        }
        undoStack.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
        redoStack = []; // Clear redo stack on new action
        updateUndoRedoButtons();
    }
    
    function handleUndo() {
        if (undoStack.length <= 1) return; // Keep the last state
        const lastState = undoStack.pop();
        redoStack.push(lastState);
        const prevState = undoStack[undoStack.length - 1];
        ctx.putImageData(prevState, 0, 0);
        updateUndoRedoButtons();
    }
    
    function handleRedo() {
        if (redoStack.length === 0) return;
        const nextState = redoStack.pop();
        undoStack.push(nextState);
        ctx.putImageData(nextState, 0, 0);
        updateUndoRedoButtons();
    }
    
    function updateUndoRedoButtons() {
        undoBtn.disabled = undoStack.length <= 1;
        redoBtn.disabled = redoStack.length === 0;
    }
    
    function handleDrawingStart(e) { /* ... unchanged, but remove userDrawingOccurred ... */ }
    function handleDrawingMove(e) { /* ... unchanged ... */ }
    function handleDrawingEnd(e) {
        if (!drawing) return;
        drawing = false;
        ctx.closePath();
        pushToUndoStack(); // Save state after a stroke is completed
    }
    
    function clearUserCanvas(isInternal = false) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if(!isInternal) {
            pushToUndoStack();
        }
    }
    
    function updateAllUITexts() {
        const texts = UI_TEXT[currentLang];
        prevBtn.textContent = texts.prev;
        clearBtn.textContent = texts.clear;
        unsureBtn.textContent = texts.unsure;
        
        if (currentStageIndex === -1 || !testStartTime) {
            submitBtn.textContent = texts.start;
        } else if (currentStageIndex === testData.stages.length - 1) {
            submitBtn.textContent = texts.finishTest;
        } else {
            submitBtn.textContent = texts.submit;
        }
    }

    function initApp() {
        resizeCanvases();
        
        // Event Listeners
        canvas.addEventListener('mousedown', handleDrawingStart);
        canvas.addEventListener('mousemove', handleDrawingMove);
        window.addEventListener('mouseup', handleDrawingEnd);
        
        prevBtn.onclick = () => transitionToStage(currentStageIndex - 1);
        submitBtn.onclick = handleNextClick;
        clearBtn.onclick = () => clearUserCanvas();
        undoBtn.onclick = handleUndo;
        redoBtn.onclick = handleRedo;
        
        unsureBtn.onclick = () => {
            const state = problemStates[currentStageIndex];
            state.status = (state.status === 'unsure') ? 'answered' : 'unsure';
            saveStateToLocalStorage();
            renderNavPanel();
        };

        navToggleBtn.onclick = () => navPanel.classList.toggle('open');
        
        notesInput.addEventListener('input', () => {
            problemStates[currentStageIndex].notes = notesInput.value;
            saveStateToLocalStorage(); // Auto-save notes
        });

        window.addEventListener('keydown', (e) => {
            // Prevent shortcuts while typing in notes
            if (document.activeElement === notesInput) return;

            if (e.key === 'a' || e.key === 'A') {
                e.preventDefault();
                notesPanel.classList.toggle('open');
            }
            if (e.key === 'u' || e.key === 'U') {
                e.preventDefault();
                unsureBtn.click();
            }
            if (e.key === 'ArrowRight') {
                e.preventDefault();
                submitBtn.click();
            }
            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                prevBtn.click();
            }
            if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                handleUndo();
            }
            if (e.ctrlKey && e.key === 'y') {
                e.preventDefault();
                handleRedo();
            }
        });
        
        window.addEventListener('resize', resizeCanvases);
        
        const urlParams = new URLSearchParams(window.location.search);
        const testFileName = urlParams.get('testFile');
        if (testFileName) {
            loadTest(`https://thelo.space/tests/${testFileName}`);
        } else {
            alert("No test file specified. Add '?testFile=your-test.json'.");
            loadingOverlay.classList.add('hidden');
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        auth.onAuthStateChanged(user => {
            initApp();
        });
    });
</script>
</body>
</html>
