<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link rel="icon" href="https://thelo.space/img/thelofavicon.png" type="image/png">
    <title>thelo | Test Mode</title>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-functions-compat.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@300;400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"></script>

<style>
  /* ALL ORIGINAL STYLES ARE PRESERVED FOR IDENTICAL APPEARANCE */
  :root {
    --thelo-blue: #2563eb; --thelo-blue-dark: #1d4ed8; --thelo-bg: #ffffff;
    --thelo-text: #111827; --thelo-text-light: #6b7280; --thelo-border: #e5e7eb;
    --success-green: #22c55e; --error-red: #ef4444; --accent-yellow: #f59e0b;
    --bg-white: #ffffff; --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
    --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
    --fade-duration: 0.3s; --animation-duration: 0.3s;
  }
  #loading-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--thelo-bg);
    display: flex; justify-content: center; align-items: center; z-index: 9999;
    opacity: 1; transition: opacity 0.5s ease-out;
  }
  #loading-overlay.hidden { opacity: 0; pointer-events: none; }
  #loading-svg { width: 150px; height: auto; animation: pulse-loader 1.5s infinite ease-in-out; }
  @keyframes pulse-loader { 0%, 100% { transform: scale(1); opacity: 0.8; } 50% { transform: scale(1.1); opacity: 1; }}
  html { font-size: 16px; background: var(--thelo-bg); }
  body {
    margin: 0; min-height: 100vh; height: 100vh; font-family: 'Manrope', system-ui, -apple-system, sans-serif;
    display: flex; flex-direction: column; overflow: hidden; background-color: var(--thelo-bg);
    color: var(--thelo-text); -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none;
    user-select: none; -webkit-touch-callout: none;
  }
  #app { display: flex; flex-grow: 1; height: 100%; }
  #lessonArea {
    position: absolute; top: 0; left: 0; right: 0; bottom: 0;
    display: flex; flex-direction: column; overflow: hidden;
  }
  #boardWrap {
    position: relative; flex-grow: 1; overflow: hidden; background-color: var(--thelo-bg);
    background-image: linear-gradient(to right, var(--thelo-border) 1px, transparent 1px), linear-gradient(to bottom, var(--thelo-border) 1px, transparent 1px);
    background-size: 40px 40px;
  }
  #backgroundCanvas, #board {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    display: block; background-color: transparent;
  }
  #backgroundCanvas { z-index: 1; pointer-events: none; opacity: 1; transition: opacity var(--fade-duration) ease-in-out; }
  #backgroundCanvas.fade-out { opacity: 0; }
  #board { z-index: 3; cursor: crosshair; touch-action: none; }
  #bottomBar {
    position: absolute; bottom: 0; left: 0; width: 100%; background-color: transparent;
    box-sizing: border-box; padding: 0.5rem 1rem 1rem 1rem; display: flex;
    justify-content: center; align-items: center; z-index: 20; gap: 0.75rem;
    transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1);
  }
  .control-btn {
    font-family: inherit; padding: 0.75rem 1.5rem; font-size: 1rem; font-weight: 500;
    border: none; border-radius: 0.5rem; color: var(--bg-white); cursor: pointer;
    transition: background-color 0.2s, transform 0.15s, box-shadow 0.2s; box-shadow: var(--shadow-md);
  }
  .control-btn:hover:not(:disabled) { transform: translateY(-2px); box-shadow: var(--shadow-lg); }
  .control-btn:disabled { background-color: #9ca3af !important; cursor: not-allowed; opacity: 0.7; }
  #prevBtn { background-color: var(--accent-yellow); }
  #clearBtn { background-color: var(--error-red); }
  #submitBtn { background-color: var(--thelo-blue); }
  #submitBtn:hover:not(:disabled) { background-color: var(--thelo-blue-dark); }
  .bar-hidden-by-stylus { transform: translateY(150%); pointer-events: none; }
  .no-cursor { cursor: none !important; }
  .control-btn { touch-action: manipulation; }

  /* Timer and Top Bar Styles */
  #topBar {
    position: absolute; top: 0; left: 0; width: 100%; z-index: 20;
    padding: 0.75rem 1.5rem; box-sizing: border-box; display: flex;
    justify-content: center; align-items: center;
  }
  #timerDisplay {
    background-color: rgba(255, 255, 255, 0.8);
    backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
    padding: 0.5rem 1.25rem; border-radius: 999px;
    font-size: 1.2rem; font-weight: 700; color: var(--thelo-text);
    box-shadow: var(--shadow-md); border: 1px solid var(--thelo-border);
  }

  /* Test Results Screen Styles */
  #resultsScreen {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    z-index: 50; background-color: var(--thelo-bg);
    display: none; flex-direction: column; align-items: center;
    padding: 2rem; box-sizing: border-box;
  }
  #resultsContainer {
      width: 100%; max-width: 800px; text-align: center;
  }
  #resultsHeader {
      border-bottom: 2px solid var(--thelo-border); padding-bottom: 1rem; margin-bottom: 1.5rem;
  }
  #resultsScore { font-size: 2.5rem; font-weight: 800; color: var(--thelo-blue); }
  #resultsTime { font-size: 1.2rem; color: var(--thelo-text-light); }
  #resultsFeedbackList {
      flex-grow: 1; width: 100%; overflow-y: auto; text-align: left;
  }
  .feedback-item {
      background-color: #f9fafb; border: 1px solid var(--thelo-border);
      border-radius: 0.75rem; padding: 1rem 1.5rem; margin-bottom: 1rem;
  }
  .feedback-item-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; }
  .feedback-item-header h3 { margin: 0; font-size: 1.1rem; }
  .feedback-item-header .status-correct { color: var(--success-green); font-weight: 700; }
  .feedback-item-header .status-incorrect { color: var(--error-red); font-weight: 700; }
  .feedback-item p { margin: 0; line-height: 1.6; }
</style>
</head>
<body>
    <div id="loading-overlay">
        <svg id="loading-svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 248 60"><text x="0" y="45" font-family="'Manrope', sans-serif" font-size="40" font-weight="800" fill="#2563eb">thelo</text></svg>
    </div>
    <div id="app">
        <div id="lessonArea">
            <div id="topBar">
                <div id="timerDisplay">00:00</div>
            </div>
            <div id="boardWrap">
                <canvas id="backgroundCanvas"></canvas>
                <canvas id="board"></canvas>
            </div>
            <div id="bottomBar">
                <button id="prevBtn" class="control-btn">Previous</button>
                <button id="clearBtn" class="control-btn">Clear</button>
                <button id="submitBtn" class="control-btn">Submit Answer</button>
            </div>
        </div>
    </div>
    <div id="resultsScreen">
        <div id="resultsContainer">
            <div id="resultsHeader">
                <h1>Test Complete!</h1>
                <div id="resultsScore">Score: 0 / 0 (0%)</div>
                <div id="resultsTime">Time Taken: 00:00</div>
            </div>
            <div id="resultsFeedbackList">
                </div>
        </div>
    </div>

<script>
    const firebaseConfig = { apiKey: "AIzaSyAbnPpcIt88B0jIAoLUdC71zmQDvR_fdu8", authDomain: "physmathacademy-722b3.firebaseapp.com", projectId: "physmathacademy-722b3", messagingSenderId: "1093640992262", appId: "1:1093640992262:web:35b1bf4d2364bcf745f587" };
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    /* ========== DOM Elements ========== */
    const loadingOverlay = document.getElementById('loading-overlay');
    const backgroundCanvas = document.getElementById('backgroundCanvas');
    const canvas = document.getElementById('board');
    const boardWrapper = document.getElementById('boardWrap');
    const prevBtn = document.getElementById('prevBtn');
    const submitBtn = document.getElementById('submitBtn');
    const clearBtn = document.getElementById('clearBtn');
    const timerDisplay = document.getElementById('timerDisplay');
    const resultsScreen = document.getElementById('resultsScreen');
    const bgCtx = backgroundCanvas.getContext('2d');
    const ctx = canvas.getContext('2d');

    /* ========== State Variables ========== */
    let testData = null;
    let currentStageIndex = -1;
    let currentStageData = null;
    let drawing = false;
    let lastPos = { x: 0, y: 0 };
    let userDrawingOccurred = false;
    let isTransitioning = false;
    let devicePixelRatio = window.devicePixelRatio || 1;
    let timerInterval = null;
    let testStartTime = null;
    let testResults = [];

    /* ========== UI Text ========== */
    const UI_TEXT = {
        start: "Start Test",
        submit: "Submit Answer",
        checking: "Checking...",
        prev: "Previous",
        clear: "Clear",
        correct: "Correct",
        incorrect: "Incorrect"
    };
    
    // ===================================================================
    //  CORE FIX 1: Bounding Box Helper Function
    //  This finds the pixels of the drawing to allow for smart cropping.
    // ===================================================================
    function getBoundingBox(ctx, padding = 20) {
        const canvas = ctx.canvas;
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        let minX = canvas.width, minY = canvas.height, maxX = -1, maxY = -1;

        for (let y = 0; y < canvas.height; y++) {
            for (let x = 0; x < canvas.width; x++) {
                const alpha = data[(y * canvas.width + x) * 4 + 3];
                if (alpha > 0) {
                    minX = Math.min(minX, x);
                    minY = Math.min(minY, y);
                    maxX = Math.max(maxX, x);
                    maxY = Math.max(maxY, y);
                }
            }
        }

        if (maxX === -1) {
            return null; // Nothing was drawn
        }
        
        // Apply padding around the drawing
        minX = Math.max(0, minX - padding);
        minY = Math.max(0, minY - padding);
        maxX = Math.min(canvas.width, maxX + padding);
        maxY = Math.min(canvas.height, maxY + padding);

        return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
    }

    /* ========== Core App Logic ========== */
    async function loadTest(testJsonPath) {
        isTransitioning = true;
        try {
            const response = await fetch(testJsonPath);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            testData = await response.json();
            if (!testData || !Array.isArray(testData.stages)) throw new Error("Invalid test format.");
            document.title = testData.testTitle || "thelo | Test Mode";
            currentStageIndex = -1;
            testResults = [];
            submitBtn.textContent = UI_TEXT.start;
            submitBtn.disabled = false;
            prevBtn.disabled = true;
        } catch (error) {
            console.error("Error loading test:", error);
            alert("Failed to load the test file. Please check the console for details.");
        } finally {
            isTransitioning = false;
            loadingOverlay.classList.add('hidden');
        }
    }

    function startTest() {
        if (currentStageIndex !== -1) return;
        testStartTime = Date.now();
        timerInterval = setInterval(updateTimerDisplay, 1000);
        transitionToStage(0);
    }

    function updateTimerDisplay() {
        const elapsed = Math.floor((Date.now() - testStartTime) / 1000);
        const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
        const seconds = (elapsed % 60).toString().padStart(2, '0');
        timerDisplay.textContent = `${minutes}:${seconds}`;
    }

    async function renderStageUI(index) {
        if (index < 0 || index >= testData.stages.length) return;
        currentStageData = testData.stages[index];
        currentStageIndex = index;

        bgCtx.clearRect(0, 0, backgroundCanvas.width / devicePixelRatio, backgroundCanvas.height / devicePixelRatio);
        clearUserCanvas();

        const headlineText = `Question ${index + 1}: ${currentStageData.headline || ''}`;
        if (headlineText && bgCtx.canvas.width > 0) {
            const fontFamily = "'Manrope', system-ui, sans-serif";
            bgCtx.font = `24px ${fontFamily}`;
            bgCtx.fillStyle = '#111827';
            bgCtx.textAlign = 'center';
            bgCtx.textBaseline = 'top';
            // Simple text wrapping
            const maxWidth = (bgCtx.canvas.width / devicePixelRatio) * 0.9;
            const words = headlineText.split(' ');
            let line = '';
            let y = 60;
            for(let n = 0; n < words.length; n++) {
                let testLine = line + words[n] + ' ';
                let metrics = bgCtx.measureText(testLine);
                if (metrics.width > maxWidth && n > 0) {
                    bgCtx.fillText(line, (bgCtx.canvas.width / devicePixelRatio) / 2, y);
                    line = words[n] + ' ';
                    y += 30;
                } else {
                    line = testLine;
                }
            }
            bgCtx.fillText(line, (bgCtx.canvas.width / devicePixelRatio) / 2, y);
        }
        
        prevBtn.disabled = index === 0;
        submitBtn.disabled = false;
        submitBtn.textContent = UI_TEXT.submit;
        userDrawingOccurred = false;
    }

    function transitionToStage(newIndex) {
        if (isTransitioning) return;
        if (newIndex >= testData.stages.length) {
            finishTest();
            return;
        }
        isTransitioning = true;
        backgroundCanvas.classList.add('fade-out');
        setTimeout(() => {
            renderStageUI(newIndex).then(() => {
                backgroundCanvas.classList.remove('fade-out');
                isTransitioning = false;
            });
        }, 300);
    }
    
    // ===================================================================
    //  CORE FIX 2: Smart Image Submission
    //  This function now crops the image before sending it to the AI.
    // ===================================================================
    async function handleSubmitClick() {
        if (currentStageIndex === -1) {
            startTest();
            return;
        }

        if (!userDrawingOccurred) {
            alert("Please provide a solution before submitting.");
            return;
        }

        submitBtn.disabled = true;
        submitBtn.textContent = UI_TEXT.checking;

        const user = auth.currentUser;
        if (!user) {
            alert("You must be signed in to submit a test.");
            submitBtn.disabled = false;
            submitBtn.textContent = UI_TEXT.submit;
            return;
        }

        let base64ImageData;
        try {
            const box = getBoundingBox(ctx);
            if (!box) throw new Error("No drawing found to capture.");

            const cropCanvas = document.createElement('canvas');
            cropCanvas.width = box.width;
            cropCanvas.height = box.height;
            const cropCtx = cropCanvas.getContext('2d');
            
            cropCtx.fillStyle = '#FFFFFF';
            cropCtx.fillRect(0, 0, cropCanvas.width, cropCanvas.height);
            
            cropCtx.drawImage(canvas, box.x, box.y, box.width, box.height, 0, 0, box.width, box.height);
            
            base64ImageData = cropCanvas.toDataURL("image/png");

        } catch (e) {
            console.error("Image capture error:", e);
            alert("Error capturing your solution. Please ensure something is drawn.");
            submitBtn.disabled = false;
            submitBtn.textContent = UI_TEXT.submit;
            return;
        }

        const payload = {
            imageBase64: base64ImageData,
            correctAnswer: currentStageData.correctAnswer,
            language: 'en'
        };

        try {
            const analyzeMathDrawing = firebase.functions().httpsCallable('analyzeMathDrawing');
            const result = await analyzeMathDrawing(payload);
            const { status, feedback } = result.data;
            
            testResults.push({
                question: currentStageData.headline,
                status: status,
                feedback: feedback
            });

            transitionToStage(currentStageIndex + 1);

        } catch (error) {
            console.error("AI analysis failed:", error);
            alert("There was an error checking your answer. Please try again.");
            submitBtn.disabled = false;
            submitBtn.textContent = UI_TEXT.submit;
        }
    }

    // ===================================================================
    //  CORE FIX 3: Save Results on Finish
    //  This function now correctly calls the cloud function to save data.
    // ===================================================================
    function finishTest() {
        clearInterval(timerInterval);
        const timeTaken = Math.floor((Date.now() - testStartTime) / 1000);
        const user = auth.currentUser;
        const urlParams = new URLSearchParams(window.location.search);

        document.getElementById('lessonArea').style.display = 'none';
        
        const correctAnswers = testResults.filter(r => r.status === 'correct').length;
        const totalQuestions = testData.stages.length;
        const scorePercentage = totalQuestions > 0 ? Math.round((correctAnswers / totalQuestions) * 100) : 0;
        
        document.getElementById('resultsScore').textContent = `Score: ${correctAnswers} / ${totalQuestions} (${scorePercentage}%)`;
        const minutes = Math.floor(timeTaken / 60).toString().padStart(2, '0');
        const seconds = (timeTaken % 60).toString().padStart(2, '0');
        document.getElementById('resultsTime').textContent = `Time Taken: ${minutes}:${seconds}`;

        const feedbackList = document.getElementById('resultsFeedbackList');
        feedbackList.innerHTML = '';
        testResults.forEach((result, index) => {
            const item = document.createElement('div');
            item.className = 'feedback-item';
            const statusClass = result.status === 'correct' ? 'status-correct' : 'status-incorrect';
            const statusText = result.status === 'correct' ? UI_TEXT.correct : (result.status || 'incorrect');
            
            item.innerHTML = `
                <div class="feedback-item-header">
                    <h3>Question ${index + 1}</h3>
                    <span class="${statusClass}">${statusText}</span>
                </div>
                <p><strong>AI Feedback:</strong> ${result.feedback}</p>
            `;
            feedbackList.appendChild(item);
        });
        
        resultsScreen.style.display = 'flex';

        if (user) {
            const submitTestResults = firebase.functions().httpsCallable('submitTestResults');
            submitTestResults({
                testId: urlParams.get('testFile')?.replace('.json', ''),
                score: correctAnswers,
                totalQuestions: totalQuestions,
                timeTakenSeconds: timeTaken,
                results: testResults
            }).then(res => {
                console.log("Test results saved successfully!", res);
            }).catch(err => {
                console.error("Error saving test results:", err);
            });
        }
    }

    /* ========== Canvas & Drawing Logic (Unchanged) ========== */
    function resizeCanvases() {
        if (!boardWrapper) return;
        const rect = boardWrapper.getBoundingClientRect();
        const cssWidth = Math.floor(rect.width);
        const cssHeight = Math.floor(rect.height);
        devicePixelRatio = window.devicePixelRatio || 1;
        const internalWidth = cssWidth * devicePixelRatio;
        const internalHeight = cssHeight * devicePixelRatio;

        [backgroundCanvas, canvas].forEach(c => {
            c.width = internalWidth;
            c.height = internalHeight;
            c.style.width = `${cssWidth}px`;
            c.style.height = `${cssHeight}px`;
        });
        setupContexts();
        if (currentStageIndex >= 0) renderStageUI(currentStageIndex);
    }

    function setupContexts() {
        [bgCtx, ctx].forEach(context => {
            context.resetTransform();
            context.scale(devicePixelRatio, devicePixelRatio);
        });
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.strokeStyle = 'black';
    }

    function getPos(e, targetCanvas) {
        const rect = targetCanvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        return { x: clientX - rect.left, y: clientY - rect.top };
    }

    function handleDrawingStart(e) {
        e.preventDefault();
        const pos = getPos(e, canvas);
        if (!pos) return;
        drawing = true;
        userDrawingOccurred = true;
        lastPos = pos;
        ctx.beginPath();
        ctx.moveTo(pos.x, pos.y);
    }

    function handleDrawingMove(e) {
        if (!drawing) return;
        e.preventDefault();
        const pos = getPos(e, canvas);
        if (!pos) return;
        const midPoint = { x: (lastPos.x + pos.x) / 2, y: (lastPos.y + pos.y) / 2 };
        ctx.quadraticCurveTo(lastPos.x, lastPos.y, midPoint.x, midPoint.y);
        ctx.stroke();
        ctx.moveTo(midPoint.x, midPoint.y);
        lastPos = pos;
    }

    function handleDrawingEnd() {
        if (!drawing) return;
        drawing = false;
        ctx.lineTo(lastPos.x, lastPos.y);
        ctx.stroke();
        ctx.closePath();
    }
    
    function clearUserCanvas() {
        ctx.clearRect(0, 0, canvas.width / devicePixelRatio, canvas.height / devicePixelRatio);
        userDrawingOccurred = false;
    }

    /* ========== Initialization ========== */
    function initApp() {
        resizeCanvases();
        
        canvas.addEventListener('mousedown', handleDrawingStart);
        canvas.addEventListener('mousemove', handleDrawingMove);
        window.addEventListener('mouseup', handleDrawingEnd); // Listen on window for mouseup
        window.addEventListener('mouseleave', handleDrawingEnd);
        canvas.addEventListener('touchstart', handleDrawingStart, { passive: false });
        canvas.addEventListener('touchmove', handleDrawingMove, { passive: false });
        window.addEventListener('touchend', handleDrawingEnd); // Listen on window for touchend
        window.addEventListener('touchcancel', handleDrawingEnd);
        
        prevBtn.onclick = () => transitionToStage(currentStageIndex - 1);
        submitBtn.onclick = handleSubmitClick;
        clearBtn.onclick = clearUserCanvas;
        window.addEventListener('resize', resizeCanvases);

        const urlParams = new URLSearchParams(window.location.search);
        const testFileName = urlParams.get('testFile');
        if (testFileName) {
            loadTest(`../tests/${testFileName}`);
        } else {
            alert("No test file specified in the URL. Please add '?testFile=your-test.json'.");
            loadingOverlay.classList.add('hidden');
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        auth.onAuthStateChanged(user => {
            initApp();
        });
    });
</script>
</body>
</html>
