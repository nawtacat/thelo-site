<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link rel="icon" href="https://thelo.space/img/thelofavicon.png" type="image/png">
    <link rel="apple-touch-icon" href="https://thelo.space/img/yarnicon.png">
    <title>thelo | Test Mode</title>
    <!-- Firebase (Compat Version as in original) -->
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-functions-compat.js"></script>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <!-- KaTeX -->
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css">
    
    <!-- PWA Meta -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<style>
  /* ===== NEW: Updated Design System ===== */
  :root {
    /* Core Palette */
    --thelo-blue: #2563eb;
    --thelo-blue-dark: #1d4ed8;
    --thelo-bg: #ffffff;
    --thelo-text: #111827;
    --thelo-text-light: #6b7280;
    --thelo-border: #e5e7eb;

    /* Status Colors */
    --success-green: #22c55e;
    --error-red: #ef4444;
    --accent-yellow: #f59e0b;

    /* UI Element Colors */
    --bg-white: #ffffff;
    --chat-ai-bg: #ffffff;
    --bg-light-gray: #f9fafb;

    /* Ink Colors */
    --ink-black: #000000;
    --ink-blue: var(--thelo-blue);

    /* Effects */
    --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
    --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);

    /* Transitions */
    --fade-duration: 0.3s;
    --animation-duration: 0.3s;
  }

  /* ===== NEW: Armenian Font Definitions ===== */
  @font-face {
    font-family: 'Montserrat Arm';
    src: url('https://thelo.space/fonts/Montserratarm-Regular.otf') format('opentype');
    font-weight: 400; /* Regular */
    font-style: normal;
    font-display: swap;
  }
  @font-face {
    font-family: 'Montserrat Arm';
    src: url('https://thelo.space/fonts/Montserratarm-SemiBold.otf') format('opentype');
    font-weight: 600; /* SemiBold */
    font-style: normal;
    font-display: swap;
  }
  @font-face {
    font-family: 'Montserrat Arm';
    src: url('https://thelo.space/fonts/Montserratarm-ExtraBold.otf') format('opentype');
    font-weight: 800; /* ExtraBold */
    font-style: normal;
    font-display: swap;
  }

  /* Rule to apply the Armenian font when needed */
  body.lang-hy {
    font-family: 'Montserrat Arm', 'Manrope', system-ui, -apple-system, sans-serif;
  }

  #loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: var(--thelo-bg);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999;
    opacity: 1;
    transition: opacity 0.5s ease-out;
  }
  #loading-overlay.hidden {
    opacity: 0;
    pointer-events: none;
  }
  #loading-svg {
    width: 150px;
    height: auto;
    animation: pulse-loader 1.5s infinite ease-in-out;
  }
  @keyframes pulse-loader {
    0% { transform: scale(1); opacity: 0.8; }
    50% { transform: scale(1.1); opacity: 1; }
    100% { transform: scale(1); opacity: 0.8; }
  }
  html {
    font-size: 16px;
    background: var(--thelo-bg);
  }
  body {
    margin: 0;
    min-height: 100vh;
    height: 100vh;
    font-family: 'Manrope', system-ui, -apple-system, sans-serif;
    font-weight: 400;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    background-color: var(--thelo-bg);
    color: var(--thelo-text);
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;
  }
  #app { display: flex; flex-grow: 1; height: 100%; }
  #lessonArea {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }
  #boardWrap {
    position: relative;
    flex-grow: 1;
    overflow: hidden;
    background-color: var(--thelo-bg);
    background-image: linear-gradient(to right, var(--thelo-border) 1px, transparent 1px),
      linear-gradient(to bottom, var(--thelo-border) 1px, transparent 1px);
    background-size: 40px 40px;
  }
  #backgroundCanvas,
  #board {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: block;
    background-color: transparent;
  }
  #backgroundCanvas {
    z-index: 1;
    pointer-events: none;
    opacity: 1;
    transition: opacity var(--fade-duration) ease-in-out;
  }
  #backgroundCanvas.fade-out {
    opacity: 0;
  }
  #board {
    z-index: 3;
    cursor: crosshair;
    touch-action: none;
  }
  #bottomBar {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    background-color: transparent;
    box-sizing: border-box;
    padding: 1rem 1.5rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    z-index: 20;
    transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1);
  }
  #button-group {
      display: flex;
      gap: 0.2rem; /* MODIFIED: Buttons are closer */
  }
  .control-btn {
    font-family: inherit;
    padding: 0.5rem 1rem;
    font-size: 0.9rem;
    font-weight: 500;
    border: none;
    border-radius: 0.5rem;
    color: var(--bg-white);
    cursor: pointer;
    transition: background-color 0.2s, transform 0.15s, box-shadow 0.2s;
    box-shadow: var(--shadow-md);
    touch-action: manipulation;
  }
  .control-btn:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: var(--shadow-lg);
  }
  .control-btn:disabled {
    background-color: #9ca3af !important;
    cursor: not-allowed;
    opacity: 0.7;
  }
  #prevBtn { background-color: var(--accent-yellow); }
  #clearBtn { background-color: var(--error-red); }
  #submitBtn { background-color: var(--thelo-blue); }
  #submitBtn:hover:not(:disabled) { background-color: var(--thelo-blue-dark); }

  .bar-hidden-by-stylus {
    transform: translateY(150%);
    pointer-events: none;
  }
  html, body {
    cursor: none !important;
  }
  .no-cursor {
    cursor: none !impor    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<style>
  /* ===== NEW: Updated Design System ===== */
  :root {
    /* Core Palette */
    --thelo-blue: #2563eb;
    --thelo-blue-dark: #1d4ed8;
    --thelo-bg: #ffffff;
    --thelo-text: #111827;
    --thelo-text-light: #6b7280;
    --thelo-border: #e5e7eb;

    /* Status Colors */
    --success-green: #22c55e;
    --error-red: #ef4444;
    --accent-yellow: #f59e0b;

    /* UI Element Colors */
    --bg-white: #ffffff;
    --chat-ai-bg: #ffffff;
    --bg-light-gray: #f9fafb;

    /* Ink Colors */
    --ink-black: #000000;
    --ink-blue: var(--thelo-blue);

    /* Effects */
    --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
    --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);

    /* Transitions */
    --fade-duration: 0.3s;
    --animation-duration: 0.3s;
  }

  /* ===== NEW: Armenian Font Definitions ===== */
  @font-face {
    font-family: 'Montserrat Arm';
    src: url('https://thelo.space/fonts/Montserratarm-Regular.otf') format('opentype');
    font-weight: 400; /* Regular */
    font-style: normal;
    font-display: swap;
  }
  @font-face {
    font-family: 'Montserrat Arm';
    src: url('https://thelo.space/fonts/Montserratarm-SemiBold.otf') format('opentype');
    font-weight: 600; /* SemiBold */
    font-style: normal;
    font-display: swap;
  }
  @font-face {
    font-family: 'Montserrat Arm';
    src: url('https://thelo.space/fonts/Montserratarm-ExtraBold.otf') format('opentype');
    font-weight: 800; /* ExtraBold */
    font-style: normal;
    font-display: swap;
  }

  /* Rule to apply the Armenian font when needed */
  body.lang-hy {
    font-family: 'Montserrat Arm', 'Manrope', system-ui, -apple-system, sans-serif;
  }

  #loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: var(--thelo-bg);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999;
    opacity: 1;
    transition: opacity 0.5s ease-out;
  }
  #loading-overlay.hidden {
    opacity: 0;
    pointer-events: none;
  }
  #loading-svg {
    width: 150px;
    height: auto;
    animation: pulse-loader 1.5s infinite ease-in-out;
  }
  @keyframes pulse-loader {
    0% { transform: scale(1); opacity: 0.8; }
    50% { transform: scale(1.1); opacity: 1; }
    100% { transform: scale(1); opacity: 0.8; }
  }
  html {
    font-size: 16px;
    background: var(--thelo-bg);
  }
  body {
    margin: 0;
    min-height: 100vh;
    height: 100vh;
    font-family: 'Manrope', system-ui, -apple-system, sans-serif;
    font-weight: 400;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    background-color: var(--thelo-bg);
    color: var(--thelo-text);
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;
  }
  #app { display: flex; flex-grow: 1; height: 100%; }
  #lessonArea {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }
  #boardWrap {
    position: relative;
    flex-grow: 1;
    overflow: hidden;
    background-color: var(--thelo-bg);
    background-image: linear-gradient(to right, var(--thelo-border) 1px, transparent 1px),
      linear-gradient(to bottom, var(--thelo-border) 1px, transparent 1px);
    background-size: 40px 40px;
  }
  #backgroundCanvas,
  #board {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: block;
    background-color: transparent;
  }
  #backgroundCanvas {
    z-index: 1;
    pointer-events: none;
    opacity: 1;
    transition: opacity var(--fade-duration) ease-in-out;
  }
  #backgroundCanvas.fade-out {
    opacity: 0;
  }
  #board {
    z-index: 3;
    cursor: crosshair;
    touch-action: none;
  }
  #bottomBar {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    background-color: transparent;
    box-sizing: border-box;
    padding: 1rem 1.5rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    z-index: 20;
    transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1);
  }
  #button-group {
      display: flex;
      gap: 0.2rem; /* MODIFIED: Buttons are closer */
  }
  .control-btn {
    font-family: inherit;
    padding: 0.5rem 1rem;
    font-size: 0.9rem;
    font-weight: 500;
    border: none;
    border-radius: 0.5rem;
    color: var(--bg-white);
    cursor: pointer;
    transition: background-color 0.2s, transform 0.15s, box-shadow 0.2s;
    box-shadow: var(--shadow-md);
    touch-action: manipulation;
  }
  .control-btn:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: var(--shadow-lg);
  }
  .control-btn:disabled {
    background-color: #9ca3af !important;
    cursor: not-allowed;
    opacity: 0.7;
  }
  #prevBtn { background-color: var(--accent-yellow); }
  #clearBtn { background-color: var(--error-red); }
  #submitBtn { background-color: var(--thelo-blue); }
  #submitBtn:hover:not(:disabled) { background-color: var(--thelo-blue-dark); }

  .bar-hidden-by-stylus {
    transform: translateY(150%);
    pointer-events: none;
  }
  html, body {
    cursor: none !important;
  }
  .no-cursor {
    cursor: none !important;
  }
  #bottom-logo-container {
    position: fixed;
    bottom: 1.25rem; /* MODIFIED: Logo is raised slightly */
    left: 50%;
    transform: translateX(-50%);
    z-index: 10000;
    pointer-events: none;
  }
  #bottom-logo-container img {
    display: block;
    height: 35px;
    width: auto;
  }
  #timerDisplay {
    background-color: rgba(255, 255, 255, 0.8);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 0.5rem 1.25rem;
    border-radius: 999px;
    font-size: 1.2rem;
    font-weight: 700;
    color: var(--thelo-text);
    box-shadow: var(--shadow-md);
    border: 1px solid var(--thelo-border);
  }
  
  .hidden {
      display: none !important;
  }
  
  /* --- Results Page CSS (REMOVED) --- */

  @media (max-width: 768px) {
    #bottomBar {
      flex-wrap: wrap;
      justify-content: center;
      gap: 1rem;
    }
    .control-btn {
      padding: 0.6rem 0.8rem;
      font-size: 0.8rem;
    }
  }

  @media (min-width: 769px) and (max-width: 1200px) and (pointer: coarse) {
    #boardWrap {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
    }
  }
</style>
</head>
<body>
    <div id="loading-overlay">
        <img id="loading-svg" src="https://thelo.space/img/bluethelo.svg" alt="Loading...">
    </div>
    <div id="app">
        <div id="lessonArea">
            <div id="boardWrap">
                <canvas id="backgroundCanvas"></canvas>
                <canvas id="board"></canvas>
            </div>
            <div id="bottomBar">
                <div id="timerDisplay">00:00</div>
                <div id="button-group">
                    <button id="prevBtn" class="control-btn"></button>
                    <button id="clearBtn" class="control-btn"></button>
                    <button id="submitBtn" class="control-btn"></button>
                </div>
            </div>
        </div>
    </div>

    <!-- Results and Detail Screens (REMOVED) -->

    <div id="bottom-logo-container">
        <img src="https://thelo.space/img/bluethelo.svg" alt="Thelo Logo">
    </div>

<script>
    // --- Firebase Config ---
    // Config will be initialized in DOMContentLoaded
    let auth;
    let db;
    let functions;

    // NEW: Environment variables
    // let appId = 'default-app-id'; // REMOVED: Not used in the new path
    let userId = null;

    /* ========== DOM Elements ========== */
    const loadingOverlay = document.getElementById('loading-overlay');
    const backgroundCanvas = document.getElementById('backgroundCanvas');
    const canvas = document.getElementById('board');
    const boardWrapper = document.getElementById('boardWrap');
    const prevBtn = document.getElementById('prevBtn');
    const submitBtn = document.getElementById('submitBtn');
    const clearBtn = document.getElementById('clearBtn');
    const timerDisplay = document.getElementById('timerDisplay');
    const bottomBar = document.getElementById('bottomBar');
    const bgCtx = backgroundCanvas.getContext('2d');
    const ctx = canvas.getContext('2d');

    // --- Results Screen DOM (REMOVED) ---

    /* ========== State Variables ========== */
    let testData = null;
    let currentStageIndex = -1;
    let currentStageData = null;
    let drawing = false;
    let lastPos = { x: 0, y: 0 };
    let userDrawingOccurred = false;
    let isTransitioning = false;
    let devicePixelRatio = window.devicePixelRatio || 1;
    let timerInterval = null;
    let testStartTime = null;
    let isTabletMode = false;
    let buttonVanishTimer = null;
    let currentLang = 'en';
    let currentTestAttemptId = null; // NEW: To store the random ID for this test attempt
    let totalCorrect = 0; // NEW: To track score for the final report
    let totalAttempted = 0; // NEW: To track attempted questions
    let currentTestName = "default-test"; // NEW: To store test name

    /* ========== UI Text ========== */
    const UI_TEXT = {
        en: {
            start: "Start Test",
            submit: "Submit Answer",
            checking: "Checking...",
            prev: "Previous",
            clear: "Clear",
            testComplete: "Test Complete!",
            score: "Score:",
            timeTaken: "Time Taken:",
            provideSolution: "Please provide a solution before submitting.",
            question: "Question",
            analysisError: "Could not submit for analysis.",
            testOver: "Test Finished" // NEW: Message for final stage
        },
        hy: {
            start: "Սկսել թեստը",
            submit: "Ուղարկել",
            checking: "Ստուգվում է...",
            prev: "Նախորդ",
            clear: "Մաքրել",
            testComplete: "Թեստն ավարտված է",
            score: "Միավոր:",
            timeTaken: "Ժամանակ:",
            provideSolution: "Խնդրում ենք լուծումը գրել նոր ուղարկել։",
            question: "Հարց",
            analysisError: "Չհաջողվեց ուղարկել վերլուծության։",
            testOver: "Թեստն Ավարտված Է" // NEW
        }
    };
    // ===================================================================
    //  KaTeX and Headline Rendering Functions (Unchanged)
    // ===================================================================
    let katexCSSInlined = null;

    function abToBase64(ab) {
        const CHUNK = 0x8000;
        const bytes = new Uint8Array(ab);
        let binary = '';
        for (let i = 0; i < bytes.length; i += CHUNK) {
            binary += String.fromCharCode(...bytes.subarray(i, i + CHUNK));
        }
        return btoa(binary);
    }

    async function getKatexCSSWithEmbeddedFonts() {
        if (katexCSSInlined) return katexCSSInlined;
        const base = 'https://cdn.jsdelivr.net/npm/katex@0.16.10/dist';
        let css = await (await fetch(`${base}/katex.min.css`)).text();
        const fonts = ['KaTeX_Main-Regular.woff2', 'KaTeX_Main-Italic.woff2', 'KaTeX_Main-Bold.woff2', 'KaTeX_Math-Italic.woff2', 'KaTeX_AMS-Regular.woff2', 'KaTeX_Size1-Regular.woff2', 'KaTeX_Size2-Regular.woff2'];
        for (const name of fonts) {
            const url = `${base}/fonts/${name}`;
            const res = await fetch(url);
            const b64 = abToBase64(await res.arrayBuffer());
            const dataURL = `url(data:font/woff2;base64,${b64}) format("woff2")`;
            css = css.replace(new RegExp(`url\\([^)]*${name}[^)]*\\)\\s*format\\("woff2"\\)`, 'g'), dataURL);
        }
        katexCSSInlined = css;
        return katexCSSInlined;
    }

    async function ensureHeadlineFontsLoaded() {
        try {
            if (document.fonts && document.fonts.load) {
                await Promise.race([
                    (async () => {
                        await document.fonts.load(`24px "Manrope"`);
                        if (currentLang === 'hy') {
                            await document.fonts.load(`24px "Montserrat Arm"`);
                        }
                        await document.fonts.ready;
                    })(),
                    new Promise(res => setTimeout(res, 800))
                ]);
            }
        } catch (_) {}
    }

    async function renderComplexHeadline(bgCtx, headline, y, opts = {}) {
        if (!headline || !bgCtx) return;
        const widthFraction = 0.88, yNudge = -14, fontSize = 24, mathFontSize = 26;
        const fontColor = getComputedStyle(document.documentElement).getPropertyValue('--thelo-text').trim() || '#111827';
        const katexCSS = await getKatexCSSWithEmbeddedFonts();
        const extraRules = `.katex, .katex .mathnormal { font-family: "KaTeX_Main", serif !important; }`;
        const segments = (headline.split(/(\/K[\s\S]*?K\/)/g) || []).filter(Boolean).map(p => p.startsWith('/K') && p.endsWith('K/') ? { type: 'math', content: p.replace(/^\/K\s*/, '').replace(/\s*K\/$/, '') } : { type: 'text', content: p });
        const measureHost = document.createElement('div');
        measureHost.style.cssText = 'position:absolute;visibility:hidden;left:-9999px;top:-9999px;';
        document.body.appendChild(measureHost);
        const tokens = [];
        for (const seg of segments) {
            if (seg.type === 'text') {
                const parts = seg.content.match(/(\s+|[^\s]+)/g) || [];
                for (const p of parts) {
                    tokens.push({ type: 'text', content: p, width: bgCtx.measureText(p).width, height: fontSize, isSpace: /^\s+$/.test(p) });
                }
                continue;
            }
            try {
                const html = katex.renderToString(seg.content, { throwOnError: false, output: 'html' });
                const style = document.createElement('style'); style.textContent = katexCSS; measureHost.appendChild(style);
                const tmp = document.createElement('div'); tmp.style.color = fontColor; tmp.style.fontSize = `${mathFontSize}px`; tmp.innerHTML = html; measureHost.appendChild(tmp);
                const rect = (tmp.querySelector('.katex') || tmp).getBoundingClientRect();
                tmp.remove();
                const PAD = 2; const w = Math.ceil(rect.width) + PAD; const h = Math.ceil(rect.height) + PAD;
                const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}"><style>${katexCSS}\n${extraRules}</style><foreignObject width="100%" height="100%"><div xmlns="http://www.w3.org/1999/xhtml" style="color:${fontColor};font-size:${mathFontSize}px;line-height:initial;display:inline-block;padding-right:${PAD/2}px;">${html}</div></foreignObject></svg>`;
                const dataUrl = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svg)));
                const image = new Image(); image.src = dataUrl; await image.decode();
                tokens.push({ type: 'math', image, width: w, height: h, drawW: w, drawH: h });
            } catch (e) {
                tokens.push({ type: 'text', content: seg.content, width: bgCtx.measureText(seg.content).width, height: fontSize, isSpace: false });
            }
        }
        measureHost.remove();
        const canvasW = bgCtx.canvas.width / devicePixelRatio;
        const maxWidth = canvasW * widthFraction;
        const lines = []; let line = { tokens: [], width: 0, height: fontSize };
        for (const t of tokens) {
            let width = t.width, height = t.height, drawW = t.drawW ?? t.width, drawH = t.drawH ?? t.height;
            if (t.type === 'math' && width > maxWidth) { const s = maxWidth / width; width = Math.floor(width * s); height = Math.floor(height * s); drawW *= s; drawH *= s; }
            const tok = { ...t, width, height, drawW, drawH };
            if (line.tokens.length && line.width + width > maxWidth) { lines.push(line); line = { tokens: [], width: 0, height: fontSize }; }
            if (!(line.tokens.length === 0 && tok.isSpace)) { line.tokens.push(tok); line.width += width; if (height > line.height) line.height = height; }
        }
        if (line.tokens.length) lines.push(line);
        const prevAlign = bgCtx.textAlign; const prevBase = bgCtx.textBaseline; const prevFill = bgCtx.fillStyle;
        bgCtx.fillStyle = fontColor; bgCtx.textAlign = 'left'; bgCtx.textBaseline = 'top';
        let curY = y + yNudge;
        for (const L of lines) {
            let x = (canvasW - L.width) / 2;
            for (const t of L.tokens) {
                const topY = curY + (L.height - t.height) / 2;
                if (t.type === 'text') bgCtx.fillText(t.content, x, topY); else bgCtx.drawImage(t.image, x, topY, t.drawW, t.drawH);
                x += t.width;
            }
            curY += L.height + 8;
        }
        bgCtx.textAlign = prevAlign; bgCtx.textBaseline = prevBase; bgCtx.fillStyle = prevFill;
    }
    // ===================================================================
    //  Main Application Logic (MODIFIED)
    // ===================================================================
    function getBoundingBox(ctx, padding = 20 * (window.devicePixelRatio || 1)) {
        const canvas = ctx.canvas;
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        let minX = canvas.width, minY = canvas.height, maxX = -1, maxY = -1;
        for (let y = 0; y < canvas.height; y++) {
            for (let x = 0; x < canvas.width; x++) {
                if (data[(y * canvas.width + x) * 4 + 3] > 0) {
                    minX = Math.min(minX, x); minY = Math.min(minY, y);
                    maxX = Math.max(maxX, x); maxY = Math.max(maxY, y);
                }
            }
        }
        if (maxX === -1) return null;
        minX = Math.max(0, minX - padding); minY = Math.max(0, minY - padding);
        maxX = Math.min(canvas.width, maxX + padding); maxY = Math.min(canvas.height, maxY + padding);
        return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
    }

    async function loadTest(testJsonPath) {
        isTransitioning = true;
        try {
            const response = await fetch(testJsonPath);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            testData = await response.json();
            if (!testData || !Array.isArray(testData.stages)) throw new Error("Invalid test format.");
            
            currentLang = testData.lang === 'hy' ? 'hy' : 'en';
            document.body.className = currentLang === 'hy' ? 'lang-hy' : '';
            currentTestName = new URLSearchParams(window.location.search).get('testFile')?.replace('.json', '') || 'unknown-test';

            document.title = testData.testTitle || "thelo | Test Mode";
            currentStageIndex = -1;
            updateAllUITexts();
            submitBtn.disabled = false;
            prevBtn.disabled = true;
        } catch (error) {
            console.error("Error loading test:", error);
            alert("Failed to load the test file. Please check the console for details."); // Using alert as per original code
        } finally {
            isTransitioning = false;
            loadingOverlay.classList.add('hidden');
        }
    }

    function startTest() {
        if (currentStageIndex !== -1) return;
        
        if (!userId) { // Check for global userId
            alert("You must be signed in to start a test.");
            return;
        }

        testStartTime = Date.now();
        timerInterval = setInterval(updateTimerDisplay, 1000);
        
        // NEW: Create a new test attempt in Firestore
        totalCorrect = 0;
        totalAttempted = 0;
        currentTestAttemptId = db.collection('thelo-students').doc().id; // Generate a random ID
        
        try {
            // UPDATED PATH: Using /thelo-students/{userId}/progress/{testAttemptId}
            const attemptDocRef = db.collection('thelo-students').doc(userId)
                                  .collection('progress').doc(currentTestAttemptId);
            
            attemptDocRef.set({
                testName: currentTestName,
                language: currentLang,
                startTime: firebase.firestore.FieldValue.serverTimestamp(),
                status: 'started',
                totalQuestions: testData.stages.length,
                solutions: [] // NEW: Initialize solutions array
            }).catch(err => {
                console.error("Failed to create test attempt document:", err);
            });

        } catch (error) {
            console.error("Error creating Firestore test attempt:", error);
        }

        transitionToStage(0);
    }

    function updateTimerDisplay() {
        if (!testStartTime) return;
        const elapsed = Math.floor((Date.now() - testStartTime) / 1000);
        const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
        const seconds = (elapsed % 60).toString().padStart(2, '0');
        timerDisplay.textContent = `${minutes}:${seconds}`;
    }

    async function renderStageUI(index) {
        // This function is called when finishing the test with index -1
        if (index === -1) {
            bgCtx.clearRect(0, 0, backgroundCanvas.width / devicePixelRatio, backgroundCanvas.height / devicePixelRatio);
            clearUserCanvas();
            const texts = UI_TEXT[currentLang] || UI_TEXT.en;
            
            bgCtx.font = `bold 32px '${currentLang === 'hy' ? "Montserrat Arm" : "Manrope"}'`;
            bgCtx.textAlign = 'center';
            bgCtx.textBaseline = 'middle';
            bgCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--thelo-text').trim();
            bgCtx.fillText(texts.testComplete, (backgroundCanvas.width / devicePixelRatio) / 2, (backgroundCanvas.height / devicePixelRatio) / 2);

            prevBtn.disabled = true;
            submitBtn.disabled = false; // Re-enable to start again
            updateAllUITexts(); // This will set submitBtn text to "Start Test"
            userDrawingOccurred = false;
            return;
        }
        
        if (index < 0 || index >= testData.stages.length) return;
        currentStageData = testData.stages[index];
        currentStageIndex = index;
        bgCtx.clearRect(0, 0, backgroundCanvas.width / devicePixelRatio, backgroundCanvas.height / devicePixelRatio);
        clearUserCanvas();
        const headlineText = `${UI_TEXT[currentLang].question} ${index + 1}: ${currentStageData.headline || ''}`;
        if (headlineText && bgCtx.canvas.width > 0) {
            const baseFont = currentLang === 'hy' ? "Montserrat Arm" : "Manrope";
            bgCtx.font = `24px '${baseFont}', system-ui, sans-serif`;
            await ensureHeadlineFontsLoaded();
            await renderComplexHeadline(bgCtx, headlineText, 65);
        }
        prevBtn.disabled = index === 0;
        submitBtn.disabled = false;
        updateAllUITexts();
        userDrawingOccurred = false;
    }

    function transitionToStage(newIndex) {
        if (isTransitioning) return;
        
        if (newIndex >= testData.stages.length) {
            finishTest(); // Test is over
            return;
        }
        
        isTransitioning = true;
        backgroundCanvas.classList.add('fade-out');
        setTimeout(() => {
            renderStageUI(newIndex).then(() => {
                backgroundCanvas.classList.remove('fade-out');
                isTransitioning = false;
            });
        }, parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--fade-duration') || '0.3') * 1000);
    }

    async function handleSubmitClick() {
        if (isTransitioning) return;

        if (currentStageIndex === -1) {
            startTest();
            return;
        }
        
        if (!userDrawingOccurred) {
            alert(UI_TEXT[currentLang].provideSolution);
            return;
        }

        const texts = UI_TEXT[currentLang] || UI_TEXT.en;
        submitBtn.disabled = true;
        submitBtn.textContent = texts.checking;
        
        if (!userId || !currentTestAttemptId) {
            alert("You must be signed in and have started a test.");
            submitBtn.disabled = false;
            updateAllUITexts();
            return;
        }

        let base64ImageData;
        try {
            const box = getBoundingBox(ctx);
            if (!box) throw new Error("No drawing found to capture.");
            const cropCanvas = document.createElement('canvas');
            cropCanvas.width = box.width;
            cropCanvas.height = box.height;
            const cropCtx = cropCanvas.getContext('2d');
            cropCtx.fillStyle = '#FFFFFF';
            cropCtx.fillRect(0, 0, cropCanvas.width, cropCanvas.height);
            cropCtx.drawImage(canvas, box.x, box.y, box.width, box.height, 0, 0, box.width, box.height);
            base64ImageData = cropCanvas.toDataURL("image/png");
        } catch (e) {
            console.error("Image capture error:", e);
            alert("Error capturing your solution. Please ensure something is drawn.");
            submitBtn.disabled = false;
            updateAllUITexts();
            return;
        }

        try {
            const analyzeMathDrawing = functions.httpsCallable('analyzeMathDrawing');
            
            const payload = {
                imageBase64: base64ImageData,
                problemText: currentStageData.headline || "A math problem.",
                correctAnswer: String(currentStageData.correctAnswer),
                language: currentLang,
                solutionSteps: currentStageData.solutionSteps || "",  
                customInstructions: currentStageData.customInstructions || ""
            };
            
            const result = await analyzeMathDrawing(payload);
            const { status, feedback } = result.data;

            // UPDATED PATH: Using /thelo-students/{userId}/progress/{testAttemptId}
            const solutionDocRef = db.collection('thelo-students').doc(userId)
                                     .collection('progress').doc(currentTestAttemptId);
            
            // Create the solution object to add to the array
            const solutionData = {
                questionIndex: currentStageIndex,
                questionText: currentStageData.headline,
                correctAnswer: currentStageData.correctAnswer,
                solutionImage: base64ImageData, // Note: Storing large images in Firestore can be costly.
                status: status,
                feedback: feedback,
                timestamp: firebase.firestore.FieldValue.serverTimestamp() // This will be the server time
            };
            
            // Update the document by adding the new solution to the 'solutions' array
            await solutionDocRef.update({
                solutions: firebase.firestore.FieldValue.arrayUnion(solutionData)
            });

            // Update score
            totalAttempted++;
            if (status === 'correct') {
                totalCorrect++;
            }

            // Move to next stage
            transitionToStage(currentStageIndex + 1);

        } catch (error) {
            console.error("AI analysis or Firestore save failed:", error);
            alert("There was an error checking your answer. Please try again.");
            submitBtn.disabled = false;
            updateAllUITexts();
        }
    }
     
    // ===================================================================
    //  REFACTORED: Simplified Finish Test Logic
    // ===================================================================

    function finishTest() {
        clearInterval(timerInterval);
        const timeTaken = Math.floor((Date.now() - testStartTime) / 1000);
        
        // Update the main attempt document in Firestore
        if (userId && currentTestAttemptId) {
            // UPDATED PATH: Using /thelo-students/{userId}/progress/{testAttemptId}
            const attemptDocRef = db.collection('thelo-students').doc(userId)
                                  .collection('progress').doc(currentTestAttemptId);
            
            attemptDocRef.update({
                status: 'completed',
                endTime: firebase.firestore.FieldValue.serverTimestamp(),
                timeTakenSeconds: timeTaken,
                score: totalCorrect,
                questionsAttempted: totalAttempted
            }).catch(err => {
                console.error("Failed to update test attempt document:", err);
            });
        }
        
        // Reset state
        currentStageIndex = -1; // Set to -1 to show "Start Test" screen
        currentTestAttemptId = null;
        testStartTime = null;
        
        // Transition to the "Test Complete" message screen
        isTransitioning = true;
        backgroundCanvas.classList.add('fade-out');
        setTimeout(() => {
            renderStageUI(-1).then(() => { // Render the -1 "complete" state
                backgroundCanvas.classList.remove('fade-out');
                isTransitioning = false;
            });
        }, parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--fade-duration') || '0.3') * 1000);
    }

    // --- Results Screen Functions (REMOVED) ---

    // ===================================================================
    //  Canvas and Event Listener Setup
    // ===================================================================
    function resizeCanvases() {
        checkTabletMode();
        if (!boardWrapper) return;
        const rect = boardWrapper.getBoundingClientRect();
        const cssWidth = Math.floor(rect.width); const cssHeight = Math.floor(rect.height);
        devicePixelRatio = window.devicePixelRatio || 1;
        const internalWidth = cssWidth * devicePixelRatio; const internalHeight = cssHeight * devicePixelRatio;
        [backgroundCanvas, canvas].forEach(c => {
            c.width = internalWidth; c.height = internalHeight;
            c.style.width = `${cssWidth}px`; c.style.height = `${cssHeight}px`;
        });
        setupContexts();
        if (testData) renderStageUI(currentStageIndex); // Re-render current stage on resize
    }

    function setupContexts() {
        [bgCtx, ctx].forEach(context => {
            context.resetTransform();
            context.scale(devicePixelRatio, devicePixelRatio);
        });
        ctx.lineWidth = 3; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.strokeStyle = '#000000';
    }

    function getPos(e, targetCanvas) {
        const rect = targetCanvas.getBoundingClientRect();
        let clientX, clientY;
        if (e.touches && e.touches.length > 0) { clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; }
        else if (e.changedTouches && e.changedTouches.length > 0) { clientX = e.changedTouches[0].clientX; clientY = e.changedTouches[0].clientY; }
        else { clientX = e.clientX; clientY = e.clientY; }
        if (typeof clientX !== 'number' || typeof clientY !== 'number') return null;
        return { x: clientX - rect.left, y: clientY - rect.top };
    }

    function handleDrawingStart(e) {
        if (isTabletMode && e.type.startsWith('touch')) {
            if (!Array.from(e.touches).some(t => t.touchType === 'stylus')) { e.preventDefault(); return; }
        }
        const pos = getPos(e, canvas);
        if (!pos) return;
        if (e.touches) e.preventDefault();
        drawing = true;
        if (e.pointerType === 'pen') canvas.classList.add('no-cursor');
        userDrawingOccurred = true;
        lastPos = pos;
        ctx.beginPath();
        ctx.moveTo(pos.x, pos.y);
    }

    function handleDrawingMove(e) {
        if (!drawing) return;
        if (isTabletMode) {
            if (buttonVanishTimer) clearTimeout(buttonVanishTimer);
            if (bottomBar && !bottomBar.classList.contains('bar-hidden-by-stylus')) {
                bottomBar.classList.add('bar-hidden-by-stylus');
            }
        }
        const pos = getPos(e, canvas);
        if (!pos) return;
        if (e.touches) e.preventDefault();
        const midPoint = { x: (lastPos.x + pos.x) / 2, y: (lastPos.y + pos.y) / 2 };
        ctx.quadraticCurveTo(lastPos.x, lastPos.y, midPoint.x, midPoint.y);
        ctx.stroke();
        ctx.moveTo(midPoint.x, midPoint.y);
        lastPos = pos;
    }

    function handleDrawingEnd(e) {
        canvas.classList.remove('no-cursor');
        if (isTabletMode) {
            if (buttonVanishTimer) clearTimeout(buttonVanishTimer);
            buttonVanishTimer = setTimeout(() => {
                if (bottomBar) bottomBar.classList.remove('bar-hidden-by-stylus');
            }, 500);
        }
        if (!drawing) return;
        drawing = false;
        ctx.lineTo(lastPos.x, lastPos.y);
        ctx.stroke();
        ctx.closePath();
    }
    
    function clearUserCanvas() {
        ctx.clearRect(0, 0, canvas.width / devicePixelRatio, canvas.height / devicePixelRatio);
        userDrawingOccurred = false;
    }

    function updateAllUITexts() {
        const texts = UI_TEXT[currentLang] || UI_TEXT.en;
        submitBtn.textContent = (currentStageIndex === -1) ? texts.start : texts.submit;
        prevBtn.textContent = texts.prev;
        clearBtn.textContent = texts.clear;
    }

    function checkTabletMode() {
        const tabletQuery = window.matchMedia('(min-width: 769px) and (max-width: 1200px) and (pointer: coarse)');
        const landscapeQuery = window.matchMedia('(min-width: 769px) and (max-width: 1200px) and (min-height: 500px)');
        isTabletMode = tabletQuery.matches || landscapeQuery.matches;
    }
    
    // NEW: Keyboard listeners
    function handleKeyDown(e) {
        // Prevent shortcuts if user is typing in an input (none here, but good practice)
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            return;
        }

        if (e.code === 'Space') {
            e.preventDefault(); // Stop spacebar from scrolling
            if (!submitBtn.disabled) {
                handleSubmitClick();
            }
        } else if (e.key === 'c' || e.key === 'C') {
            e.preventDefault();
            if (!clearBtn.disabled) {
                clearUserCanvas();
            }
        }
    }

    function initApp() {
        resizeCanvases();
        // Test-taking listeners
        canvas.addEventListener('mousedown', handleDrawingStart);
        canvas.addEventListener('mousemove', handleDrawingMove);
        canvas.addEventListener('touchstart', handleDrawingStart, { passive: false });
        canvas.addEventListener('touchmove', handleDrawingMove, { passive: false });
        window.addEventListener('mouseup', handleDrawingEnd);
        window.addEventListener('mouseleave', handleDrawingEnd);
        window.addEventListener('touchend', handleDrawingEnd);
        window.addEventListener('touchcancel', handleDrawingEnd);
        prevBtn.onclick = () => transitionToStage(currentStageIndex - 1);
        submitBtn.onclick = handleSubmitClick;
        clearBtn.onclick = clearUserCanvas;

        // --- Results listeners (REMOVED) ---
        
        // NEW: Keyboard listener
        window.addEventListener('keydown', handleKeyDown);

        window.addEventListener('resize', resizeCanvases);
        const urlParams = new URLSearchParams(window.location.search);
        const testFileName = urlParams.get('testFile');
        if (testFileName) {
            loadTest(`https://thelo.space/tests/${testFileName}`);
        } else {
            alert("No test file specified in the URL. Please add '?testFile=your-test.json'.");
            loadingOverlay.classList.add('hidden');
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        updateAllUITexts(); // Set initial button text

        // NEW: Initialize Firebase from environment
        const hardcodedConfig = { apiKey: "AIzaSyAbnPpcIt88B0jIAoLUdC71zmQDvR_fdu8", authDomain: "physmathacademy-722b3.firebaseapp.com", projectId: "physmathacademy-722b3", messagingSenderId: "1093640992262", appId: "1:1093640992262:web:35b1bf4d2364bcf745f587" };
        
        let firebaseConfigToUse;
        // Use environment config if available
        if (typeof __firebase_config !== 'undefined' && __firebase_config) {
            try {
                firebaseConfigToUse = JSON.parse(__firebase_config);
                console.log("Initialized Firebase with environment config.");
            } catch (e) {
                console.error("Failed to parse __firebase_config, using hardcoded config.", e);
                firebaseConfigToUse = hardcodedConfig;
            }
        } else {
            firebaseConfigToUse = hardcodedConfig;
            console.log("Initialized Firebase with hardcoded config (environment config not found).");
        }
        
        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfigToUse);
        }

        // Assign global instances
        auth = firebase.auth();
        db = firebase.firestore();
        functions = firebase.functions();
        
        // Set log level for debugging
        firebase.firestore.setLogLevel('debug');

        // NEW: Add Auth logic from instructions
        auth.onAuthStateChanged(async (user) => {
            if (user) {
                userId = user.uid; // Set global userId
                console.log("User is signed in:", userId);
            } else {
                console.log("User is not signed in. Attempting auth...");
                try {
                    // Use environment token if available
                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                        await auth.signInWithCustomToken(__initial_auth_token);
                        console.log("Signed in with custom token.");
                    } else {
                        await auth.signInAnonymously();
                        console.log("Signed in anonymously.");
                    }
                    userId = auth.currentUser?.uid;
                    console.log("Signed in. UserID:", userId);
                } catch (error) {
                    console.error("Error signing in:", error);
                    alert("Authentication failed. Please refresh and try again.");
                    return;
                }
            }
            
            // Set global appId - REMOVED as it's no longer used in Firestore paths
            // appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            // console.log("AppID:", appId);

            // Now that auth is ready, init the app
            if (userId) {
                initApp();
            } else {
                console.error("Auth completed but userId is still not set.");
                alert("Could not verify user. Please refresh.");
            }
        });
    });
</script>
</body>
</html>

