<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Graphing Calculator Replay</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;700&display=swap" rel="stylesheet">
    
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.1/math.min.js"></script>
    
    <style>
        /* --- General Setup & Variables --- */
        :root {
            --thelo-blue: #2563eb;
            --thelo-blue-dark: #1d4ed8;
            --thelo-bg: #f9fafb;
            --sidebar-bg: #ffffff;
            --thelo-text: #111827;
            --thelo-text-light: #6b7280;
            --thelo-border: #e5e7eb;
            --error-red: #ef4444;
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            --shadow-sm: 0 2px 4px -1px rgb(0 0 0 / 0.06), 0 2px 2px -1px rgb(0 0 0 / 0.04);
        }
        body {
            margin: 0;
            font-family: 'Manrope', sans-serif;
            display: flex;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            background-color: var(--thelo-bg);
            color: var(--thelo-text);
        }

        /* --- Non-Interactive UI --- */
        #sidebar, #canvasContainer {
            pointer-events: none; /* Disable all interaction */
        }

        /* --- Layout (Mirrors Recorder) --- */
        #sidebar {
            width: 420px;
            min-width: 320px;
            height: 100%;
            background-color: var(--sidebar-bg);
            border-right: 1px solid var(--thelo-border);
            box-shadow: var(--shadow-lg);
            z-index: 10;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--thelo-border);
            flex-shrink: 0;
        }
        .sidebar-header h1 { margin: 0; font-size: 1.25rem; }
        .header-buttons { display: flex; gap: 0.75rem; }
        .header-btn {
            background-color: var(--sidebar-bg);
            color: var(--thelo-text-light);
            border: 1px solid var(--thelo-border);
            border-radius: 8px;
            width: 38px; height: 38px;
            display: flex; align-items: center; justify-content: center;
            font-size: 0.8rem; font-weight: 700;
        }
        #expressionListContainer {
            flex-grow: 1;
            overflow-y: auto;
            padding: 0.5rem 0;
        }
        .expression-item { border-bottom: 1px solid var(--thelo-border); padding: 0.5rem 1rem 0.5rem 0.75rem; }
        .expression-main { display: flex; align-items: center; gap: 0.5rem; }
        .expression-color-bar { width: 28px; height: 28px; border-radius: 50%; flex-shrink: 0; border: 2px solid; }
        .expression-color-bar.hidden-expr { opacity: 0.3; }
        .expression-number { color: var(--thelo-text-light); font-weight: 500; width: 20px; text-align: center; }
        .expression-input-wrapper { display: flex; align-items: center; flex-grow: 1; min-width: 0; }
        .math-input-field { flex-grow: 1; min-width: 0; padding: 8px; font-size: 1.3rem; background-color: var(--sidebar-bg); border: none; }
        
        .expression-result { padding: 0 0.75rem; font-size: 1rem; color: var(--thelo-text-light); font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .expression-extras { padding: 0.75rem 0 0.5rem 52px; }
        .slider-container { display: flex; align-items: center; gap: 10px; margin-bottom: 5px; }
        .slider-container label { font-family: monospace; width: 90px; white-space: nowrap; font-size: 0.9rem; }
        .slider-container input[type=range] { flex-grow: 1; pointer-events: none; }

        /* --- Canvas Area --- */
        #canvasContainer { flex-grow: 1; position: relative; }
        #graphCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #homeBtn { position: absolute; bottom: 20px; right: 20px; width: 44px; height: 44px; background-color: var(--sidebar-bg); border: 1px solid var(--thelo-border); border-radius: 50%; box-shadow: 0 4px 8px rgba(0,0,0,0.1); display: flex; align-items: center; justify-content: center; z-index: 5; }
        #homeBtn svg { width: 24px; height: 24px; stroke: var(--thelo-text-light); }
        
        /* --- Progress Bar (Optional visual feedback) --- */
        #progressBarContainer { position: fixed; bottom: 0; left: 0; width: 100%; height: 4px; background-color: transparent; z-index: 100; }
        #progressBar { width: 0%; height: 100%; background-color: var(--thelo-blue); transition: width 0.1s linear; }

        /* --- Responsive Design --- */
        @media (max-width: 768px) {
            body { flex-direction: column; }
            #sidebar { width: 100%; height: 45vh; min-height: 300px; resize: none; border-right: none; border-bottom: 1px solid var(--thelo-border); }
            #homeBtn { bottom: 15px; right: 15px; }
        }
        #progressBarContainer {
    display: none; /* This line hides the container and its contents */
}
    </style>
</head>
<body>
    <!-- The non-interactive calculator UI -->
    <div id="sidebar">
        <div class="sidebar-header">
            <h1>Replay</h1>
            <div class="header-buttons">
                <div id="toggleAngleModeBtn" class="header-btn active">RAD</div>
            </div>
        </div>
        <div id="expressionListContainer"></div>
    </div>
    <div id="canvasContainer">
        <canvas id="graphCanvas"></canvas>
        <div id="homeBtn">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M2.25 12l8.954-8.955c.44-.439 1.152-.439 1.591 0L21.75 12M4.5 9.75v10.125c0 .621.504 1.125 1.125 1.125H9.75v-4.875c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125V21h4.125c.621 0 1.125-.504 1.125-1.125V9.75M8.25 21h7.5" /></svg>
        </div>
    </div>
    
    <!-- Progress bar for visual feedback during playback -->
    <div id="progressBarContainer"><div id="progressBar"></div></div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // ======================================================
    // =========== AUTOMATED REPLAY ENGINE V5.2 =============
    // =========== (Improved Stability on Seek) =============
    // ======================================================

    // --- DOM ELEMENTS ---
    const canvas = document.getElementById('graphCanvas');
    const ctx = canvas.getContext('2d');
    const expressionListContainer = document.getElementById('expressionListContainer');
    const toggleAngleModeBtn = document.getElementById('toggleAngleModeBtn');
    const progressBarContainer = document.getElementById('progressBarContainer');
    const progressBar = document.getElementById('progressBar');

    // --- LIBRARIES & CONSTANTS ---
    const MQ = MathQuill.getInterface(2);
    let currentDevicePixelRatio = window.devicePixelRatio || 1;
    const PLOT_COLORS = ['#2563eb', '#c026d3', '#22c55e', '#f97316', '#8b5cf6', '#d946ef'];
    const INEQUALITY_ALPHA = 0.2;
    let POI_RADIUS = 4 * currentDevicePixelRatio;

    const SEEK_AMOUNT_MS = 5000; // Time in milliseconds for seeking with arrow keys

    // --- STATE MANAGEMENT ---
    // Define initialGraphState to easily reset to default view settings
    const initialGraphView = { originX: 0, originY: 0, scale: 40 };

    let graphState = {
        ...initialGraphView,
        expressions: [],
        intersections: [],
        lockedPoint: { visible: false, x: 0, y: 0 },
        angleMode: 'rad',
        definedVariables: {},
        activeAnimateView: null // { startTime: ms, duration: ms, startView: {x,y,s}, endView: {x,y,s} }
    };

    // --- PLAYBACK CONTROL STATE ---
    let timeline = [];
    let totalDuration = 0;
    let playbackTime = 0;
    let isPlaying = false;
    let animationFrameId = null;
    let lastTimestamp = 0;
    let lastProcessedEventIndex = -1; // Index of the last command processed by renderStateAtTime or animationLoop

    // --- INITIALIZATION & EVENT LISTENERS ---
    function initialize() {
        // Set initial origin values correctly for the current canvas size
        graphState.originX = canvas.width / 2;
        graphState.originY = canvas.height / 2;

        resizeCanvases(); // Initial resize and draw of empty grid
        setupMessageListener();
        setupKeyListeners();
        renderAll(); // Ensure an empty grid is drawn on load
    }

    function setupMessageListener() {
        window.addEventListener('message', (event) => {
            const receivedData = event.data;
            if (receivedData && Array.isArray(receivedData.actions) && receivedData.meta) {
                // Adjust devicePixelRatio and canvas size based on recorder metadata
                if (receivedData.meta.devicePixelRatio) {
                    currentDevicePixelRatio = receivedData.meta.devicePixelRatio;
                    POI_RADIUS = 4 * currentDevicePixelRatio;
                }
                resizeCanvases(receivedData.meta.canvasDimensions); // Pass recorded dimensions
                startReplay(receivedData.actions);
            } else if (receivedData && receivedData.command === 'seekToTime' && typeof receivedData.timeMs === 'number') {
                seekToAbsoluteTime(receivedData.timeMs);
            } else if (receivedData && receivedData.command === 'seek') {
                // Internal directional seek (e.g., keyboard within iframe)
                seekRelative(receivedData.direction === 'forward' ? SEEK_AMOUNT_MS : -SEEK_AMOUNT_MS);
            }
        });
    }

    function setupKeyListeners() {
        window.addEventListener('keydown', (e) => {
            if (timeline.length === 0) return; // No replay loaded
            if (e.key === 'ArrowRight') seekRelative(SEEK_AMOUNT_MS);
            else if (e.key === 'ArrowLeft') seekRelative(-SEEK_AMOUNT_MS);
            else if (e.key === ' ') {
                e.preventDefault(); // Prevent scrolling page
                togglePlayPause();
            }
        });
    }

    /**
     * Builds the timeline of all actions with absolute timestamps.
     * @param {Array<Object>} actions - Array of raw replay actions.
     */
    function buildTimeline(actions) {
        let currentTime = 0;
        timeline = [];
        actions.forEach(action => {
            // Store action with its starting time
            timeline.push({ time: currentTime, ...action });

            // Advance time based on action type
            if (action.action === 'delay') {
                currentTime += action.ms;
            } else if (action.action === 'animateView') {
                currentTime += action.payload.duration;
            }
            // Other actions implicitly take 0 time for timeline progression
        });
        totalDuration = currentTime;
    }

    /**
     * Starts the replay from the beginning of the loaded actions.
     * @param {Array<Object>} actions - The replay actions to play.
     */
    function startReplay(actions) {
        if (isPlaying) pause(); // Stop any ongoing playback
        buildTimeline(actions); // Create the full timeline
        seekToAbsoluteTime(0); // Jump to time 0 to initialize state and begin playback
        play(); // Start playing
    }

    // --- PLAYBACK CONTROLS ---

    function play() {
        if (isPlaying) return;
        isPlaying = true;
        // progressBarContainer.style.display = 'block'; // Uncomment if you want to show the progress bar
        lastTimestamp = performance.now(); // Initialize lastTimestamp for accurate deltaTime
        animationFrameId = requestAnimationFrame(animationLoop);
    }

    // In the replay iframe's script
function pause() {
    if (!isPlaying) return;
    isPlaying = false;
    cancelAnimationFrame(animationFrameId);
    animationFrameId = null;
}

    // In the replay iframe's script
// In the replay iframe's script

function togglePlayPause() {
    if (isPlaying) {
        pause();
    } else {
        // THIS IS THE KEY FIX FOR REWATCHING:
        // If playback is at (or past) the end, always
        // force a seek to the very beginning before playing.
        if (playbackTime >= totalDuration) {
            seekToAbsoluteTime(0);
        }
        play();
    }
}

    /**
 * Seeks playback relative to the current playback time.
 * Used for internal keyboard controls.
 * @param {number} amountMs - Milliseconds to move forward (+) or backward (-).
 */
function seekRelative(amountMs) {
    let targetTime = playbackTime + amountMs;

    // THIS IS THE KEY CHANGE for boundary handling
    const epsilon = 10; // A small tolerance of 10ms

    // If seeking backwards past the start, snap cleanly to 0.
    if (targetTime < epsilon) {
        targetTime = 0;
    }
    // If seeking forwards past the end, snap cleanly to the end.
    else if (targetTime > totalDuration - epsilon) {
        targetTime = totalDuration;
    }

    seekToAbsoluteTime(targetTime);
}
    /**
     * Seeks playback to an absolute time in the replay timeline.
     * This is the robust method for jumps, especially from external controls.
     * @param {number} targetTimeMs - The absolute time in milliseconds to seek to.
     */
    function seekToAbsoluteTime(targetTimeMs) {
        const wasPlaying = isPlaying;
        if (wasPlaying) pause(); // Pause current animation/loop

        // Clamp target time within valid duration
        playbackTime = Math.max(0, Math.min(targetTimeMs, totalDuration));

        // Fully reconstruct the state at the target time
        renderStateAtTime(playbackTime);

        // Resume playback if it was playing before the seek
        if (wasPlaying) {
            play();
        }
    }

    // --- CORE RENDERING & PLAYBACK LOGIC ---

    /**
 * The main animation loop, called repeatedly by requestAnimationFrame.
 * Manages time progression, continuous animations, and discrete event processing.
 * This version includes robust logic to cleanly handle the end of the replay.
 * @param {DOMHighResTimeStamp} currentDOMTime - Current time provided by requestAnimationFrame.
 */
function animationLoop(currentDOMTime) {
    if (!isPlaying) return;

    const deltaTime = currentDOMTime - lastTimestamp;
    lastTimestamp = currentDOMTime;

    // --- NEW: Robustly handle the end of playback ---
    // Check if this frame will cross the finish line.
    if (playbackTime + deltaTime >= totalDuration) {
        playbackTime = totalDuration;     // Clamp time to the exact end
        renderStateAtTime(totalDuration); // Render the final state perfectly
        pause();                          // Cleanly stop the animation loop
        return;                           // Exit the function
    }

    // --- Default path: Advance time and process events ---
    playbackTime += deltaTime;

    let needsFullReevaluation = false;
    let nextCommandIndex = lastProcessedEventIndex + 1;

    // Handle interpolation for an active 'animateView' command
    if (graphState.activeAnimateView) {
        const { startTime, duration, startView, endView } = graphState.activeAnimateView;
        const animationProgress = Math.min(1, (playbackTime - startTime) / duration);

        if (animationProgress < 1) {
            graphState.originX = startView.originX + (endView.originX - startView.originX) * animationProgress;
            graphState.originY = startView.originY + (endView.originY - startView.originY) * animationProgress;
            graphState.scale = startView.scale + (endView.scale - startView.scale) * animationProgress;
        } else {
            Object.assign(graphState, endView);
            graphState.activeAnimateView = null;
            needsFullReevaluation = true;
        }
    }

    // Process discrete commands that have become due
    while (nextCommandIndex < timeline.length && timeline[nextCommandIndex].time <= playbackTime) {
        const command = timeline[nextCommandIndex];

        if (command.action === 'animateView') {
            graphState.activeAnimateView = {
                startTime: command.time,
                duration: command.payload.duration,
                startView: command.payload.startView,
                endView: command.payload.endView
            };
            Object.assign(graphState, command.payload.startView);
            needsFullReevaluation = true;
        } else if (command.action !== 'delay') {
            executeReplayCommand(command);
            if (['setLatex', 'addExpression', 'removeExpression', 'setSlider', 'setAngleMode', 'toggleVisibility', 'resetView', 'lockPoint', 'unlockPoint'].includes(command.action)) {
                needsFullReevaluation = true;
            }
        }
        lastProcessedEventIndex = nextCommandIndex;
        nextCommandIndex++;
    }

    if (needsFullReevaluation) {
        evaluateAndCacheAll();
    }

    renderAll();

    // --- Update UI and continue the loop ---
    progressBar.style.width = `${(playbackTime / totalDuration) * 100}%`;
    animationFrameId = requestAnimationFrame(animationLoop);
}

    /**
 * The "Cold Path": Reconstructs the entire calculator state for a specific time.
 * This is the critical function for reliable seeking.
 * It ensures the `graphState` and UI are precisely as they would be if the replay played linearly to `time`.
 * @param {number} time - The target time in milliseconds to reconstruct the state for.
 */
function renderStateAtTime(time) {
    // --- STEP 1: Perform a complete reset of the replay player's UI and internal state.
    expressionListContainer.innerHTML = ''; // Clear all expression UI elements
    
    // THE FIX IS HERE: Reset the expressions array to prevent duplicates on rebuild.
    graphState.expressions = []; 

    // Reset other main graphState properties to their defaults (or initial state)
    Object.assign(graphState, {
        ...initialGraphView,
        intersections: [],
        lockedPoint: { visible: false, x: 0, y: 0 },
        angleMode: 'rad',
        definedVariables: {},
        activeAnimateView: null
    });

    // Reset angle mode button to default visual state
    toggleAngleModeBtn.textContent = 'RAD';
    toggleAngleModeBtn.classList.add('active');

    // Clear the canvas to remove any previous drawing
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Reset the last processed event index.
    lastProcessedEventIndex = -1;

    // --- STEP 2: Iterate through the timeline from the beginning up to the target time. ---
    for (let i = 0; i < timeline.length; i++) {
        const command = timeline[i];

        if (command.time > time) {
             // Special handling for seeking *into* an 'animateView' command
            if (command.action === 'animateView' && command.time < time) {
                const animationEndTime = command.time + command.payload.duration;
                if (time < animationEndTime) {
                    const progress = (time - command.time) / command.payload.duration;
                    graphState.originX = command.payload.startView.originX + (command.payload.endView.originX - command.payload.startView.originX) * progress;
                    graphState.originY = command.payload.startView.originY + (command.payload.endView.originY - command.payload.startView.originY) * progress;
                    graphState.scale = command.payload.startView.scale + (command.payload.endView.scale - command.payload.startView.scale) * progress;
                    
                    graphState.activeAnimateView = { ...command.payload, startTime: command.time };
                    lastProcessedEventIndex = i;
                    break;
                }
            }
            break; // Stop, no more commands to process up to 'time'
        }

        // --- Apply the command's effect to the state ---
        if (command.action === 'initialState') {
            Object.assign(graphState, command.payload.view);
            graphState.angleMode = command.payload.angleMode;
            toggleAngleModeBtn.textContent = graphState.angleMode.toUpperCase();
            toggleAngleModeBtn.classList.toggle('active', graphState.angleMode === 'rad');
            command.payload.expressions.forEach(initialExpr => {
                const clonedSliders = initialExpr.sliders ? JSON.parse(JSON.stringify(initialExpr.sliders)) : {};
                const completeExpr = { plotPoints: [], ...initialExpr, sliders: clonedSliders };
                addExpressionUI(completeExpr);
            });
        } else if (command.action === 'animateView') {
            // Apply the final state of any animation that completed before 'time'
            Object.assign(graphState, command.payload.endView);
        } else if (command.action !== 'delay') {
            executeReplayCommand(command);
        }

        lastProcessedEventIndex = i;
    }

    // --- STEP 3: Finalize state and perform initial render. ---
    evaluateAndCacheAll();
    renderAll();
    progressBar.style.width = `${(playbackTime / totalDuration) * 100}%`;
}
    /**
     * Executes a single replay command, applying its effect to the graphState and UI.
     * This function is used by both `renderStateAtTime` (cold path) and `animationLoop` (hot path).
     * @param {Object} command - The command object from the timeline.
     */
    function executeReplayCommand(command) {
        if (!command || !command.action) return; // Basic validation
        const { action, payload } = command;
        let expr, mathField, item;

        switch (action) {
            case 'initialState':
                // `initialState` should primarily be handled by `renderStateAtTime`'s top-level reset and loop.
                // If it somehow gets called here, it would trigger a reset.
                // For robustness, ensure all relevant state is reset.
                expressionListContainer.innerHTML = '';
                graphState.expressions = [];
                Object.assign(graphState, payload.view);
                graphState.angleMode = payload.angleMode;
                toggleAngleModeBtn.textContent = graphState.angleMode.toUpperCase();
                toggleAngleModeBtn.classList.toggle('active', graphState.angleMode === 'rad');
                payload.expressions.forEach(initialExpr => {
                    const completeExpr = { sliders: {}, ...initialExpr };
                    completeExpr.sliders = initialExpr.sliders ? JSON.parse(JSON.stringify(initialExpr.sliders)) : {};
                    addExpressionUI(completeExpr); // This re-creates UI, vital!
                });
                break;
            case 'addExpression':
                // When adding, ensure we generate a unique ID if not provided (should be provided by recorder)
                // and assign a plot color.
                const color = PLOT_COLORS[graphState.expressions.length % PLOT_COLORS.length];
                const newExprData = {
                    id: payload.id, // Use ID from payload for consistency
                    latex: payload.latex || '',
                    visible: payload.visible !== undefined ? payload.visible : true,
                    color: payload.color || color,
                    sliders: payload.sliders || {}
                };
                addExpressionUI(newExprData); // Calls addExpressionUI to create the UI element
                break;
            case 'removeExpression':
                // Find and remove the expression's UI element
                item = document.getElementById(payload.id);
                if (item) item.remove();
                // Filter the expression from the global state array
                graphState.expressions = graphState.expressions.filter(e => e.id !== payload.id);
                updateExpressionNumbers(); // Re-index expression numbers in UI
                break;
            case 'focusExpression':
                // Remove focus from any currently focused MathQuill fields
                document.querySelectorAll('.math-input-field.mq-focused').forEach(el => el.classList.remove('mq-focused'));
                // Add focus to the target expression's field
                item = document.getElementById(payload.id);
                if (item) {
                    item.querySelector('.math-input-field').classList.add('mq-focused');
                }
                break;
            case 'setLatex':
                // Find the expression in state and update its latex
                expr = graphState.expressions.find(e => e.id === payload.id);
                if (expr) {
                    expr.latex = payload.latex;
                    // Find the MathQuill field and update its displayed LaTeX
                    mathField = MQ(document.getElementById(payload.id).querySelector('.math-input-field'));
                    if (mathField) {
                        mathField.latex(payload.latex);
                    }
                }
                break;
            case 'animateView':
                // `animateView` is largely handled by `renderStateAtTime` and `animationLoop`
                // for interpolation. If `executeReplayCommand` is called with it, it means
                // we should apply the *start* view as a discrete jump.
                Object.assign(graphState, payload.startView);
                break;
            case 'setSlider':
                // Find the expression and its slider, then update the value
                expr = graphState.expressions.find(e => e.id === payload.exprId);
                if (expr && expr.sliders[payload.name]) {
                    expr.sliders[payload.name].val = payload.value;
                    // Update the visible slider and its label in the UI
                    const itemElement = document.getElementById(payload.exprId);
                    if (itemElement) {
                        const sliderInputs = itemElement.querySelectorAll(`.slider-container input[type=range]`);
                        let targetSlider = null;
                        for (const input of sliderInputs) {
                            const label = input.previousElementSibling;
                            if (label && label.textContent.startsWith(payload.name)) {
                                targetSlider = input;
                                break;
                            }
                        }
                        if (targetSlider) {
                            targetSlider.value = payload.value;
                            const labelEl = targetSlider.previousElementSibling;
                            if (labelEl) {
                                labelEl.textContent = `${payload.name} = ${payload.value}`;
                            }
                        }
                    }
                }
                break;
            case 'toggleVisibility':
                // Update expression's visibility in state and its UI indicator
                expr = graphState.expressions.find(e => e.id === payload.id);
                if (expr) {
                    expr.visible = payload.visible;
                    document.getElementById(payload.id).querySelector('.expression-color-bar').classList.toggle('hidden-expr', !expr.visible);
                }
                break;
            case 'resetView':
                // Reset graph view to defaults (without immediately redrawing; renderAll will do that)
                resetView(false);
                break;
            case 'setAngleMode':
                // Update angle mode in state and its UI button
                graphState.angleMode = payload.mode;
                toggleAngleModeBtn.textContent = graphState.angleMode.toUpperCase();
                toggleAngleModeBtn.classList.toggle('active', graphState.angleMode === 'rad');
                break;
            case 'lockPoint':
                // Set the locked point's properties
                graphState.lockedPoint = { visible: true, ...payload };
                break;
            case 'unlockPoint':
                // Hide the locked point
                graphState.lockedPoint.visible = false;
                break;
        }
    }

    /**
     * Adds an expression's UI element to the sidebar and initializes its MathQuill field.
     * Crucial for rebuilding the UI during `renderStateAtTime`.
     * @param {Object} exprData - The expression data to add.
     */
    function addExpressionUI(exprData) {
        // Create a deep copy to ensure independence
        const newExpr = JSON.parse(JSON.stringify(exprData));
        newExpr.plotPoints = []; // Initialize plotPoints cache

        graphState.expressions.push(newExpr); // Add to the state

        const item = document.createElement('div');
        item.className = 'expression-item';
        item.id = newExpr.id; // Set the ID from data
        const exprIndex = graphState.expressions.length; // Use current length for display number
        item.innerHTML = `
            <div class="expression-main">
                <span class="expression-number">${exprIndex}</span>
                <div class="expression-color-bar"></div>
                <div class="expression-input-wrapper">
                    <span class="math-input-field"></span>
                </div>
                <span class="expression-result"></span>
            </div>
            <div class="expression-extras"></div>
        `;
        expressionListContainer.appendChild(item);

        // Initialize MathQuill StaticMath for the new field
        const mathFieldElement = item.querySelector('.math-input-field');
        const mathField = MQ.StaticMath(mathFieldElement);

        // **IMPORTANT:** Set the LaTeX for the MathQuill field immediately after initialization.
        // This ensures the content is displayed correctly from the start.
        if (newExpr.latex) {
            mathField.latex(newExpr.latex);
        }

        // Apply initial styling for color and visibility
        item.querySelector('.expression-color-bar').style.backgroundColor = newExpr.color;
        item.querySelector('.expression-color-bar').style.borderColor = newExpr.color;
        item.querySelector('.expression-color-bar').classList.toggle('hidden-expr', !newExpr.visible);

        // Populate sliders UI (non-interactive in replay)
        const extrasEl = item.querySelector('.expression-extras');
        if (newExpr.sliders) {
            Object.keys(newExpr.sliders).forEach(name => {
                const slider = newExpr.sliders[name];
                const sliderDiv = document.createElement('div');
                sliderDiv.className = 'slider-container';
                sliderDiv.innerHTML = `<label>${name} = ${slider.val}</label><input type="range" min="${slider.min}" max="${slider.max}" value="${slider.val}" step="${slider.step}" disabled>`;
                extrasEl.appendChild(sliderDiv);
            });
        }

        updateExpressionNumbers(); // Update numbers for all expressions
    }

    function updateExpressionNumbers() {
        expressionListContainer.querySelectorAll('.expression-item').forEach((item, index) => {
            item.querySelector('.expression-number').textContent = index + 1;
        });
    }

    /**
     * Heavy evaluation path. Parses expressions, calculates plot points, and finds intersections.
     * Called after any state change that affects the graph's mathematical rendering.
     */
    function evaluateAndCacheAll() {
        // Reset defined variables for a clean re-evaluation
        graphState.definedVariables = {};
        // Parse and compile each expression, also identifying sliders
        graphState.expressions.forEach(parseSingleExpression);
        // Calculate and cache plot points for all visible functions/inequalities
        graphState.expressions.forEach(calculatePlotPoints);
        // Find and store intersection points
        findAndStoreIntersections();
        // Update the UI elements (results, slider values) based on current state
        graphState.expressions.forEach(updateExpressionUI);
    }

    /**
     * Calculates a high-density set of points for a function and caches them.
     * This pre-computation makes `plotFunction` very fast.
     */
    function calculatePlotPoints(expr) {
        if (!expr.compiled || (expr.type !== 'function' && expr.type !== 'inequality')) {
            expr.plotPoints = [];
            return;
        }

        const scope = getEvaluationScope(expr);
        const points = [];
        const xMin = -100; // Wide range for data, regardless of current zoom
        const xMax = 100;
        const numPoints = 10000; // High density for smooth curves
        const dx = (xMax - xMin) / numPoints;

        for (let i = 0; i <= numPoints; i++) {
            const x = xMin + i * dx;
            scope.x = x;
            try {
                const y = expr.compiled.evaluate(scope);
                if (Number.isFinite(y)) {
                    points.push({ x, y });
                } else {
                    points.push(null); // Indicates a break or discontinuity
                }
            } catch (e) {
                points.push(null); // Error in evaluation
            }
        }
        expr.plotPoints = points;
    }

    /**
     * Fast rendering path. Draws grid, cached points, and overlays. Always fast.
     * This function should only *draw* based on the current `graphState` and `plotPoints` cache.
     */
    function renderAll() {
        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the entire canvas
        drawGraphGrid(); // Draw the background grid and axes
        graphState.expressions.forEach(expr => {
            if (!expr.visible || expr.error) return; // Skip hidden or erroring expressions
            if (expr.type === "inequality") plotInequality(expr);
            else if (expr.type === "vertical_inequality") plotVerticalInequality(expr);
            else if (expr.type === "function") { plotFunction(expr); drawPointsOfInterest(expr); }
            else if (expr.type === "vertical_line") plotVerticalLine(expr);
        });
        drawAllIntersectionPoints(); // Draw intersection points
        if (graphState.lockedPoint.visible) drawLockedPoint(); // Draw the locked point if visible
    }

    /**
     * High-performance plot function that uses the pre-calculated point cache.
     */
    function plotFunction(expr) {
        if (!expr.plotPoints || expr.plotPoints.length === 0) return;

        ctx.strokeStyle = expr.color;
        ctx.lineWidth = 2.5 * currentDevicePixelRatio;
        ctx.beginPath();
        let firstPoint = true; // Flag to handle discontinuities (moveTo vs lineTo)

        for (const point of expr.plotPoints) {
            if (point === null) {
                firstPoint = true; // Start a new segment after a discontinuity
                continue;
            }
            // Transform graph coordinates to pixel coordinates
            const px = graphState.originX + point.x * graphState.scale;
            const py = graphState.originY - point.y * graphState.scale; // Y-axis inverted for canvas

            // Basic culling: skip drawing points far off-screen to save performance
            if (px < -10 || px > canvas.width + 10 || py < -10 || py > canvas.height + 10) {
                 firstPoint = true; // Treat as discontinuity if off-screen
                 continue;
            }

            if (firstPoint) {
                ctx.moveTo(px, py);
                firstPoint = false;
            } else {
                ctx.lineTo(px, py);
            }
        }
        ctx.stroke(); // Draw the path
    }

    // --- Graphing Helpers (Remaining functions largely unchanged, but included for completeness) ---

    function plotInequality(expr) { if (!expr.plotPoints || expr.plotPoints.length === 0) return; const scope = getEvaluationScope(expr); ctx.fillStyle = expr.color; ctx.globalAlpha = INEQUALITY_ALPHA; ctx.beginPath(); let firstPoint = !0; for (const point of expr.plotPoints) { if (point === null) { firstPoint = !0; continue } const px = graphState.originX + point.x * graphState.scale; if (px < -10 || px > canvas.width + 10) { firstPoint = !0; continue } const py = graphState.originY - point.y * graphState.scale; if (firstPoint) { ctx.moveTo(px, py); firstPoint = !1 } else { ctx.lineTo(px, py) } } const op = expr.inequalityType; if (op.includes(">")) { ctx.lineTo(canvas.width, 0); ctx.lineTo(0, 0) } else { ctx.lineTo(canvas.width, canvas.height); ctx.lineTo(0, canvas.height) } ctx.closePath(); ctx.fill(); ctx.globalAlpha = 1; if (op === "<" || op === ">") { ctx.setLineDash([8 * currentDevicePixelRatio, 8 * currentDevicePixelRatio]) } plotFunction(expr); ctx.setLineDash([]) }
    function parseSingleExpression(expr) { Object.assign(expr, { type: "empty", compiled: null, error: null, result: null, node: null, inequalityType: null, isImplicit: !1 }); let cleanStr = preprocessInputString(latexToMathJs(expr.latex.trim())); if (!cleanStr) return; try { const node = math.parse(cleanStr); expr.node = node; const scope = getEvaluationScope(expr); if (node.isAssignmentNode) { const varName = node.object.name; if (node.toString().match(/[xy]/)) { expr.error = "Cannot assign expression with x or y."; return } expr.type = "assignment"; const result = node.evaluate(scope); expr.result = result; graphState.definedVariables[varName] = result } else if (cleanStr.includes("x") || cleanStr.includes("y")) { expr.type = "function"; let parseableNode = node; if (node.isOperatorNode && node.op === "=") { const [left, right] = node.args; if (left.isSymbolNode && left.name === "y") { parseableNode = right } else if (right.isSymbolNode && right.name === "y") { parseableNode = left } else if (left.isSymbolNode && left.name === "x") { expr.type = "vertical_line"; expr.x_value = right.evaluate(scope) } else if (right.isSymbolNode && right.name === "x") { expr.type = "vertical_line"; expr.x_value = left.evaluate(scope) } else { expr.error = "Implicit functions not supported yet." } } if (expr.type === "function") { expr.node = parseableNode; expr.compiled = parseableNode.compile() } } else if (node.isOperatorNode && ["<", ">", "<=", ">="].includes(node.op)) { expr.inequalityType = node.op; const [left, right] = node.args; if (left.isSymbolNode && left.name === "y") { expr.type = "inequality"; expr.compiled = right.compile() } else if (right.isSymbolNode && right.name === "y") { expr.type = "inequality"; expr.compiled = left.compile(); expr.inequalityType = { ">": "<", ">=": "<=", "<": ">", "<=": ">=" }[node.op] } else if (left.isSymbolNode && left.name === "x") { expr.type = "vertical_inequality"; expr.x_value = right.evaluate(scope) } else if (right.isSymbolNode && right.name === "x") { expr.type = "vertical_inequality"; expr.x_value = left.evaluate(scope); expr.inequalityType = { ">": "<", ">=": "<=", "<": ">", "<=": ">=" }[node.op] } else { expr.type = "calculation"; expr.result = node.evaluate(scope) } } else { expr.type = "calculation"; expr.result = node.evaluate(scope) } if (expr.type === "function" || expr.type === "inequality") { const knownSymbols = ["x", "y", "e", "pi", "i", "true", "false", "theta", ...Object.keys(math)]; const foundSymbols = new Set; expr.node.traverse(n => { if (n.isSymbolNode && !knownSymbols.includes(n.name) && !graphState.definedVariables.hasOwnProperty(n.name)) { foundSymbols.add(n.name) } }); foundSymbols.forEach(name => { if (!expr.sliders[name]) expr.sliders[name] = { val: 1, min: -5, max: 5, step: .1 } }); Object.keys(expr.sliders).forEach(name => { if (!foundSymbols.has(name)) delete expr.sliders[name] }) } else { expr.sliders = {} } if (expr.type === "function") findPointsOfInterest(expr) } catch (err) { expr.error = err.message.length > 50 ? err.message.substring(0, 50) + "..." : err.message } }
    function updateExpressionUI(expr) {
        const item = document.getElementById(expr.id);
        if (!item) return;
        const resultEl = item.querySelector(".expression-result");
        const extrasEl = item.querySelector(".expression-extras");
        const colorBar = item.querySelector(".expression-color-bar");
        resultEl.textContent = "";
        extrasEl.innerHTML = "";
        colorBar.style.backgroundColor = expr.error ? "var(--error-red)" : expr.visible ? expr.color : "#ccc";
        colorBar.style.borderColor = expr.error ? "var(--error-red)" : expr.color;
        if (expr.error) { resultEl.textContent = "Error" } else if (expr.result !== null && expr.result !== undefined) { try { if (Array.isArray(expr.result)) { resultEl.textContent = `= [${expr.result.map(v => math.format(v, { precision: 3 })).join(", ")}]` } else if (typeof expr.result === "function") { resultEl.textContent = "f(x)" } else { resultEl.textContent = `= ${math.format(expr.result, { precision: 5 })}` } } catch { resultEl.textContent = `= ${expr.result.toString()}` } }
        Object.keys(expr.sliders).forEach(name => {
            const slider = expr.sliders[name];
            const sliderDiv = document.createElement("div");
            sliderDiv.className = "slider-container";
            sliderDiv.innerHTML = `<label>${name} = ${slider.val}</label><input type="range" min="${slider.min}" max="${slider.max}" value="${slider.val}" step="${slider.step}" disabled>`;
            extrasEl.appendChild(sliderDiv)
        })
    }
    function plotVerticalLine(expr) { ctx.strokeStyle = expr.color; ctx.lineWidth = 2.5 * currentDevicePixelRatio; const boundaryPx = graphState.originX + expr.x_value * graphState.scale; ctx.beginPath(); ctx.moveTo(boundaryPx, 0); ctx.lineTo(boundaryPx, canvas.height); ctx.stroke() }
    function plotVerticalInequality(expr) { ctx.fillStyle = expr.color; ctx.globalAlpha = INEQUALITY_ALPHA; const boundaryPx = graphState.originX + expr.x_value * graphState.scale; const op = expr.inequalityType; if (op.includes("<")) { ctx.fillRect(0, 0, boundaryPx, canvas.height) } if (op.includes(">")) { ctx.fillRect(boundaryPx, 0, canvas.width - boundaryPx, canvas.height) } ctx.globalAlpha = 1; if (!op.includes("=")) { ctx.setLineDash([8 * currentDevicePixelRatio, 8 * currentDevicePixelRatio]) } plotVerticalLine(expr); ctx.setLineDash([]) }
    function findPointsOfInterest(expr) {
        expr.poi = { roots: [], y_intercept: null, extrema: [] }; if (!expr.compiled) return; const scope = getEvaluationScope(expr); try { const y_intercept = expr.compiled.evaluate({ ...scope, x: 0 }); if (Number.isFinite(y_intercept)) expr.poi.y_intercept = { x: 0, y: y_intercept } } catch (e) { }
        let prev_y, prev_slope_sign; const step = 1 / graphState.scale; for (let px = 0; px < canvas.width; px++) {
            const x = (px - graphState.originX) / graphState.scale; try {
                const y = expr.compiled.evaluate({ ...scope, x: x }); if (prev_y !== undefined && Number.isFinite(y) && Number.isFinite(prev_y)) {
                    if (Math.sign(y) !== Math.sign(prev_y)) { expr.poi.roots.push({ x: x - step / 2, y: 0 }) } const next_y = expr.compiled.evaluate({ ...scope, x: x + step }); if (Number.isFinite(next_y)) {
                        const slope_sign = Math.sign(next_y - y); if (prev_slope_sign !== undefined && slope_sign !== prev_slope_sign && slope_sign !== 0) { expr.poi.extrema.push({ x: x, y: y }) }
                        prev_slope_sign = slope_sign
                    }
                } prev_y = y
            } catch (e) { prev_y = undefined; prev_slope_sign = undefined }
        }
    }
    function drawPointsOfInterest(expr) {
        ctx.fillStyle = expr.color; const all_pois = [...expr.poi.roots, ...expr.poi.extrema]; if (expr.poi.y_intercept) all_pois.push(expr.poi.y_intercept); all_pois.forEach(point => {
            if (!point) return; const px = graphState.originX + point.x * graphState.scale; const py = graphState.originY - point.y * graphState.scale; ctx.beginPath(); ctx.arc(px, py, POI_RADIUS, 0, Math.PI * 2); ctx.fill()
        })
    }
    function bisectionSolve(f1_expr, f2_expr, a, b, tolerance = 1e-7, maxIterations = 50) {
        const f1_scope = getEvaluationScope(f1_expr); const f2_scope = getEvaluationScope(f2_expr); let fa, fb; try { fa = f1_expr.compiled.evaluate({ ...f1_scope, x: a }) - f2_expr.compiled.evaluate({ ...f2_scope, x: a }); fb = f1_expr.compiled.evaluate({ ...f1_scope, x: b }) - f2_expr.compiled.evaluate({ ...f2_scope, x: b }) } catch (e) { return null } if (isNaN(fa) || isNaN(fb) || Math.sign(fa) === Math.sign(fb)) return null; let c = a; for (let i = 0; i < maxIterations; i++) { c = (a + b) / 2; let fc = f1_expr.compiled.evaluate({ ...f1_scope, x: c }) - f2_expr.compiled.evaluate({ ...f2_scope, x: c }); if (Math.abs(fc) < tolerance || (b - a) / 2 < tolerance) return c; if (Math.sign(fc) === Math.sign(fa)) { a = c; fa = fc } else { b = c } } return c
    }
    function findAndStoreIntersections() {
        graphState.intersections = []; const plottableFuncs = graphState.expressions.filter(e => e.visible && e.compiled && (e.type === "function" || e.type === "inequality")); if (plottableFuncs.length < 2) return; for (let i = 0; i < plottableFuncs.length; i++) {
            for (let j = i + 1; j < plottableFuncs.length; j++) {
                const f1_expr = plottableFuncs[i], f2_expr = plottableFuncs[j]; let prev_diff; for (let px = 0; px < canvas.width; px++) {
                    const x = (px - graphState.originX) / graphState.scale; try {
                        const y1 = f1_expr.compiled.evaluate({ ...getEvaluationScope(f1_expr), x: x }); const y2 = f2_expr.compiled.evaluate({ ...getEvaluationScope(f2_expr), x: x }); const diff = y1 - y2; if (prev_diff !== undefined && Math.sign(diff) !== Math.sign(prev_diff)) {
                            const intersectionX = bisectionSolve(f1_expr, f2_expr, x - (1 / graphState.scale), x); if (intersectionX !== null) {
                                const intersectionY = f1_expr.compiled.evaluate({ ...getEvaluationScope(f1_expr), x: intersectionX }); if (Number.isFinite(intersectionY)) graphState.intersections.push({ x: intersectionX, y: intersectionY })
                            }
                        } prev_diff = diff
                    } catch (e) { prev_diff = undefined }
                }
            }
        }
    }
    function drawAllIntersectionPoints() {
        ctx.fillStyle = "#333"; graphState.intersections.forEach(point => {
            const pixelX = graphState.originX + point.x * graphState.scale; const pixelY = graphState.originY - point.y * graphState.scale; ctx.beginPath(); ctx.arc(pixelX, pixelY, POI_RADIUS, 0, Math.PI * 2); ctx.fill()
        })
    }
    function drawLockedPoint() {
        const { x, y } = graphState.lockedPoint; const pixelX = graphState.originX + x * graphState.scale; const pixelY = graphState.originY - y * graphState.scale; ctx.fillStyle = "#000"; ctx.beginPath(); ctx.arc(pixelX, pixelY, POI_RADIUS * 1.2, 0, Math.PI * 2); ctx.fill(); const displayX = snapToZero(x); const displayY = snapToZero(y); const coordText = `(${displayX.toFixed(3)}, ${displayY.toFixed(3)})`; const FONT_SIZE = 12 * currentDevicePixelRatio; ctx.font = `bold ${FONT_SIZE}px 'Manrope'`; const textMetrics = ctx.measureText(coordText); const boxWidth = textMetrics.width + 16 * currentDevicePixelRatio; const boxHeight = FONT_SIZE + 12 * currentDevicePixelRatio; let boxX = pixelX + 15 * currentDevicePixelRatio; let boxY = pixelY - boxHeight / 2; if (boxX + boxWidth > canvas.width) boxX = pixelX - boxWidth - 15 * currentDevicePixelRatio; if (boxY < 0) boxY = 5 * currentDevicePixelRatio; if (boxY + boxHeight > canvas.height) boxY = canvas.height - boxHeight - 5 * currentDevicePixelRatio; ctx.fillStyle = "rgba(255, 255, 255, 0.9)"; ctx.shadowColor = "rgba(0,0,0,0.2)"; ctx.shadowBlur = 10; ctx.beginPath(); ctx.roundRect(boxX, boxY, boxWidth, boxHeight, 5 * currentDevicePixelRatio); ctx.fill(); ctx.shadowColor = "transparent"; ctx.fillStyle = "#000"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(coordText, boxX + boxWidth / 2, boxY + boxHeight / 2)
    }
    function resizeCanvases(recordedCanvasDimensions = null) {
        const rect = canvas.parentElement.getBoundingClientRect();
        if (recordedCanvasDimensions && recordedCanvasDimensions.width && recordedCanvasDimensions.height) {
            canvas.width = recordedCanvasDimensions.width * currentDevicePixelRatio;
            canvas.height = recordedCanvasDimensions.height * currentDevicePixelRatio;
            canvas.style.width = `${recordedCanvasDimensions.width}px`;
            canvas.style.height = `${recordedCanvasDimensions.height}px`;
        } else {
            canvas.width = rect.width * currentDevicePixelRatio;
            canvas.height = rect.height * currentDevicePixelRatio;
            canvas.style.width = `${rect.width}px`;
            canvas.style.height = `${rect.height}px`;
        }
        // When resizing, we must reset the view based on the new dimensions
        // and trigger a full state re-evaluation and render.
        graphState.originX = canvas.width / 2;
        graphState.originY = canvas.height / 2;
        // Don't reset scale, as it should persist across resizes unless explicitly reset by command
        
        // No need to call evaluateAndCacheAll() or renderAll() here directly,
        // because initialize() or startReplay() will call renderStateAtTime(0)
        // or a subsequent seekToAbsoluteTime() will trigger it, which covers all drawing.
    }
    // Updated resetView to use initialGraphView constants
    function resetView(redraw = true) {
        Object.assign(graphState, initialGraphView); // Reset to predefined initial view
        // Adjust origin based on current canvas size, which might have changed since initialGraphView was defined
        graphState.originX = canvas.width / 2;
        graphState.originY = canvas.height / 2;
        if (redraw) {
            evaluateAndCacheAll();
            renderAll();
        }
    }
    function drawGraphGrid() {
        const computedStyles = getComputedStyle(document.documentElement); const THELO_BORDER_COLOR = computedStyles.getPropertyValue("--thelo-border").trim(); const THELO_TEXT_LIGHT_COLOR = computedStyles.getPropertyValue("--thelo-text-light").trim(); ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.restore(); let dynamicGrid = 1; while (dynamicGrid * graphState.scale < 50 * currentDevicePixelRatio) { dynamicGrid *= (dynamicGrid * graphState.scale < 25 * currentDevicePixelRatio ? 2 : 2.5) }
        while (dynamicGrid * graphState.scale > 100 * currentDevicePixelRatio) { dynamicGrid /= (dynamicGrid * graphState.scale > 250 * currentDevicePixelRatio ? 2.5 : 2) }
        ctx.strokeStyle = THELO_BORDER_COLOR; ctx.lineWidth = 1 * currentDevicePixelRatio; ctx.font = `${10 * currentDevicePixelRatio}px 'Manrope'`; ctx.fillStyle = THELO_TEXT_LIGHT_COLOR; ctx.textAlign = "center"; ctx.textBaseline = "middle"; const startX = Math.floor(-graphState.originX / (graphState.scale * dynamicGrid)) * dynamicGrid; for (let x = startX; x * graphState.scale + graphState.originX < canvas.width; x += dynamicGrid) { const px = x * graphState.scale + graphState.originX; ctx.beginPath(); ctx.moveTo(px, 0); ctx.lineTo(px, canvas.height); ctx.stroke(); if (Math.abs(x) > 1e-9) { ctx.fillText(Number(x.toPrecision(4)), px + 2 * currentDevicePixelRatio, graphState.originY - 5 * currentDevicePixelRatio) } }
        const startY = Math.floor(graphState.originY / (graphState.scale * dynamicGrid)) * dynamicGrid; for (let y = startY; graphState.originY - y * graphState.scale < canvas.height; y -= dynamicGrid) { const py = graphState.originY - y * graphState.scale; ctx.beginPath(); ctx.moveTo(0, py); ctx.lineTo(canvas.width, py); ctx.stroke(); if (Math.abs(y) > 1e-9) { ctx.save(); ctx.textAlign = "right"; ctx.fillText(Number(y.toPrecision(4)), graphState.originX - 5 * currentDevicePixelRatio, py + 2 * currentDevicePixelRatio); ctx.restore() } }
        ctx.strokeStyle = THELO_TEXT_LIGHT_COLOR; ctx.lineWidth = 1.5 * currentDevicePixelRatio; ctx.beginPath(); ctx.moveTo(0, graphState.originY); ctx.lineTo(canvas.width, graphState.originY); ctx.stroke(); ctx.beginPath(); ctx.moveTo(graphState.originX, 0); ctx.lineTo(graphState.originX, canvas.height); ctx.stroke()
    }
    function snapToZero(num, tolerance = 1e-6) { return Math.abs(num) < tolerance ? 0 : num }
    function latexToMathJs(latex) {
        let processed = latex.replace(/\\left\|([\s\S]+?)\\right\|/g, "abs($1)"); while (processed.includes("|")) { processed = processed.replace(/\|([^|]*)\|/g, "abs($1)") }
        return processed.replace(/\\operatorname{([a-zA-Z]+)}/g, "$1").replace(/\\frac{d}{dx}\\left\(([\s\S]+?)\\right\)/g, "derivative('$1', 'x')").replace(/\\sin/g, "sin").replace(/\\cos/g, "cos").replace(/\\tan/g, "tan").replace(/\\log/g, "log10").replace(/\\ln/g, "log").replace(/\\sqrt/g, "sqrt").replace(/\\pi/g, "pi").replace(/\\theta/g, "theta").replace(/\\le/g, "<=").replace(/\\ge/g, ">=").replace(/\\left\(/g, "(").replace(/\\right\)/g, ")").replace(/\\left\[/g, "[").replace(/\\right\]/g, "]").replace(/\\cdot/g, "*").replace(/\\frac{([^}]+)}{([^}]+)}/g, "($1)/($2)").replace(/{/g, "(").replace(/}/g, ")")
    }
    function preprocessInputString(str) { const functionNames = "sin|cos|tan|asin|acos|atan|log10|log|sqrt|abs|mean|median|stdev|min|max|total|quartile"; const funcArgRegex = new RegExp(`\\b(${functionNames})\\s+([a-zA-Z0-9πθ.\\[\\]]+)`, "g"); return str.replace(funcArgRegex, "$1($2)") }
    function getEvaluationScope(expr) {
        const scope = { ...graphState.definedVariables }; Object.keys(expr.sliders).forEach(name => { scope[name] = expr.sliders[name].val }); scope.total = math.sum; scope.stdev = math.std; scope.mean = math.median; scope.median = math.median; scope.min = math.min; scope.max = math.max; scope.quartile = math.quantileSeq; scope.nCr = math.combinations; scope.nPr = math.permutations; if (graphState.angleMode === "deg") { scope.sin = math.sind; scope.cos = math.cosd; scope.tan = math.tand; scope.asin = math.asind; scope.acos = math.acosd; scope.atan = math.atand; scope.atan2 = math.atan2d } return scope
    }

    initialize();
});
</script>
</body>
</html>
