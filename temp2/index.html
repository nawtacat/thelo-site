<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Advanced Interactive Calculator</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;700&display=swap" rel="stylesheet">
    
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.1/math.min.js"></script>
    
    <style>
        /* --- General Setup & Variables --- */
        :root {
            --thelo-blue: #2563eb;
            --thelo-blue-dark: #1d4ed8;
            --thelo-bg: #f9fafb;
            --sidebar-bg: #ffffff;
            --thelo-text: #111827;
            --thelo-text-light: #6b7280;
            --thelo-border: #e5e7eb;
            --error-red: #ef4444;
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
        body {
            margin: 0;
            font-family: 'Manrope', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            display: flex;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            background-color: var(--thelo-bg);
            color: var(--thelo-text);
        }

        /* --- Sidebar & Header --- */
        #sidebar {
            width: 420px;
            min-width: 320px;
            height: 100%;
            background-color: var(--sidebar-bg);
            border-right: 1px solid var(--thelo-border);
            box-shadow: var(--shadow-lg);
            z-index: 10;
            display: flex;
            flex-direction: column;
            resize: horizontal;
            overflow: auto;
        }
        .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--thelo-border);
            flex-shrink: 0;
        }
        .sidebar-header h1 {
            margin: 0;
            font-size: 1.25rem;
        }
        .header-buttons {
            display: flex;
            gap: 0.5rem;
        }
        .header-btn {
            background-color: var(--sidebar-bg);
            color: var(--thelo-text-light);
            border: 1px solid var(--thelo-border);
            border-radius: 8px;
            padding: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .header-btn:hover, .header-btn.active {
            background-color: var(--thelo-blue);
            color: white;
            border-color: var(--thelo-blue);
        }
        .header-btn svg {
            width: 20px;
            height: 20px;
            stroke-width: 2;
        }
        #addFunctionBtn {
            background-color: var(--thelo-blue);
            color: white;
            font-size: 1.5rem;
            line-height: 1;
        }
        #addFunctionBtn:hover {
            background-color: var(--thelo-blue-dark);
        }

        /* --- Expression List --- */
        #expressionListContainer {
            flex-grow: 1;
            overflow-y: auto;
            padding: 0.5rem 0;
        }
        .expression-item {
            border-bottom: 1px solid var(--thelo-border);
            padding: 0.5rem 1rem 0.5rem 0.75rem;
        }
        .expression-main {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .expression-color-bar {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            flex-shrink: 0;
            cursor: pointer;
            border: 2px solid;
            transition: opacity 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            user-select: none;
        }
        .expression-color-bar.hidden-expr {
            opacity: 0.3;
        }
        .expression-number {
            color: var(--thelo-text-light);
            font-weight: 500;
            user-select: none;
            width: 20px;
            text-align: center;
        }
        .expression-input-wrapper {
            display: flex;
            align-items: center;
            flex-grow: 1;
            border-radius: 8px;
            padding: 4px;
        }
        .expression-result {
            padding: 0 0.75rem;
            font-size: 1.1rem;
            color: var(--thelo-text-light);
            font-weight: 500;
            white-space: nowrap;
        }
        .remove-expression-btn {
            background: transparent;
            border: none;
            font-size: 1.75rem;
            color: var(--thelo-text-light);
            cursor: pointer;
            padding: 0 0.5rem;
            transition: color 0.2s;
        }
        .remove-expression-btn:hover {
            color: var(--error-red);
        }

         /* ADD THIS NEW BLOCK IN ITS PLACE */
.math-input-field {
    width: 100%;
    padding: 9px 8px; /* Added 1px top/bottom padding to maintain alignment */
    font-size: 1.1rem;
    cursor: text;
    border: 1px solid transparent; /* Make the border transparent */
    background-color: transparent; /* Make the background transparent */
}
.math-input-field.mq-focused {
    /* The focus styles are now removed to prevent any box from appearing */
    background-color: transparent;
    box-shadow: none;
}
        
        /* --- Sliders & Extras --- */
        .expression-extras {
            padding: 0.5rem 0 0.5rem 52px;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 5px;
        }
        .slider-container label {
            font-family: monospace;
            width: 80px;
            white-space: nowrap;
        }
        .slider-container input[type=range] {
            flex-grow: 1;
        }

        /* --- Math Keyboard --- */
        #mathKeyboard {
            background: #f0f3ff;
            padding: 1rem;
            border-top: 1px solid var(--thelo-border);
            flex-shrink: 0;
            display: none; /* Hidden by default */
            grid-template-columns: repeat(auto-fill, minmax(45px, 1fr));
            gap: 8px;
        }
        #sidebar.keyboard-open #mathKeyboard {
            display: grid; /* Show when class is present */
        }
        #mathKeyboard button {
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 1.1rem;
            height: 40px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #mathKeyboard button:hover {
            background-color: #e0e8ff;
        }

        /* --- Canvas & Graphing Area --- */
        #canvasContainer {
            flex-grow: 1;
            position: relative;
        }
        #graphCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        #graphCanvas:active {
            cursor: grabbing;
        }
        #homeBtn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 44px;
            height: 44px;
            background-color: var(--sidebar-bg);
            border: 1px solid var(--thelo-border);
            border-radius: 50%;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s, box-shadow 0.2s;
            z-index: 5;
        }
        #homeBtn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }
        #homeBtn svg {
            width: 24px;
            height: 24px;
            stroke: var(--thelo-text-light);
        }

        /* --- Responsive Design --- */
        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }
            #sidebar {
                width: 100%;
                height: 45vh;
                resize: none;
            }
            #homeBtn {
                bottom: 15px;
                right: 15px;
            }
        }
    </style>
</head>
<body>

    <div id="sidebar">
        <div class="sidebar-header">
            <h1>Advanced Calculator</h1>
            <div class="header-buttons">
                <button id="toggleKeyboardBtn" class="header-btn" title="Toggle Keyboard">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M3 3h18M3 7h18M3 11h18M3 15h18M4 21h4M10 21h4M16 21h4" />
                    </svg>
                </button>
                <button id="addFunctionBtn" class="header-btn" title="Add new expression">+</button>
            </div>
        </div>
        <div id="expressionListContainer">
            </div>
        <div id="mathKeyboard">
            </div>
    </div>

    <div id="canvasContainer">
        <canvas id="graphCanvas"></canvas>
        <button id="homeBtn" title="Reset View">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M2.25 12l8.954-8.955c.44-.439 1.152-.439 1.591 0L21.75 12M4.5 9.75v10.125c0 .621.504 1.125 1.125 1.125H9.75v-4.875c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125V21h4.125c.621 0 1.125-.504 1.125-1.125V9.75M8.25 21h7.5" />
            </svg>                      
        </button>
    </div>

    <script>
    // --- Advanced Interactive Calculator ---
    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM ELEMENTS & CONSTANTS ---
        const sidebar = document.getElementById('sidebar');
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        const expressionListContainer = document.getElementById('expressionListContainer');
        const addFunctionBtn = document.getElementById('addFunctionBtn');
        const homeBtn = document.getElementById('homeBtn');
        const mathKeyboard = document.getElementById('mathKeyboard');
        const toggleKeyboardBtn = document.getElementById('toggleKeyboardBtn');

        const devicePixelRatio = window.devicePixelRatio || 1;
        const PLOT_COLORS = ['#2563eb', '#c026d3', '#22c55e', '#f97316', '#8b5cf6', '#d946ef'];
        const INEQUALITY_ALPHA = 0.2;
        const POI_RADIUS = 5 * devicePixelRatio;
        const KEYBOARD_SYMBOLS = [
            'x', 'y', 'π', 'θ', '^', '√', '(', ')', 
            '7', '8', '9', '/', 'sin', 'cos', 'tan',
            '4', '5', '6', '*', '<', '>', '≤', '≥',
            '1', '2', '3', '-', '{', '}', 'd/dx',
            '0', '.', '=', '+', 'abs', 'log', 'ln'
        ];
        
        // --- STATE MANAGEMENT ---
        let graphState = {
            originX: 0, originY: 0, scale: 40,
            isPanning: false, panStart: { x: 0, y: 0 },
            expressions: [],
            activeInput: null,
            touchState: { isPinching: false, initialPinchDistance: 0 },
            intersections: [],
            hoverPoint: { visible: false, x: 0, y: 0 },
            lockedPoint: { visible: false, x: 0, y: 0, color: '#000' }
        };

        // --- OPTIMIZATION ---
        function debounce(func, delay) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), delay);
            };
        }
        const debouncedEvaluateAndPlotAll = debounce(evaluateAndPlotAll, 250);

        // --- INITIALIZATION ---
        function initialize() {
            setupMathKeyboard();
            resizeCanvas();
            addExpressionInput(''); // Start with one empty expression bar
            setupEventListeners();
            evaluateAndPlotAll();
        }

        function setupEventListeners() {
            window.addEventListener('resize', resizeCanvas);
            addFunctionBtn.addEventListener('click', () => addExpressionInput());
            homeBtn.addEventListener('click', () => resetView());
            toggleKeyboardBtn.addEventListener('click', () => {
                sidebar.classList.toggle('keyboard-open');
                toggleKeyboardBtn.classList.toggle('active', sidebar.classList.contains('keyboard-open'));
            });
            canvas.addEventListener('wheel', handleGraphZoom, { passive: false });
            canvas.addEventListener('mousedown', handleGraphPanStart);
            canvas.addEventListener('mousemove', handleGraphPanMove);
            window.addEventListener('mouseup', handleGraphPanEnd);
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd);
            
            canvas.addEventListener('click', handleGraphClick);
            canvas.addEventListener('mousemove', handleMouseMoveForHover);
            canvas.addEventListener('mouseleave', () => {
                graphState.hoverPoint.visible = false;
                requestAnimationFrame(renderAll);
            });
        }
        
        // --- MATH KEYBOARD ---
        function setupMathKeyboard() {
            KEYBOARD_SYMBOLS.forEach(symbol => {
                const btn = document.createElement('button');
                btn.textContent = symbol;
                btn.addEventListener('click', () => insertSymbol(symbol));
                mathKeyboard.appendChild(btn);
            });
        }
        
        function insertSymbol(symbol) {
            if (!graphState.activeInput) return;
            const input = graphState.activeInput;
            const start = input.selectionStart;
            const end = input.selectionEnd;
            let template = symbol;

            if (['sin', 'cos', 'tan', 'log', 'ln', 'abs', '√'].includes(symbol)) {
                template = `${symbol}()`;
            } else if (symbol === '^') {
                template = '^()';
            } else if (symbol === 'd/dx') {
                template = 'derivative( , x)';
            } else if (symbol === '≤') {
                template = '<=';
            } else if (symbol === '≥') {
                template = '>=';
            }

            input.setRangeText(template, start, end, 'end');
            input.focus();
            if (template.includes('()') || template.includes('( ,')) {
                 input.setSelectionRange(input.selectionStart - 1, input.selectionStart - 1);
            }
            
            const exprId = input.closest('.expression-item').id;
            const expr = graphState.expressions.find(e => e.id === exprId);
            if (expr) {
                expr.str = input.value;
                debouncedEvaluateAndPlotAll();
            }
        }
        
        // --- UI & EXPRESSION MANAGEMENT ---
        function addExpressionInput(str = '') {
    const exprIndex = graphState.expressions.length;
    const newExpr = {
        id: `expr-${Date.now()}`,
        str: str,
        visible: true,
        color: PLOT_COLORS[exprIndex % PLOT_COLORS.length],
    };
    graphState.expressions.push(newExpr);

    const item = document.createElement('div');
    item.className = 'expression-item';
    item.id = newExpr.id;
    // The HTML is much simpler now
    item.innerHTML = `
        <div class="expression-main">
            <span class="expression-number">${exprIndex + 1}</span>
            <div class="expression-color-bar" title="Toggle visibility"></div>
            <div class="expression-input-wrapper">
                <span class="math-input-field"></span>
            </div>
            <span class="expression-result"></span>
            <button class="remove-expression-btn" title="Remove expression">&times;</button>
        </div>
        <div class="expression-extras"></div>
    `;
    expressionListContainer.appendChild(item);

    const mathFieldSpan = item.querySelector('.math-input-field');
    
    // Let MathQuill know that we've added a new field
    var MQ = MathQuill.getInterface(2);
    
    // Initialize the MathQuill field
    const mathField = MQ.MathField(mathFieldSpan, {
        spaceBehavesLikeTab: true,
        handlers: {
            edit: function() {
                // This function is called every time the content changes
                let latexString = mathField.latex();
                
                // Convert some LaTeX to math.js compatible syntax
                // This is a crucial step!
                let mathjsString = latexString
                    .replace(/\\left\(/g, '(')
                    .replace(/\\right\)/g, ')')
                    .replace(/\\cdot/g, '*')
                    .replace(/\\frac{/g, '(/')
                    .replace(/}{/g, ')/(')
                    .replace(/}/g, ')');
                
                newExpr.str = mathjsString;
                debouncedEvaluateAndPlotAll();
            },
            enter: function() {
                addExpressionInput(); // Add a new expression on Enter
            }
        }
    });

    // Set the initial value if one is provided
    if (str) {
        mathField.latex(str);
    }
    
    // Focus the new field
    mathField.focus();
    graphState.activeInput = mathField; // Store the mathField object as the active input

    // --- (Your other event listeners for remove, color bar, etc. remain the same) ---
    item.querySelector('.remove-expression-btn').addEventListener('click', () => {
        graphState.expressions = graphState.expressions.filter(e => e.id !== newExpr.id);
        item.remove();
        updateExpressionNumbers();
        evaluateAndPlotAll();
    });

    item.querySelector('.expression-color-bar').addEventListener('click', (e) => {
        newExpr.visible = !newExpr.visible;
        e.currentTarget.classList.toggle('hidden-expr', !newExpr.visible);
        evaluateAndPlotAll();
    });
}
        function updateExpressionNumbers() {
            expressionListContainer.querySelectorAll('.expression-item').forEach((item, index) => {
                item.querySelector('.expression-number').textContent = index + 1;
            });
        }
        
        // --- PARSING & EVALUATION ENGINE ---

        /**
         * Recursively traverses a math.js node tree to find the coefficients of a linear expression ax+b.
         * @param {math.Node} node - The root node of the expression.
         * @returns {{a: number, b: number}|null} - An object with coefficients {a, b}, or null if not linear.
         */
        function getLinearCoefficients(node) {
            if (node.isConstantNode) {
                return { a: 0, b: node.value };
            }
            if (node.isSymbolNode && node.name === 'x') {
                return { a: 1, b: 0 };
            }
            if (node.isOperatorNode) {
                if (node.op === '+' && node.args.length === 2) {
                    const c1 = getLinearCoefficients(node.args[0]);
                    const c2 = getLinearCoefficients(node.args[1]);
                    if (!c1 || !c2) return null;
                    return { a: c1.a + c2.a, b: c1.b + c2.b };
                }
                if (node.op === '-' && node.args.length === 2) {
                    const c1 = getLinearCoefficients(node.args[0]);
                    const c2 = getLinearCoefficients(node.args[1]);
                    if (!c1 || !c2) return null;
                    return { a: c1.a - c2.a, b: c1.b - c2.b };
                }
                if (node.op === '*' && node.args.length === 2) {
                    const c1 = getLinearCoefficients(node.args[0]);
                    const c2 = getLinearCoefficients(node.args[1]);
                    if (!c1 || !c2) return null;
                    if (c1.a === 0 && c2.a === 0) return { a: 0, b: c1.b * c2.b };
                    if (c1.a === 0) return { a: c1.b * c2.a, b: c1.b * c2.b };
                    if (c2.a === 0) return { a: c2.b * c1.a, b: c2.b * c1.b };
                    return null;
                }
                if (node.op === '/' && node.args.length === 2) {
                    const c1 = getLinearCoefficients(node.args[0]);
                    const c2 = getLinearCoefficients(node.args[1]);
                    if (!c1 || !c2 || c2.a !== 0 || c2.b === 0) return null;
                    return { a: c1.a / c2.b, b: c1.b / c2.b };
                }
                if (node.op === 'unaryMinus' && node.args.length === 1) {
                    const c1 = getLinearCoefficients(node.args[0]);
                    if (!c1) return null;
                    return { a: -c1.a, b: -c1.b };
                }
            }
            return null;
        }

        function evaluateAndPlotAll() {
            graphState.expressions.forEach(parseSingleExpression);
            findAndStoreIntersections();
            graphState.expressions.forEach(updateExpressionUI);
            requestAnimationFrame(renderAll);
        }

        function parseSingleExpression(expr) {
            expr.type = 'calculation';
            expr.compiled = null;
            expr.error = null;
            expr.result = null;
            expr.sliders = expr.sliders || {};
            expr.poi = { roots: [], y_intercept: null, extrema: [] };
            expr.node = null;

            let cleanStr = expr.str.trim();
            if (!cleanStr) return;

            try {
                // NEW: Handle vertical inequalities like '2x-1 < 0' or 'x > 5'
                const inequalityMatchX = cleanStr.match(/(.+)\s*([<>]=?)\s*(.+)/);
                if (inequalityMatchX && !cleanStr.includes('y')) {
                    const left = inequalityMatchX[1];
                    const op = inequalityMatchX[2];
                    const right = inequalityMatchX[3];

                    const simplifiedNode = math.simplify(`${left} - (${right})`);
                    const coeffs = getLinearCoefficients(simplifiedNode);

                    if (coeffs && coeffs.a !== 0) {
                        expr.type = 'vertical_inequality';
                        expr.x_value = -coeffs.b / coeffs.a;
                        
                        let finalOp = op;
                        if (coeffs.a < 0) { // Flip operator if we divided by a negative
                           finalOp = op.replace('<', 'TEMP').replace('>', '<').replace('TEMP', '>');
                        }
                        expr.inequalityType = finalOp;
                        expr.compiled = true; // Mark as plottable
                        return; // Done with this expression
                    }
                }

                const inequalityMatchY = cleanStr.match(/y\s*([<>]=?)\s*(.*)/);
                if (inequalityMatchY) {
                    expr.type = 'inequality';
                    expr.inequalityType = inequalityMatchY[1].replace(/\s/g, '');
                    const funcStr = inequalityMatchY[2];
                    expr.node = math.parse(funcStr);
                } else if (cleanStr.includes('y=')) {
                     expr.type = 'function';
                     const funcStr = cleanStr.split('=')[1];
                     expr.node = math.parse(funcStr);
                } else if (cleanStr.match(/(^|[^a-zA-Z])x([^a-zA-Z]|$)/)) {
                    expr.type = 'function';
                    expr.node = math.parse(cleanStr);
                }

                if (expr.node) {
                    expr.compiled = expr.node.compile();
                    expr.node.filter(node => node.isSymbolNode && !['x', 'y', 'e', 'pi', 'i', 'true', 'false'].includes(node.name))
                        .forEach(sliderNode => {
                            if (!expr.sliders[sliderNode.name]) {
                                expr.sliders[sliderNode.name] = { val: 1, min: -5, max: 5, step: 0.1 };
                            }
                        });
                }
                
                if (expr.type === 'calculation') {
                    expr.result = math.parse(cleanStr).evaluate();
                }

                if (expr.type === 'function') {
                    findPointsOfInterest(expr);
                }

            } catch (err) {
                expr.error = err.message;
            }
        }

        function updateExpressionUI(expr) {
            const item = document.getElementById(expr.id);
            if (!item) return;

            const resultEl = item.querySelector('.expression-result');
            const extrasEl = item.querySelector('.expression-extras');
            const colorBar = item.querySelector('.expression-color-bar');
            
            resultEl.textContent = '';
            extrasEl.innerHTML = '';
            colorBar.style.backgroundColor = expr.error ? 'var(--error-red)' : (expr.visible ? expr.color : '#ccc');
            colorBar.style.borderColor = expr.error ? 'var(--error-red)' : expr.color;

            if (expr.error) {
                resultEl.textContent = 'Error';
            } else if (expr.result !== null) {
                resultEl.textContent = `= ${math.format(expr.result, {precision: 5})}`;
            }

            Object.keys(expr.sliders).forEach(name => {
                const slider = expr.sliders[name];
                const sliderDiv = document.createElement('div');
                sliderDiv.className = 'slider-container';
                sliderDiv.innerHTML = `
                    <label>${name} = ${slider.val}</label>
                    <input type="range" min="${slider.min}" max="${slider.max}" value="${slider.val}" step="${slider.step}">
                `;
                extrasEl.appendChild(sliderDiv);

                const rangeInput = sliderDiv.querySelector('input[type=range]');
                rangeInput.addEventListener('input', (e) => {
                    slider.val = parseFloat(e.target.value);
                    sliderDiv.querySelector('label').textContent = `${name} = ${slider.val}`;
                    if (expr.type === 'function') findPointsOfInterest(expr);
                    requestAnimationFrame(renderAll);
                });
            });
        }

        // --- CORE DRAWING & ANALYSIS ---
        function renderAll() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGraphGrid();

            graphState.expressions.forEach(expr => {
                if (!expr.visible || !expr.compiled) return;
                const scope = {};
                Object.keys(expr.sliders).forEach(name => { scope[name] = expr.sliders[name].val; });
                
                if (expr.type === 'inequality') {
                    plotInequality(expr, scope);
                } else if (expr.type === 'vertical_inequality') {
                    plotVerticalInequality(expr);
                } else if (expr.type === 'function') {
                    plotFunction(expr, scope);
                    drawPointsOfInterest(expr);
                }
            });
            
            drawAllIntersectionPoints();
            if (graphState.hoverPoint.visible) drawHoverPoint();
            if (graphState.lockedPoint.visible) drawLockedPoint();
        }
        
        function plotFunction(expr, scope) {
            ctx.strokeStyle = expr.color;
            ctx.lineWidth = 2.5 * devicePixelRatio;
            ctx.beginPath();
            let firstPoint = true;
            for (let px = 0; px < canvas.width; px++) {
                const x = (px - graphState.originX) / graphState.scale;
                scope.x = x;
                
                try {
                    const y = expr.compiled.evaluate(scope);
                    if (!Number.isFinite(y)) { firstPoint = true; continue; }

                    const py = graphState.originY - (y * graphState.scale);
                    if (firstPoint) {
                        ctx.moveTo(px, py);
                        firstPoint = false;
                    } else {
                        ctx.lineTo(px, py);
                    }
                } catch (e) { firstPoint = true; }
            }
            ctx.stroke();
        }
        
        function plotInequality(expr, scope) {
            ctx.fillStyle = expr.color;
            ctx.globalAlpha = INEQUALITY_ALPHA;
            
            const step = 8;
            for(let px = 0; px < canvas.width; px += step) {
                for (let py_px = 0; py_px < canvas.height; py_px += step) {
                    const x = (px - graphState.originX) / graphState.scale;
                    const y = (graphState.originY - py_px) / graphState.scale;
                    scope.x = x;
                    
                    try {
                        const y_func = expr.compiled.evaluate(scope);
                        let satisfied = false;
                        if (expr.inequalityType === '<') satisfied = y < y_func;
                        else if (expr.inequalityType === '<=') satisfied = y <= y_func;
                        else if (expr.inequalityType === '>') satisfied = y > y_func;
                        else if (expr.inequalityType === '>=') satisfied = y >= y_func;
                        
                        if(satisfied) {
                            ctx.fillRect(px, py_px, step, step);
                        }
                    } catch(e) {}
                }
            }
            ctx.globalAlpha = 1.0;

            // Draw boundary line
            ctx.strokeStyle = expr.color;
            ctx.lineWidth = 2.5 * devicePixelRatio;
            if (expr.inequalityType === '<' || expr.inequalityType === '>') {
                ctx.setLineDash([8 * devicePixelRatio, 8 * devicePixelRatio]);
            }
            plotFunction(expr, scope);
            ctx.setLineDash([]); // Reset for other plots
        }

        // NEW: Function to plot vertical inequalities like x > 2
        function plotVerticalInequality(expr) {
            ctx.fillStyle = expr.color;
            ctx.globalAlpha = INEQUALITY_ALPHA;

            const boundaryPx = graphState.originX + expr.x_value * graphState.scale;
            const op = expr.inequalityType;

            if (op.includes('<')) { // < or <=
                ctx.fillRect(0, 0, boundaryPx, canvas.height);
            }
            if (op.includes('>')) { // > or >=
                ctx.fillRect(boundaryPx, 0, canvas.width - boundaryPx, canvas.height);
            }

            ctx.globalAlpha = 1.0;

            // Draw boundary line
            ctx.strokeStyle = expr.color;
            ctx.lineWidth = 2.5 * devicePixelRatio;
            
            // Dotted line for strict inequalities
            if (!op.includes('=')) {
                ctx.setLineDash([8 * devicePixelRatio, 8 * devicePixelRatio]);
            }

            ctx.beginPath();
            ctx.moveTo(boundaryPx, 0);
            ctx.lineTo(boundaryPx, canvas.height);
            ctx.stroke();

            // Reset line dash for other plots
            ctx.setLineDash([]);
        }

        function findPointsOfInterest(expr) {
            expr.poi = { roots: [], y_intercept: null, extrema: [] };
            const scope = {};
            Object.keys(expr.sliders).forEach(name => { scope[name] = expr.sliders[name].val; });

            try {
                scope.x = 0;
                const y_intercept = expr.compiled.evaluate(scope);
                if (Number.isFinite(y_intercept)) expr.poi.y_intercept = { x: 0, y: y_intercept };
            } catch (e) {}

            let prev_y, prev_slope_sign;
            const step = 1 / graphState.scale;
            for (let px = 0; px < canvas.width; px++) {
                 const x = (px - graphState.originX) / graphState.scale;
                 scope.x = x;
                 
                 try {
                     const y = expr.compiled.evaluate(scope);
                     if (prev_y !== undefined && Number.isFinite(y) && Number.isFinite(prev_y)) {
                         if (Math.sign(y) !== Math.sign(prev_y)) {
                              expr.poi.roots.push({ x: (x - step/2), y: 0 });
                         }
                         const next_y = expr.compiled.evaluate({ ...scope, x: x + step });
                         if (Number.isFinite(next_y)) {
                             const slope_sign = Math.sign(next_y - y);
                             if (prev_slope_sign !== undefined && slope_sign !== prev_slope_sign) {
                                 expr.poi.extrema.push({ x: x, y: y });
                             }
                             prev_slope_sign = slope_sign;
                         }
                     }
                     prev_y = y;
                 } catch (e) { prev_y = undefined; }
            }
        }
        
        function drawPointsOfInterest(expr) {
            ctx.fillStyle = expr.color;
            const all_pois = [...expr.poi.roots, ...expr.poi.extrema];
            if(expr.poi.y_intercept) all_pois.push(expr.poi.y_intercept);

            all_pois.forEach(point => {
                if(!point) return;
                const px = graphState.originX + point.x * graphState.scale;
                const py = graphState.originY - point.y * graphState.scale;
                ctx.beginPath();
                ctx.arc(px, py, POI_RADIUS, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        // --- INTERSECTION FUNCTIONS ---
        function bisectionSolve(f1, f2, a, b, scope1, scope2, tolerance = 1e-7, maxIterations = 50) {
            let fa = f1.evaluate({...scope1, x: a}) - f2.evaluate({...scope2, x: a});
            let fb = f1.evaluate({...scope1, x: b}) - f2.evaluate({...scope2, x: b});

            if (isNaN(fa) || isNaN(fb) || Math.sign(fa) === Math.sign(fb)) {
                return null;
            }

            let c = a;
            for (let i = 0; i < maxIterations; i++) {
                c = (a + b) / 2;
                let fc = f1.evaluate({...scope1, x: c}) - f2.evaluate({...scope2, x: c});

                if (Math.abs(fc) < tolerance || (b - a) / 2 < tolerance) {
                    return c;
                }

                if (Math.sign(fc) === Math.sign(fa)) {
                    a = c;
                    fa = fc;
                } else {
                    b = c;
                }
            }
            return c;
        }

        function findAndStoreIntersections() {
            graphState.intersections = [];
            const validFuncs = graphState.expressions.filter(e => e.visible && e.compiled && (e.type === 'function' || e.type === 'inequality'));
            if (validFuncs.length < 2) return;

            for (let i = 0; i < validFuncs.length; i++) {
                for (let j = i + 1; j < validFuncs.length; j++) {
                    const f1_expr = validFuncs[i];
                    const f2_expr = validFuncs[j];
                    const f1 = f1_expr.compiled;
                    const f2 = f2_expr.compiled;
                    
                    const scope1 = {};
                    Object.keys(f1_expr.sliders).forEach(name => { scope1[name] = f1_expr.sliders[name].val; });
                    const scope2 = {};
                    Object.keys(f2_expr.sliders).forEach(name => { scope2[name] = f2_expr.sliders[name].val; });

                    let prev_diff;
                    for (let px = 0; px < canvas.width; px++) {
                        const x = (px - graphState.originX) / graphState.scale;
                        try {
                            const y1 = f1.evaluate({...scope1, x: x});
                            const y2 = f2.evaluate({...scope2, x: x});
                            const diff = y1 - y2;

                            if (prev_diff !== undefined && Math.sign(diff) !== Math.sign(prev_diff)) {
                                const intersectionX = bisectionSolve(f1, f2, x - (1 / graphState.scale), x, scope1, scope2);
                                if (intersectionX !== null) {
                                    const intersectionY = f1.evaluate({...scope1, x: intersectionX});
                                    if(Number.isFinite(intersectionY)) {
                                        graphState.intersections.push({ x: intersectionX, y: intersectionY });
                                    }
                                }
                            }
                            prev_diff = diff;
                        } catch (e) {
                            prev_diff = undefined;
                        }
                    }
                }
            }
        }

        function drawAllIntersectionPoints() {
            ctx.fillStyle = '#000';
            graphState.intersections.forEach(point => {
                const pixelX = graphState.originX + point.x * graphState.scale;
                const pixelY = graphState.originY - point.y * graphState.scale;
                ctx.beginPath();
                ctx.arc(pixelX, pixelY, POI_RADIUS, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        function drawHoverPoint() {
            const { x, y } = graphState.hoverPoint;
            const pixelX = graphState.originX + x * graphState.scale;
            const pixelY = graphState.originY - y * graphState.scale;
            ctx.fillStyle = '#000';
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 3 * devicePixelRatio;
            ctx.beginPath();
            ctx.arc(pixelX, pixelY, POI_RADIUS * 1.2, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fill();
        }

        function drawLockedPoint() {
            const { x, y } = graphState.lockedPoint;
            const pixelX = graphState.originX + x * graphState.scale;
            const pixelY = graphState.originY - y * graphState.scale;

            // Draw Point
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(pixelX, pixelY, POI_RADIUS * 1.2, 0, Math.PI * 2);
            ctx.fill();

            // Draw Coordinate Box
            const coordText = `(${x.toFixed(3)}, ${y.toFixed(3)})`;
            const FONT_SIZE = 12 * devicePixelRatio;
            ctx.font = `bold ${FONT_SIZE}px 'Manrope'`;
            const textMetrics = ctx.measureText(coordText);
            const boxWidth = textMetrics.width + 16 * devicePixelRatio;
            const boxHeight = FONT_SIZE + 12 * devicePixelRatio;
            
            let boxX = pixelX + 15 * devicePixelRatio;
            let boxY = pixelY - (boxHeight / 2);

            if (boxX + boxWidth > canvas.width) boxX = pixelX - boxWidth - 15 * devicePixelRatio;
            if (boxY < 0) boxY = 5 * devicePixelRatio;
            if (boxY + boxHeight > canvas.height) boxY = canvas.height - boxHeight - 5 * devicePixelRatio;
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.shadowColor = 'rgba(0,0,0,0.2)';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.roundRect(boxX, boxY, boxWidth, boxHeight, 5 * devicePixelRatio);
            ctx.fill();
            ctx.shadowColor = 'transparent';

            ctx.fillStyle = '#000';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(coordText, boxX + boxWidth / 2, boxY + boxHeight / 2);
        }

        function findClosestPoint(pixelX, pixelY, points) {
            let closestDist = Infinity;
            let closestPoint = null;
            const CLICK_RADIUS = 20 * devicePixelRatio;

            points.forEach(point => {
                const pointPixelX = graphState.originX + point.x * graphState.scale;
                const pointPixelY = graphState.originY - point.y * graphState.scale;
                const dist = Math.sqrt(Math.pow(pixelX - pointPixelX, 2) + Math.pow(pixelY - pointPixelY, 2));

                if (dist < closestDist && dist < CLICK_RADIUS) {
                    closestDist = dist;
                    closestPoint = point;
                }
            });
            return closestPoint;
        }

        // --- UTILITY & INTERACTION FUNCTIONS ---
        function resizeCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width * devicePixelRatio;
            canvas.height = rect.height * devicePixelRatio;
            canvas.style.width = `${rect.width}px`;
            canvas.style.height = `${rect.height}px`;
            resetView(false);
        }

        function resetView(redraw = true) {
            graphState.originX = canvas.width / 2;
            graphState.originY = canvas.height / 2;
            graphState.scale = 40;
            if (redraw) {
                evaluateAndPlotAll();
            }
        }

        function handleGraphZoom(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left) * devicePixelRatio;
            const mouseY = (e.clientY - rect.top) * devicePixelRatio;
            const zoomFactor = e.deltaY < 0 ? 1.1 : 1 / 1.1;
            applyZoom(mouseX, mouseY, zoomFactor);
        }

        function handleGraphPanStart(e) {
            if (e.button !== 0) return;
            graphState.isPanning = true;
            graphState.panStart.x = e.clientX;
            graphState.panStart.y = e.clientY;
            if (graphState.lockedPoint.visible) {
                 graphState.lockedPoint.visible = false;
                 requestAnimationFrame(renderAll);
            }
        }

        function handleGraphPanMove(e) {
            if (!graphState.isPanning) return;
            const dx = (e.clientX - graphState.panStart.x) * devicePixelRatio;
            const dy = (e.clientY - graphState.panStart.y) * devicePixelRatio;
            graphState.originX += dx;
            graphState.originY += dy;
            graphState.panStart.x = e.clientX;
            graphState.panStart.y = e.clientY;
            requestAnimationFrame(renderAll);
        }

        function handleGraphPanEnd() {
            graphState.isPanning = false;
        }

        function handleTouchStart(e) {
            e.preventDefault();
            const touches = e.touches;
            if (touches.length === 1) {
                graphState.isPanning = true;
                graphState.panStart.x = touches[0].clientX;
                graphState.panStart.y = touches[0].clientY;
            } else if (touches.length === 2) {
                graphState.isPanning = false;
                graphState.touchState.isPinching = true;
                graphState.touchState.initialPinchDistance = getPinchDistance(touches);
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            const touches = e.touches;
            if (graphState.isPanning && touches.length === 1) {
                const dx = (touches[0].clientX - graphState.panStart.x) * devicePixelRatio;
                const dy = (touches[0].clientY - graphState.panStart.y) * devicePixelRatio;
                graphState.originX += dx;
                graphState.originY += dy;
                graphState.panStart.x = touches[0].clientX;
                graphState.panStart.y = touches[0].clientY;
                requestAnimationFrame(renderAll);
            } else if (graphState.touchState.isPinching && touches.length === 2) {
                const newDist = getPinchDistance(touches);
                const zoomFactor = newDist / graphState.touchState.initialPinchDistance;
                const rect = canvas.getBoundingClientRect();
                const midX = ((touches[0].clientX + touches[1].clientX) / 2 - rect.left) * devicePixelRatio;
                const midY = ((touches[0].clientY + touches[1].clientY) / 2 - rect.top) * devicePixelRatio;
                applyZoom(midX, midY, zoomFactor);
                graphState.touchState.initialPinchDistance = newDist;
            }
        }

        function handleTouchEnd(e) {
            graphState.isPanning = false;
            graphState.touchState.isPinching = false;
        }

        function getPinchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function applyZoom(centerX, centerY, zoomFactor) {
            const mouseGraphX_before = (centerX - graphState.originX) / graphState.scale;
            const mouseGraphY_before = (graphState.originY - centerY) / graphState.scale;
            
            graphState.scale *= zoomFactor;
            graphState.scale = Math.max(0.1, Math.min(graphState.scale, 10000));

            const mouseGraphX_after = (centerX - graphState.originX) / graphState.scale;
            const mouseGraphY_after = (graphState.originY - centerY) / graphState.scale;

            graphState.originX += (mouseGraphX_after - mouseGraphX_before) * graphState.scale;
            graphState.originY -= (mouseGraphY_after - mouseGraphY_before) * graphState.scale;

            evaluateAndPlotAll();
        }
        
        function handleMouseMoveForHover(e) {
            if (graphState.isPanning) return;
            const rect = canvas.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left) * devicePixelRatio;
            const mouseY = (e.clientY - rect.top) * devicePixelRatio;
            
            const allPoints = [...graphState.intersections];
            graphState.expressions.forEach(expr => {
                if (expr.poi) {
                    allPoints.push(...expr.poi.roots, ...expr.poi.extrema, expr.poi.y_intercept);
                }
            });

            const closestPoint = findClosestPoint(mouseX, mouseY, allPoints.filter(p => p));
            
            if (closestPoint) {
                graphState.hoverPoint.visible = true;
                graphState.hoverPoint.x = closestPoint.x;
                graphState.hoverPoint.y = closestPoint.y;
            } else {
                graphState.hoverPoint.visible = false;
            }
            requestAnimationFrame(renderAll);
        }
        
        function handleGraphClick(e) {
            const rect = canvas.getBoundingClientRect();
            const clickX = (e.clientX - rect.left) * devicePixelRatio;
            const clickY = (e.clientY - rect.top) * devicePixelRatio;

            const allPoints = [...graphState.intersections];
            graphState.expressions.forEach(expr => {
                if (expr.poi) {
                    allPoints.push(...expr.poi.roots, ...expr.poi.extrema, expr.poi.y_intercept);
                }
            });
            
            const pointToLock = findClosestPoint(clickX, clickY, allPoints.filter(p => p));

            if (pointToLock) {
                graphState.lockedPoint.visible = true;
                graphState.lockedPoint.x = pointToLock.x;
                graphState.lockedPoint.y = pointToLock.y;
            }
            requestAnimationFrame(renderAll);
        }

        function drawGraphGrid() {
            const computedStyles = getComputedStyle(document.documentElement);
            const THELO_BORDER_COLOR = computedStyles.getPropertyValue('--thelo-border').trim();
            const THELO_TEXT_LIGHT_COLOR = computedStyles.getPropertyValue('--thelo-text-light').trim();
            
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.restore();

            const baseGridUnits = 1;
            let dynamicGrid = baseGridUnits;
            while (dynamicGrid * graphState.scale < 50 * devicePixelRatio) dynamicGrid *= 2;
            while (dynamicGrid * graphState.scale > 100 * devicePixelRatio) dynamicGrid /= 2;

            ctx.strokeStyle = THELO_BORDER_COLOR;
            ctx.lineWidth = 1 * devicePixelRatio;
            ctx.font = `${10 * devicePixelRatio}px 'Manrope'`;
            ctx.fillStyle = THELO_TEXT_LIGHT_COLOR;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const startX = Math.floor(-graphState.originX / (graphState.scale * dynamicGrid)) * dynamicGrid;
            for (let x = startX; (x * graphState.scale + graphState.originX) < canvas.width; x += dynamicGrid) {
                const px = x * graphState.scale + graphState.originX;
                ctx.beginPath();
                ctx.moveTo(px, 0);
                ctx.lineTo(px, canvas.height);
                ctx.stroke();
                if (Math.abs(x) > 1e-9) {
                    ctx.fillText(x.toPrecision(3), px, graphState.originY - 5 * devicePixelRatio);
                }
            }

            const startY = Math.floor(graphState.originY / (graphState.scale * dynamicGrid)) * dynamicGrid;
            for (let y = startY; (graphState.originY - y * graphState.scale) < canvas.height; y -= dynamicGrid) {
                const py = graphState.originY - y * graphState.scale;
                ctx.beginPath();
                ctx.moveTo(0, py);
                ctx.lineTo(canvas.width, py);
                ctx.stroke();
                if (Math.abs(y) > 1e-9) {
                    ctx.save();
                    ctx.textAlign = 'right';
                    ctx.fillText(y.toPrecision(3), graphState.originX - 5 * devicePixelRatio, py);
                    ctx.restore();
                }
            }

            ctx.strokeStyle = THELO_TEXT_LIGHT_COLOR;
            ctx.lineWidth = 1.5 * devicePixelRatio;
            ctx.beginPath();
            ctx.moveTo(0, graphState.originY);
            ctx.lineTo(canvas.width, graphState.originY);
            ctx.moveTo(graphState.originX, 0);
            ctx.lineTo(graphState.originX, canvas.height);
            ctx.stroke();
        }
        
        // --- START THE APP ---
        initialize();
    });
    </script>
</body>
</html>
