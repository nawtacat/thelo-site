<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Advanced Interactive Calculator</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.1/math.min.js"></script>
    <style>
        :root {
            --thelo-blue: #2563eb;
            --thelo-blue-dark: #1d4ed8;
            --thelo-bg: #f9fafb;
            --sidebar-bg: #ffffff;
            --thelo-text: #111827;
            --thelo-text-light: #6b7280;
            --thelo-border: #e5e7eb;
            --error-red: #ef4444;
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
        body {
            margin: 0;
            font-family: 'Manrope', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            display: flex;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            background-color: var(--thelo-bg);
            color: var(--thelo-text);
        }
        #sidebar {
            width: 420px;
            min-width: 320px;
            height: 100%;
            background-color: var(--sidebar-bg);
            border-right: 1px solid var(--thelo-border);
            box-shadow: var(--shadow-lg);
            z-index: 10;
            display: flex;
            flex-direction: column;
            resize: horizontal;
            overflow: auto;
        }
        .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--thelo-border);
            flex-shrink: 0;
        }
        .sidebar-header h1 {
            margin: 0;
            font-size: 1.25rem;
        }
        .header-buttons {
            display: flex;
            gap: 0.5rem;
        }
        .header-btn {
            background-color: var(--sidebar-bg);
            color: var(--thelo-text-light);
            border: 1px solid var(--thelo-border);
            border-radius: 8px;
            padding: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .header-btn:hover, .header-btn.active {
            background-color: var(--thelo-blue);
            color: white;
            border-color: var(--thelo-blue);
        }
        .header-btn svg {
            width: 20px;
            height: 20px;
            stroke-width: 2;
        }
        #addFunctionBtn {
            background-color: var(--thelo-blue);
            color: white;
            font-size: 1.5rem;
            line-height: 1;
        }
        #addFunctionBtn:hover {
            background-color: var(--thelo-blue-dark);
        }
        #expressionListContainer {
            flex-grow: 1;
            overflow-y: auto;
            padding: 0.5rem 0;
        }
        .expression-item {
            border-bottom: 1px solid var(--thelo-border);
            padding: 0.5rem 1rem 0.5rem 0.75rem;
        }
        .expression-main {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .expression-item:focus-within {
            background-color: #f0f3ff;
        }
        .expression-color-bar {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            flex-shrink: 0;
            cursor: pointer;
            border: 2px solid;
            transition: opacity 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            user-select: none;
        }
        .expression-color-bar.hidden-expr {
            opacity: 0.3;
        }
        .expression-number {
            color: var(--thelo-text-light);
            font-weight: 500;
            user-select: none;
            width: 20px;
            text-align: center;
        }
        .expression-input-wrapper {
            display: flex;
            align-items: center;
            flex-grow: 1;
            border-radius: 8px;
            border: 1px solid transparent;
            padding: 4px;
        }
        .expression-input {
            width: 100%;
            padding: 8px;
            border: none;
            background: transparent;
            font-size: 1.1rem;
            font-family: 'Manrope', monospace;
            color: var(--thelo-text);
        }
        .expression-input:focus {
            outline: none;
        }
        .expression-input.input-error {
            color: var(--error-red);
        }
        .expression-result {
            padding: 0 0.75rem;
            font-size: 1.1rem;
            color: var(--thelo-text-light);
            font-weight: 500;
            white-space: nowrap;
        }
        .remove-expression-btn {
            background: transparent;
            border: none;
            font-size: 1.75rem;
            color: var(--thelo-text-light);
            cursor: pointer;
            padding: 0 0.5rem;
            transition: color 0.2s;
        }
        .remove-expression-btn:hover {
            color: var(--error-red);
        }
        .expression-extras {
            padding: 0.5rem 0 0.5rem 52px;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 5px;
        }
        .slider-container label {
            font-family: monospace;
            width: 80px;
            white-space: nowrap;
        }
        .slider-container input[type=range] {
            flex-grow: 1;
        }
        #mathKeyboard {
            background: #f0f3ff;
            padding: 1rem;
            border-top: 1px solid var(--thelo-border);
            flex-shrink: 0;
            display: none; /* Hidden by default */
            grid-template-columns: repeat(auto-fill, minmax(45px, 1fr));
            gap: 8px;
        }
        #sidebar.keyboard-open #mathKeyboard {
            display: grid; /* Show when class is present */
        }
        #mathKeyboard button {
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 1.1rem;
            height: 40px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #mathKeyboard button:hover {
            background-color: #e0e8ff;
        }
        #canvasContainer {
            flex-grow: 1;
            position: relative;
        }
        #graphCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        #graphCanvas:active {
            cursor: grabbing;
        }
        #homeBtn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 44px;
            height: 44px;
            background-color: var(--sidebar-bg);
            border: 1px solid var(--thelo-border);
            border-radius: 50%;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s, box-shadow 0.2s;
            z-index: 5;
        }
        #homeBtn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }
        #homeBtn svg {
            width: 24px;
            height: 24px;
            stroke: var(--thelo-text-light);
        }
        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }
            #sidebar {
                width: 100%;
                height: 45vh;
                resize: none;
            }
            #homeBtn {
                bottom: 15px;
                right: 15px;
            }
        }
    </style>
</head>
<body>

    <div id="sidebar">
        <div class="sidebar-header">
            <h1>Advanced Calculator</h1>
            <div class="header-buttons">
                <button id="toggleKeyboardBtn" class="header-btn" title="Toggle Keyboard">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M3 3h18M3 7h18M3 11h18M3 15h18M4 21h4M10 21h4M16 21h4" />
                    </svg>
                </button>
                <button id="addFunctionBtn" class="header-btn" title="Add new expression">+</button>
            </div>
        </div>
        <div id="expressionListContainer">
            <!-- Expression items will be dynamically added here -->
        </div>
        <div id="mathKeyboard">
            <!-- Math keyboard buttons will be dynamically added here -->
        </div>
    </div>

    <div id="canvasContainer">
        <canvas id="graphCanvas"></canvas>
        <button id="homeBtn" title="Reset View">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M2.25 12l8.954-8.955c.44-.439 1.152-.439 1.591 0L21.75 12M4.5 9.75v10.125c0 .621.504 1.125 1.125 1.125H9.75v-4.875c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125V21h4.125c.621 0 1.125-.504 1.125-1.125V9.75M8.25 21h7.5" />
            </svg>                      
        </button>
    </div>

    <script>
    // --- Advanced Interactive Calculator ---
    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM ELEMENTS & CONSTANTS ---
        const sidebar = document.getElementById('sidebar');
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        const expressionListContainer = document.getElementById('expressionListContainer');
        const addFunctionBtn = document.getElementById('addFunctionBtn');
        const homeBtn = document.getElementById('homeBtn');
        const mathKeyboard = document.getElementById('mathKeyboard');
        const toggleKeyboardBtn = document.getElementById('toggleKeyboardBtn');

        const devicePixelRatio = window.devicePixelRatio || 1;
        const PLOT_COLORS = ['#2563eb', '#c026d3', '#22c55e', '#f97316', '#8b5cf6', '#d946ef'];
        const INEQUALITY_ALPHA = 0.2;
        const POI_RADIUS = 5 * devicePixelRatio;
        const KEYBOARD_SYMBOLS = [
            'x', 'y', 'π', 'θ', '^', '√', '(', ')', 
            '7', '8', '9', '/', 'sin', 'cos', 'tan',
            '4', '5', '6', '*', '<', '>', '≤', '≥',
            '1', '2', '3', '-', '{', '}', 'd/dx',
            '0', '.', '=', '+', 'abs', 'log', 'ln'
        ];
        
        // --- STATE MANAGEMENT ---
        let graphState = {
            originX: 0, originY: 0, scale: 40,
            isPanning: false, panStart: { x: 0, y: 0 },
            expressions: [],
            activeInput: null,
            touchState: { isPinching: false, initialPinchDistance: 0 },
        };

        // --- OPTIMIZATION ---
        function debounce(func, delay) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), delay);
            };
        }
        const debouncedEvaluateAndPlotAll = debounce(evaluateAndPlotAll, 250);

        // --- INITIALIZATION ---
        function initialize() {
            setupMathKeyboard();
            resizeCanvas();
            addExpressionInput('y = a*x^2 + k');
            addExpressionInput('y < sin(x)');
            addExpressionInput('2^4 / 4');
            setupEventListeners();
            evaluateAndPlotAll();
        }

        function setupEventListeners() {
            window.addEventListener('resize', resizeCanvas);
            addFunctionBtn.addEventListener('click', () => addExpressionInput());
            homeBtn.addEventListener('click', () => resetView());
            toggleKeyboardBtn.addEventListener('click', () => {
                sidebar.classList.toggle('keyboard-open');
                toggleKeyboardBtn.classList.toggle('active', sidebar.classList.contains('keyboard-open'));
            });
            canvas.addEventListener('wheel', handleGraphZoom, { passive: false });
            canvas.addEventListener('mousedown', handleGraphPanStart);
            canvas.addEventListener('mousemove', handleGraphPanMove);
            window.addEventListener('mouseup', handleGraphPanEnd);
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd);
        }
        
        // --- MATH KEYBOARD ---
        function setupMathKeyboard() {
            KEYBOARD_SYMBOLS.forEach(symbol => {
                const btn = document.createElement('button');
                btn.textContent = symbol;
                btn.addEventListener('click', () => insertSymbol(symbol));
                mathKeyboard.appendChild(btn);
            });
        }
        
        function insertSymbol(symbol) {
            if (!graphState.activeInput) return;
            const input = graphState.activeInput;
            const start = input.selectionStart;
            const end = input.selectionEnd;
            let template = symbol;

            if (['sin', 'cos', 'tan', 'log', 'ln', 'abs', '√'].includes(symbol)) {
                template = `${symbol}()`;
            } else if (symbol === '^') {
                template = '^()';
            } else if (symbol === 'd/dx') {
                template = 'derivative( , x)';
            } else if (symbol === '≤') {
                template = '<=';
            } else if (symbol === '≥') {
                template = '>=';
            }

            input.setRangeText(template, start, end, 'end');
            input.focus();
            if (template.includes('()') || template.includes('( ,')) {
                 input.setSelectionRange(input.selectionStart - 1, input.selectionStart - 1);
            }
            
            const exprId = input.closest('.expression-item').id;
            const expr = graphState.expressions.find(e => e.id === exprId);
            if (expr) {
                expr.str = input.value;
                debouncedEvaluateAndPlotAll();
            }
        }
        
        // --- UI & EXPRESSION MANAGEMENT ---
        function addExpressionInput(str = '') {
            const exprIndex = graphState.expressions.length;
            const newExpr = {
                id: `expr-${Date.now()}`,
                str: str,
                visible: true,
                color: PLOT_COLORS[exprIndex % PLOT_COLORS.length],
            };
            graphState.expressions.push(newExpr);
            
            const item = document.createElement('div');
            item.className = 'expression-item';
            item.id = newExpr.id;
            item.innerHTML = `
                <div class="expression-main">
                    <span class="expression-number">${exprIndex + 1}</span>
                    <div class="expression-color-bar" title="Toggle visibility"></div>
                    <div class="expression-input-wrapper">
                        <input type="text" class="expression-input" value="${newExpr.str}" placeholder="Enter expression...">
                    </div>
                    <span class="expression-result"></span>
                    <button class="remove-expression-btn" title="Remove expression">&times;</button>
                </div>
                <div class="expression-extras"></div>
            `;
            expressionListContainer.appendChild(item);
            
            const input = item.querySelector('.expression-input');
            input.addEventListener('input', (e) => {
                newExpr.str = e.target.value;
                debouncedEvaluateAndPlotAll();
            });
            input.addEventListener('focus', () => { graphState.activeInput = input; });
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    addExpressionInput();
                }
            });
            
            item.querySelector('.remove-expression-btn').addEventListener('click', () => {
                graphState.expressions = graphState.expressions.filter(e => e.id !== newExpr.id);
                item.remove();
                updateExpressionNumbers();
                evaluateAndPlotAll();
            });

            item.querySelector('.expression-color-bar').addEventListener('click', (e) => {
                newExpr.visible = !newExpr.visible;
                e.currentTarget.classList.toggle('hidden-expr', !newExpr.visible);
                evaluateAndPlotAll();
            });

            item.querySelector('input').focus();
            graphState.activeInput = input;
        }

        function updateExpressionNumbers() {
            expressionListContainer.querySelectorAll('.expression-item').forEach((item, index) => {
                item.querySelector('.expression-number').textContent = index + 1;
            });
        }
        
        // --- PARSING & EVALUATION ENGINE ---
        function evaluateAndPlotAll() {
            graphState.expressions.forEach(parseSingleExpression);
            graphState.expressions.forEach(updateExpressionUI);
            requestAnimationFrame(renderAll);
        }

        function parseSingleExpression(expr) {
            expr.type = 'calculation';
            expr.compiled = null;
            expr.error = null;
            expr.result = null;
            expr.sliders = expr.sliders || {};
            expr.poi = { roots: [], y_intercept: null, extrema: [] };
            expr.node = null;

            let cleanStr = expr.str.trim();
            if (!cleanStr) return;

            try {
                const inequalityMatch = cleanStr.match(/y\s*([<>]=?)\s*(.*)/);
                if (inequalityMatch) {
                    expr.type = 'inequality';
                    expr.inequalityType = inequalityMatch[1].replace(/\s/g, '');
                    const funcStr = inequalityMatch[2];
                    expr.node = math.parse(funcStr);
                } else if (cleanStr.includes('y=')) {
                     expr.type = 'function';
                     const funcStr = cleanStr.split('=')[1];
                     expr.node = math.parse(funcStr);
                } else if (cleanStr.match(/(^|[^a-zA-Z])x([^a-zA-Z]|$)/)) {
                    expr.type = 'function';
                    expr.node = math.parse(cleanStr);
                }

                if (expr.node) {
                    expr.compiled = expr.node.compile();
                    expr.node.filter(node => node.isSymbolNode && !['x', 'y', 'e', 'pi', 'i', 'true', 'false'].includes(node.name))
                        .forEach(sliderNode => {
                            if (!expr.sliders[sliderNode.name]) {
                                expr.sliders[sliderNode.name] = { val: 1, min: -5, max: 5, step: 0.1 };
                            }
                        });
                }
                
                if (expr.type === 'calculation') {
                    expr.result = math.parse(cleanStr).evaluate();
                }

                if (expr.type === 'function') {
                    findPointsOfInterest(expr);
                }

            } catch (err) {
                expr.error = err.message;
            }
        }

        function updateExpressionUI(expr) {
            const item = document.getElementById(expr.id);
            if (!item) return;

            const resultEl = item.querySelector('.expression-result');
            const extrasEl = item.querySelector('.expression-extras');
            const colorBar = item.querySelector('.expression-color-bar');
            
            resultEl.textContent = '';
            extrasEl.innerHTML = '';
            colorBar.style.backgroundColor = expr.error ? 'var(--error-red)' : (expr.visible ? expr.color : '#ccc');
            colorBar.style.borderColor = expr.error ? 'var(--error-red)' : expr.color;

            if (expr.error) {
                resultEl.textContent = 'Error';
            } else if (expr.result !== null) {
                resultEl.textContent = `= ${math.format(expr.result, {precision: 5})}`;
            }

            Object.keys(expr.sliders).forEach(name => {
                const slider = expr.sliders[name];
                const sliderDiv = document.createElement('div');
                sliderDiv.className = 'slider-container';
                sliderDiv.innerHTML = `
                    <label>${name} = ${slider.val}</label>
                    <input type="range" min="${slider.min}" max="${slider.max}" value="${slider.val}" step="${slider.step}">
                `;
                extrasEl.appendChild(sliderDiv);

                const rangeInput = sliderDiv.querySelector('input[type=range]');
                rangeInput.addEventListener('input', (e) => {
                    slider.val = parseFloat(e.target.value);
                    sliderDiv.querySelector('label').textContent = `${name} = ${slider.val}`;
                    if (expr.type === 'function') findPointsOfInterest(expr);
                    requestAnimationFrame(renderAll);
                });
            });
        }

        // --- CORE DRAWING & ANALYSIS ---
        function renderAll() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGraphGrid();

            graphState.expressions.forEach(expr => {
                if (!expr.visible || !expr.compiled) return;
                const scope = {};
                Object.keys(expr.sliders).forEach(name => { scope[name] = expr.sliders[name].val; });
                
                if (expr.type === 'inequality') {
                    plotInequality(expr, scope);
                } else if (expr.type === 'function') {
                    plotFunction(expr, scope);
                    drawPointsOfInterest(expr);
                }
            });
        }
        
        function plotFunction(expr, scope) {
            ctx.strokeStyle = expr.color;
            ctx.lineWidth = 2.5 * devicePixelRatio;
            ctx.beginPath();
            let firstPoint = true;
            for (let px = 0; px < canvas.width; px++) {
                const x = (px - graphState.originX) / graphState.scale;
                scope.x = x;
                
                try {
                    const y = expr.compiled.evaluate(scope);
                    if (!Number.isFinite(y)) { firstPoint = true; continue; }

                    const py = graphState.originY - (y * graphState.scale);
                    if (firstPoint) {
                        ctx.moveTo(px, py);
                        firstPoint = false;
                    } else {
                        ctx.lineTo(px, py);
                    }
                } catch (e) { firstPoint = true; }
            }
            ctx.stroke();
        }
        
        function plotInequality(expr, scope) {
            ctx.fillStyle = expr.color;
            ctx.globalAlpha = INEQUALITY_ALPHA;
            
            const step = 8;
            for(let px = 0; px < canvas.width; px += step) {
                for (let py_px = 0; py_px < canvas.height; py_px += step) {
                    const x = (px - graphState.originX) / graphState.scale;
                    const y = (graphState.originY - py_px) / graphState.scale;
                    scope.x = x;
                    
                    try {
                        const y_func = expr.compiled.evaluate(scope);
                        let satisfied = false;
                        if (expr.inequalityType === '<') satisfied = y < y_func;
                        else if (expr.inequalityType === '<=') satisfied = y <= y_func;
                        else if (expr.inequalityType === '>') satisfied = y > y_func;
                        else if (expr.inequalityType === '>=') satisfied = y >= y_func;
                        
                        if(satisfied) {
                            ctx.fillRect(px, py_px, step, step);
                        }
                    } catch(e) {}
                }
            }
            ctx.globalAlpha = 1.0;
            plotFunction({...expr, color: `rgba(0,0,0,0.3)`}, scope);
        }

        function findPointsOfInterest(expr) {
            expr.poi = { roots: [], y_intercept: null, extrema: [] };
            const scope = {};
            Object.keys(expr.sliders).forEach(name => { scope[name] = expr.sliders[name].val; });

            try {
                scope.x = 0;
                const y_intercept = expr.compiled.evaluate(scope);
                if (Number.isFinite(y_intercept)) expr.poi.y_intercept = { x: 0, y: y_intercept };
            } catch (e) {}

            let prev_y, prev_slope_sign;
            const step = 1 / graphState.scale;
            for (let px = 0; px < canvas.width; px++) {
                 const x = (px - graphState.originX) / graphState.scale;
                 scope.x = x;
                 
                 try {
                    const y = expr.compiled.evaluate(scope);
                    if (prev_y !== undefined && Number.isFinite(y) && Number.isFinite(prev_y)) {
                        if (Math.sign(y) !== Math.sign(prev_y)) {
                             expr.poi.roots.push({ x: (x - step/2), y: 0 });
                        }
                        const next_y = expr.compiled.evaluate({ ...scope, x: x + step });
                        if (Number.isFinite(next_y)) {
                            const slope_sign = Math.sign(next_y - y);
                            if (prev_slope_sign !== undefined && slope_sign !== prev_slope_sign) {
                                expr.poi.extrema.push({ x: x, y: y });
                            }
                            prev_slope_sign = slope_sign;
                        }
                    }
                    prev_y = y;
                 } catch (e) { prev_y = undefined; }
            }
        }
        
        function drawPointsOfInterest(expr) {
            ctx.fillStyle = expr.color;
            const all_pois = [...expr.poi.roots, ...expr.poi.extrema];
            if(expr.poi.y_intercept) all_pois.push(expr.poi.y_intercept);

            all_pois.forEach(point => {
                if(!point) return;
                const px = graphState.originX + point.x * graphState.scale;
                const py = graphState.originY - point.y * graphState.scale;
                ctx.beginPath();
                ctx.arc(px, py, POI_RADIUS, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        // --- UTILITY & INTERACTION FUNCTIONS ---
        function resizeCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width * devicePixelRatio;
            canvas.height = rect.height * devicePixelRatio;
            canvas.style.width = `${rect.width}px`;
            canvas.style.height = `${rect.height}px`;
            resetView(false);
        }

        function resetView(redraw = true) {
            graphState.originX = canvas.width / 2;
            graphState.originY = canvas.height / 2;
            graphState.scale = 40;
            if (redraw) {
                evaluateAndPlotAll();
            }
        }

        function handleGraphZoom(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left) * devicePixelRatio;
            const mouseY = (e.clientY - rect.top) * devicePixelRatio;
            const zoomFactor = e.deltaY < 0 ? 1.1 : 1 / 1.1;
            applyZoom(mouseX, mouseY, zoomFactor);
        }

        function handleGraphPanStart(e) {
            if (e.button !== 0) return;
            graphState.isPanning = true;
            graphState.panStart.x = e.clientX;
            graphState.panStart.y = e.clientY;
        }

        function handleGraphPanMove(e) {
            if (!graphState.isPanning) return;
            const dx = (e.clientX - graphState.panStart.x) * devicePixelRatio;
            const dy = (e.clientY - graphState.panStart.y) * devicePixelRatio;
            graphState.originX += dx;
            graphState.originY += dy;
            graphState.panStart.x = e.clientX;
            graphState.panStart.y = e.clientY;
            requestAnimationFrame(renderAll);
        }

        function handleGraphPanEnd() {
            graphState.isPanning = false;
        }

        function handleTouchStart(e) {
            e.preventDefault();
            const touches = e.touches;
            if (touches.length === 1) {
                graphState.isPanning = true;
                graphState.panStart.x = touches[0].clientX;
                graphState.panStart.y = touches[0].clientY;
            } else if (touches.length === 2) {
                graphState.isPanning = false;
                graphState.touchState.isPinching = true;
                graphState.touchState.initialPinchDistance = getPinchDistance(touches);
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            const touches = e.touches;
            if (graphState.isPanning && touches.length === 1) {
                const dx = (touches[0].clientX - graphState.panStart.x) * devicePixelRatio;
                const dy = (touches[0].clientY - graphState.panStart.y) * devicePixelRatio;
                graphState.originX += dx;
                graphState.originY += dy;
                graphState.panStart.x = touches[0].clientX;
                graphState.panStart.y = touches[0].clientY;
                requestAnimationFrame(renderAll);
            } else if (graphState.touchState.isPinching && touches.length === 2) {
                const newDist = getPinchDistance(touches);
                const zoomFactor = newDist / graphState.touchState.initialPinchDistance;
                const rect = canvas.getBoundingClientRect();
                const midX = ((touches[0].clientX + touches[1].clientX) / 2 - rect.left) * devicePixelRatio;
                const midY = ((touches[0].clientY + touches[1].clientY) / 2 - rect.top) * devicePixelRatio;
                applyZoom(midX, midY, zoomFactor);
                graphState.touchState.initialPinchDistance = newDist;
            }
        }

        function handleTouchEnd(e) {
            graphState.isPanning = false;
            graphState.touchState.isPinching = false;
        }

        function getPinchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function applyZoom(centerX, centerY, zoomFactor) {
            const mouseGraphX_before = (centerX - graphState.originX) / graphState.scale;
            const mouseGraphY_before = (graphState.originY - centerY) / graphState.scale;
            
            graphState.scale *= zoomFactor;
            graphState.scale = Math.max(0.1, Math.min(graphState.scale, 10000));

            const mouseGraphX_after = (centerX - graphState.originX) / graphState.scale;
            const mouseGraphY_after = (graphState.originY - centerY) / graphState.scale;

            graphState.originX += (mouseGraphX_after - mouseGraphX_before) * graphState.scale;
            graphState.originY -= (mouseGraphY_after - mouseGraphY_before) * graphState.scale;

            evaluateAndPlotAll();
        }

        function drawGraphGrid() {
            const computedStyles = getComputedStyle(document.documentElement);
            const THELO_BORDER_COLOR = computedStyles.getPropertyValue('--thelo-border').trim();
            const THELO_TEXT_LIGHT_COLOR = computedStyles.getPropertyValue('--thelo-text-light').trim();
            
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.restore();

            const baseGridUnits = 1;
            let dynamicGrid = baseGridUnits;
            while (dynamicGrid * graphState.scale < 50 * devicePixelRatio) dynamicGrid *= 2;
            while (dynamicGrid * graphState.scale > 100 * devicePixelRatio) dynamicGrid /= 2;

            ctx.strokeStyle = THELO_BORDER_COLOR;
            ctx.lineWidth = 1 * devicePixelRatio;
            ctx.font = `${10 * devicePixelRatio}px 'Manrope'`;
            ctx.fillStyle = THELO_TEXT_LIGHT_COLOR;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const startX = Math.floor(-graphState.originX / (graphState.scale * dynamicGrid)) * dynamicGrid;
            for (let x = startX; (x * graphState.scale + graphState.originX) < canvas.width; x += dynamicGrid) {
                const px = x * graphState.scale + graphState.originX;
                ctx.beginPath();
                ctx.moveTo(px, 0);
                ctx.lineTo(px, canvas.height);
                ctx.stroke();
                if (Math.abs(x) > 1e-9) {
                    ctx.fillText(x.toPrecision(3), px, graphState.originY - 5 * devicePixelRatio);
                }
            }

            const startY = Math.floor(graphState.originY / (graphState.scale * dynamicGrid)) * dynamicGrid;
            for (let y = startY; (graphState.originY - y * graphState.scale) < canvas.height; y -= dynamicGrid) {
                const py = graphState.originY - y * graphState.scale;
                ctx.beginPath();
                ctx.moveTo(0, py);
                ctx.lineTo(canvas.width, py);
                ctx.stroke();
                if (Math.abs(y) > 1e-9) {
                    ctx.save();
                    ctx.textAlign = 'right';
                    ctx.fillText(y.toPrecision(3), graphState.originX - 5 * devicePixelRatio, py);
                    ctx.restore();
                }
            }

            ctx.strokeStyle = THELO_TEXT_LIGHT_COLOR;
            ctx.lineWidth = 1.5 * devicePixelRatio;
            ctx.beginPath();
            ctx.moveTo(0, graphState.originY);
            ctx.lineTo(canvas.width, graphState.originY);
            ctx.moveTo(graphState.originX, 0);
            ctx.lineTo(graphState.originX, canvas.height);
            ctx.stroke();
        }
        
        // --- START THE APP ---
        initialize();
    });
    </script>
</body>
</html>
