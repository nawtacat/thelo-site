<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Advanced Interactive Calculator (Enhanced)</title>
    
    <!-- Google Fonts: Manrope -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;700&display=swap" rel="stylesheet">
    
    <!-- Libraries: jQuery, MathQuill, Math.js -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.1/math.min.js"></script>
    
    <style>
    /* --- General Setup & Variables --- */
    :root {
        --thelo-blue: #2563eb;
        --thelo-blue-dark: #1d4ed8;
        --thelo-bg: #f9fafb;
        --sidebar-bg: #ffffff;
        --thelo-text: #111827;
        --thelo-text-light: #6b7280;
        --thelo-border: #e5e7eb;
        --error-red: #ef4444;
        --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        
        /* NEW: Added for enhanced button styles */
        --shadow-sm: 0 2px 4px -1px rgb(0 0 0 / 0.06), 0 2px 2px -1px rgb(0 0 0 / 0.04);
        --shadow-md-hover: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    }
    body {
        margin: 0;
        font-family: 'Manrope', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        display: flex;
        height: 100vh;
        width: 100vw;
        overflow: hidden;
        background-color: var(--thelo-bg);
        color: var(--thelo-text);
    }

    /* --- Sidebar & Header --- */
    #sidebar {
        width: 420px;
        min-width: 320px;
        height: 100%;
        background-color: var(--sidebar-bg);
        border-right: 1px solid var(--thelo-border);
        box-shadow: var(--shadow-lg);
        z-index: 10;
        display: flex;
        flex-direction: column;
        resize: horizontal;
        overflow: auto;
    }
    .sidebar-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem 1.5rem;
        border-bottom: 1px solid var(--thelo-border);
        flex-shrink: 0;
    }
    .sidebar-header h1 {
        margin: 0;
        font-size: 1.25rem;
    }
    .header-buttons {
        display: flex;
        gap: 0.75rem; /* Increased gap for better spacing */
    }
    
    /* --- ENHANCEMENT: Header Buttons --- */
    .header-btn {
        background-color: var(--sidebar-bg);
        color: var(--thelo-text-light);
        border: 1px solid var(--thelo-border);
        border-radius: 8px;
        padding: 0.5rem;
        cursor: pointer;
        transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease, transform 0.15s ease, box-shadow 0.2s ease;
        width: 38px; /* Slightly larger */
        height: 38px; /* Slightly larger */
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.8rem;
        font-weight: 700;
        box-shadow: var(--shadow-sm);
    }

    /* Hover for INACTIVE buttons */
    .header-btn:not(.active):hover {
        background-color: var(--thelo-bg);
        border-color: var(--thelo-text-light);
        transform: translateY(-1px);
    }
    
    /* Active state for toggle buttons like RAD/DEG */
    .header-btn.active {
        background-color: var(--thelo-blue);
        color: white;
        border-color: var(--thelo-blue);
    }
    .header-btn:active {
        transform: translateY(1px); /* Pressed down effect */
    }
    
    .header-btn svg {
        width: 20px;
        height: 20px;
        stroke-width: 2;
    }

    /* --- ENHANCEMENT: "+" Add Button --- */
    #addFunctionBtn {
        background-color: var(--thelo-blue);
        color: white;
        border: none;
        font-size: 1.75rem; /* Larger plus symbol */
        line-height: 1;
        box-shadow: 0 4px 10px -2px rgba(37, 99, 235, 0.4); /* Stronger shadow */
    }
    #addFunctionBtn:hover {
        background-color: var(--thelo-blue-dark);
        transform: translateY(-2px);
        box-shadow: 0 6px 12px -2px rgba(37, 99, 235, 0.5);
    }

    /* --- Expression List --- */
    #expressionListContainer {
        flex-grow: 1;
        overflow-y: auto;
        padding: 0.5rem 0;
    }
    .expression-item {
        border-bottom: 1px solid var(--thelo-border);
        padding: 0.5rem 1rem 0.5rem 0.75rem;
    }
    .expression-main {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    .expression-color-bar {
        width: 28px;
        height: 28px;
        border-radius: 50%;
        flex-shrink: 0;
        cursor: pointer;
        border: 2px solid;
        transition: opacity 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        user-select: none;
    }
    .expression-color-bar.hidden-expr {
        opacity: 0.3;
    }
    .expression-number {
        color: var(--thelo-text-light);
        font-weight: 500;
        user-select: none;
        width: 20px;
        text-align: center;
    }
    .expression-input-wrapper {
        display: flex;
        align-items: center;
        flex-grow: 1;
        min-width: 0; /* Prevents overflow in flexbox */
    }
    .math-input-field {
        flex-grow: 1;  
        min-width: 0;  
        padding: 8px;
        font-size: 1.3rem;
        cursor: text;
        background-color: var(--sidebar-bg);
        border: none;
        border-radius: 0;  
    }
    .math-input-field.mq-focused {
        outline: none;
        box-shadow: none;
    }
    .expression-result {
        padding: 0 0.75rem;
        font-size: 1rem;
        color: var(--thelo-text-light);
        font-weight: 500;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .remove-expression-btn {
        background: transparent;
        border: none;
        font-size: 1.75rem;
        color: var(--thelo-text-light);
        cursor: pointer;
        padding: 0 0.5rem;
        transition: color 0.2s;
    }
    .remove-expression-btn:hover {
        color: var(--error-red);
    }
    
    /* --- Sliders & Extras --- */
    .expression-extras {
        padding: 0.75rem 0 0.5rem 52px;
    }
    .slider-container {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 5px;
    }
    .slider-container label {
        font-family: monospace;
        width: 90px;
        white-space: nowrap;
        font-size: 0.9rem;
    }
    .slider-container input[type=range] {
        flex-grow: 1;
    }

    /* --- ENHANCEMENT: Math Keyboard --- */
    #mathKeyboard {
        background: #f3f4f6; /* A neutral gray from Tailwind palette, close to var(--thelo-bg) */
        padding: 1rem;
        border-top: 1px solid var(--thelo-border);
        flex-shrink: 0;
        display: none; /* Hidden by default */
        grid-template-columns: repeat(auto-fill, minmax(48px, 1fr));
        gap: 10px; /* Increased gap */
    }
    #sidebar.keyboard-open #mathKeyboard {
        display: grid; /* Show when class is present */
    }
    #mathKeyboard button {
        background: var(--sidebar-bg);
        color: var(--thelo-text);
        border: 1px solid var(--thelo-border);
        box-shadow: var(--shadow-sm); /* Subtle shadow for depth */
        border-radius: 6px; /* Softened radius */
        font-size: 1.1rem;
        font-family: 'Manrope', sans-serif; /* Consistent font */
        font-weight: 500;
        height: 44px;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease, background-color 0.2s ease;
    }
    #mathKeyboard button:hover {
        background-color: var(--thelo-bg);
        box-shadow: var(--shadow-md-hover); /* Lift effect */
        transform: translateY(-2px); /* Lift effect */
    }
    #mathKeyboard button:active {
        box-shadow: none; /* Pressed in effect */
        transform: translateY(1px); /* Pressed in effect */
    }

    /* Styling for special operator keys for visual hierarchy */
    /* To use this, you would need to add class="keyboard-operator" to these buttons in your JS */
    /* Example: `if (['+', '-', '*', '/'].includes(symbol)) btn.classList.add('keyboard-operator');` */
    .keyboard-operator {
        color: var(--thelo-blue);
        font-weight: 700;
    }
    /* You can apply it directly to specific buttons if you can't change JS */
    #mathKeyboard button[data-symbol="+"],
    #mathKeyboard button[data-symbol="-"],
    #mathKeyboard button[data-symbol="*"],
    #mathKeyboard button[data-symbol="/"],
    #mathKeyboard button[data-symbol="="],
    #mathKeyboard button[data-symbol="d/dx"] {
        color: var(--thelo-blue);
        font-weight: 700;
    }


    /* --- Canvas & Graphing Area --- */
    #canvasContainer {
        flex-grow: 1;
        position: relative;
    }
    #graphCanvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        cursor: grab;
    }
    #graphCanvas:active {
        cursor: grabbing;
    }
    #homeBtn {
        position: absolute;
        bottom: 20px;
        right: 20px;
        width: 44px;
        height: 44px;
        background-color: var(--sidebar-bg);
        border: 1px solid var(--thelo-border);
        border-radius: 50%;
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.2s, box-shadow 0.2s;
        z-index: 5;
    }
    #homeBtn:hover {
        transform: scale(1.1);
        box-shadow: 0 6px 12px rgba(0,0,0,0.15);
    }
    #homeBtn svg {
        width: 24px;
        height: 24px;
        stroke: var(--thelo-text-light);
    }

    /* --- Responsive Design --- */
    @media (max-width: 768px) {
        body {
            flex-direction: column;
        }
        #sidebar {
            width: 100%;
            height: 45vh;
            min-height: 250px; /* Ensure sidebar doesn't get too small */
            resize: none;
            border-right: none;
            border-bottom: 1px solid var(--thelo-border);
        }
        #homeBtn {
            bottom: 15px;
            right: 15px;
        }
    }
</style>
</head>
<body>

    <div id="sidebar">
        <div class="sidebar-header">
            <h1>Graphing Calculator</h1>
            <div class="header-buttons">
                <!-- NEW: Radian/Degree Toggle Button -->
                <button id="toggleAngleModeBtn" class="header-btn active" title="Switch to Degrees">RAD</button>
                <button id="toggleKeyboardBtn" class="header-btn" title="Toggle Keyboard">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M3 3h18M3 7h18M3 11h18M3 15h18M4 21h4M10 21h4M16 21h4" />
                    </svg>
                </button>
                <button id="addFunctionBtn" class="header-btn" title="Add new expression">+</button>
            </div>
        </div>
        <div id="expressionListContainer">
            <!-- Expression items will be dynamically added here -->
        </div>
        <div id="mathKeyboard">
            <!-- Keyboard buttons will be dynamically added here -->
        </div>
    </div>

    <div id="canvasContainer">
        <canvas id="graphCanvas"></canvas>
        <button id="homeBtn" title="Reset View">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M2.25 12l8.954-8.955c.44-.439 1.152-.439 1.591 0L21.75 12M4.5 9.75v10.125c0 .621.504 1.125 1.125 1.125H9.75v-4.875c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125V21h4.125c.621 0 1.125-.504 1.125-1.125V9.75M8.25 21h7.5" />
            </svg>                      
        </button>
    </div>

    <script>
// --- Advanced Interactive Calculator (v3.1 - Robust Stats) ---
document.addEventListener('DOMContentLoaded', () => {
    // --- DOM ELEMENTS & CONSTANTS ---
    const sidebar = document.getElementById('sidebar');
    const canvas = document.getElementById('graphCanvas');
    const ctx = canvas.getContext('2d');
    const expressionListContainer = document.getElementById('expressionListContainer');
    const addFunctionBtn = document.getElementById('addFunctionBtn');
    const homeBtn = document.getElementById('homeBtn');
    const mathKeyboard = document.getElementById('mathKeyboard');
    const toggleKeyboardBtn = document.getElementById('toggleKeyboardBtn');
    const toggleAngleModeBtn = document.getElementById('toggleAngleModeBtn');
    const MQ = MathQuill.getInterface(2);
    const devicePixelRatio = window.devicePixelRatio || 1;
    const PLOT_COLORS = ['#2563eb', '#c026d3', '#22c55e', '#f97316', '#8b5cf6', '#d946ef'];
    const INEQUALITY_ALPHA = 0.2;
    const POI_RADIUS = 4 * devicePixelRatio;

    const KEYBOARD_SYMBOLS = [
        'sin', 'cos', 'tan', 'asin', 'acos', 'atan', 'd/dx',
        'mean', 'median', 'stdev', 'min', 'max', 'total', 'quartile',
        '7', '8', '9', '/', '(', ')', 'nCr',
        '4', '5', '6', '*', '[', ']', 'nPr',
        '1', '2', '3', '-', 'x', 'y', '!',
        '0', '.', '=', '+', 'π', 'e', 'θ'
    ];
    
    // --- STATE MANAGEMENT ---
    let graphState = {
        originX: 0, originY: 0, scale: 40,
        isPanning: false, panStart: { x: 0, y: 0 },
        expressions: [],
        activeInput: null,
        touchState: { isPinching: false, initialPinchDistance: 0 },
        intersections: [],
        hoverPoint: { visible: false, x: 0, y: 0 },
        lockedPoint: { visible: false, x: 0, y: 0, color: '#000' },
        angleMode: 'rad',
        definedVariables: {}
    };

    // --- OPTIMIZATION ---
    function debounce(func, delay) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), delay);
        };
    }
    const debouncedEvaluateAndPlotAll = debounce(evaluateAndPlotAll, 200);

    // --- INITIALIZATION ---
    function initialize() {
        setupMathKeyboard();
        resizeCanvas();
        addExpressionInput('');
        setupEventListeners();
        evaluateAndPlotAll();
    }

    function setupEventListeners() {
        window.addEventListener('resize', resizeCanvas);
        addFunctionBtn.addEventListener('click', () => addExpressionInput());
        homeBtn.addEventListener('click', () => resetView());
        
        toggleKeyboardBtn.addEventListener('click', () => {
            sidebar.classList.toggle('keyboard-open');
            toggleKeyboardBtn.classList.toggle('active', sidebar.classList.contains('keyboard-open'));
        });

        toggleAngleModeBtn.addEventListener('click', () => {
            graphState.angleMode = graphState.angleMode === 'rad' ? 'deg' : 'rad';
            toggleAngleModeBtn.textContent = graphState.angleMode.toUpperCase();
            toggleAngleModeBtn.title = `Switch to ${graphState.angleMode === 'rad' ? 'Degrees' : 'Radians'}`;
            toggleAngleModeBtn.classList.toggle('active', graphState.angleMode === 'rad');
            evaluateAndPlotAll();
        });

        canvas.addEventListener('wheel', handleGraphZoom, { passive: false });
        canvas.addEventListener('mousedown', handleGraphPanStart);
        canvas.addEventListener('mousemove', handleGraphPanMove);
        window.addEventListener('mouseup', handleGraphPanEnd);
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd);
        canvas.addEventListener('click', handleGraphClick);
        canvas.addEventListener('mousemove', handleMouseMoveForHover);
        canvas.addEventListener('mouseleave', () => {
            graphState.hoverPoint.visible = false;
            requestAnimationFrame(renderAll);
        });
    }
    
    // --- MATH KEYBOARD ---
    function setupMathKeyboard() {
        KEYBOARD_SYMBOLS.forEach(symbol => {
            const btn = document.createElement('button');
            btn.innerHTML = symbol;
            btn.dataset.symbol = symbol;
            if (symbol === '≤') btn.innerHTML = '&le;';
            if (symbol === '≥') btn.innerHTML = '&ge;';
            if (symbol === 'π') btn.innerHTML = '&pi;';
            if (symbol === 'θ') btn.innerHTML = '&theta;';
            btn.addEventListener('click', () => insertSymbol(symbol));
            mathKeyboard.appendChild(btn);
        });
    }
    
    function insertSymbol(symbol) {
        const mathField = graphState.activeInput;
        if (!mathField) return;
        const functionList = ['sin', 'cos', 'tan', 'asin', 'acos', 'atan', 'log', 'ln', 'abs', 'mean', 'median', 'stdev', 'min', 'max', 'total', 'quartile'];
        if (functionList.includes(symbol)) {
            mathField.write(`\\operatorname{${symbol}}\\left(\\right)`);
            mathField.keystroke('Left');
        } else if (symbol === 'nCr' || symbol === 'nPr') {
            mathField.write(`\\operatorname{${symbol}}\\left(,\\right)`);
            mathField.keystroke('Left');
            mathField.keystroke('Left');
        } else if (symbol === '^') {
            mathField.cmd('^');
        } else if (symbol === '√') {
            mathField.cmd('\\sqrt');
        } else if (symbol === 'π') {
            mathField.cmd('\\pi');
        } else if (symbol === 'θ') {
            mathField.cmd('\\theta');
        } else if (symbol === '≤') {
            mathField.cmd('\\le');
        } else if (symbol === '≥') {
            mathField.cmd('\\ge');
        } else if (symbol === 'd/dx') {
            mathField.write('\\frac{d}{dx}\\left(\\right)');
            mathField.keystroke('Left');
        } else {
            mathField.write(symbol);
        }
        mathField.focus();
    }       

    // --- EXPRESSION MANAGEMENT ---
    function addExpressionInput(latexStr = '') {
        const exprIndex = graphState.expressions.length;
        const newExpr = {
            id: `expr-${Date.now()}-${Math.random()}`,
            latex: latexStr,
            visible: true,
            color: PLOT_COLORS[exprIndex % PLOT_COLORS.length],
            sliders: {},
        };
        graphState.expressions.push(newExpr);
        const item = document.createElement('div');
        item.className = 'expression-item';
        item.id = newExpr.id;
        item.innerHTML = `
            <div class="expression-main">
                <span class="expression-number">${exprIndex + 1}</span>
                <div class="expression-color-bar" title="Toggle visibility"></div>
                <div class="expression-input-wrapper"><span class="math-input-field"></span></div>
                <span class="expression-result"></span>
                <button class="remove-expression-btn" title="Remove expression">&times;</button>
            </div>
            <div class="expression-extras"></div>
        `;
        expressionListContainer.appendChild(item);
        const mathFieldSpan = item.querySelector('.math-input-field');
        const mathField = MQ.MathField(mathFieldSpan, {
            spaceBehavesLikeTab: true,
            handlers: {
                edit: () => { newExpr.latex = mathField.latex(); debouncedEvaluateAndPlotAll(); },
                enter: () => addExpressionInput(),
                deleteOutOf: (dir, field) => { if (dir === -1 && field.latex() === '' && graphState.expressions.length > 1) removeExpression(newExpr.id, item.previousElementSibling); },
                upOutOf: () => { const prevItem = item.previousElementSibling; if (prevItem) MQ(prevItem.querySelector('.math-input-field')).focus().moveToRightEnd(); },
                downOutOf: () => { const nextItem = item.nextElementSibling; if (nextItem) MQ(nextItem.querySelector('.math-input-field')).focus().moveToRightEnd(); }
            }
        });
        if (latexStr) mathField.latex(latexStr);
        mathField.focus();
        graphState.activeInput = mathField;
        item.querySelector('.remove-expression-btn').addEventListener('click', () => { if (graphState.expressions.length > 1) removeExpression(newExpr.id); });
        item.querySelector('.expression-color-bar').addEventListener('click', (e) => { newExpr.visible = !newExpr.visible; e.currentTarget.classList.toggle('hidden-expr', !newExpr.visible); evaluateAndPlotAll(); });
        mathFieldSpan.addEventListener('focusin', () => { graphState.activeInput = mathField; });
    }

    function removeExpression(id, focusTarget = null) {
        const item = document.getElementById(id);
        if (!item) return;
        const nextFocusItem = focusTarget || item.previousElementSibling || item.nextElementSibling;
        item.remove();
        graphState.expressions = graphState.expressions.filter(e => e.id !== id);
        updateExpressionNumbers();
        evaluateAndPlotAll();
        if (nextFocusItem) {
            const prevMathField = MQ(nextFocusItem.querySelector('.math-input-field'));
            if (prevMathField) {
                prevMathField.focus().moveToRightEnd();
                graphState.activeInput = prevMathField;
            }
        }
    }

    function updateExpressionNumbers() {
        expressionListContainer.querySelectorAll('.expression-item').forEach((item, index) => {
            item.querySelector('.expression-number').textContent = index + 1;
        });
    }
    
    // --- PARSING & EVALUATION ENGINE ---
    function evaluateAndPlotAll() {
        graphState.definedVariables = {};
        graphState.expressions.forEach(expr => {
            if (!expr.latex) return;
            try {
                const node = math.parse(preprocessInputString(latexToMathJs(expr.latex)));
                if (node.isAssignmentNode && !node.toString().match(/[xy]/)) {
                    const varName = node.object.name;
                    const value = node.evaluate(getEvaluationScope(expr));
                    graphState.definedVariables[varName] = value;
                }
            } catch (e) { /* Ignore */ }
        });
        graphState.expressions.forEach(parseSingleExpression);
        findAndStoreIntersections();
        graphState.expressions.forEach(updateExpressionUI);
        requestAnimationFrame(renderAll);
    }

    function latexToMathJs(latex) {
        return latex
            .replace(/\\operatorname{([a-zA-Z]+)}/g, '$1')
            .replace(/\\frac{d}{dx}\\left\(([^)]+)\\right\)/g, "derivative('$1', 'x')")
            .replace(/\\sin/g, 'sin').replace(/\\cos/g, 'cos').replace(/\\tan/g, 'tan')
            .replace(/\\asin/g, 'asin').replace(/\\acos/g, 'acos').replace(/\\atan/g, 'atan')
            .replace(/\\log/g, 'log10').replace(/\\ln/g, 'log')
            .replace(/\\sqrt/g, 'sqrt').replace(/\\pi/g, 'pi').replace(/\\theta/g, 'theta')
            .replace(/\\le/g, '<=').replace(/\\ge/g, '>=')
            .replace(/\\left\(/g, '(').replace(/\\right\)/g, ')')
            .replace(/\\left\[/g, '[').replace(/\\right\]/g, ']')
            .replace(/\\cdot/g, '*').replace(/\\frac{([^}]+)}{([^}]+)}/g, '($1)/($2)')
            .replace(/{/g, '(').replace(/}/g, ')');
    }

    function preprocessInputString(str) {
        const functionNames = 'sin|cos|tan|asin|acos|atan|log10|log|sqrt|abs|mean|median|stdev|min|max|total|quartile';
        const funcArgRegex = new RegExp(`\\b(${functionNames})\\s+([a-zA-Z0-9πθ.\\[\\]]+)`, 'g');
        return str.replace(funcArgRegex, '$1($2)');
    }

    // --- FIX: This function now correctly handles both list and multi-argument inputs ---
    function getEvaluationScope(expr) {
        const scope = { ...graphState.definedVariables };
        Object.keys(expr.sliders).forEach(name => {
            scope[name] = expr.sliders[name].val;
        });

        // This helper creates a wrapper around a math.js function.
        // It allows the function to be called with multiple arguments (e.g., median(1, 5, 2))
        // or with a single array (e.g., median([1, 5, 2])).
        const createFlexibleStatFunction = (mathFunc) => {
            return (...args) => {
                // If the first argument is already an array, use it directly.
                if (args.length === 1 && Array.isArray(args[0])) {
                    return mathFunc(args[0]);
                }
                // Otherwise, gather all arguments into a new array.
                return mathFunc(args);
            };
        };

        // Apply the wrapper to all relevant statistical functions
        scope.total = createFlexibleStatFunction(math.sum);
        scope.stdev = createFlexibleStatFunction(math.std);
        scope.mean = createFlexibleStatFunction(math.mean);
        scope.median = createFlexibleStatFunction(math.median);
        scope.min = createFlexibleStatFunction(math.min);
        scope.max = createFlexibleStatFunction(math.max);
        
        // These functions require specific arguments, so no wrapper is needed.
        scope.quartile = math.quantileSeq;
        scope.nCr = math.combinations;
        scope.nPr = math.permutations;

        if (graphState.angleMode === 'deg') {
            scope.sin = math.sind; scope.cos = math.cosd; scope.tan = math.tand;
            scope.asin = math.asind; scope.acos = math.acosd; scope.atan = math.atand;
            scope.atan2 = math.atan2d;
        }
        return scope;
    }

    function parseSingleExpression(expr) {
        Object.assign(expr, { type: 'empty', compiled: null, error: null, result: null, node: null, inequalityType: null, isImplicit: false });
        let cleanStr = preprocessInputString(latexToMathJs(expr.latex.trim()));
        if (!cleanStr) return;
        try {
            const node = math.parse(cleanStr);
            expr.node = node;
            const scope = getEvaluationScope(expr);
            if (node.isAssignmentNode) {
                const varName = node.object.name;
                if (varName !== 'x' && varName !== 'y') {
                    expr.type = 'assignment';
                    expr.result = node.evaluate(scope);
                    graphState.definedVariables[varName] = expr.result;
                    return;
                }
            }
            if (node.isOperatorNode && ['<', '>', '<=', '>='].includes(node.op)) {
                expr.inequalityType = node.op;
                const [left, right] = node.args;
                if (left.isSymbolNode && left.name === 'y') { expr.type = 'inequality'; expr.compiled = right.compile(); }
                else if (right.isSymbolNode && right.name === 'y') { expr.type = 'inequality'; expr.compiled = left.compile(); expr.inequalityType = {'>':'<', '>=':'<=', '<':'>', '<=':'>='}[node.op]; }
                else if (left.isSymbolNode && left.name === 'x') { expr.type = 'vertical_inequality'; expr.x_value = right.evaluate(scope); }
                else if (right.isSymbolNode && right.name === 'x') { expr.type = 'vertical_inequality'; expr.x_value = left.evaluate(scope); expr.inequalityType = {'>':'<', '>=':'<=', '<':'>', '<=':'>='}[node.op]; }
                else { expr.error = "Inequalities must be in terms of x or y."; }
            } else if (cleanStr.includes('x') || cleanStr.includes('y')) {
                expr.type = 'function';
                let parseableNode = node;
                if (node.isOperatorNode && node.op === '=') {
                    const [left, right] = node.args;
                    if (left.isSymbolNode && left.name === 'y') { parseableNode = right; }
                    else if (right.isSymbolNode && right.name === 'y') { parseableNode = left; }
                    else if (left.isSymbolNode && left.name === 'x') { expr.type = 'vertical_line'; expr.x_value = right.evaluate(scope); }
                    else if (right.isSymbolNode && right.name === 'x') { expr.type = 'vertical_line'; expr.x_value = left.evaluate(scope); }
                    else { expr.error = "Implicit functions not supported yet."; }
                }
                if (expr.type === 'function') { expr.node = parseableNode; expr.compiled = parseableNode.compile(); }
            } else {
                expr.type = 'calculation';
                expr.result = node.evaluate(scope);
            }
            if (expr.type === 'function' || expr.type === 'inequality') {
                const knownSymbols = ['x', 'y', 'e', 'pi', 'i', 'true', 'false', 'theta', ...Object.keys(math)];
                const foundSymbols = new Set();
                expr.node.traverse(n => { if (n.isSymbolNode && !knownSymbols.includes(n.name) && !graphState.definedVariables.hasOwnProperty(n.name)) foundSymbols.add(n.name); });
                foundSymbols.forEach(name => { if (!expr.sliders[name]) expr.sliders[name] = { val: 1, min: -5, max: 5, step: 0.1 }; });
                Object.keys(expr.sliders).forEach(name => { if (!foundSymbols.has(name)) delete expr.sliders[name]; });
            } else { expr.sliders = {}; }
            if (expr.type === 'function') findPointsOfInterest(expr);
        } catch (err) { expr.error = err.message.length > 50 ? err.message.substring(0, 50) + '...' : err.message; }
    }

    function updateExpressionUI(expr) {
        const item = document.getElementById(expr.id);
        if (!item) return;
        const resultEl = item.querySelector('.expression-result');
        const extrasEl = item.querySelector('.expression-extras');
        const colorBar = item.querySelector('.expression-color-bar');
        resultEl.textContent = '';
        extrasEl.innerHTML = '';
        colorBar.style.backgroundColor = expr.error ? 'var(--error-red)' : (expr.visible ? expr.color : '#ccc');
        colorBar.style.borderColor = expr.error ? 'var(--error-red)' : expr.color;
        colorBar.title = expr.error ? expr.error : "Toggle visibility";
        if (expr.error) { resultEl.textContent = 'Error'; }
        else if (expr.result !== null && expr.result !== undefined) {
            try {
                if (Array.isArray(expr.result)) { resultEl.textContent = `${expr.result.length} elements`; }
                else { resultEl.textContent = `= ${math.format(expr.result, {precision: 5})}`; }
            } catch { resultEl.textContent = `= ${expr.result.toString()}`; }
        }
        Object.keys(expr.sliders).forEach(name => {
            const slider = expr.sliders[name];
            const sliderDiv = document.createElement('div');
            sliderDiv.className = 'slider-container';
            sliderDiv.innerHTML = `<label>${name} = ${slider.val}</label><input type="range" min="${slider.min}" max="${slider.max}" value="${slider.val}" step="${slider.step}">`;
            extrasEl.appendChild(sliderDiv);
            sliderDiv.querySelector('input[type=range]').addEventListener('input', (e) => {
                slider.val = parseFloat(e.target.value);
                sliderDiv.querySelector('label').textContent = `${name} = ${slider.val}`;
                evaluateAndPlotAll();
            });
        });
    }

    // --- All plotting, interaction, and helper functions below this line are unchanged. ---
    function renderAll() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGraphGrid();
        graphState.expressions.forEach(expr => {
            if (!expr.visible || expr.error) return;
            if (expr.type === 'inequality') plotInequality(expr);
            else if (expr.type === 'vertical_inequality') plotVerticalInequality(expr);
            else if (expr.type === 'function') { plotFunction(expr); drawPointsOfInterest(expr); }
            else if (expr.type === 'vertical_line') plotVerticalLine(expr);
        });
        drawAllIntersectionPoints();
        if (graphState.hoverPoint.visible) drawHoverPoint();
        if (graphState.lockedPoint.visible) drawLockedPoint();
    }
    function plotFunction(expr){if(!expr.compiled)return;const t=getEvaluationScope(expr);ctx.strokeStyle=expr.color,ctx.lineWidth=2.5*devicePixelRatio,ctx.beginPath();let o=!0;for(let r=0;r<canvas.width;r++){const n=(r-graphState.originX)/graphState.scale;t.x=n;try{const e=expr.compiled.evaluate(t);if(!Number.isFinite(e)){o=!0;continue}const i=graphState.originY-e*graphState.scale;o?(ctx.moveTo(r,i),o=!1):ctx.lineTo(r,i)}catch(s){o=!0}}ctx.stroke()}
    function plotInequality(expr){if(!expr.compiled)return;const t=getEvaluationScope(expr);ctx.fillStyle=expr.color,ctx.globalAlpha=INEQUALITY_ALPHA,ctx.beginPath();let o=!0;for(let r=0;r<=canvas.width;r++){const n=(r-graphState.originX)/graphState.scale;t.x=n;try{const e=expr.compiled.evaluate(t);if(!Number.isFinite(e))continue;const i=graphState.originY-e*graphState.scale;o?(ctx.moveTo(r,i),o=!1):ctx.lineTo(r,i)}catch(s){}}const r=expr.inequalityType;r.includes(">")?(ctx.lineTo(canvas.width,0),ctx.lineTo(0,0)):(ctx.lineTo(canvas.width,canvas.height),ctx.lineTo(0,canvas.height)),ctx.closePath(),ctx.fill(),ctx.globalAlpha=1,("<"===r||">"===r)&&ctx.setLineDash([8*devicePixelRatio,8*devicePixelRatio]),plotFunction(expr),ctx.setLineDash([])}
    function plotVerticalLine(expr){ctx.strokeStyle=expr.color,ctx.lineWidth=2.5*devicePixelRatio;const t=graphState.originX+expr.x_value*graphState.scale;ctx.beginPath(),ctx.moveTo(t,0),ctx.lineTo(t,canvas.height),ctx.stroke()}
    function plotVerticalInequality(expr){ctx.fillStyle=expr.color,ctx.globalAlpha=INEQUALITY_ALPHA;const t=graphState.originX+expr.x_value*graphState.scale,o=expr.inequalityType;o.includes("<")&&ctx.fillRect(0,0,t,canvas.height),o.includes(">")&&ctx.fillRect(t,0,canvas.width-t,canvas.height),ctx.globalAlpha=1,o.includes("=")||ctx.setLineDash([8*devicePixelRatio,8*devicePixelRatio]),plotVerticalLine(expr),ctx.setLineDash([])}
    function findPointsOfInterest(expr){expr.poi={roots:[],y_intercept:null,extrema:[]};if(!expr.compiled)return;const t=getEvaluationScope(expr);try{const o=expr.compiled.evaluate({...t,x:0});Number.isFinite(o)&&(expr.poi.y_intercept={x:0,y:o})}catch(r){}let o,n;const e=1/graphState.scale;for(let i=0;i<canvas.width;i++){const s=(i-graphState.originX)/graphState.scale;try{const a=expr.compiled.evaluate({...t,x:s});if(void 0!==o&&Number.isFinite(a)&&Number.isFinite(o)){Math.sign(a)!==Math.sign(o)&&expr.poi.roots.push({x:s-e/2,y:0});const l=expr.compiled.evaluate({...t,x:s+e});if(Number.isFinite(l)){const h=Math.sign(l-a);void 0!==n&&h!==n&&0!==h&&expr.poi.extrema.push({x:s,y:a}),n=h}}o=a}catch(c){o=void 0,n=void 0}}}
    function drawPointsOfInterest(expr){ctx.fillStyle=expr.color;const t=[...expr.poi.roots,...expr.poi.extrema];expr.poi.y_intercept&&t.push(expr.poi.y_intercept),t.forEach(o=>{if(!o)return;const r=graphState.originX+o.x*graphState.scale,n=graphState.originY-o.y*graphState.scale;ctx.beginPath(),ctx.arc(r,n,POI_RADIUS,0,2*Math.PI),ctx.fill()})}
    function bisectionSolve(t,o,r,n,e=1e-7,i=50){const s=getEvaluationScope(t),a=getEvaluationScope(o);let l,h;try{l=t.compiled.evaluate({...s,x:r})-o.compiled.evaluate({...a,x:r}),h=t.compiled.evaluate({...s,x:n})-o.compiled.evaluate({...a,x:n})}catch(p){return null}if(isNaN(l)||isNaN(h)||Math.sign(l)===Math.sign(h))return null;let c=r;for(let d=0;d<i;d++){c=(r+n)/2;let f=t.compiled.evaluate({...s,x:c})-o.compiled.evaluate({...a,x:c});if(Math.abs(f)<e||(n-r)/2<e)return c;Math.sign(f)===Math.sign(l)?(r=c,l=f):n=c}return c}
    function findAndStoreIntersections(){graphState.intersections=[];const t=graphState.expressions.filter(o=>o.visible&&o.compiled&&("function"===o.type||"inequality"===o.type));if(t.length<2)return;for(let o=0;o<t.length;o++)for(let r=o+1;r<t.length;r++){const n=t[o],e=t[r];let i;for(let s=0;s<canvas.width;s++){const a=(s-graphState.originX)/graphState.scale;try{const l=n.compiled.evaluate({...getEvaluationScope(n),x:a}),h=e.compiled.evaluate({...getEvaluationScope(e),x:a}),c=l-h;if(void 0!==i&&Math.sign(c)!==Math.sign(i)){const d=bisectionSolve(n,e,a-1/graphState.scale,a);if(null!==d){const f=n.compiled.evaluate({...getEvaluationScope(n),x:d});Number.isFinite(f)&&graphState.intersections.push({x:d,y:f})}}i=c}catch(p){i=void 0}}}}
    function drawAllIntersectionPoints(){ctx.fillStyle="#333",graphState.intersections.forEach(t=>{const o=graphState.originX+t.x*graphState.scale,r=graphState.originY-t.y*graphState.scale;ctx.beginPath(),ctx.arc(o,r,POI_RADIUS,0,2*Math.PI),ctx.fill()})}
    function drawHoverPoint(){const{x:t,y:o}=graphState.hoverPoint,r=graphState.originX+t*graphState.scale,n=graphState.originY-o*graphState.scale;ctx.fillStyle="#000",ctx.strokeStyle="rgba(255, 255, 255, 0.7)",ctx.lineWidth=3*devicePixelRatio,ctx.beginPath(),ctx.arc(r,n,1.2*POI_RADIUS,0,2*Math.PI),ctx.stroke(),ctx.fill()}
    function drawLockedPoint(){const{x:t,y:o}=graphState.lockedPoint,r=graphState.originX+t*graphState.scale,n=graphState.originY-o*graphState.scale;ctx.fillStyle="#000",ctx.beginPath(),ctx.arc(r,n,1.2*POI_RADIUS,0,2*Math.PI),ctx.fill();const e=`(${t.toFixed(3)}, ${o.toFixed(3)})`,i=12*devicePixelRatio;ctx.font=`bold ${i}px 'Manrope'`;const s=ctx.measureText(e),a=s.width+16*devicePixelRatio,l=i+12*devicePixelRatio;let h=r+15*devicePixelRatio,c=n-l/2;h+a>canvas.width&&(h=r-a-15*devicePixelRatio),c<0&&(c=5*devicePixelRatio),c+l>canvas.height&&(c=canvas.height-l-5*devicePixelRatio),ctx.fillStyle="rgba(255, 255, 255, 0.9)",ctx.shadowColor="rgba(0,0,0,0.2)",ctx.shadowBlur=10,ctx.beginPath(),ctx.roundRect(h,c,a,l,5*devicePixelRatio),ctx.fill(),ctx.shadowColor="transparent",ctx.fillStyle="#000",ctx.textAlign="center",ctx.textBaseline="middle",ctx.fillText(e,h+a/2,c+l/2)}
    function findClosestPoint(t,o){let r=1/0,n=null;const e=15*devicePixelRatio,i=[...graphState.intersections];return graphState.expressions.forEach(t=>{t.poi&&i.push(...t.poi.roots,...t.poi.extrema,t.poi.y_intercept)}),i.filter(t=>t).forEach(i=>{const s=graphState.originX+i.x*graphState.scale,a=graphState.originY-i.y*graphState.scale,l=Math.sqrt(Math.pow(t-s,2)+Math.pow(o-a,2));l<r&&l<e&&(r=l,n=i)}),n}
    function resizeCanvas(){const t=canvas.parentElement.getBoundingClientRect();canvas.width=t.width*devicePixelRatio,canvas.height=t.height*devicePixelRatio,canvas.style.width=`${t.width}px`,canvas.style.height=`${t.height}px`,resetView(!1),evaluateAndPlotAll()}
    function resetView(t=!0){graphState.originX=canvas.width/2,graphState.originY=canvas.height/2,graphState.scale=40,t&&evaluateAndPlotAll()}
    function handleGraphZoom(t){t.preventDefault();const o=canvas.getBoundingClientRect(),r=(t.clientX-o.left)*devicePixelRatio,n=(t.clientY-o.top)*devicePixelRatio,e=t.deltaY<0?1.1:1/1.1;applyZoom(r,n,e)}
    function handleGraphPanStart(t){0===t.button&&(graphState.isPanning=!0,graphState.panStart={x:t.clientX,y:t.clientY},graphState.lockedPoint.visible&&(graphState.lockedPoint.visible=!1,requestAnimationFrame(renderAll)))}
    function handleGraphPanMove(t){if(!graphState.isPanning)return;const o=(t.clientX-graphState.panStart.x)*devicePixelRatio,r=(t.clientY-graphState.panStart.y)*devicePixelRatio;graphState.originX+=o,graphState.originY+=r,graphState.panStart={x:t.clientX,y:t.clientY},requestAnimationFrame(renderAll)}
    function handleGraphPanEnd(){graphState.isPanning&&(graphState.isPanning=!1,evaluateAndPlotAll())}
    function handleTouchStart(t){t.preventDefault();const o=t.touches;1===o.length?(graphState.isPanning=!0,graphState.panStart={x:o[0].clientX,y:o[0].clientY}):2===o.length&&(graphState.isPanning=!1,graphState.touchState.isPinching=!0,graphState.touchState.initialPinchDistance=getPinchDistance(o))}
    function handleTouchMove(t){t.preventDefault();const o=t.touches;if(graphState.isPanning&&1===o.length){const r=(o[0].clientX-graphState.panStart.x)*devicePixelRatio,n=(o[0].clientY-graphState.panStart.y)*devicePixelRatio;graphState.originX+=r,graphState.originY+=n,graphState.panStart={x:o[0].clientX,y:o[0].clientY},requestAnimationFrame(renderAll)}else if(graphState.touchState.isPinching&&2===o.length){const e=getPinchDistance(o),i=e/graphState.touchState.initialPinchDistance,s=canvas.getBoundingClientRect(),a=((o[0].clientX+o[1].clientX)/2-s.left)*devicePixelRatio,l=((o[0].clientY+o[1].clientY)/2-s.top)*devicePixelRatio;applyZoom(a,l,i),graphState.touchState.initialPinchDistance=e}}
    function handleTouchEnd(t){(graphState.touchState.isPinching||graphState.isPanning)&&evaluateAndPlotAll(),graphState.isPanning=!1,graphState.touchState.isPinching=!1}
    function getPinchDistance(t){const o=t[0].clientX-t[1].clientX,r=t[0].clientY-t[1].clientY;return Math.sqrt(o*o+r*r)}
    function applyZoom(t,o,r){const n=(t-graphState.originX)/graphState.scale,e=(graphState.originY-o)/graphState.scale;graphState.scale*=r,graphState.scale=Math.max(.1,Math.min(graphState.scale,2e4));const i=(t-graphState.originX)/graphState.scale,s=(graphState.originY-o)/graphState.scale;graphState.originX+=(i-n)*graphState.scale,graphState.originY-=(s-e)*graphState.scale,evaluateAndPlotAll()}
    function handleMouseMoveForHover(t){if(graphState.isPanning)return;const o=canvas.getBoundingClientRect(),r=(t.clientX-o.left)*devicePixelRatio,n=(t.clientY-o.top)*devicePixelRatio,e=findClosestPoint(r,n);graphState.hoverPoint.visible=!!e,e&&(graphState.hoverPoint.x=e.x,graphState.hoverPoint.y=e.y),requestAnimationFrame(renderAll)}
    function handleGraphClick(t){if(graphState.isPanning)return;const o=canvas.getBoundingClientRect(),r=(t.clientX-o.left)*devicePixelRatio,n=(t.clientY-o.top)*devicePixelRatio,e=findClosestPoint(r,n);graphState.lockedPoint.visible=!!e,e&&(graphState.lockedPoint.x=e.x,graphState.lockedPoint.y=e.y),requestAnimationFrame(renderAll)}
    function drawGraphGrid(){const t=getComputedStyle(document.documentElement),o=t.getPropertyValue("--thelo-border").trim(),r=t.getPropertyValue("--thelo-text-light").trim();ctx.save(),ctx.setTransform(1,0,0,1,0,0),ctx.clearRect(0,0,canvas.width,canvas.height),ctx.restore();let n=1;for(;n*graphState.scale<50*devicePixelRatio;)n*=n*graphState.scale<25*devicePixelRatio?2:2.5;for(;n*graphState.scale>100*devicePixelRatio;)n/=n*graphState.scale>250*devicePixelRatio?2.5:2;ctx.strokeStyle=o,ctx.lineWidth=1*devicePixelRatio,ctx.font=`${10*devicePixelRatio}px 'Manrope'`,ctx.fillStyle=r,ctx.textAlign="center",ctx.textBaseline="middle";const e=Math.floor(-graphState.originX/(graphState.scale*n))*n;for(let i=e;(i*graphState.scale+graphState.originX)<canvas.width;i+=n){const s=i*graphState.scale+graphState.originX;ctx.beginPath(),ctx.moveTo(s,0),ctx.lineTo(s,canvas.height),ctx.stroke(),Math.abs(i)>1e-9&&ctx.fillText(Number(i.toPrecision(4)),s+2*devicePixelRatio,graphState.originY-5*devicePixelRatio)}const a=Math.floor(graphState.originY/(graphState.scale*n))*n;for(let l=a;(graphState.originY-l*graphState.scale)<canvas.height;l-=n){const h=graphState.originY-l*graphState.scale;ctx.beginPath(),ctx.moveTo(0,h),ctx.lineTo(canvas.width,h),ctx.stroke(),Math.abs(l)>1e-9&&(ctx.save(),ctx.textAlign="right",ctx.fillText(Number(l.toPrecision(4)),graphState.originX-5*devicePixelRatio,h+2*devicePixelRatio),ctx.restore())}ctx.strokeStyle=r,ctx.lineWidth=1.5*devicePixelRatio,ctx.beginPath(),ctx.moveTo(0,graphState.originY),ctx.lineTo(canvas.width,graphState.originY),ctx.stroke(),ctx.beginPath(),ctx.moveTo(graphState.originX,0),ctx.lineTo(graphState.originX,canvas.height),ctx.stroke()}

    // --- START THE APP ---
    initialize();
});
</script>
</body>
</html>
